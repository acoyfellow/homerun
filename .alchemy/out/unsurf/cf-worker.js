var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value3) => __defProp(target, "name", { value: value3, configurable: true });
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all9) => {
  for (var name in all9)
    __defProp(target, name, { get: all9[name], enumerable: true });
};
var __copyProps = (to, from2, except2, desc2) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except2)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc2 = __getOwnPropDesc(from2, key)) || desc2.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn2 = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn2, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance2;
var init_performance = __esm({
  "node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options) {
        this.name = name;
        this.startTime = options?.startTime || _performanceNow();
        this.detail = options?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e) => e.entryType !== "resource" || e.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type) {
        return this._entries.filter((e) => e.name === name && (!type || e.entryType === type));
      }
      getEntriesByType(type) {
        return this._entries.filter((e) => e.entryType === type);
      }
      mark(name, options) {
        const entry = new PerformanceMark(name, options);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start5;
        let end6;
        if (typeof startOrMeasureOptions === "string") {
          start5 = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end6 = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start5 = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end6 = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start5,
          detail: {
            start: start5,
            end: end6
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type, listener, options) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn2) {
        return fn2;
      }
      runInAsyncScope(fn2, thisArg, ...args2) {
        return fn2.call(thisArg, ...args2);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance2 = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance2;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// node_modules/alchemy/src/cloudflare/bundle/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "node_modules/alchemy/src/cloudflare/bundle/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now2 = Date.now();
      const seconds2 = Math.trunc(now2 / 1e3);
      const nanos2 = now2 % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds2 - startTime[0];
        let diffNanos = nanos2 - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds2, nanos2];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir3, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env2) {
        return 1;
      }
      hasColors(count6, env2) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/tty.mjs
var isatty, tty_default;
var init_tty = __esm({
  "node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
    init_read_stream();
    init_write_stream();
    isatty = /* @__PURE__ */ __name(function() {
      return false;
    }, "isatty");
    tty_default = {
      ReadStream,
      WriteStream,
      isatty
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION;
var init_node_version = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NODE_VERSION = "22.14.0";
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    init_node_version();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value3 = this[prop];
          if (typeof value3 === "function") {
            this[prop] = value3.bind(this);
          }
        }
      }
      // --- event emitter ---
      emitWarning(warning2, type, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type ? `${type}: ` : ""}${warning2}`);
      }
      emit(...args2) {
        return super.emit(...args2);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      // --- stdio (lazy initializers) ---
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      // --- cwd ---
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      // --- dummy props and getters ---
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return `v${NODE_VERSION}`;
      }
      get versions() {
        return { node: NODE_VERSION };
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      // --- noop methods ---
      ref() {
      }
      unref() {
      }
      // --- unimplemented methods ---
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      // --- attached interfaces ---
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      // --- undefined props ---
      mainModule = void 0;
      domain = void 0;
      // optional
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      // internals
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, workerdProcess, isWorkerdProcessV2, unenvProcess, exit, features, platform, env, hrtime3, nextTick, _channel, _disconnect, _events, _eventsCount, _handleQueue, _maxListeners, _pendingMessage, _send, assert2, disconnect, mainModule, _debugEnd, _debugProcess, _exiting, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _linkedBinding, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, abort, addListener, allowedNodeEnvironmentFlags, arch, argv, argv0, availableMemory, binding, channel, chdir, config, connected, constrainedMemory, cpuUsage, cwd, debugPort, dlopen, domain, emit, emitWarning, eventNames, execArgv, execPath, exitCode, finalization, getActiveResourcesInfo, getegid, geteuid, getgid, getgroups, getMaxListeners, getuid, hasUncaughtExceptionCaptureCallback, initgroups, kill, listenerCount, listeners, loadEnvFile, memoryUsage, moduleLoadList, off, on, once, openStdin, permission, pid, ppid, prependListener, prependOnceListener, rawListeners, reallyExit, ref, release, removeAllListeners, removeListener, report, resourceUsage, send, setegid, seteuid, setgid, setgroups, setMaxListeners, setSourceMapsEnabled, setuid, setUncaughtExceptionCaptureCallback, sourceMapsEnabled, stderr, stdin, stdout, throwDeprecation, title, traceDeprecation, umask, unref, uptime, version, versions, _process, process_default;
var init_process2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    workerdProcess = getBuiltinModule("node:process");
    isWorkerdProcessV2 = globalThis.Cloudflare.compatibilityFlags.enable_nodejs_process_v2;
    unenvProcess = new Process({
      env: globalProcess.env,
      // `hrtime` is only available from workerd process v2
      hrtime: isWorkerdProcessV2 ? workerdProcess.hrtime : hrtime,
      // `nextTick` is available from workerd process v1
      nextTick: workerdProcess.nextTick
    });
    ({ exit, features, platform } = workerdProcess);
    ({
      env: (
        // Always implemented by workerd
        env
      ),
      hrtime: (
        // Only implemented in workerd v2
        hrtime3
      ),
      nextTick: (
        // Always implemented by workerd
        nextTick
      )
    } = unenvProcess);
    ({
      _channel,
      _disconnect,
      _events,
      _eventsCount,
      _handleQueue,
      _maxListeners,
      _pendingMessage,
      _send,
      assert: assert2,
      disconnect,
      mainModule
    } = unenvProcess);
    ({
      _debugEnd: (
        // @ts-expect-error `_debugEnd` is missing typings
        _debugEnd
      ),
      _debugProcess: (
        // @ts-expect-error `_debugProcess` is missing typings
        _debugProcess
      ),
      _exiting: (
        // @ts-expect-error `_exiting` is missing typings
        _exiting
      ),
      _fatalException: (
        // @ts-expect-error `_fatalException` is missing typings
        _fatalException
      ),
      _getActiveHandles: (
        // @ts-expect-error `_getActiveHandles` is missing typings
        _getActiveHandles
      ),
      _getActiveRequests: (
        // @ts-expect-error `_getActiveRequests` is missing typings
        _getActiveRequests
      ),
      _kill: (
        // @ts-expect-error `_kill` is missing typings
        _kill
      ),
      _linkedBinding: (
        // @ts-expect-error `_linkedBinding` is missing typings
        _linkedBinding
      ),
      _preload_modules: (
        // @ts-expect-error `_preload_modules` is missing typings
        _preload_modules
      ),
      _rawDebug: (
        // @ts-expect-error `_rawDebug` is missing typings
        _rawDebug
      ),
      _startProfilerIdleNotifier: (
        // @ts-expect-error `_startProfilerIdleNotifier` is missing typings
        _startProfilerIdleNotifier
      ),
      _stopProfilerIdleNotifier: (
        // @ts-expect-error `_stopProfilerIdleNotifier` is missing typings
        _stopProfilerIdleNotifier
      ),
      _tickCallback: (
        // @ts-expect-error `_tickCallback` is missing typings
        _tickCallback
      ),
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      arch,
      argv,
      argv0,
      availableMemory,
      binding: (
        // @ts-expect-error `binding` is missing typings
        binding
      ),
      channel,
      chdir,
      config,
      connected,
      constrainedMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      domain: (
        // @ts-expect-error `domain` is missing typings
        domain
      ),
      emit,
      emitWarning,
      eventNames,
      execArgv,
      execPath,
      exitCode,
      finalization,
      getActiveResourcesInfo,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getMaxListeners,
      getuid,
      hasUncaughtExceptionCaptureCallback,
      initgroups: (
        // @ts-expect-error `initgroups` is missing typings
        initgroups
      ),
      kill,
      listenerCount,
      listeners,
      loadEnvFile,
      memoryUsage,
      moduleLoadList: (
        // @ts-expect-error `moduleLoadList` is missing typings
        moduleLoadList
      ),
      off,
      on,
      once,
      openStdin: (
        // @ts-expect-error `openStdin` is missing typings
        openStdin
      ),
      permission,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      reallyExit: (
        // @ts-expect-error `reallyExit` is missing typings
        reallyExit
      ),
      ref,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      send,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setMaxListeners,
      setSourceMapsEnabled,
      setuid,
      setUncaughtExceptionCaptureCallback,
      sourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      throwDeprecation,
      title,
      traceDeprecation,
      umask,
      unref,
      uptime,
      version,
      versions
    } = isWorkerdProcessV2 ? workerdProcess : unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// node_modules/alchemy/src/cloudflare/bundle/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "node_modules/alchemy/src/cloudflare/bundle/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// node_modules/effect/dist/esm/Function.js
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
var isFunction, dual, identity, constant, constTrue, constFalse, constNull, constUndefined, constVoid;
var init_Function = __esm({
  "node_modules/effect/dist/esm/Function.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    isFunction = /* @__PURE__ */ __name((input) => typeof input === "function", "isFunction");
    dual = /* @__PURE__ */ __name(function(arity, body) {
      if (typeof arity === "function") {
        return function() {
          if (arity(arguments)) {
            return body.apply(this, arguments);
          }
          return (self2) => body(self2, ...arguments);
        };
      }
      switch (arity) {
        case 0:
        case 1:
          throw new RangeError(`Invalid arity ${arity}`);
        case 2:
          return function(a, b) {
            if (arguments.length >= 2) {
              return body(a, b);
            }
            return function(self2) {
              return body(self2, a);
            };
          };
        case 3:
          return function(a, b, c) {
            if (arguments.length >= 3) {
              return body(a, b, c);
            }
            return function(self2) {
              return body(self2, a, b);
            };
          };
        case 4:
          return function(a, b, c, d) {
            if (arguments.length >= 4) {
              return body(a, b, c, d);
            }
            return function(self2) {
              return body(self2, a, b, c);
            };
          };
        case 5:
          return function(a, b, c, d, e) {
            if (arguments.length >= 5) {
              return body(a, b, c, d, e);
            }
            return function(self2) {
              return body(self2, a, b, c, d);
            };
          };
        default:
          return function() {
            if (arguments.length >= arity) {
              return body.apply(this, arguments);
            }
            const args2 = arguments;
            return function(self2) {
              return body(self2, ...args2);
            };
          };
      }
    }, "dual");
    identity = /* @__PURE__ */ __name((a) => a, "identity");
    constant = /* @__PURE__ */ __name((value3) => () => value3, "constant");
    constTrue = /* @__PURE__ */ constant(true);
    constFalse = /* @__PURE__ */ constant(false);
    constNull = /* @__PURE__ */ constant(null);
    constUndefined = /* @__PURE__ */ constant(void 0);
    constVoid = constUndefined;
    __name(pipe, "pipe");
  }
});

// node_modules/effect/dist/esm/Equivalence.js
var make, isStrictEquivalent, strict, number, mapInput, Date2, array;
var init_Equivalence = __esm({
  "node_modules/effect/dist/esm/Equivalence.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    make = /* @__PURE__ */ __name((isEquivalent) => (self2, that) => self2 === that || isEquivalent(self2, that), "make");
    isStrictEquivalent = /* @__PURE__ */ __name((x, y) => x === y, "isStrictEquivalent");
    strict = /* @__PURE__ */ __name(() => isStrictEquivalent, "strict");
    number = /* @__PURE__ */ strict();
    mapInput = /* @__PURE__ */ dual(2, (self2, f) => make((x, y) => self2(f(x), f(y))));
    Date2 = /* @__PURE__ */ mapInput(number, (date7) => date7.getTime());
    array = /* @__PURE__ */ __name((item) => make((self2, that) => {
      if (self2.length !== that.length) {
        return false;
      }
      for (let i = 0; i < self2.length; i++) {
        const isEq = item(self2[i], that[i]);
        if (!isEq) {
          return false;
        }
      }
      return true;
    }), "array");
  }
});

// node_modules/effect/dist/esm/internal/doNotation.js
var let_, bindTo, bind;
var init_doNotation = __esm({
  "node_modules/effect/dist/esm/internal/doNotation.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    let_ = /* @__PURE__ */ __name((map31) => dual(3, (self2, name, f) => map31(self2, (a) => ({
      ...a,
      [name]: f(a)
    }))), "let_");
    bindTo = /* @__PURE__ */ __name((map31) => dual(2, (self2, name) => map31(self2, (a) => ({
      [name]: a
    }))), "bindTo");
    bind = /* @__PURE__ */ __name((map31, flatMap19) => dual(3, (self2, name, f) => flatMap19(self2, (a) => map31(f(a), (b) => ({
      ...a,
      [name]: b
    })))), "bind");
  }
});

// node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId, globalStore, globalValue;
var init_GlobalValue = __esm({
  "node_modules/effect/dist/esm/GlobalValue.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    globalStoreId = `effect/GlobalValue`;
    globalValue = /* @__PURE__ */ __name((id2, compute) => {
      if (!globalStore) {
        globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
        globalStore = globalThis[globalStoreId];
      }
      if (!globalStore.has(id2)) {
        globalStore.set(id2, compute());
      }
      return globalStore.get(id2);
    }, "globalValue");
  }
});

// node_modules/effect/dist/esm/Predicate.js
var isTruthy, isSet, isMap, isString, isNumber, isBoolean, isBigInt, isSymbol, isFunction2, isUndefined, isNotUndefined, isNotNull, isNever, isRecordOrArray, isObject, hasProperty, isTagged, isNullable, isNotNullable, isUint8Array, isDate, isIterable, isRecord, isPromiseLike;
var init_Predicate = __esm({
  "node_modules/effect/dist/esm/Predicate.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    isTruthy = /* @__PURE__ */ __name((input) => !!input, "isTruthy");
    isSet = /* @__PURE__ */ __name((input) => input instanceof Set, "isSet");
    isMap = /* @__PURE__ */ __name((input) => input instanceof Map, "isMap");
    isString = /* @__PURE__ */ __name((input) => typeof input === "string", "isString");
    isNumber = /* @__PURE__ */ __name((input) => typeof input === "number", "isNumber");
    isBoolean = /* @__PURE__ */ __name((input) => typeof input === "boolean", "isBoolean");
    isBigInt = /* @__PURE__ */ __name((input) => typeof input === "bigint", "isBigInt");
    isSymbol = /* @__PURE__ */ __name((input) => typeof input === "symbol", "isSymbol");
    isFunction2 = isFunction;
    isUndefined = /* @__PURE__ */ __name((input) => input === void 0, "isUndefined");
    isNotUndefined = /* @__PURE__ */ __name((input) => input !== void 0, "isNotUndefined");
    isNotNull = /* @__PURE__ */ __name((input) => input !== null, "isNotNull");
    isNever = /* @__PURE__ */ __name((_) => false, "isNever");
    isRecordOrArray = /* @__PURE__ */ __name((input) => typeof input === "object" && input !== null, "isRecordOrArray");
    isObject = /* @__PURE__ */ __name((input) => isRecordOrArray(input) || isFunction2(input), "isObject");
    hasProperty = /* @__PURE__ */ dual(2, (self2, property2) => isObject(self2) && property2 in self2);
    isTagged = /* @__PURE__ */ dual(2, (self2, tag2) => hasProperty(self2, "_tag") && self2["_tag"] === tag2);
    isNullable = /* @__PURE__ */ __name((input) => input === null || input === void 0, "isNullable");
    isNotNullable = /* @__PURE__ */ __name((input) => input !== null && input !== void 0, "isNotNullable");
    isUint8Array = /* @__PURE__ */ __name((input) => input instanceof Uint8Array, "isUint8Array");
    isDate = /* @__PURE__ */ __name((input) => input instanceof Date, "isDate");
    isIterable = /* @__PURE__ */ __name((input) => typeof input === "string" || hasProperty(input, Symbol.iterator), "isIterable");
    isRecord = /* @__PURE__ */ __name((input) => isRecordOrArray(input) && !Array.isArray(input), "isRecord");
    isPromiseLike = /* @__PURE__ */ __name((input) => hasProperty(input, "then") && isFunction2(input.then), "isPromiseLike");
  }
});

// node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage;
var init_errors = __esm({
  "node_modules/effect/dist/esm/internal/errors.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    getBugErrorMessage = /* @__PURE__ */ __name((message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`, "getBugErrorMessage");
  }
});

// node_modules/effect/dist/esm/Utils.js
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
function yieldWrapGet(self2) {
  if (typeof self2 === "object" && self2 !== null && YieldWrapTypeId in self2) {
    return self2[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
var GenKindTypeId, isGenKind, GenKindImpl, SingleShotGen, adapter, defaultIncHi, defaultIncLo, MUL_HI, MUL_LO, BIT_53, BIT_27, PCGRandom, YieldWrapTypeId, YieldWrap, structuralRegionState, standard, forced, isNotOptimizedAway, internalCall, genConstructor, isGeneratorFunction;
var init_Utils = __esm({
  "node_modules/effect/dist/esm/Utils.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_GlobalValue();
    init_errors();
    init_Predicate();
    GenKindTypeId = /* @__PURE__ */ Symbol.for("effect/Gen/GenKind");
    isGenKind = /* @__PURE__ */ __name((u) => isObject(u) && GenKindTypeId in u, "isGenKind");
    GenKindImpl = class {
      static {
        __name(this, "GenKindImpl");
      }
      value;
      constructor(value3) {
        this.value = value3;
      }
      /**
       * @since 2.0.0
       */
      get _F() {
        return identity;
      }
      /**
       * @since 2.0.0
       */
      get _R() {
        return (_) => _;
      }
      /**
       * @since 2.0.0
       */
      get _O() {
        return (_) => _;
      }
      /**
       * @since 2.0.0
       */
      get _E() {
        return (_) => _;
      }
      /**
       * @since 2.0.0
       */
      [GenKindTypeId] = GenKindTypeId;
      /**
       * @since 2.0.0
       */
      [Symbol.iterator]() {
        return new SingleShotGen(this);
      }
    };
    SingleShotGen = class _SingleShotGen {
      static {
        __name(this, "SingleShotGen");
      }
      self;
      called = false;
      constructor(self2) {
        this.self = self2;
      }
      /**
       * @since 2.0.0
       */
      next(a) {
        return this.called ? {
          value: a,
          done: true
        } : (this.called = true, {
          value: this.self,
          done: false
        });
      }
      /**
       * @since 2.0.0
       */
      return(a) {
        return {
          value: a,
          done: true
        };
      }
      /**
       * @since 2.0.0
       */
      throw(e) {
        throw e;
      }
      /**
       * @since 2.0.0
       */
      [Symbol.iterator]() {
        return new _SingleShotGen(this.self);
      }
    };
    adapter = /* @__PURE__ */ __name(() => function() {
      let x = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        x = arguments[i](x);
      }
      return new GenKindImpl(x);
    }, "adapter");
    defaultIncHi = 335903614;
    defaultIncLo = 4150755663;
    MUL_HI = 1481765933 >>> 0;
    MUL_LO = 1284865837 >>> 0;
    BIT_53 = 9007199254740992;
    BIT_27 = 134217728;
    PCGRandom = class {
      static {
        __name(this, "PCGRandom");
      }
      _state;
      constructor(seedHi, seedLo, incHi, incLo) {
        if (isNullable(seedLo) && isNullable(seedHi)) {
          seedLo = Math.random() * 4294967295 >>> 0;
          seedHi = 0;
        } else if (isNullable(seedLo)) {
          seedLo = seedHi;
          seedHi = 0;
        }
        if (isNullable(incLo) && isNullable(incHi)) {
          incLo = this._state ? this._state[3] : defaultIncLo;
          incHi = this._state ? this._state[2] : defaultIncHi;
        } else if (isNullable(incLo)) {
          incLo = incHi;
          incHi = 0;
        }
        this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
        this._next();
        add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
        this._next();
        return this;
      }
      /**
       * Returns a copy of the internal state of this random number generator as a
       * JavaScript Array.
       *
       * @category getters
       * @since 2.0.0
       */
      getState() {
        return [this._state[0], this._state[1], this._state[2], this._state[3]];
      }
      /**
       * Restore state previously retrieved using `getState()`.
       *
       * @since 2.0.0
       */
      setState(state) {
        this._state[0] = state[0];
        this._state[1] = state[1];
        this._state[2] = state[2];
        this._state[3] = state[3] | 1;
      }
      /**
       * Get a uniformly distributed 32 bit integer between [0, max).
       *
       * @category getter
       * @since 2.0.0
       */
      integer(max6) {
        return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max6;
      }
      /**
       * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
       * 53 bits of precision (every bit of the mantissa is randomized).
       *
       * @category getters
       * @since 2.0.0
       */
      number() {
        const hi = (this._next() & 67108863) * 1;
        const lo = (this._next() & 134217727) * 1;
        return (hi * BIT_27 + lo) / BIT_53;
      }
      /** @internal */
      _next() {
        const oldHi = this._state[0] >>> 0;
        const oldLo = this._state[1] >>> 0;
        mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
        add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
        let xsHi = oldHi >>> 18;
        let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
        xsHi = (xsHi ^ oldHi) >>> 0;
        xsLo = (xsLo ^ oldLo) >>> 0;
        const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
        const rot = oldHi >>> 27;
        const rot2 = (-rot >>> 0 & 31) >>> 0;
        return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
      }
    };
    __name(mul64, "mul64");
    __name(add64, "add64");
    YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
    YieldWrap = class {
      static {
        __name(this, "YieldWrap");
      }
      /**
       * @since 3.0.6
       */
      #value;
      constructor(value3) {
        this.#value = value3;
      }
      /**
       * @since 3.0.6
       */
      [YieldWrapTypeId]() {
        return this.#value;
      }
    };
    __name(yieldWrapGet, "yieldWrapGet");
    structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
      enabled: false,
      tester: void 0
    }));
    standard = {
      effect_internal_function: /* @__PURE__ */ __name((body) => {
        return body();
      }, "effect_internal_function")
    };
    forced = {
      effect_internal_function: /* @__PURE__ */ __name((body) => {
        try {
          return body();
        } finally {
        }
      }, "effect_internal_function")
    };
    isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
    internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
    genConstructor = function* () {
    }.constructor;
    isGeneratorFunction = /* @__PURE__ */ __name((u) => isObject(u) && u.constructor === genConstructor, "isGeneratorFunction");
  }
});

// node_modules/effect/dist/esm/Hash.js
var randomHashCache, symbol, hash, random, combine, optimize, isHash, number2, string, structureKeys, structure, array2, cached;
var init_Hash = __esm({
  "node_modules/effect/dist/esm/Hash.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_GlobalValue();
    init_Predicate();
    init_Utils();
    randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
    symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
    hash = /* @__PURE__ */ __name((self2) => {
      if (structuralRegionState.enabled === true) {
        return 0;
      }
      switch (typeof self2) {
        case "number":
          return number2(self2);
        case "bigint":
          return string(self2.toString(10));
        case "boolean":
          return string(String(self2));
        case "symbol":
          return string(String(self2));
        case "string":
          return string(self2);
        case "undefined":
          return string("undefined");
        case "function":
        case "object": {
          if (self2 === null) {
            return string("null");
          } else if (self2 instanceof Date) {
            if (Number.isNaN(self2.getTime())) {
              return string("Invalid Date");
            }
            return hash(self2.toISOString());
          } else if (self2 instanceof URL) {
            return hash(self2.href);
          } else if (isHash(self2)) {
            return self2[symbol]();
          } else {
            return random(self2);
          }
        }
        default:
          throw new Error(`BUG: unhandled typeof ${typeof self2} - please report an issue at https://github.com/Effect-TS/effect/issues`);
      }
    }, "hash");
    random = /* @__PURE__ */ __name((self2) => {
      if (!randomHashCache.has(self2)) {
        randomHashCache.set(self2, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
      }
      return randomHashCache.get(self2);
    }, "random");
    combine = /* @__PURE__ */ __name((b) => (self2) => self2 * 53 ^ b, "combine");
    optimize = /* @__PURE__ */ __name((n) => n & 3221225471 | n >>> 1 & 1073741824, "optimize");
    isHash = /* @__PURE__ */ __name((u) => hasProperty(u, symbol), "isHash");
    number2 = /* @__PURE__ */ __name((n) => {
      if (n !== n || n === Infinity) {
        return 0;
      }
      let h = n | 0;
      if (h !== n) {
        h ^= n * 4294967295;
      }
      while (n > 4294967295) {
        h ^= n /= 4294967295;
      }
      return optimize(h);
    }, "number");
    string = /* @__PURE__ */ __name((str) => {
      let h = 5381, i = str.length;
      while (i) {
        h = h * 33 ^ str.charCodeAt(--i);
      }
      return optimize(h);
    }, "string");
    structureKeys = /* @__PURE__ */ __name((o, keys5) => {
      let h = 12289;
      for (let i = 0; i < keys5.length; i++) {
        h ^= pipe(string(keys5[i]), combine(hash(o[keys5[i]])));
      }
      return optimize(h);
    }, "structureKeys");
    structure = /* @__PURE__ */ __name((o) => structureKeys(o, Object.keys(o)), "structure");
    array2 = /* @__PURE__ */ __name((arr) => {
      let h = 6151;
      for (let i = 0; i < arr.length; i++) {
        h = pipe(h, combine(hash(arr[i])));
      }
      return optimize(h);
    }, "array");
    cached = /* @__PURE__ */ __name(function() {
      if (arguments.length === 1) {
        const self3 = arguments[0];
        return function(hash5) {
          Object.defineProperty(self3, symbol, {
            value() {
              return hash5;
            },
            enumerable: false
          });
          return hash5;
        };
      }
      const self2 = arguments[0];
      const hash4 = arguments[1];
      Object.defineProperty(self2, symbol, {
        value() {
          return hash4;
        },
        enumerable: false
      });
      return hash4;
    }, "cached");
  }
});

// node_modules/effect/dist/esm/Equal.js
function equals() {
  if (arguments.length === 1) {
    return (self2) => compareBoth(self2, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self2, that) {
  if (self2 === that) {
    return true;
  }
  const selfType = typeof self2;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self2 !== null && that !== null) {
      if (isEqual(self2) && isEqual(that)) {
        if (hash(self2) === hash(that) && self2[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
        }
      } else if (self2 instanceof Date && that instanceof Date) {
        const t1 = self2.getTime();
        const t2 = that.getTime();
        return t1 === t2 || Number.isNaN(t1) && Number.isNaN(t2);
      } else if (self2 instanceof URL && that instanceof URL) {
        return self2.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self2) && Array.isArray(that)) {
        return self2.length === that.length && self2.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self2) === Object.prototype && Object.getPrototypeOf(that) === Object.prototype) {
        const keysSelf = Object.keys(self2);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth(self2[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
}
var symbol2, isEqual, equivalence;
var init_Equal = __esm({
  "node_modules/effect/dist/esm/Equal.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Hash();
    init_Predicate();
    init_Utils();
    symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
    __name(equals, "equals");
    __name(compareBoth, "compareBoth");
    isEqual = /* @__PURE__ */ __name((u) => hasProperty(u, symbol2), "isEqual");
    equivalence = /* @__PURE__ */ __name(() => equals, "equivalence");
  }
});

// node_modules/effect/dist/esm/Inspectable.js
function formatDate(date7) {
  try {
    return date7.toISOString();
  } catch {
    return "Invalid Date";
  }
}
function safeToString(input) {
  try {
    const s = input.toString();
    return typeof s === "string" ? s : String(s);
  } catch {
    return "[toString threw]";
  }
}
function formatPropertyKey(name) {
  return isString(name) ? JSON.stringify(name) : String(name);
}
function formatUnknown(input, options) {
  const space = options?.space ?? 0;
  const seen = /* @__PURE__ */ new WeakSet();
  const gap = !space ? "" : isNumber(space) ? " ".repeat(space) : space;
  const ind = /* @__PURE__ */ __name((d) => gap.repeat(d), "ind");
  const wrap = /* @__PURE__ */ __name((v, body) => {
    const ctor = v?.constructor;
    return ctor && ctor !== Object.prototype.constructor && ctor.name ? `${ctor.name}(${body})` : body;
  }, "wrap");
  const ownKeys = /* @__PURE__ */ __name((o) => {
    try {
      return Reflect.ownKeys(o);
    } catch {
      return ["[ownKeys threw]"];
    }
  }, "ownKeys");
  function go3(v, d = 0) {
    if (Array.isArray(v)) {
      if (seen.has(v)) return CIRCULAR;
      seen.add(v);
      if (!gap || v.length <= 1) return `[${v.map((x) => go3(x, d)).join(",")}]`;
      const inner = v.map((x) => go3(x, d + 1)).join(",\n" + ind(d + 1));
      return `[
${ind(d + 1)}${inner}
${ind(d)}]`;
    }
    if (isDate(v)) return formatDate(v);
    if (!options?.ignoreToString && hasProperty(v, "toString") && isFunction2(v["toString"]) && v["toString"] !== Object.prototype.toString && v["toString"] !== Array.prototype.toString) {
      const s = safeToString(v);
      if (v instanceof Error && v.cause) {
        return `${s} (cause: ${go3(v.cause, d)})`;
      }
      return s;
    }
    if (isString(v)) return JSON.stringify(v);
    if (isNumber(v) || v == null || isBoolean(v) || isSymbol(v)) return String(v);
    if (isBigInt(v)) return String(v) + "n";
    if (v instanceof Set || v instanceof Map) {
      if (seen.has(v)) return CIRCULAR;
      seen.add(v);
      return `${v.constructor.name}(${go3(Array.from(v), d)})`;
    }
    if (isObject(v)) {
      if (seen.has(v)) return CIRCULAR;
      seen.add(v);
      const keys5 = ownKeys(v);
      if (!gap || keys5.length <= 1) {
        const body2 = `{${keys5.map((k) => `${formatPropertyKey(k)}:${go3(v[k], d)}`).join(",")}}`;
        return wrap(v, body2);
      }
      const body = `{
${keys5.map((k) => `${ind(d + 1)}${formatPropertyKey(k)}: ${go3(v[k], d + 1)}`).join(",\n")}
${ind(d)}}`;
      return wrap(v, body);
    }
    return String(v);
  }
  __name(go3, "go");
  return go3(input, 0);
}
var NodeInspectSymbol, toJSON, CIRCULAR, format, BaseProto, Class, toStringUnknown, stringifyCircular, symbolRedactable, isRedactable, redactableState, withRedactableContext, redact;
var init_Inspectable = __esm({
  "node_modules/effect/dist/esm/Inspectable.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_GlobalValue();
    init_Predicate();
    NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
    toJSON = /* @__PURE__ */ __name((x) => {
      try {
        if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
          return x.toJSON();
        } else if (Array.isArray(x)) {
          return x.map(toJSON);
        }
      } catch {
        return {};
      }
      return redact(x);
    }, "toJSON");
    CIRCULAR = "[Circular]";
    __name(formatDate, "formatDate");
    __name(safeToString, "safeToString");
    __name(formatPropertyKey, "formatPropertyKey");
    __name(formatUnknown, "formatUnknown");
    format = /* @__PURE__ */ __name((x) => JSON.stringify(x, null, 2), "format");
    BaseProto = {
      toJSON() {
        return toJSON(this);
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      toString() {
        return format(this.toJSON());
      }
    };
    Class = class {
      static {
        __name(this, "Class");
      }
      /**
       * @since 2.0.0
       */
      [NodeInspectSymbol]() {
        return this.toJSON();
      }
      /**
       * @since 2.0.0
       */
      toString() {
        return format(this.toJSON());
      }
    };
    toStringUnknown = /* @__PURE__ */ __name((u, whitespace = 2) => {
      if (typeof u === "string") {
        return u;
      }
      try {
        return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
      } catch {
        return String(u);
      }
    }, "toStringUnknown");
    stringifyCircular = /* @__PURE__ */ __name((obj, whitespace) => {
      let cache = [];
      const retVal = JSON.stringify(obj, (_key, value3) => typeof value3 === "object" && value3 !== null ? cache.includes(value3) ? void 0 : cache.push(value3) && (redactableState.fiberRefs !== void 0 && isRedactable(value3) ? value3[symbolRedactable](redactableState.fiberRefs) : value3) : value3, whitespace);
      cache = void 0;
      return retVal;
    }, "stringifyCircular");
    symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
    isRedactable = /* @__PURE__ */ __name((u) => typeof u === "object" && u !== null && symbolRedactable in u, "isRedactable");
    redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
      fiberRefs: void 0
    }));
    withRedactableContext = /* @__PURE__ */ __name((context10, f) => {
      const prev = redactableState.fiberRefs;
      redactableState.fiberRefs = context10;
      try {
        return f();
      } finally {
        redactableState.fiberRefs = prev;
      }
    }, "withRedactableContext");
    redact = /* @__PURE__ */ __name((u) => {
      if (isRedactable(u) && redactableState.fiberRefs !== void 0) {
        return u[symbolRedactable](redactableState.fiberRefs);
      }
      return u;
    }, "redact");
  }
});

// node_modules/effect/dist/esm/Pipeable.js
var pipeArguments;
var init_Pipeable = __esm({
  "node_modules/effect/dist/esm/Pipeable.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    pipeArguments = /* @__PURE__ */ __name((self2, args2) => {
      switch (args2.length) {
        case 0:
          return self2;
        case 1:
          return args2[0](self2);
        case 2:
          return args2[1](args2[0](self2));
        case 3:
          return args2[2](args2[1](args2[0](self2)));
        case 4:
          return args2[3](args2[2](args2[1](args2[0](self2))));
        case 5:
          return args2[4](args2[3](args2[2](args2[1](args2[0](self2)))));
        case 6:
          return args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2))))));
        case 7:
          return args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2)))))));
        case 8:
          return args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2))))))));
        case 9:
          return args2[8](args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2)))))))));
        default: {
          let ret = self2;
          for (let i = 0, len = args2.length; i < len; i++) {
            ret = args2[i](ret);
          }
          return ret;
        }
      }
    }, "pipeArguments");
  }
});

// node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC, OP_COMMIT, OP_FAILURE, OP_ON_FAILURE, OP_ON_SUCCESS, OP_ON_SUCCESS_AND_FAILURE, OP_SUCCESS, OP_SYNC, OP_TAG, OP_UPDATE_RUNTIME_FLAGS, OP_WHILE, OP_ITERATOR, OP_WITH_RUNTIME, OP_YIELD, OP_REVERT_FLAGS;
var init_effect = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/effect.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_ASYNC = "Async";
    OP_COMMIT = "Commit";
    OP_FAILURE = "Failure";
    OP_ON_FAILURE = "OnFailure";
    OP_ON_SUCCESS = "OnSuccess";
    OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
    OP_SUCCESS = "Success";
    OP_SYNC = "Sync";
    OP_TAG = "Tag";
    OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
    OP_WHILE = "While";
    OP_ITERATOR = "Iterator";
    OP_WITH_RUNTIME = "WithRuntime";
    OP_YIELD = "Yield";
    OP_REVERT_FLAGS = "RevertFlags";
  }
});

// node_modules/effect/dist/esm/internal/version.js
var moduleVersion, getCurrentVersion;
var init_version = __esm({
  "node_modules/effect/dist/esm/internal/version.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    moduleVersion = "3.19.17";
    getCurrentVersion = /* @__PURE__ */ __name(() => moduleVersion, "getCurrentVersion");
  }
});

// node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId, StreamTypeId, SinkTypeId, ChannelTypeId, effectVariance, sinkVariance, channelVariance, EffectPrototype, StructuralPrototype, CommitPrototype, StructuralCommitPrototype, Base;
var init_effectable = __esm({
  "node_modules/effect/dist/esm/internal/effectable.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Hash();
    init_Pipeable();
    init_Utils();
    init_effect();
    init_version();
    EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
    StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
    SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
    ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
    effectVariance = {
      /* c8 ignore next */
      _R: /* @__PURE__ */ __name((_) => _, "_R"),
      /* c8 ignore next */
      _E: /* @__PURE__ */ __name((_) => _, "_E"),
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A"),
      _V: /* @__PURE__ */ getCurrentVersion()
    };
    sinkVariance = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A"),
      /* c8 ignore next */
      _In: /* @__PURE__ */ __name((_) => _, "_In"),
      /* c8 ignore next */
      _L: /* @__PURE__ */ __name((_) => _, "_L"),
      /* c8 ignore next */
      _E: /* @__PURE__ */ __name((_) => _, "_E"),
      /* c8 ignore next */
      _R: /* @__PURE__ */ __name((_) => _, "_R")
    };
    channelVariance = {
      /* c8 ignore next */
      _Env: /* @__PURE__ */ __name((_) => _, "_Env"),
      /* c8 ignore next */
      _InErr: /* @__PURE__ */ __name((_) => _, "_InErr"),
      /* c8 ignore next */
      _InElem: /* @__PURE__ */ __name((_) => _, "_InElem"),
      /* c8 ignore next */
      _InDone: /* @__PURE__ */ __name((_) => _, "_InDone"),
      /* c8 ignore next */
      _OutErr: /* @__PURE__ */ __name((_) => _, "_OutErr"),
      /* c8 ignore next */
      _OutElem: /* @__PURE__ */ __name((_) => _, "_OutElem"),
      /* c8 ignore next */
      _OutDone: /* @__PURE__ */ __name((_) => _, "_OutDone")
    };
    EffectPrototype = {
      [EffectTypeId]: effectVariance,
      [StreamTypeId]: effectVariance,
      [SinkTypeId]: sinkVariance,
      [ChannelTypeId]: channelVariance,
      [symbol2](that) {
        return this === that;
      },
      [symbol]() {
        return cached(this, random(this));
      },
      [Symbol.iterator]() {
        return new SingleShotGen(new YieldWrap(this));
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    StructuralPrototype = {
      [symbol]() {
        return cached(this, structure(this));
      },
      [symbol2](that) {
        const selfKeys = Object.keys(this);
        const thatKeys = Object.keys(that);
        if (selfKeys.length !== thatKeys.length) {
          return false;
        }
        for (const key of selfKeys) {
          if (!(key in that && equals(this[key], that[key]))) {
            return false;
          }
        }
        return true;
      }
    };
    CommitPrototype = {
      ...EffectPrototype,
      _op: OP_COMMIT
    };
    StructuralCommitPrototype = {
      ...CommitPrototype,
      ...StructuralPrototype
    };
    Base = /* @__PURE__ */ (function() {
      function Base3() {
      }
      __name(Base3, "Base");
      Base3.prototype = CommitPrototype;
      return Base3;
    })();
  }
});

// node_modules/effect/dist/esm/internal/option.js
var TypeId, CommonProto, SomeProto, NoneHash, NoneProto, isOption, isNone, isSome, none, some;
var init_option = __esm({
  "node_modules/effect/dist/esm/internal/option.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Hash();
    init_Inspectable();
    init_Predicate();
    init_effectable();
    TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
    CommonProto = {
      ...EffectPrototype,
      [TypeId]: {
        _A: /* @__PURE__ */ __name((_) => _, "_A")
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      toString() {
        return format(this.toJSON());
      }
    };
    SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
      _tag: "Some",
      _op: "Some",
      [symbol2](that) {
        return isOption(that) && isSome(that) && equals(this.value, that.value);
      },
      [symbol]() {
        return cached(this, combine(hash(this._tag))(hash(this.value)));
      },
      toJSON() {
        return {
          _id: "Option",
          _tag: this._tag,
          value: toJSON(this.value)
        };
      }
    });
    NoneHash = /* @__PURE__ */ hash("None");
    NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
      _tag: "None",
      _op: "None",
      [symbol2](that) {
        return isOption(that) && isNone(that);
      },
      [symbol]() {
        return NoneHash;
      },
      toJSON() {
        return {
          _id: "Option",
          _tag: this._tag
        };
      }
    });
    isOption = /* @__PURE__ */ __name((input) => hasProperty(input, TypeId), "isOption");
    isNone = /* @__PURE__ */ __name((fa) => fa._tag === "None", "isNone");
    isSome = /* @__PURE__ */ __name((fa) => fa._tag === "Some", "isSome");
    none = /* @__PURE__ */ Object.create(NoneProto);
    some = /* @__PURE__ */ __name((value3) => {
      const a = Object.create(SomeProto);
      a.value = value3;
      return a;
    }, "some");
  }
});

// node_modules/effect/dist/esm/internal/either.js
var TypeId2, CommonProto2, RightProto, LeftProto, isEither, isLeft, isRight, left, right, getLeft, getRight, fromOption;
var init_either = __esm({
  "node_modules/effect/dist/esm/internal/either.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_Hash();
    init_Inspectable();
    init_Predicate();
    init_effectable();
    init_option();
    TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
    CommonProto2 = {
      ...EffectPrototype,
      [TypeId2]: {
        _R: /* @__PURE__ */ __name((_) => _, "_R")
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      toString() {
        return format(this.toJSON());
      }
    };
    RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
      _tag: "Right",
      _op: "Right",
      [symbol2](that) {
        return isEither(that) && isRight(that) && equals(this.right, that.right);
      },
      [symbol]() {
        return combine(hash(this._tag))(hash(this.right));
      },
      toJSON() {
        return {
          _id: "Either",
          _tag: this._tag,
          right: toJSON(this.right)
        };
      }
    });
    LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
      _tag: "Left",
      _op: "Left",
      [symbol2](that) {
        return isEither(that) && isLeft(that) && equals(this.left, that.left);
      },
      [symbol]() {
        return combine(hash(this._tag))(hash(this.left));
      },
      toJSON() {
        return {
          _id: "Either",
          _tag: this._tag,
          left: toJSON(this.left)
        };
      }
    });
    isEither = /* @__PURE__ */ __name((input) => hasProperty(input, TypeId2), "isEither");
    isLeft = /* @__PURE__ */ __name((ma) => ma._tag === "Left", "isLeft");
    isRight = /* @__PURE__ */ __name((ma) => ma._tag === "Right", "isRight");
    left = /* @__PURE__ */ __name((left3) => {
      const a = Object.create(LeftProto);
      a.left = left3;
      return a;
    }, "left");
    right = /* @__PURE__ */ __name((right3) => {
      const a = Object.create(RightProto);
      a.right = right3;
      return a;
    }, "right");
    getLeft = /* @__PURE__ */ __name((self2) => isRight(self2) ? none : some(self2.left), "getLeft");
    getRight = /* @__PURE__ */ __name((self2) => isLeft(self2) ? none : some(self2.right), "getRight");
    fromOption = /* @__PURE__ */ dual(2, (self2, onNone) => isNone(self2) ? left(onNone()) : right(self2.value));
  }
});

// node_modules/effect/dist/esm/Either.js
var right2, left2, fromOption2, try_, isEither2, isLeft2, isRight2, getEquivalence, mapBoth, mapLeft, map, match, merge, getOrThrowWith, getOrThrow, all;
var init_Either = __esm({
  "node_modules/effect/dist/esm/Either.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equivalence();
    init_Function();
    init_either();
    init_Predicate();
    right2 = right;
    left2 = left;
    fromOption2 = fromOption;
    try_ = /* @__PURE__ */ __name((evaluate3) => {
      if (isFunction2(evaluate3)) {
        try {
          return right2(evaluate3());
        } catch (e) {
          return left2(e);
        }
      } else {
        try {
          return right2(evaluate3.try());
        } catch (e) {
          return left2(evaluate3.catch(e));
        }
      }
    }, "try_");
    isEither2 = isEither;
    isLeft2 = isLeft;
    isRight2 = isRight;
    getEquivalence = /* @__PURE__ */ __name(({
      left: left3,
      right: right3
    }) => make((x, y) => isLeft2(x) ? isLeft2(y) && left3(x.left, y.left) : isRight2(y) && right3(x.right, y.right)), "getEquivalence");
    mapBoth = /* @__PURE__ */ dual(2, (self2, {
      onLeft,
      onRight
    }) => isLeft2(self2) ? left2(onLeft(self2.left)) : right2(onRight(self2.right)));
    mapLeft = /* @__PURE__ */ dual(2, (self2, f) => isLeft2(self2) ? left2(f(self2.left)) : right2(self2.right));
    map = /* @__PURE__ */ dual(2, (self2, f) => isRight2(self2) ? right2(f(self2.right)) : left2(self2.left));
    match = /* @__PURE__ */ dual(2, (self2, {
      onLeft,
      onRight
    }) => isLeft2(self2) ? onLeft(self2.left) : onRight(self2.right));
    merge = /* @__PURE__ */ match({
      onLeft: identity,
      onRight: identity
    });
    getOrThrowWith = /* @__PURE__ */ dual(2, (self2, onLeft) => {
      if (isRight2(self2)) {
        return self2.right;
      }
      throw onLeft(self2.left);
    });
    getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a Left"));
    all = /* @__PURE__ */ __name((input) => {
      if (Symbol.iterator in input) {
        const out2 = [];
        for (const e of input) {
          if (isLeft2(e)) {
            return e;
          }
          out2.push(e.right);
        }
        return right2(out2);
      }
      const out = {};
      for (const key of Object.keys(input)) {
        const e = input[key];
        if (isLeft2(e)) {
          return e;
        }
        out[key] = e.right;
      }
      return right2(out);
    }, "all");
  }
});

// node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray;
var init_array = __esm({
  "node_modules/effect/dist/esm/internal/array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    isNonEmptyArray = /* @__PURE__ */ __name((self2) => self2.length > 0, "isNonEmptyArray");
  }
});

// node_modules/effect/dist/esm/Order.js
var make2, number3, bigint2, mapInput2, all2, tuple, lessThan, greaterThan, lessThanOrEqualTo, greaterThanOrEqualTo, min, max, clamp, between;
var init_Order = __esm({
  "node_modules/effect/dist/esm/Order.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    make2 = /* @__PURE__ */ __name((compare2) => (self2, that) => self2 === that ? 0 : compare2(self2, that), "make");
    number3 = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
    bigint2 = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
    mapInput2 = /* @__PURE__ */ dual(2, (self2, f) => make2((b1, b2) => self2(f(b1), f(b2))));
    all2 = /* @__PURE__ */ __name((collection) => {
      return make2((x, y) => {
        const len = Math.min(x.length, y.length);
        let collectionLength = 0;
        for (const O of collection) {
          if (collectionLength >= len) {
            break;
          }
          const o = O(x[collectionLength], y[collectionLength]);
          if (o !== 0) {
            return o;
          }
          collectionLength++;
        }
        return 0;
      });
    }, "all");
    tuple = /* @__PURE__ */ __name((...elements) => all2(elements), "tuple");
    lessThan = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => O(self2, that) === -1), "lessThan");
    greaterThan = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => O(self2, that) === 1), "greaterThan");
    lessThanOrEqualTo = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => O(self2, that) !== 1), "lessThanOrEqualTo");
    greaterThanOrEqualTo = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => O(self2, that) !== -1), "greaterThanOrEqualTo");
    min = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => self2 === that || O(self2, that) < 1 ? self2 : that), "min");
    max = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => self2 === that || O(self2, that) > -1 ? self2 : that), "max");
    clamp = /* @__PURE__ */ __name((O) => dual(2, (self2, options) => min(O)(options.maximum, max(O)(options.minimum, self2))), "clamp");
    between = /* @__PURE__ */ __name((O) => dual(2, (self2, options) => !lessThan(O)(self2, options.minimum) && !greaterThan(O)(self2, options.maximum)), "between");
  }
});

// node_modules/effect/dist/esm/Option.js
var Option_exports = {};
__export(Option_exports, {
  Do: () => Do,
  TypeId: () => TypeId3,
  all: () => all3,
  andThen: () => andThen,
  ap: () => ap,
  as: () => as,
  asVoid: () => asVoid,
  bind: () => bind2,
  bindTo: () => bindTo2,
  composeK: () => composeK,
  contains: () => contains,
  containsWith: () => containsWith,
  exists: () => exists,
  filter: () => filter,
  filterMap: () => filterMap,
  firstSomeOf: () => firstSomeOf,
  flatMap: () => flatMap,
  flatMapNullable: () => flatMapNullable,
  flatten: () => flatten,
  fromIterable: () => fromIterable,
  fromNullable: () => fromNullable,
  gen: () => gen,
  getEquivalence: () => getEquivalence2,
  getLeft: () => getLeft2,
  getOrElse: () => getOrElse,
  getOrNull: () => getOrNull,
  getOrThrow: () => getOrThrow2,
  getOrThrowWith: () => getOrThrowWith2,
  getOrUndefined: () => getOrUndefined,
  getOrder: () => getOrder,
  getRight: () => getRight2,
  isNone: () => isNone2,
  isOption: () => isOption2,
  isSome: () => isSome2,
  let: () => let_2,
  lift2: () => lift2,
  liftNullable: () => liftNullable,
  liftPredicate: () => liftPredicate,
  liftThrowable: () => liftThrowable,
  map: () => map2,
  match: () => match2,
  mergeWith: () => mergeWith,
  none: () => none2,
  orElse: () => orElse,
  orElseEither: () => orElseEither,
  orElseSome: () => orElseSome,
  partitionMap: () => partitionMap,
  product: () => product,
  productMany: () => productMany,
  reduceCompact: () => reduceCompact,
  some: () => some2,
  tap: () => tap,
  toArray: () => toArray,
  toRefinement: () => toRefinement,
  void: () => void_,
  zipLeft: () => zipLeft,
  zipRight: () => zipRight,
  zipWith: () => zipWith
});
var TypeId3, none2, some2, isOption2, isNone2, isSome2, match2, toRefinement, fromIterable, getRight2, getLeft2, getOrElse, orElse, orElseSome, orElseEither, firstSomeOf, fromNullable, liftNullable, getOrNull, getOrUndefined, liftThrowable, getOrThrowWith2, getOrThrow2, map2, as, asVoid, void_, flatMap, andThen, flatMapNullable, flatten, zipRight, zipLeft, composeK, tap, product, productMany, all3, zipWith, ap, reduceCompact, toArray, partitionMap, filterMap, filter, getEquivalence2, getOrder, lift2, liftPredicate, containsWith, _equivalence, contains, exists, bindTo2, let_2, bind2, Do, adapter2, gen, mergeWith;
var init_Option = __esm({
  "node_modules/effect/dist/esm/Option.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Equivalence();
    init_Function();
    init_doNotation();
    init_either();
    init_option();
    init_Order();
    init_Utils();
    TypeId3 = /* @__PURE__ */ Symbol.for("effect/Option");
    none2 = /* @__PURE__ */ __name(() => none, "none");
    some2 = some;
    isOption2 = isOption;
    isNone2 = isNone;
    isSome2 = isSome;
    match2 = /* @__PURE__ */ dual(2, (self2, {
      onNone,
      onSome
    }) => isNone2(self2) ? onNone() : onSome(self2.value));
    toRefinement = /* @__PURE__ */ __name((f) => (a) => isSome2(f(a)), "toRefinement");
    fromIterable = /* @__PURE__ */ __name((collection) => {
      for (const a of collection) {
        return some2(a);
      }
      return none2();
    }, "fromIterable");
    getRight2 = getRight;
    getLeft2 = getLeft;
    getOrElse = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? onNone() : self2.value);
    orElse = /* @__PURE__ */ dual(2, (self2, that) => isNone2(self2) ? that() : self2);
    orElseSome = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? some2(onNone()) : self2);
    orElseEither = /* @__PURE__ */ dual(2, (self2, that) => isNone2(self2) ? map2(that(), right) : map2(self2, left));
    firstSomeOf = /* @__PURE__ */ __name((collection) => {
      let out = none2();
      for (out of collection) {
        if (isSome2(out)) {
          return out;
        }
      }
      return out;
    }, "firstSomeOf");
    fromNullable = /* @__PURE__ */ __name((nullableValue) => nullableValue == null ? none2() : some2(nullableValue), "fromNullable");
    liftNullable = /* @__PURE__ */ __name((f) => (...a) => fromNullable(f(...a)), "liftNullable");
    getOrNull = /* @__PURE__ */ getOrElse(constNull);
    getOrUndefined = /* @__PURE__ */ getOrElse(constUndefined);
    liftThrowable = /* @__PURE__ */ __name((f) => (...a) => {
      try {
        return some2(f(...a));
      } catch {
        return none2();
      }
    }, "liftThrowable");
    getOrThrowWith2 = /* @__PURE__ */ dual(2, (self2, onNone) => {
      if (isSome2(self2)) {
        return self2.value;
      }
      throw onNone();
    });
    getOrThrow2 = /* @__PURE__ */ getOrThrowWith2(() => new Error("getOrThrow called on a None"));
    map2 = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : some2(f(self2.value)));
    as = /* @__PURE__ */ dual(2, (self2, b) => map2(self2, () => b));
    asVoid = /* @__PURE__ */ as(void 0);
    void_ = /* @__PURE__ */ some2(void 0);
    flatMap = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : f(self2.value));
    andThen = /* @__PURE__ */ dual(2, (self2, f) => flatMap(self2, (a) => {
      const b = isFunction(f) ? f(a) : f;
      return isOption2(b) ? b : some2(b);
    }));
    flatMapNullable = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : fromNullable(f(self2.value)));
    flatten = /* @__PURE__ */ flatMap(identity);
    zipRight = /* @__PURE__ */ dual(2, (self2, that) => flatMap(self2, () => that));
    zipLeft = /* @__PURE__ */ dual(2, (self2, that) => tap(self2, () => that));
    composeK = /* @__PURE__ */ dual(2, (afb, bfc) => (a) => flatMap(afb(a), bfc));
    tap = /* @__PURE__ */ dual(2, (self2, f) => flatMap(self2, (a) => map2(f(a), () => a)));
    product = /* @__PURE__ */ __name((self2, that) => isSome2(self2) && isSome2(that) ? some2([self2.value, that.value]) : none2(), "product");
    productMany = /* @__PURE__ */ __name((self2, collection) => {
      if (isNone2(self2)) {
        return none2();
      }
      const out = [self2.value];
      for (const o of collection) {
        if (isNone2(o)) {
          return none2();
        }
        out.push(o.value);
      }
      return some2(out);
    }, "productMany");
    all3 = /* @__PURE__ */ __name((input) => {
      if (Symbol.iterator in input) {
        const out2 = [];
        for (const o of input) {
          if (isNone2(o)) {
            return none2();
          }
          out2.push(o.value);
        }
        return some2(out2);
      }
      const out = {};
      for (const key of Object.keys(input)) {
        const o = input[key];
        if (isNone2(o)) {
          return none2();
        }
        out[key] = o.value;
      }
      return some2(out);
    }, "all");
    zipWith = /* @__PURE__ */ dual(3, (self2, that, f) => map2(product(self2, that), ([a, b]) => f(a, b)));
    ap = /* @__PURE__ */ dual(2, (self2, that) => zipWith(self2, that, (f, a) => f(a)));
    reduceCompact = /* @__PURE__ */ dual(3, (self2, b, f) => {
      let out = b;
      for (const oa of self2) {
        if (isSome2(oa)) {
          out = f(out, oa.value);
        }
      }
      return out;
    });
    toArray = /* @__PURE__ */ __name((self2) => isNone2(self2) ? [] : [self2.value], "toArray");
    partitionMap = /* @__PURE__ */ dual(2, (self2, f) => {
      if (isNone2(self2)) {
        return [none2(), none2()];
      }
      const e = f(self2.value);
      return isLeft(e) ? [some2(e.left), none2()] : [none2(), some2(e.right)];
    });
    filterMap = flatMap;
    filter = /* @__PURE__ */ dual(2, (self2, predicate) => filterMap(self2, (b) => predicate(b) ? some(b) : none));
    getEquivalence2 = /* @__PURE__ */ __name((isEquivalent) => make((x, y) => isNone2(x) ? isNone2(y) : isNone2(y) ? false : isEquivalent(x.value, y.value)), "getEquivalence");
    getOrder = /* @__PURE__ */ __name((O) => make2((self2, that) => isSome2(self2) ? isSome2(that) ? O(self2.value, that.value) : 1 : -1), "getOrder");
    lift2 = /* @__PURE__ */ __name((f) => dual(2, (self2, that) => zipWith(self2, that, f)), "lift2");
    liftPredicate = /* @__PURE__ */ dual(2, (b, predicate) => predicate(b) ? some2(b) : none2());
    containsWith = /* @__PURE__ */ __name((isEquivalent) => dual(2, (self2, a) => isNone2(self2) ? false : isEquivalent(self2.value, a)), "containsWith");
    _equivalence = /* @__PURE__ */ equivalence();
    contains = /* @__PURE__ */ containsWith(_equivalence);
    exists = /* @__PURE__ */ dual(2, (self2, refinement) => isNone2(self2) ? false : refinement(self2.value));
    bindTo2 = /* @__PURE__ */ bindTo(map2);
    let_2 = /* @__PURE__ */ let_(map2);
    bind2 = /* @__PURE__ */ bind(map2, flatMap);
    Do = /* @__PURE__ */ some2({});
    adapter2 = /* @__PURE__ */ adapter();
    gen = /* @__PURE__ */ __name((...args2) => {
      const f = args2.length === 1 ? args2[0] : args2[1].bind(args2[0]);
      const iterator2 = f(adapter2);
      let state = iterator2.next();
      while (!state.done) {
        const current2 = isGenKind(state.value) ? state.value.value : yieldWrapGet(state.value);
        if (isNone2(current2)) {
          return current2;
        }
        state = iterator2.next(current2.value);
      }
      return some2(state.value);
    }, "gen");
    mergeWith = /* @__PURE__ */ __name((f) => (o1, o2) => {
      if (isNone2(o1)) {
        return o2;
      } else if (isNone2(o2)) {
        return o1;
      }
      return some2(f(o1.value, o2.value));
    }, "mergeWith");
  }
});

// node_modules/effect/dist/esm/Tuple.js
var make3;
var init_Tuple = __esm({
  "node_modules/effect/dist/esm/Tuple.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    make3 = /* @__PURE__ */ __name((...elements) => elements, "make");
  }
});

// node_modules/effect/dist/esm/Iterable.js
var findFirst, constEmpty, constEmptyIterator, empty, map3;
var init_Iterable = __esm({
  "node_modules/effect/dist/esm/Iterable.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_Option();
    init_Predicate();
    findFirst = /* @__PURE__ */ dual(2, (self2, f) => {
      let i = 0;
      for (const a of self2) {
        const o = f(a, i);
        if (isBoolean(o)) {
          if (o) {
            return some2(a);
          }
        } else {
          if (isSome2(o)) {
            return o;
          }
        }
        i++;
      }
      return none2();
    });
    constEmpty = {
      [Symbol.iterator]() {
        return constEmptyIterator;
      }
    };
    constEmptyIterator = {
      next() {
        return {
          done: true,
          value: void 0
        };
      }
    };
    empty = /* @__PURE__ */ __name(() => constEmpty, "empty");
    map3 = /* @__PURE__ */ dual(2, (self2, f) => ({
      [Symbol.iterator]() {
        const iterator2 = self2[Symbol.iterator]();
        let i = 0;
        return {
          next() {
            const result = iterator2.next();
            if (result.done) {
              return {
                done: true,
                value: void 0
              };
            }
            return {
              done: false,
              value: f(result.value, i++)
            };
          }
        };
      }
    }));
  }
});

// node_modules/effect/dist/esm/Record.js
var init_Record = __esm({
  "node_modules/effect/dist/esm/Record.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Array.js
var allocate, makeBy, fromIterable2, ensure, match3, matchLeft, prepend, append, appendAll, isArray, isEmptyArray, isEmptyReadonlyArray, isNonEmptyArray2, isNonEmptyReadonlyArray, isOutOfBounds, clamp2, get, unsafeGet, head, headNonEmpty, last, lastNonEmpty, tailNonEmpty, spanIndex, span, drop, findFirst2, reverse, sort, zip, zipWith2, containsWith2, _equivalence2, splitAt, splitNonEmptyAt, copy, unionWith, union, intersectionWith, intersection, empty2, of, map4, flatMap2, flatten2, filterMap2, filterMapWhile, partitionMap2, getSomes, filter2, reduce, reduceRight, every, unfold, getEquivalence3, dedupeWith, dedupe, join, mapAccum;
var init_Array = __esm({
  "node_modules/effect/dist/esm/Array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Either();
    init_Equal();
    init_Equivalence();
    init_Function();
    init_array();
    init_Iterable();
    init_Option();
    init_Tuple();
    allocate = /* @__PURE__ */ __name((n) => new Array(n), "allocate");
    makeBy = /* @__PURE__ */ dual(2, (n, f) => {
      const max6 = Math.max(1, Math.floor(n));
      const out = new Array(max6);
      for (let i = 0; i < max6; i++) {
        out[i] = f(i);
      }
      return out;
    });
    fromIterable2 = /* @__PURE__ */ __name((collection) => Array.isArray(collection) ? collection : Array.from(collection), "fromIterable");
    ensure = /* @__PURE__ */ __name((self2) => Array.isArray(self2) ? self2 : [self2], "ensure");
    match3 = /* @__PURE__ */ dual(2, (self2, {
      onEmpty,
      onNonEmpty
    }) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(self2) : onEmpty());
    matchLeft = /* @__PURE__ */ dual(2, (self2, {
      onEmpty,
      onNonEmpty
    }) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(headNonEmpty(self2), tailNonEmpty(self2)) : onEmpty());
    prepend = /* @__PURE__ */ dual(2, (self2, head7) => [head7, ...self2]);
    append = /* @__PURE__ */ dual(2, (self2, last6) => [...self2, last6]);
    appendAll = /* @__PURE__ */ dual(2, (self2, that) => fromIterable2(self2).concat(fromIterable2(that)));
    isArray = Array.isArray;
    isEmptyArray = /* @__PURE__ */ __name((self2) => self2.length === 0, "isEmptyArray");
    isEmptyReadonlyArray = isEmptyArray;
    isNonEmptyArray2 = isNonEmptyArray;
    isNonEmptyReadonlyArray = isNonEmptyArray;
    isOutOfBounds = /* @__PURE__ */ __name((i, as12) => i < 0 || i >= as12.length, "isOutOfBounds");
    clamp2 = /* @__PURE__ */ __name((i, as12) => Math.floor(Math.min(Math.max(0, i), as12.length)), "clamp");
    get = /* @__PURE__ */ dual(2, (self2, index2) => {
      const i = Math.floor(index2);
      return isOutOfBounds(i, self2) ? none2() : some2(self2[i]);
    });
    unsafeGet = /* @__PURE__ */ dual(2, (self2, index2) => {
      const i = Math.floor(index2);
      if (isOutOfBounds(i, self2)) {
        throw new Error(`Index ${i} out of bounds`);
      }
      return self2[i];
    });
    head = /* @__PURE__ */ get(0);
    headNonEmpty = /* @__PURE__ */ unsafeGet(0);
    last = /* @__PURE__ */ __name((self2) => isNonEmptyReadonlyArray(self2) ? some2(lastNonEmpty(self2)) : none2(), "last");
    lastNonEmpty = /* @__PURE__ */ __name((self2) => self2[self2.length - 1], "lastNonEmpty");
    tailNonEmpty = /* @__PURE__ */ __name((self2) => self2.slice(1), "tailNonEmpty");
    spanIndex = /* @__PURE__ */ __name((self2, predicate) => {
      let i = 0;
      for (const a of self2) {
        if (!predicate(a, i)) {
          break;
        }
        i++;
      }
      return i;
    }, "spanIndex");
    span = /* @__PURE__ */ dual(2, (self2, predicate) => splitAt(self2, spanIndex(self2, predicate)));
    drop = /* @__PURE__ */ dual(2, (self2, n) => {
      const input = fromIterable2(self2);
      return input.slice(clamp2(n, input), input.length);
    });
    findFirst2 = findFirst;
    reverse = /* @__PURE__ */ __name((self2) => Array.from(self2).reverse(), "reverse");
    sort = /* @__PURE__ */ dual(2, (self2, O) => {
      const out = Array.from(self2);
      out.sort(O);
      return out;
    });
    zip = /* @__PURE__ */ dual(2, (self2, that) => zipWith2(self2, that, make3));
    zipWith2 = /* @__PURE__ */ dual(3, (self2, that, f) => {
      const as12 = fromIterable2(self2);
      const bs = fromIterable2(that);
      if (isNonEmptyReadonlyArray(as12) && isNonEmptyReadonlyArray(bs)) {
        const out = [f(headNonEmpty(as12), headNonEmpty(bs))];
        const len = Math.min(as12.length, bs.length);
        for (let i = 1; i < len; i++) {
          out[i] = f(as12[i], bs[i]);
        }
        return out;
      }
      return [];
    });
    containsWith2 = /* @__PURE__ */ __name((isEquivalent) => dual(2, (self2, a) => {
      for (const i of self2) {
        if (isEquivalent(a, i)) {
          return true;
        }
      }
      return false;
    }), "containsWith");
    _equivalence2 = /* @__PURE__ */ equivalence();
    splitAt = /* @__PURE__ */ dual(2, (self2, n) => {
      const input = Array.from(self2);
      const _n = Math.floor(n);
      if (isNonEmptyReadonlyArray(input)) {
        if (_n >= 1) {
          return splitNonEmptyAt(input, _n);
        }
        return [[], input];
      }
      return [input, []];
    });
    splitNonEmptyAt = /* @__PURE__ */ dual(2, (self2, n) => {
      const _n = Math.max(1, Math.floor(n));
      return _n >= self2.length ? [copy(self2), []] : [prepend(self2.slice(1, _n), headNonEmpty(self2)), self2.slice(_n)];
    });
    copy = /* @__PURE__ */ __name((self2) => self2.slice(), "copy");
    unionWith = /* @__PURE__ */ dual(3, (self2, that, isEquivalent) => {
      const a = fromIterable2(self2);
      const b = fromIterable2(that);
      if (isNonEmptyReadonlyArray(a)) {
        if (isNonEmptyReadonlyArray(b)) {
          const dedupe2 = dedupeWith(isEquivalent);
          return dedupe2(appendAll(a, b));
        }
        return a;
      }
      return b;
    });
    union = /* @__PURE__ */ dual(2, (self2, that) => unionWith(self2, that, _equivalence2));
    intersectionWith = /* @__PURE__ */ __name((isEquivalent) => {
      const has9 = containsWith2(isEquivalent);
      return dual(2, (self2, that) => {
        const bs = fromIterable2(that);
        return fromIterable2(self2).filter((a) => has9(bs, a));
      });
    }, "intersectionWith");
    intersection = /* @__PURE__ */ intersectionWith(_equivalence2);
    empty2 = /* @__PURE__ */ __name(() => [], "empty");
    of = /* @__PURE__ */ __name((a) => [a], "of");
    map4 = /* @__PURE__ */ dual(2, (self2, f) => self2.map(f));
    flatMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
      if (isEmptyReadonlyArray(self2)) {
        return [];
      }
      const out = [];
      for (let i = 0; i < self2.length; i++) {
        const inner = f(self2[i], i);
        for (let j = 0; j < inner.length; j++) {
          out.push(inner[j]);
        }
      }
      return out;
    });
    flatten2 = /* @__PURE__ */ flatMap2(identity);
    filterMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
      const as12 = fromIterable2(self2);
      const out = [];
      for (let i = 0; i < as12.length; i++) {
        const o = f(as12[i], i);
        if (isSome2(o)) {
          out.push(o.value);
        }
      }
      return out;
    });
    filterMapWhile = /* @__PURE__ */ dual(2, (self2, f) => {
      let i = 0;
      const out = [];
      for (const a of self2) {
        const b = f(a, i);
        if (isSome2(b)) {
          out.push(b.value);
        } else {
          break;
        }
        i++;
      }
      return out;
    });
    partitionMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
      const left3 = [];
      const right3 = [];
      const as12 = fromIterable2(self2);
      for (let i = 0; i < as12.length; i++) {
        const e = f(as12[i], i);
        if (isLeft2(e)) {
          left3.push(e.left);
        } else {
          right3.push(e.right);
        }
      }
      return [left3, right3];
    });
    getSomes = /* @__PURE__ */ filterMap2(identity);
    filter2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
      const as12 = fromIterable2(self2);
      const out = [];
      for (let i = 0; i < as12.length; i++) {
        if (predicate(as12[i], i)) {
          out.push(as12[i]);
        }
      }
      return out;
    });
    reduce = /* @__PURE__ */ dual(3, (self2, b, f) => fromIterable2(self2).reduce((b2, a, i) => f(b2, a, i), b));
    reduceRight = /* @__PURE__ */ dual(3, (self2, b, f) => fromIterable2(self2).reduceRight((b2, a, i) => f(b2, a, i), b));
    every = /* @__PURE__ */ dual(2, (self2, refinement) => self2.every(refinement));
    unfold = /* @__PURE__ */ __name((b, f) => {
      const out = [];
      let next4 = b;
      let o;
      while (isSome2(o = f(next4))) {
        const [a, b2] = o.value;
        out.push(a);
        next4 = b2;
      }
      return out;
    }, "unfold");
    getEquivalence3 = array;
    dedupeWith = /* @__PURE__ */ dual(2, (self2, isEquivalent) => {
      const input = fromIterable2(self2);
      if (isNonEmptyReadonlyArray(input)) {
        const out = [headNonEmpty(input)];
        const rest = tailNonEmpty(input);
        for (const r of rest) {
          if (out.every((a) => !isEquivalent(r, a))) {
            out.push(r);
          }
        }
        return out;
      }
      return [];
    });
    dedupe = /* @__PURE__ */ __name((self2) => dedupeWith(self2, equivalence()), "dedupe");
    join = /* @__PURE__ */ dual(2, (self2, sep) => fromIterable2(self2).join(sep));
    mapAccum = /* @__PURE__ */ dual(3, (self2, s, f) => {
      let i = 0;
      let s1 = s;
      const out = [];
      for (const a of self2) {
        const r = f(s1, a, i);
        s1 = r[0];
        out.push(r[1]);
        i++;
      }
      return [s1, out];
    });
  }
});

// node_modules/fast-check/lib/esm/check/precondition/PreconditionFailure.js
var PreconditionFailure;
var init_PreconditionFailure = __esm({
  "node_modules/fast-check/lib/esm/check/precondition/PreconditionFailure.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    PreconditionFailure = class _PreconditionFailure extends Error {
      static {
        __name(this, "PreconditionFailure");
      }
      constructor(interruptExecution = false) {
        super();
        this.interruptExecution = interruptExecution;
        this.footprint = _PreconditionFailure.SharedFootPrint;
      }
      static isFailure(err) {
        return err != null && err.footprint === _PreconditionFailure.SharedFootPrint;
      }
    };
    PreconditionFailure.SharedFootPrint = Symbol.for("fast-check/PreconditionFailure");
  }
});

// node_modules/fast-check/lib/esm/check/precondition/Pre.js
var init_Pre = __esm({
  "node_modules/fast-check/lib/esm/check/precondition/Pre.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_PreconditionFailure();
  }
});

// node_modules/fast-check/lib/esm/stream/StreamHelpers.js
function nilHelper() {
  return Nil.nil;
}
function* mapHelper(g, f) {
  for (const v of g) {
    yield f(v);
  }
}
function* flatMapHelper(g, f) {
  for (const v of g) {
    yield* f(v);
  }
}
function* filterHelper(g, f) {
  for (const v of g) {
    if (f(v)) {
      yield v;
    }
  }
}
function* takeNHelper(g, n) {
  for (let i = 0; i < n; ++i) {
    const cur = g.next();
    if (cur.done) {
      break;
    }
    yield cur.value;
  }
}
function* takeWhileHelper(g, f) {
  let cur = g.next();
  while (!cur.done && f(cur.value)) {
    yield cur.value;
    cur = g.next();
  }
}
function* joinHelper(g, others) {
  for (let cur = g.next(); !cur.done; cur = g.next()) {
    yield cur.value;
  }
  for (const s of others) {
    for (let cur = s.next(); !cur.done; cur = s.next()) {
      yield cur.value;
    }
  }
}
var Nil;
var init_StreamHelpers = __esm({
  "node_modules/fast-check/lib/esm/stream/StreamHelpers.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Nil = class {
      static {
        __name(this, "Nil");
      }
      [Symbol.iterator]() {
        return this;
      }
      next(value3) {
        return { value: value3, done: true };
      }
    };
    Nil.nil = new Nil();
    __name(nilHelper, "nilHelper");
    __name(mapHelper, "mapHelper");
    __name(flatMapHelper, "flatMapHelper");
    __name(filterHelper, "filterHelper");
    __name(takeNHelper, "takeNHelper");
    __name(takeWhileHelper, "takeWhileHelper");
    __name(joinHelper, "joinHelper");
  }
});

// node_modules/fast-check/lib/esm/stream/Stream.js
function stream(g) {
  return new Stream(g);
}
var safeSymbolIterator, Stream;
var init_Stream = __esm({
  "node_modules/fast-check/lib/esm/stream/Stream.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_StreamHelpers();
    safeSymbolIterator = Symbol.iterator;
    Stream = class _Stream {
      static {
        __name(this, "Stream");
      }
      static nil() {
        return new _Stream(nilHelper());
      }
      static of(...elements) {
        return new _Stream(elements[safeSymbolIterator]());
      }
      constructor(g) {
        this.g = g;
      }
      next() {
        return this.g.next();
      }
      [Symbol.iterator]() {
        return this.g;
      }
      map(f) {
        return new _Stream(mapHelper(this.g, f));
      }
      flatMap(f) {
        return new _Stream(flatMapHelper(this.g, f));
      }
      dropWhile(f) {
        let foundEligible = false;
        function* helper(v) {
          if (foundEligible || !f(v)) {
            foundEligible = true;
            yield v;
          }
        }
        __name(helper, "helper");
        return this.flatMap(helper);
      }
      drop(n) {
        if (n <= 0) {
          return this;
        }
        let idx = 0;
        function helper() {
          return idx++ < n;
        }
        __name(helper, "helper");
        return this.dropWhile(helper);
      }
      takeWhile(f) {
        return new _Stream(takeWhileHelper(this.g, f));
      }
      take(n) {
        return new _Stream(takeNHelper(this.g, n));
      }
      filter(f) {
        return new _Stream(filterHelper(this.g, f));
      }
      every(f) {
        for (const v of this.g) {
          if (!f(v)) {
            return false;
          }
        }
        return true;
      }
      has(f) {
        for (const v of this.g) {
          if (f(v)) {
            return [true, v];
          }
        }
        return [false, null];
      }
      join(...others) {
        return new _Stream(joinHelper(this.g, others));
      }
      getNthOrLast(nth) {
        let remaining = nth;
        let last6 = null;
        for (const v of this.g) {
          if (remaining-- === 0)
            return v;
          last6 = v;
        }
        return last6;
      }
    };
    __name(stream, "stream");
  }
});

// node_modules/fast-check/lib/esm/check/symbols.js
function hasCloneMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && cloneMethod in instance && typeof instance[cloneMethod] === "function";
}
function cloneIfNeeded(instance) {
  return hasCloneMethod(instance) ? instance[cloneMethod]() : instance;
}
var cloneMethod;
var init_symbols = __esm({
  "node_modules/fast-check/lib/esm/check/symbols.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    cloneMethod = Symbol.for("fast-check/cloneMethod");
    __name(hasCloneMethod, "hasCloneMethod");
    __name(cloneIfNeeded, "cloneIfNeeded");
  }
});

// node_modules/fast-check/lib/esm/check/arbitrary/definition/Value.js
var safeObjectDefineProperty, Value;
var init_Value = __esm({
  "node_modules/fast-check/lib/esm/check/arbitrary/definition/Value.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_symbols();
    safeObjectDefineProperty = Object.defineProperty;
    Value = class {
      static {
        __name(this, "Value");
      }
      constructor(value_, context10, customGetValue = void 0) {
        this.value_ = value_;
        this.context = context10;
        this.hasToBeCloned = customGetValue !== void 0 || hasCloneMethod(value_);
        this.readOnce = false;
        if (this.hasToBeCloned) {
          safeObjectDefineProperty(this, "value", { get: customGetValue !== void 0 ? customGetValue : this.getValue });
        } else {
          this.value = value_;
        }
      }
      getValue() {
        if (this.hasToBeCloned) {
          if (!this.readOnce) {
            this.readOnce = true;
            return this.value_;
          }
          return this.value_[cloneMethod]();
        }
        return this.value_;
      }
    };
  }
});

// node_modules/fast-check/lib/esm/check/arbitrary/definition/Arbitrary.js
var safeObjectAssign, Arbitrary, ChainArbitrary, MapArbitrary, FilterArbitrary, NoShrinkArbitrary, NoBiasArbitrary;
var init_Arbitrary = __esm({
  "node_modules/fast-check/lib/esm/check/arbitrary/definition/Arbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Stream();
    init_symbols();
    init_Value();
    safeObjectAssign = Object.assign;
    Arbitrary = class {
      static {
        __name(this, "Arbitrary");
      }
      filter(refinement) {
        return new FilterArbitrary(this, refinement);
      }
      map(mapper, unmapper) {
        return new MapArbitrary(this, mapper, unmapper);
      }
      chain(chainer) {
        return new ChainArbitrary(this, chainer);
      }
      noShrink() {
        return new NoShrinkArbitrary(this);
      }
      noBias() {
        return new NoBiasArbitrary(this);
      }
    };
    ChainArbitrary = class extends Arbitrary {
      static {
        __name(this, "ChainArbitrary");
      }
      constructor(arb, chainer) {
        super();
        this.arb = arb;
        this.chainer = chainer;
      }
      generate(mrng, biasFactor) {
        const clonedMrng = mrng.clone();
        const src = this.arb.generate(mrng, biasFactor);
        return this.valueChainer(src, mrng, clonedMrng, biasFactor);
      }
      canShrinkWithoutContext(value3) {
        return false;
      }
      shrink(value3, context10) {
        if (this.isSafeContext(context10)) {
          return (!context10.stoppedForOriginal ? this.arb.shrink(context10.originalValue, context10.originalContext).map((v) => this.valueChainer(v, context10.clonedMrng.clone(), context10.clonedMrng, context10.originalBias)) : Stream.nil()).join(context10.chainedArbitrary.shrink(value3, context10.chainedContext).map((dst) => {
            const newContext = safeObjectAssign(safeObjectAssign({}, context10), {
              chainedContext: dst.context,
              stoppedForOriginal: true
            });
            return new Value(dst.value_, newContext);
          }));
        }
        return Stream.nil();
      }
      valueChainer(v, generateMrng, clonedMrng, biasFactor) {
        const chainedArbitrary = this.chainer(v.value_);
        const dst = chainedArbitrary.generate(generateMrng, biasFactor);
        const context10 = {
          originalBias: biasFactor,
          originalValue: v.value_,
          originalContext: v.context,
          stoppedForOriginal: false,
          chainedArbitrary,
          chainedContext: dst.context,
          clonedMrng
        };
        return new Value(dst.value_, context10);
      }
      isSafeContext(context10) {
        return context10 != null && typeof context10 === "object" && "originalBias" in context10 && "originalValue" in context10 && "originalContext" in context10 && "stoppedForOriginal" in context10 && "chainedArbitrary" in context10 && "chainedContext" in context10 && "clonedMrng" in context10;
      }
    };
    MapArbitrary = class extends Arbitrary {
      static {
        __name(this, "MapArbitrary");
      }
      constructor(arb, mapper, unmapper) {
        super();
        this.arb = arb;
        this.mapper = mapper;
        this.unmapper = unmapper;
        this.bindValueMapper = (v) => this.valueMapper(v);
      }
      generate(mrng, biasFactor) {
        const g = this.arb.generate(mrng, biasFactor);
        return this.valueMapper(g);
      }
      canShrinkWithoutContext(value3) {
        if (this.unmapper !== void 0) {
          try {
            const unmapped = this.unmapper(value3);
            return this.arb.canShrinkWithoutContext(unmapped);
          } catch (_err) {
            return false;
          }
        }
        return false;
      }
      shrink(value3, context10) {
        if (this.isSafeContext(context10)) {
          return this.arb.shrink(context10.originalValue, context10.originalContext).map(this.bindValueMapper);
        }
        if (this.unmapper !== void 0) {
          const unmapped = this.unmapper(value3);
          return this.arb.shrink(unmapped, void 0).map(this.bindValueMapper);
        }
        return Stream.nil();
      }
      mapperWithCloneIfNeeded(v) {
        const sourceValue = v.value;
        const mappedValue = this.mapper(sourceValue);
        if (v.hasToBeCloned && (typeof mappedValue === "object" && mappedValue !== null || typeof mappedValue === "function") && Object.isExtensible(mappedValue) && !hasCloneMethod(mappedValue)) {
          Object.defineProperty(mappedValue, cloneMethod, { get: /* @__PURE__ */ __name(() => () => this.mapperWithCloneIfNeeded(v)[0], "get") });
        }
        return [mappedValue, sourceValue];
      }
      valueMapper(v) {
        const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);
        const context10 = { originalValue: sourceValue, originalContext: v.context };
        return new Value(mappedValue, context10);
      }
      isSafeContext(context10) {
        return context10 != null && typeof context10 === "object" && "originalValue" in context10 && "originalContext" in context10;
      }
    };
    FilterArbitrary = class extends Arbitrary {
      static {
        __name(this, "FilterArbitrary");
      }
      constructor(arb, refinement) {
        super();
        this.arb = arb;
        this.refinement = refinement;
        this.bindRefinementOnValue = (v) => this.refinementOnValue(v);
      }
      generate(mrng, biasFactor) {
        while (true) {
          const g = this.arb.generate(mrng, biasFactor);
          if (this.refinementOnValue(g)) {
            return g;
          }
        }
      }
      canShrinkWithoutContext(value3) {
        return this.arb.canShrinkWithoutContext(value3) && this.refinement(value3);
      }
      shrink(value3, context10) {
        return this.arb.shrink(value3, context10).filter(this.bindRefinementOnValue);
      }
      refinementOnValue(v) {
        return this.refinement(v.value);
      }
    };
    NoShrinkArbitrary = class extends Arbitrary {
      static {
        __name(this, "NoShrinkArbitrary");
      }
      constructor(arb) {
        super();
        this.arb = arb;
      }
      generate(mrng, biasFactor) {
        return this.arb.generate(mrng, biasFactor);
      }
      canShrinkWithoutContext(value3) {
        return this.arb.canShrinkWithoutContext(value3);
      }
      shrink(_value, _context) {
        return Stream.nil();
      }
      noShrink() {
        return this;
      }
    };
    NoBiasArbitrary = class extends Arbitrary {
      static {
        __name(this, "NoBiasArbitrary");
      }
      constructor(arb) {
        super();
        this.arb = arb;
      }
      generate(mrng, _biasFactor) {
        return this.arb.generate(mrng, void 0);
      }
      canShrinkWithoutContext(value3) {
        return this.arb.canShrinkWithoutContext(value3);
      }
      shrink(value3, context10) {
        return this.arb.shrink(value3, context10);
      }
      noBias() {
        return this;
      }
    };
  }
});

// node_modules/fast-check/lib/esm/utils/apply.js
function safeExtractApply(f) {
  try {
    return f.apply;
  } catch (err) {
    return void 0;
  }
}
function safeApplyHacky(f, instance, args2) {
  const ff = f;
  ff[ApplySymbol] = untouchedApply;
  const out = ff[ApplySymbol](instance, args2);
  delete ff[ApplySymbol];
  return out;
}
function safeApply(f, instance, args2) {
  if (safeExtractApply(f) === untouchedApply) {
    return f.apply(instance, args2);
  }
  return safeApplyHacky(f, instance, args2);
}
var untouchedApply, ApplySymbol;
var init_apply = __esm({
  "node_modules/fast-check/lib/esm/utils/apply.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    untouchedApply = Function.prototype.apply;
    ApplySymbol = Symbol("apply");
    __name(safeExtractApply, "safeExtractApply");
    __name(safeApplyHacky, "safeApplyHacky");
    __name(safeApply, "safeApply");
  }
});

// node_modules/fast-check/lib/esm/utils/globals.js
function extractIndexOf(instance) {
  try {
    return instance.indexOf;
  } catch (err) {
    return void 0;
  }
}
function extractJoin(instance) {
  try {
    return instance.join;
  } catch (err) {
    return void 0;
  }
}
function extractMap(instance) {
  try {
    return instance.map;
  } catch (err) {
    return void 0;
  }
}
function extractFilter(instance) {
  try {
    return instance.filter;
  } catch (err) {
    return void 0;
  }
}
function extractPush(instance) {
  try {
    return instance.push;
  } catch (err) {
    return void 0;
  }
}
function extractSlice(instance) {
  try {
    return instance.slice;
  } catch (err) {
    return void 0;
  }
}
function safeIndexOf(instance, ...args2) {
  if (extractIndexOf(instance) === untouchedIndexOf) {
    return instance.indexOf(...args2);
  }
  return safeApply(untouchedIndexOf, instance, args2);
}
function safeJoin(instance, ...args2) {
  if (extractJoin(instance) === untouchedJoin) {
    return instance.join(...args2);
  }
  return safeApply(untouchedJoin, instance, args2);
}
function safeMap(instance, fn2) {
  if (extractMap(instance) === untouchedMap) {
    return instance.map(fn2);
  }
  return safeApply(untouchedMap, instance, [fn2]);
}
function safeFilter(instance, predicate) {
  if (extractFilter(instance) === untouchedFilter) {
    return instance.filter(predicate);
  }
  return safeApply(untouchedFilter, instance, [predicate]);
}
function safePush(instance, ...args2) {
  if (extractPush(instance) === untouchedPush) {
    return instance.push(...args2);
  }
  return safeApply(untouchedPush, instance, args2);
}
function safeSlice(instance, ...args2) {
  if (extractSlice(instance) === untouchedSlice) {
    return instance.slice(...args2);
  }
  return safeApply(untouchedSlice, instance, args2);
}
function extractGetTime(instance) {
  try {
    return instance.getTime;
  } catch (err) {
    return void 0;
  }
}
function extractToISOString(instance) {
  try {
    return instance.toISOString;
  } catch (err) {
    return void 0;
  }
}
function safeGetTime(instance) {
  if (extractGetTime(instance) === untouchedGetTime) {
    return instance.getTime();
  }
  return safeApply(untouchedGetTime, instance, []);
}
function safeToISOString(instance) {
  if (extractToISOString(instance) === untouchedToISOString) {
    return instance.toISOString();
  }
  return safeApply(untouchedToISOString, instance, []);
}
function extractMapSet(instance) {
  try {
    return instance.set;
  } catch (err) {
    return void 0;
  }
}
function extractMapGet(instance) {
  try {
    return instance.get;
  } catch (err) {
    return void 0;
  }
}
function safeMapSet(instance, key, value3) {
  if (extractMapSet(instance) === untouchedMapSet) {
    return instance.set(key, value3);
  }
  return safeApply(untouchedMapSet, instance, [key, value3]);
}
function safeMapGet(instance, key) {
  if (extractMapGet(instance) === untouchedMapGet) {
    return instance.get(key);
  }
  return safeApply(untouchedMapGet, instance, [key]);
}
function extractSplit(instance) {
  try {
    return instance.split;
  } catch (err) {
    return void 0;
  }
}
function extractCharCodeAt(instance) {
  try {
    return instance.charCodeAt;
  } catch (err) {
    return void 0;
  }
}
function safeSplit(instance, ...args2) {
  if (extractSplit(instance) === untouchedSplit) {
    return instance.split(...args2);
  }
  return safeApply(untouchedSplit, instance, args2);
}
function safeCharCodeAt(instance, index2) {
  if (extractCharCodeAt(instance) === untouchedCharCodeAt) {
    return instance.charCodeAt(index2);
  }
  return safeApply(untouchedCharCodeAt, instance, [index2]);
}
function extractNumberToString(instance) {
  try {
    return instance.toString;
  } catch (err) {
    return void 0;
  }
}
function safeNumberToString(instance, ...args2) {
  if (extractNumberToString(instance) === untouchedNumberToString) {
    return instance.toString(...args2);
  }
  return safeApply(untouchedNumberToString, instance, args2);
}
function safeToString2(instance) {
  return safeApply(untouchedToString, instance, []);
}
var SArray, SError, SString, SencodeURIComponent, SSymbol, untouchedForEach, untouchedIndexOf, untouchedJoin, untouchedMap, untouchedFilter, untouchedPush, untouchedPop, untouchedSplice, untouchedSlice, untouchedSort, untouchedEvery, untouchedGetTime, untouchedToISOString, untouchedAdd, untouchedHas, untouchedSet, untouchedGet, untouchedMapSet, untouchedMapGet, untouchedSplit, untouchedStartsWith, untouchedEndsWith, untouchedSubstring, untouchedToLowerCase, untouchedToUpperCase, untouchedPadStart, untouchedCharCodeAt, untouchedNormalize, untouchedReplace, untouchedNumberToString, untouchedToString;
var init_globals = __esm({
  "node_modules/fast-check/lib/esm/utils/globals.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_apply();
    SArray = typeof Array !== "undefined" ? Array : void 0;
    SError = typeof Error !== "undefined" ? Error : void 0;
    SString = typeof String !== "undefined" ? String : void 0;
    SencodeURIComponent = typeof encodeURIComponent !== "undefined" ? encodeURIComponent : void 0;
    SSymbol = Symbol;
    untouchedForEach = Array.prototype.forEach;
    untouchedIndexOf = Array.prototype.indexOf;
    untouchedJoin = Array.prototype.join;
    untouchedMap = Array.prototype.map;
    untouchedFilter = Array.prototype.filter;
    untouchedPush = Array.prototype.push;
    untouchedPop = Array.prototype.pop;
    untouchedSplice = Array.prototype.splice;
    untouchedSlice = Array.prototype.slice;
    untouchedSort = Array.prototype.sort;
    untouchedEvery = Array.prototype.every;
    __name(extractIndexOf, "extractIndexOf");
    __name(extractJoin, "extractJoin");
    __name(extractMap, "extractMap");
    __name(extractFilter, "extractFilter");
    __name(extractPush, "extractPush");
    __name(extractSlice, "extractSlice");
    __name(safeIndexOf, "safeIndexOf");
    __name(safeJoin, "safeJoin");
    __name(safeMap, "safeMap");
    __name(safeFilter, "safeFilter");
    __name(safePush, "safePush");
    __name(safeSlice, "safeSlice");
    untouchedGetTime = Date.prototype.getTime;
    untouchedToISOString = Date.prototype.toISOString;
    __name(extractGetTime, "extractGetTime");
    __name(extractToISOString, "extractToISOString");
    __name(safeGetTime, "safeGetTime");
    __name(safeToISOString, "safeToISOString");
    untouchedAdd = Set.prototype.add;
    untouchedHas = Set.prototype.has;
    untouchedSet = WeakMap.prototype.set;
    untouchedGet = WeakMap.prototype.get;
    untouchedMapSet = Map.prototype.set;
    untouchedMapGet = Map.prototype.get;
    __name(extractMapSet, "extractMapSet");
    __name(extractMapGet, "extractMapGet");
    __name(safeMapSet, "safeMapSet");
    __name(safeMapGet, "safeMapGet");
    untouchedSplit = String.prototype.split;
    untouchedStartsWith = String.prototype.startsWith;
    untouchedEndsWith = String.prototype.endsWith;
    untouchedSubstring = String.prototype.substring;
    untouchedToLowerCase = String.prototype.toLowerCase;
    untouchedToUpperCase = String.prototype.toUpperCase;
    untouchedPadStart = String.prototype.padStart;
    untouchedCharCodeAt = String.prototype.charCodeAt;
    untouchedNormalize = String.prototype.normalize;
    untouchedReplace = String.prototype.replace;
    __name(extractSplit, "extractSplit");
    __name(extractCharCodeAt, "extractCharCodeAt");
    __name(safeSplit, "safeSplit");
    __name(safeCharCodeAt, "safeCharCodeAt");
    untouchedNumberToString = Number.prototype.toString;
    __name(extractNumberToString, "extractNumberToString");
    __name(safeNumberToString, "safeNumberToString");
    untouchedToString = Object.prototype.toString;
    __name(safeToString2, "safeToString");
  }
});

// node_modules/fast-check/lib/esm/stream/LazyIterableIterator.js
function makeLazy(producer) {
  return new LazyIterableIterator(producer);
}
var LazyIterableIterator;
var init_LazyIterableIterator = __esm({
  "node_modules/fast-check/lib/esm/stream/LazyIterableIterator.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    LazyIterableIterator = class {
      static {
        __name(this, "LazyIterableIterator");
      }
      constructor(producer) {
        this.producer = producer;
      }
      [Symbol.iterator]() {
        if (this.it === void 0) {
          this.it = this.producer();
        }
        return this.it;
      }
      next() {
        if (this.it === void 0) {
          this.it = this.producer();
        }
        return this.it.next();
      }
    };
    __name(makeLazy, "makeLazy");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/TupleArbitrary.js
var init_TupleArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/TupleArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Stream();
    init_symbols();
    init_Arbitrary();
    init_Value();
    init_globals();
    init_LazyIterableIterator();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/tuple.js
var init_tuple = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/tuple.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_TupleArbitrary();
  }
});

// node_modules/fast-check/lib/esm/check/property/IRawProperty.js
function runIdToFrequency(runId) {
  return 2 + ~~(safeMathLog(runId + 1) * 0.4342944819032518);
}
var safeMathLog;
var init_IRawProperty = __esm({
  "node_modules/fast-check/lib/esm/check/property/IRawProperty.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    safeMathLog = Math.log;
    __name(runIdToFrequency, "runIdToFrequency");
  }
});

// node_modules/fast-check/lib/esm/check/runner/configuration/GlobalParameters.js
function readConfigureGlobal() {
  return globalParameters;
}
var globalParameters;
var init_GlobalParameters = __esm({
  "node_modules/fast-check/lib/esm/check/runner/configuration/GlobalParameters.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    globalParameters = {};
    __name(readConfigureGlobal, "readConfigureGlobal");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/NoUndefinedAsContext.js
function noUndefinedAsContext(value3) {
  if (value3.context !== void 0) {
    return value3;
  }
  if (value3.hasToBeCloned) {
    return new Value(value3.value_, UndefinedContextPlaceholder, () => value3.value);
  }
  return new Value(value3.value_, UndefinedContextPlaceholder);
}
var UndefinedContextPlaceholder;
var init_NoUndefinedAsContext = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/NoUndefinedAsContext.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Value();
    UndefinedContextPlaceholder = Symbol("UndefinedContextPlaceholder");
    __name(noUndefinedAsContext, "noUndefinedAsContext");
  }
});

// node_modules/fast-check/lib/esm/check/property/AsyncProperty.generic.js
var AsyncProperty;
var init_AsyncProperty_generic = __esm({
  "node_modules/fast-check/lib/esm/check/property/AsyncProperty.generic.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_PreconditionFailure();
    init_IRawProperty();
    init_GlobalParameters();
    init_Stream();
    init_NoUndefinedAsContext();
    init_globals();
    AsyncProperty = class _AsyncProperty {
      static {
        __name(this, "AsyncProperty");
      }
      constructor(arb, predicate) {
        this.arb = arb;
        this.predicate = predicate;
        const { asyncBeforeEach, asyncAfterEach, beforeEach, afterEach } = readConfigureGlobal() || {};
        if (asyncBeforeEach !== void 0 && beforeEach !== void 0) {
          throw SError(`Global "asyncBeforeEach" and "beforeEach" parameters can't be set at the same time when running async properties`);
        }
        if (asyncAfterEach !== void 0 && afterEach !== void 0) {
          throw SError(`Global "asyncAfterEach" and "afterEach" parameters can't be set at the same time when running async properties`);
        }
        this.beforeEachHook = asyncBeforeEach || beforeEach || _AsyncProperty.dummyHook;
        this.afterEachHook = asyncAfterEach || afterEach || _AsyncProperty.dummyHook;
      }
      isAsync() {
        return true;
      }
      generate(mrng, runId) {
        const value3 = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : void 0);
        return noUndefinedAsContext(value3);
      }
      shrink(value3) {
        if (value3.context === void 0 && !this.arb.canShrinkWithoutContext(value3.value_)) {
          return Stream.nil();
        }
        const safeContext = value3.context !== UndefinedContextPlaceholder ? value3.context : void 0;
        return this.arb.shrink(value3.value_, safeContext).map(noUndefinedAsContext);
      }
      async runBeforeEach() {
        await this.beforeEachHook();
      }
      async runAfterEach() {
        await this.afterEachHook();
      }
      async run(v, dontRunHook) {
        if (!dontRunHook) {
          await this.beforeEachHook();
        }
        try {
          const output = await this.predicate(v);
          return output == null || output === true ? null : {
            error: new SError("Property failed by returning false"),
            errorMessage: "Error: Property failed by returning false"
          };
        } catch (err) {
          if (PreconditionFailure.isFailure(err))
            return err;
          if (err instanceof SError && err.stack) {
            return { error: err, errorMessage: err.stack };
          }
          return { error: err, errorMessage: SString(err) };
        } finally {
          if (!dontRunHook) {
            await this.afterEachHook();
          }
        }
      }
      beforeEach(hookFunction) {
        const previousBeforeEachHook = this.beforeEachHook;
        this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
        return this;
      }
      afterEach(hookFunction) {
        const previousAfterEachHook = this.afterEachHook;
        this.afterEachHook = () => hookFunction(previousAfterEachHook);
        return this;
      }
    };
    AsyncProperty.dummyHook = () => {
    };
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/AlwaysShrinkableArbitrary.js
var init_AlwaysShrinkableArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/AlwaysShrinkableArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary();
    init_Stream();
    init_NoUndefinedAsContext();
  }
});

// node_modules/fast-check/lib/esm/check/property/AsyncProperty.js
var init_AsyncProperty = __esm({
  "node_modules/fast-check/lib/esm/check/property/AsyncProperty.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary();
    init_tuple();
    init_AsyncProperty_generic();
    init_AlwaysShrinkableArbitrary();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/check/property/Property.generic.js
var Property;
var init_Property_generic = __esm({
  "node_modules/fast-check/lib/esm/check/property/Property.generic.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_PreconditionFailure();
    init_IRawProperty();
    init_GlobalParameters();
    init_Stream();
    init_NoUndefinedAsContext();
    init_globals();
    Property = class _Property {
      static {
        __name(this, "Property");
      }
      constructor(arb, predicate) {
        this.arb = arb;
        this.predicate = predicate;
        const { beforeEach = _Property.dummyHook, afterEach = _Property.dummyHook, asyncBeforeEach, asyncAfterEach } = readConfigureGlobal() || {};
        if (asyncBeforeEach !== void 0) {
          throw SError(`"asyncBeforeEach" can't be set when running synchronous properties`);
        }
        if (asyncAfterEach !== void 0) {
          throw SError(`"asyncAfterEach" can't be set when running synchronous properties`);
        }
        this.beforeEachHook = beforeEach;
        this.afterEachHook = afterEach;
      }
      isAsync() {
        return false;
      }
      generate(mrng, runId) {
        const value3 = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : void 0);
        return noUndefinedAsContext(value3);
      }
      shrink(value3) {
        if (value3.context === void 0 && !this.arb.canShrinkWithoutContext(value3.value_)) {
          return Stream.nil();
        }
        const safeContext = value3.context !== UndefinedContextPlaceholder ? value3.context : void 0;
        return this.arb.shrink(value3.value_, safeContext).map(noUndefinedAsContext);
      }
      runBeforeEach() {
        this.beforeEachHook();
      }
      runAfterEach() {
        this.afterEachHook();
      }
      run(v, dontRunHook) {
        if (!dontRunHook) {
          this.beforeEachHook();
        }
        try {
          const output = this.predicate(v);
          return output == null || output === true ? null : {
            error: new SError("Property failed by returning false"),
            errorMessage: "Error: Property failed by returning false"
          };
        } catch (err) {
          if (PreconditionFailure.isFailure(err))
            return err;
          if (err instanceof SError && err.stack) {
            return { error: err, errorMessage: err.stack };
          }
          return { error: err, errorMessage: SString(err) };
        } finally {
          if (!dontRunHook) {
            this.afterEachHook();
          }
        }
      }
      beforeEach(hookFunction) {
        const previousBeforeEachHook = this.beforeEachHook;
        this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
        return this;
      }
      afterEach(hookFunction) {
        const previousAfterEachHook = this.afterEachHook;
        this.afterEachHook = () => hookFunction(previousAfterEachHook);
        return this;
      }
    };
    Property.dummyHook = () => {
    };
  }
});

// node_modules/fast-check/lib/esm/check/property/Property.js
var init_Property = __esm({
  "node_modules/fast-check/lib/esm/check/property/Property.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary();
    init_tuple();
    init_Property_generic();
    init_AlwaysShrinkableArbitrary();
    init_globals();
  }
});

// node_modules/pure-rand/lib/esm/generator/RandomGenerator.js
function unsafeGenerateN(rng, num) {
  var out = [];
  for (var idx = 0; idx != num; ++idx) {
    out.push(rng.unsafeNext());
  }
  return out;
}
function generateN(rng, num) {
  var nextRng = rng.clone();
  var out = unsafeGenerateN(nextRng, num);
  return [out, nextRng];
}
function unsafeSkipN(rng, num) {
  for (var idx = 0; idx != num; ++idx) {
    rng.unsafeNext();
  }
}
function skipN(rng, num) {
  var nextRng = rng.clone();
  unsafeSkipN(nextRng, num);
  return nextRng;
}
var init_RandomGenerator = __esm({
  "node_modules/pure-rand/lib/esm/generator/RandomGenerator.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(unsafeGenerateN, "unsafeGenerateN");
    __name(generateN, "generateN");
    __name(unsafeSkipN, "unsafeSkipN");
    __name(skipN, "skipN");
  }
});

// node_modules/pure-rand/lib/esm/generator/LinearCongruential.js
function fromState(state) {
  var valid = state.length === 1;
  if (!valid) {
    throw new Error("The state must have been produced by a congruential32 RandomGenerator");
  }
  return new LinearCongruential32(state[0]);
}
var MULTIPLIER, INCREMENT, MASK, MASK_2, computeNextSeed, computeValueFromNextSeed, LinearCongruential32, congruential32;
var init_LinearCongruential = __esm({
  "node_modules/pure-rand/lib/esm/generator/LinearCongruential.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    MULTIPLIER = 214013;
    INCREMENT = 2531011;
    MASK = 4294967295;
    MASK_2 = (1 << 31) - 1;
    computeNextSeed = /* @__PURE__ */ __name(function(seed) {
      return seed * MULTIPLIER + INCREMENT & MASK;
    }, "computeNextSeed");
    computeValueFromNextSeed = /* @__PURE__ */ __name(function(nextseed) {
      return (nextseed & MASK_2) >> 16;
    }, "computeValueFromNextSeed");
    LinearCongruential32 = (function() {
      function LinearCongruential322(seed) {
        this.seed = seed;
      }
      __name(LinearCongruential322, "LinearCongruential32");
      LinearCongruential322.prototype.clone = function() {
        return new LinearCongruential322(this.seed);
      };
      LinearCongruential322.prototype.next = function() {
        var nextRng = new LinearCongruential322(this.seed);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
      };
      LinearCongruential322.prototype.unsafeNext = function() {
        var s1 = computeNextSeed(this.seed);
        var v1 = computeValueFromNextSeed(s1);
        var s2 = computeNextSeed(s1);
        var v2 = computeValueFromNextSeed(s2);
        this.seed = computeNextSeed(s2);
        var v3 = computeValueFromNextSeed(this.seed);
        var vnext = v3 + (v2 + (v1 << 15) << 15);
        return vnext | 0;
      };
      LinearCongruential322.prototype.getState = function() {
        return [this.seed];
      };
      return LinearCongruential322;
    })();
    __name(fromState, "fromState");
    congruential32 = Object.assign(function(seed) {
      return new LinearCongruential32(seed);
    }, { fromState });
  }
});

// node_modules/pure-rand/lib/esm/generator/MersenneTwister.js
function fromState2(state) {
  return MersenneTwister.fromState(state);
}
var __read, __spreadArray, MersenneTwister, MersenneTwister_default;
var init_MersenneTwister = __esm({
  "node_modules/pure-rand/lib/esm/generator/MersenneTwister.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error50) {
        e = { error: error50 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray = function(to, from2, pack2) {
      if (pack2 || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
        if (ar || !(i in from2)) {
          if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
          ar[i] = from2[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from2));
    };
    MersenneTwister = (function() {
      function MersenneTwister2(states, index2) {
        this.states = states;
        this.index = index2;
      }
      __name(MersenneTwister2, "MersenneTwister");
      MersenneTwister2.twist = function(prev) {
        var mt = prev.slice();
        for (var idx = 0; idx !== MersenneTwister2.N - MersenneTwister2.M; ++idx) {
          var y_1 = (mt[idx] & MersenneTwister2.MASK_UPPER) + (mt[idx + 1] & MersenneTwister2.MASK_LOWER);
          mt[idx] = mt[idx + MersenneTwister2.M] ^ y_1 >>> 1 ^ -(y_1 & 1) & MersenneTwister2.A;
        }
        for (var idx = MersenneTwister2.N - MersenneTwister2.M; idx !== MersenneTwister2.N - 1; ++idx) {
          var y_2 = (mt[idx] & MersenneTwister2.MASK_UPPER) + (mt[idx + 1] & MersenneTwister2.MASK_LOWER);
          mt[idx] = mt[idx + MersenneTwister2.M - MersenneTwister2.N] ^ y_2 >>> 1 ^ -(y_2 & 1) & MersenneTwister2.A;
        }
        var y = (mt[MersenneTwister2.N - 1] & MersenneTwister2.MASK_UPPER) + (mt[0] & MersenneTwister2.MASK_LOWER);
        mt[MersenneTwister2.N - 1] = mt[MersenneTwister2.M - 1] ^ y >>> 1 ^ -(y & 1) & MersenneTwister2.A;
        return mt;
      };
      MersenneTwister2.seeded = function(seed) {
        var out = Array(MersenneTwister2.N);
        out[0] = seed;
        for (var idx = 1; idx !== MersenneTwister2.N; ++idx) {
          var xored = out[idx - 1] ^ out[idx - 1] >>> 30;
          out[idx] = Math.imul(MersenneTwister2.F, xored) + idx | 0;
        }
        return out;
      };
      MersenneTwister2.from = function(seed) {
        return new MersenneTwister2(MersenneTwister2.twist(MersenneTwister2.seeded(seed)), 0);
      };
      MersenneTwister2.prototype.clone = function() {
        return new MersenneTwister2(this.states, this.index);
      };
      MersenneTwister2.prototype.next = function() {
        var nextRng = new MersenneTwister2(this.states, this.index);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
      };
      MersenneTwister2.prototype.unsafeNext = function() {
        var y = this.states[this.index];
        y ^= this.states[this.index] >>> MersenneTwister2.U;
        y ^= y << MersenneTwister2.S & MersenneTwister2.B;
        y ^= y << MersenneTwister2.T & MersenneTwister2.C;
        y ^= y >>> MersenneTwister2.L;
        if (++this.index >= MersenneTwister2.N) {
          this.states = MersenneTwister2.twist(this.states);
          this.index = 0;
        }
        return y;
      };
      MersenneTwister2.prototype.getState = function() {
        return __spreadArray([this.index], __read(this.states), false);
      };
      MersenneTwister2.fromState = function(state) {
        var valid = state.length === MersenneTwister2.N + 1 && state[0] >= 0 && state[0] < MersenneTwister2.N;
        if (!valid) {
          throw new Error("The state must have been produced by a mersenne RandomGenerator");
        }
        return new MersenneTwister2(state.slice(1), state[0]);
      };
      MersenneTwister2.N = 624;
      MersenneTwister2.M = 397;
      MersenneTwister2.R = 31;
      MersenneTwister2.A = 2567483615;
      MersenneTwister2.F = 1812433253;
      MersenneTwister2.U = 11;
      MersenneTwister2.S = 7;
      MersenneTwister2.B = 2636928640;
      MersenneTwister2.T = 15;
      MersenneTwister2.C = 4022730752;
      MersenneTwister2.L = 18;
      MersenneTwister2.MASK_LOWER = Math.pow(2, MersenneTwister2.R) - 1;
      MersenneTwister2.MASK_UPPER = Math.pow(2, MersenneTwister2.R);
      return MersenneTwister2;
    })();
    __name(fromState2, "fromState");
    MersenneTwister_default = Object.assign(function(seed) {
      return MersenneTwister.from(seed);
    }, { fromState: fromState2 });
  }
});

// node_modules/pure-rand/lib/esm/generator/XorShift.js
function fromState3(state) {
  var valid = state.length === 4;
  if (!valid) {
    throw new Error("The state must have been produced by a xorshift128plus RandomGenerator");
  }
  return new XorShift128Plus(state[0], state[1], state[2], state[3]);
}
var XorShift128Plus, xorshift128plus;
var init_XorShift = __esm({
  "node_modules/pure-rand/lib/esm/generator/XorShift.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    XorShift128Plus = (function() {
      function XorShift128Plus2(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
      }
      __name(XorShift128Plus2, "XorShift128Plus");
      XorShift128Plus2.prototype.clone = function() {
        return new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
      };
      XorShift128Plus2.prototype.next = function() {
        var nextRng = new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
      };
      XorShift128Plus2.prototype.unsafeNext = function() {
        var a0 = this.s00 ^ this.s00 << 23;
        var a1 = this.s01 ^ (this.s01 << 23 | this.s00 >>> 9);
        var b0 = a0 ^ this.s10 ^ (a0 >>> 18 | a1 << 14) ^ (this.s10 >>> 5 | this.s11 << 27);
        var b1 = a1 ^ this.s11 ^ a1 >>> 18 ^ this.s11 >>> 5;
        var out = this.s00 + this.s10 | 0;
        this.s01 = this.s11;
        this.s00 = this.s10;
        this.s11 = b1;
        this.s10 = b0;
        return out;
      };
      XorShift128Plus2.prototype.jump = function() {
        var nextRng = new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
      };
      XorShift128Plus2.prototype.unsafeJump = function() {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [1667051007, 2321340297, 1548169110, 304075285];
        for (var i = 0; i !== 4; ++i) {
          for (var mask = 1; mask; mask <<= 1) {
            if (jump[i] & mask) {
              ns01 ^= this.s01;
              ns00 ^= this.s00;
              ns11 ^= this.s11;
              ns10 ^= this.s10;
            }
            this.unsafeNext();
          }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
      };
      XorShift128Plus2.prototype.getState = function() {
        return [this.s01, this.s00, this.s11, this.s10];
      };
      return XorShift128Plus2;
    })();
    __name(fromState3, "fromState");
    xorshift128plus = Object.assign(function(seed) {
      return new XorShift128Plus(-1, ~seed, seed | 0, 0);
    }, { fromState: fromState3 });
  }
});

// node_modules/pure-rand/lib/esm/generator/XoroShiro.js
function fromState4(state) {
  var valid = state.length === 4;
  if (!valid) {
    throw new Error("The state must have been produced by a xoroshiro128plus RandomGenerator");
  }
  return new XoroShiro128Plus(state[0], state[1], state[2], state[3]);
}
var XoroShiro128Plus, xoroshiro128plus;
var init_XoroShiro = __esm({
  "node_modules/pure-rand/lib/esm/generator/XoroShiro.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    XoroShiro128Plus = (function() {
      function XoroShiro128Plus2(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
      }
      __name(XoroShiro128Plus2, "XoroShiro128Plus");
      XoroShiro128Plus2.prototype.clone = function() {
        return new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
      };
      XoroShiro128Plus2.prototype.next = function() {
        var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
      };
      XoroShiro128Plus2.prototype.unsafeNext = function() {
        var out = this.s00 + this.s10 | 0;
        var a0 = this.s10 ^ this.s00;
        var a1 = this.s11 ^ this.s01;
        var s00 = this.s00;
        var s01 = this.s01;
        this.s00 = s00 << 24 ^ s01 >>> 8 ^ a0 ^ a0 << 16;
        this.s01 = s01 << 24 ^ s00 >>> 8 ^ a1 ^ (a1 << 16 | a0 >>> 16);
        this.s10 = a1 << 5 ^ a0 >>> 27;
        this.s11 = a0 << 5 ^ a1 >>> 27;
        return out;
      };
      XoroShiro128Plus2.prototype.jump = function() {
        var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
      };
      XoroShiro128Plus2.prototype.unsafeJump = function() {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [3639956645, 3750757012, 1261568508, 386426335];
        for (var i = 0; i !== 4; ++i) {
          for (var mask = 1; mask; mask <<= 1) {
            if (jump[i] & mask) {
              ns01 ^= this.s01;
              ns00 ^= this.s00;
              ns11 ^= this.s11;
              ns10 ^= this.s10;
            }
            this.unsafeNext();
          }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
      };
      XoroShiro128Plus2.prototype.getState = function() {
        return [this.s01, this.s00, this.s11, this.s10];
      };
      return XoroShiro128Plus2;
    })();
    __name(fromState4, "fromState");
    xoroshiro128plus = Object.assign(function(seed) {
      return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
    }, { fromState: fromState4 });
  }
});

// node_modules/pure-rand/lib/esm/distribution/internals/ArrayInt.js
function addArrayIntToNew(arrayIntA, arrayIntB) {
  if (arrayIntA.sign !== arrayIntB.sign) {
    return substractArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
  }
  var data = [];
  var reminder = 0;
  var dataA = arrayIntA.data;
  var dataB = arrayIntB.data;
  for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    var current2 = vA + vB + reminder;
    data.push(current2 >>> 0);
    reminder = ~~(current2 / 4294967296);
  }
  if (reminder !== 0) {
    data.push(reminder);
  }
  return { sign: arrayIntA.sign, data: data.reverse() };
}
function addOneToPositiveArrayInt(arrayInt) {
  arrayInt.sign = 1;
  var data = arrayInt.data;
  for (var index2 = data.length - 1; index2 >= 0; --index2) {
    if (data[index2] === 4294967295) {
      data[index2] = 0;
    } else {
      data[index2] += 1;
      return arrayInt;
    }
  }
  data.unshift(1);
  return arrayInt;
}
function isStrictlySmaller(dataA, dataB) {
  var maxLength2 = Math.max(dataA.length, dataB.length);
  for (var index2 = 0; index2 < maxLength2; ++index2) {
    var indexA = index2 + dataA.length - maxLength2;
    var indexB = index2 + dataB.length - maxLength2;
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    if (vA < vB)
      return true;
    if (vA > vB)
      return false;
  }
  return false;
}
function substractArrayIntToNew(arrayIntA, arrayIntB) {
  if (arrayIntA.sign !== arrayIntB.sign) {
    return addArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
  }
  var dataA = arrayIntA.data;
  var dataB = arrayIntB.data;
  if (isStrictlySmaller(dataA, dataB)) {
    var out = substractArrayIntToNew(arrayIntB, arrayIntA);
    out.sign = -out.sign;
    return out;
  }
  var data = [];
  var reminder = 0;
  for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    var current2 = vA - vB - reminder;
    data.push(current2 >>> 0);
    reminder = current2 < 0 ? 1 : 0;
  }
  return { sign: arrayIntA.sign, data: data.reverse() };
}
function trimArrayIntInplace(arrayInt) {
  var data = arrayInt.data;
  var firstNonZero = 0;
  for (; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero) {
  }
  if (firstNonZero === data.length) {
    arrayInt.sign = 1;
    arrayInt.data = [0];
    return arrayInt;
  }
  data.splice(0, firstNonZero);
  return arrayInt;
}
function fromNumberToArrayInt64(out, n) {
  if (n < 0) {
    var posN = -n;
    out.sign = -1;
    out.data[0] = ~~(posN / 4294967296);
    out.data[1] = posN >>> 0;
  } else {
    out.sign = 1;
    out.data[0] = ~~(n / 4294967296);
    out.data[1] = n >>> 0;
  }
  return out;
}
function substractArrayInt64(out, arrayIntA, arrayIntB) {
  var lowA = arrayIntA.data[1];
  var highA = arrayIntA.data[0];
  var signA = arrayIntA.sign;
  var lowB = arrayIntB.data[1];
  var highB = arrayIntB.data[0];
  var signB = arrayIntB.sign;
  out.sign = 1;
  if (signA === 1 && signB === -1) {
    var low_1 = lowA + lowB;
    var high = highA + highB + (low_1 > 4294967295 ? 1 : 0);
    out.data[0] = high >>> 0;
    out.data[1] = low_1 >>> 0;
    return out;
  }
  var lowFirst = lowA;
  var highFirst = highA;
  var lowSecond = lowB;
  var highSecond = highB;
  if (signA === -1) {
    lowFirst = lowB;
    highFirst = highB;
    lowSecond = lowA;
    highSecond = highA;
  }
  var reminderLow = 0;
  var low = lowFirst - lowSecond;
  if (low < 0) {
    reminderLow = 1;
    low = low >>> 0;
  }
  out.data[0] = highFirst - highSecond - reminderLow;
  out.data[1] = low;
  return out;
}
var init_ArrayInt = __esm({
  "node_modules/pure-rand/lib/esm/distribution/internals/ArrayInt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(addArrayIntToNew, "addArrayIntToNew");
    __name(addOneToPositiveArrayInt, "addOneToPositiveArrayInt");
    __name(isStrictlySmaller, "isStrictlySmaller");
    __name(substractArrayIntToNew, "substractArrayIntToNew");
    __name(trimArrayIntInplace, "trimArrayIntInplace");
    __name(fromNumberToArrayInt64, "fromNumberToArrayInt64");
    __name(substractArrayInt64, "substractArrayInt64");
  }
});

// node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformIntDistributionInternal.js
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
  var MaxAllowed = rangeSize > 2 ? ~~(4294967296 / rangeSize) * rangeSize : 4294967296;
  var deltaV = rng.unsafeNext() + 2147483648;
  while (deltaV >= MaxAllowed) {
    deltaV = rng.unsafeNext() + 2147483648;
  }
  return deltaV % rangeSize;
}
var init_UnsafeUniformIntDistributionInternal = __esm({
  "node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformIntDistributionInternal.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(unsafeUniformIntDistributionInternal, "unsafeUniformIntDistributionInternal");
  }
});

// node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
  var rangeLength = rangeSize.length;
  while (true) {
    for (var index2 = 0; index2 !== rangeLength; ++index2) {
      var indexRangeSize = index2 === 0 ? rangeSize[0] + 1 : 4294967296;
      var g = unsafeUniformIntDistributionInternal(indexRangeSize, rng);
      out[index2] = g;
    }
    for (var index2 = 0; index2 !== rangeLength; ++index2) {
      var current2 = out[index2];
      var currentInRange = rangeSize[index2];
      if (current2 < currentInRange) {
        return out;
      } else if (current2 > currentInRange) {
        break;
      }
    }
  }
}
var init_UnsafeUniformArrayIntDistributionInternal = __esm({
  "node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_UnsafeUniformIntDistributionInternal();
    __name(unsafeUniformArrayIntDistributionInternal, "unsafeUniformArrayIntDistributionInternal");
  }
});

// node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js
function unsafeUniformArrayIntDistribution(from2, to, rng) {
  var rangeSize = trimArrayIntInplace(addOneToPositiveArrayInt(substractArrayIntToNew(to, from2)));
  var emptyArrayIntData = rangeSize.data.slice(0);
  var g = unsafeUniformArrayIntDistributionInternal(emptyArrayIntData, rangeSize.data, rng);
  return trimArrayIntInplace(addArrayIntToNew({ sign: 1, data: g }, from2));
}
var init_UnsafeUniformArrayIntDistribution = __esm({
  "node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_ArrayInt();
    init_UnsafeUniformArrayIntDistributionInternal();
    __name(unsafeUniformArrayIntDistribution, "unsafeUniformArrayIntDistribution");
  }
});

// node_modules/pure-rand/lib/esm/distribution/UniformArrayIntDistribution.js
function uniformArrayIntDistribution(from2, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformArrayIntDistribution(from2, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformArrayIntDistribution(from2, to, nextRng2), nextRng2];
  };
}
var init_UniformArrayIntDistribution = __esm({
  "node_modules/pure-rand/lib/esm/distribution/UniformArrayIntDistribution.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_UnsafeUniformArrayIntDistribution();
    __name(uniformArrayIntDistribution, "uniformArrayIntDistribution");
  }
});

// node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js
function unsafeUniformBigIntDistribution(from2, to, rng) {
  var diff8 = to - from2 + SBigInt(1);
  var MinRng = SBigInt(-2147483648);
  var NumValues = SBigInt(4294967296);
  var FinalNumValues = NumValues;
  var NumIterations = 1;
  while (FinalNumValues < diff8) {
    FinalNumValues *= NumValues;
    ++NumIterations;
  }
  var MaxAcceptedRandom = FinalNumValues - FinalNumValues % diff8;
  while (true) {
    var value3 = SBigInt(0);
    for (var num = 0; num !== NumIterations; ++num) {
      var out = rng.unsafeNext();
      value3 = NumValues * value3 + (SBigInt(out) - MinRng);
    }
    if (value3 < MaxAcceptedRandom) {
      var inDiff = value3 % diff8;
      return inDiff + from2;
    }
  }
}
var SBigInt;
var init_UnsafeUniformBigIntDistribution = __esm({
  "node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SBigInt = typeof BigInt !== "undefined" ? BigInt : void 0;
    __name(unsafeUniformBigIntDistribution, "unsafeUniformBigIntDistribution");
  }
});

// node_modules/pure-rand/lib/esm/distribution/UniformBigIntDistribution.js
function uniformBigIntDistribution(from2, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformBigIntDistribution(from2, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformBigIntDistribution(from2, to, nextRng2), nextRng2];
  };
}
var init_UniformBigIntDistribution = __esm({
  "node_modules/pure-rand/lib/esm/distribution/UniformBigIntDistribution.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_UnsafeUniformBigIntDistribution();
    __name(uniformBigIntDistribution, "uniformBigIntDistribution");
  }
});

// node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js
function uniformLargeIntInternal(from2, to, rangeSize, rng) {
  var rangeSizeArrayIntValue = rangeSize <= safeNumberMaxSafeInteger ? fromNumberToArrayInt64(sharedC, rangeSize) : substractArrayInt64(sharedC, fromNumberToArrayInt64(sharedA, to), fromNumberToArrayInt64(sharedB, from2));
  if (rangeSizeArrayIntValue.data[1] === 4294967295) {
    rangeSizeArrayIntValue.data[0] += 1;
    rangeSizeArrayIntValue.data[1] = 0;
  } else {
    rangeSizeArrayIntValue.data[1] += 1;
  }
  unsafeUniformArrayIntDistributionInternal(sharedData, rangeSizeArrayIntValue.data, rng);
  return sharedData[0] * 4294967296 + sharedData[1] + from2;
}
function unsafeUniformIntDistribution(from2, to, rng) {
  var rangeSize = to - from2;
  if (rangeSize <= 4294967295) {
    var g = unsafeUniformIntDistributionInternal(rangeSize + 1, rng);
    return g + from2;
  }
  return uniformLargeIntInternal(from2, to, rangeSize, rng);
}
var safeNumberMaxSafeInteger, sharedA, sharedB, sharedC, sharedData;
var init_UnsafeUniformIntDistribution = __esm({
  "node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_UnsafeUniformIntDistributionInternal();
    init_ArrayInt();
    init_UnsafeUniformArrayIntDistributionInternal();
    safeNumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;
    sharedA = { sign: 1, data: [0, 0] };
    sharedB = { sign: 1, data: [0, 0] };
    sharedC = { sign: 1, data: [0, 0] };
    sharedData = [0, 0];
    __name(uniformLargeIntInternal, "uniformLargeIntInternal");
    __name(unsafeUniformIntDistribution, "unsafeUniformIntDistribution");
  }
});

// node_modules/pure-rand/lib/esm/distribution/UniformIntDistribution.js
function uniformIntDistribution(from2, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformIntDistribution(from2, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformIntDistribution(from2, to, nextRng2), nextRng2];
  };
}
var init_UniformIntDistribution = __esm({
  "node_modules/pure-rand/lib/esm/distribution/UniformIntDistribution.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_UnsafeUniformIntDistribution();
    __name(uniformIntDistribution, "uniformIntDistribution");
  }
});

// node_modules/pure-rand/lib/esm/pure-rand-default.js
var pure_rand_default_exports = {};
__export(pure_rand_default_exports, {
  __commitHash: () => __commitHash,
  __type: () => __type,
  __version: () => __version,
  congruential32: () => congruential32,
  generateN: () => generateN,
  mersenne: () => MersenneTwister_default,
  skipN: () => skipN,
  uniformArrayIntDistribution: () => uniformArrayIntDistribution,
  uniformBigIntDistribution: () => uniformBigIntDistribution,
  uniformIntDistribution: () => uniformIntDistribution,
  unsafeGenerateN: () => unsafeGenerateN,
  unsafeSkipN: () => unsafeSkipN,
  unsafeUniformArrayIntDistribution: () => unsafeUniformArrayIntDistribution,
  unsafeUniformBigIntDistribution: () => unsafeUniformBigIntDistribution,
  unsafeUniformIntDistribution: () => unsafeUniformIntDistribution,
  xoroshiro128plus: () => xoroshiro128plus,
  xorshift128plus: () => xorshift128plus
});
var __type, __version, __commitHash;
var init_pure_rand_default = __esm({
  "node_modules/pure-rand/lib/esm/pure-rand-default.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_RandomGenerator();
    init_LinearCongruential();
    init_MersenneTwister();
    init_XorShift();
    init_XoroShiro();
    init_UniformArrayIntDistribution();
    init_UniformBigIntDistribution();
    init_UniformIntDistribution();
    init_UnsafeUniformArrayIntDistribution();
    init_UnsafeUniformBigIntDistribution();
    init_UnsafeUniformIntDistribution();
    __type = "module";
    __version = "6.1.0";
    __commitHash = "a413dd2b721516be2ef29adffb515c5ae67bfbad";
  }
});

// node_modules/pure-rand/lib/esm/pure-rand.js
var pure_rand_default;
var init_pure_rand = __esm({
  "node_modules/pure-rand/lib/esm/pure-rand.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pure_rand_default();
    init_pure_rand_default();
    pure_rand_default = pure_rand_default_exports;
  }
});

// node_modules/fast-check/lib/esm/check/runner/configuration/VerbosityLevel.js
var VerbosityLevel;
var init_VerbosityLevel = __esm({
  "node_modules/fast-check/lib/esm/check/runner/configuration/VerbosityLevel.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(VerbosityLevel2) {
      VerbosityLevel2[VerbosityLevel2["None"] = 0] = "None";
      VerbosityLevel2[VerbosityLevel2["Verbose"] = 1] = "Verbose";
      VerbosityLevel2[VerbosityLevel2["VeryVerbose"] = 2] = "VeryVerbose";
    })(VerbosityLevel || (VerbosityLevel = {}));
  }
});

// node_modules/fast-check/lib/esm/check/runner/configuration/QualifiedParameters.js
var safeDateNow, safeMathMin, safeMathRandom, QualifiedParameters;
var init_QualifiedParameters = __esm({
  "node_modules/fast-check/lib/esm/check/runner/configuration/QualifiedParameters.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pure_rand();
    init_VerbosityLevel();
    safeDateNow = Date.now;
    safeMathMin = Math.min;
    safeMathRandom = Math.random;
    QualifiedParameters = class _QualifiedParameters {
      static {
        __name(this, "QualifiedParameters");
      }
      constructor(op) {
        const p = op || {};
        this.seed = _QualifiedParameters.readSeed(p);
        this.randomType = _QualifiedParameters.readRandomType(p);
        this.numRuns = _QualifiedParameters.readNumRuns(p);
        this.verbose = _QualifiedParameters.readVerbose(p);
        this.maxSkipsPerRun = _QualifiedParameters.readOrDefault(p, "maxSkipsPerRun", 100);
        this.timeout = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "timeout", null));
        this.skipAllAfterTimeLimit = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "skipAllAfterTimeLimit", null));
        this.interruptAfterTimeLimit = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "interruptAfterTimeLimit", null));
        this.markInterruptAsFailure = _QualifiedParameters.readBoolean(p, "markInterruptAsFailure");
        this.skipEqualValues = _QualifiedParameters.readBoolean(p, "skipEqualValues");
        this.ignoreEqualValues = _QualifiedParameters.readBoolean(p, "ignoreEqualValues");
        this.logger = _QualifiedParameters.readOrDefault(p, "logger", (v) => {
          console.log(v);
        });
        this.path = _QualifiedParameters.readOrDefault(p, "path", "");
        this.unbiased = _QualifiedParameters.readBoolean(p, "unbiased");
        this.examples = _QualifiedParameters.readOrDefault(p, "examples", []);
        this.endOnFailure = _QualifiedParameters.readBoolean(p, "endOnFailure");
        this.reporter = _QualifiedParameters.readOrDefault(p, "reporter", null);
        this.asyncReporter = _QualifiedParameters.readOrDefault(p, "asyncReporter", null);
        this.errorWithCause = _QualifiedParameters.readBoolean(p, "errorWithCause");
      }
      toParameters() {
        const orUndefined2 = /* @__PURE__ */ __name((value3) => value3 !== null ? value3 : void 0, "orUndefined");
        const parameters = {
          seed: this.seed,
          randomType: this.randomType,
          numRuns: this.numRuns,
          maxSkipsPerRun: this.maxSkipsPerRun,
          timeout: orUndefined2(this.timeout),
          skipAllAfterTimeLimit: orUndefined2(this.skipAllAfterTimeLimit),
          interruptAfterTimeLimit: orUndefined2(this.interruptAfterTimeLimit),
          markInterruptAsFailure: this.markInterruptAsFailure,
          skipEqualValues: this.skipEqualValues,
          ignoreEqualValues: this.ignoreEqualValues,
          path: this.path,
          logger: this.logger,
          unbiased: this.unbiased,
          verbose: this.verbose,
          examples: this.examples,
          endOnFailure: this.endOnFailure,
          reporter: orUndefined2(this.reporter),
          asyncReporter: orUndefined2(this.asyncReporter),
          errorWithCause: this.errorWithCause
        };
        return parameters;
      }
      static read(op) {
        return new _QualifiedParameters(op);
      }
    };
    QualifiedParameters.createQualifiedRandomGenerator = (random4) => {
      return (seed) => {
        const rng = random4(seed);
        if (rng.unsafeJump === void 0) {
          rng.unsafeJump = () => unsafeSkipN(rng, 42);
        }
        return rng;
      };
    };
    QualifiedParameters.readSeed = (p) => {
      if (p.seed == null)
        return safeDateNow() ^ safeMathRandom() * 4294967296;
      const seed32 = p.seed | 0;
      if (p.seed === seed32)
        return seed32;
      const gap = p.seed - seed32;
      return seed32 ^ gap * 4294967296;
    };
    QualifiedParameters.readRandomType = (p) => {
      if (p.randomType == null)
        return pure_rand_default.xorshift128plus;
      if (typeof p.randomType === "string") {
        switch (p.randomType) {
          case "mersenne":
            return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.mersenne);
          case "congruential":
          case "congruential32":
            return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.congruential32);
          case "xorshift128plus":
            return pure_rand_default.xorshift128plus;
          case "xoroshiro128plus":
            return pure_rand_default.xoroshiro128plus;
          default:
            throw new Error(`Invalid random specified: '${p.randomType}'`);
        }
      }
      const mrng = p.randomType(0);
      if ("min" in mrng && mrng.min !== -2147483648) {
        throw new Error(`Invalid random number generator: min must equal -0x80000000, got ${String(mrng.min)}`);
      }
      if ("max" in mrng && mrng.max !== 2147483647) {
        throw new Error(`Invalid random number generator: max must equal 0x7fffffff, got ${String(mrng.max)}`);
      }
      if ("unsafeJump" in mrng) {
        return p.randomType;
      }
      return QualifiedParameters.createQualifiedRandomGenerator(p.randomType);
    };
    QualifiedParameters.readNumRuns = (p) => {
      const defaultValue = 100;
      if (p.numRuns != null)
        return p.numRuns;
      if (p.num_runs != null)
        return p.num_runs;
      return defaultValue;
    };
    QualifiedParameters.readVerbose = (p) => {
      if (p.verbose == null)
        return VerbosityLevel.None;
      if (typeof p.verbose === "boolean") {
        return p.verbose === true ? VerbosityLevel.Verbose : VerbosityLevel.None;
      }
      if (p.verbose <= VerbosityLevel.None) {
        return VerbosityLevel.None;
      }
      if (p.verbose >= VerbosityLevel.VeryVerbose) {
        return VerbosityLevel.VeryVerbose;
      }
      return p.verbose | 0;
    };
    QualifiedParameters.readBoolean = (p, key) => p[key] === true;
    QualifiedParameters.readOrDefault = (p, key, defaultValue) => {
      const value3 = p[key];
      return value3 != null ? value3 : defaultValue;
    };
    QualifiedParameters.safeTimeout = (value3) => {
      if (value3 === null) {
        return null;
      }
      return safeMathMin(value3, 2147483647);
    };
  }
});

// node_modules/fast-check/lib/esm/check/property/SkipAfterProperty.js
var init_SkipAfterProperty = __esm({
  "node_modules/fast-check/lib/esm/check/property/SkipAfterProperty.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_PreconditionFailure();
  }
});

// node_modules/fast-check/lib/esm/check/property/TimeoutProperty.js
var init_TimeoutProperty = __esm({
  "node_modules/fast-check/lib/esm/check/property/TimeoutProperty.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/check/property/UnbiasedProperty.js
var init_UnbiasedProperty = __esm({
  "node_modules/fast-check/lib/esm/check/property/UnbiasedProperty.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/fast-check/lib/esm/utils/stringify.js
function hasToStringMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && toStringMethod in instance && typeof instance[toStringMethod] === "function";
}
function hasAsyncToStringMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && asyncToStringMethod in instance && typeof instance[asyncToStringMethod] === "function";
}
function getSymbolDescription(s) {
  if (s.description !== void 0)
    return s.description;
  const m = findSymbolNameRegex.exec(SString(s));
  return m && m[1].length ? m[1] : null;
}
function stringifyNumber(numValue) {
  switch (numValue) {
    case 0:
      return 1 / numValue === safeNegativeInfinity ? "-0" : "0";
    case safeNegativeInfinity:
      return "Number.NEGATIVE_INFINITY";
    case safePositiveInfinity:
      return "Number.POSITIVE_INFINITY";
    default:
      return numValue === numValue ? SString(numValue) : "Number.NaN";
  }
}
function isSparseArray(arr) {
  let previousNumberedIndex = -1;
  for (const index2 in arr) {
    const numberedIndex = Number(index2);
    if (numberedIndex !== previousNumberedIndex + 1)
      return true;
    previousNumberedIndex = numberedIndex;
  }
  return previousNumberedIndex + 1 !== arr.length;
}
function stringifyInternal(value3, previousValues, getAsyncContent) {
  const currentValues = [...previousValues, value3];
  if (typeof value3 === "object") {
    if (safeIndexOf(previousValues, value3) !== -1) {
      return "[cyclic]";
    }
  }
  if (hasAsyncToStringMethod(value3)) {
    const content = getAsyncContent(value3);
    if (content.state === "fulfilled") {
      return content.value;
    }
  }
  if (hasToStringMethod(value3)) {
    try {
      return value3[toStringMethod]();
    } catch (err) {
    }
  }
  switch (safeToString2(value3)) {
    case "[object Array]": {
      const arr = value3;
      if (arr.length >= 50 && isSparseArray(arr)) {
        const assignments = [];
        for (const index2 in arr) {
          if (!safeNumberIsNaN(Number(index2)))
            safePush(assignments, `${index2}:${stringifyInternal(arr[index2], currentValues, getAsyncContent)}`);
        }
        return assignments.length !== 0 ? `Object.assign(Array(${arr.length}),{${safeJoin(assignments, ",")}})` : `Array(${arr.length})`;
      }
      const stringifiedArray = safeJoin(safeMap(arr, (v) => stringifyInternal(v, currentValues, getAsyncContent)), ",");
      return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;
    }
    case "[object BigInt]":
      return `${value3}n`;
    case "[object Boolean]": {
      const unboxedToString = value3 == true ? "true" : "false";
      return typeof value3 === "boolean" ? unboxedToString : `new Boolean(${unboxedToString})`;
    }
    case "[object Date]": {
      const d = value3;
      return safeNumberIsNaN(safeGetTime(d)) ? `new Date(NaN)` : `new Date(${safeJsonStringify(safeToISOString(d))})`;
    }
    case "[object Map]":
      return `new Map(${stringifyInternal(Array.from(value3), currentValues, getAsyncContent)})`;
    case "[object Null]":
      return `null`;
    case "[object Number]":
      return typeof value3 === "number" ? stringifyNumber(value3) : `new Number(${stringifyNumber(Number(value3))})`;
    case "[object Object]": {
      try {
        const toStringAccessor = value3.toString;
        if (typeof toStringAccessor === "function" && toStringAccessor !== Object.prototype.toString) {
          return value3.toString();
        }
      } catch (err) {
        return "[object Object]";
      }
      const mapper = /* @__PURE__ */ __name((k) => `${k === "__proto__" ? '["__proto__"]' : typeof k === "symbol" ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]` : safeJsonStringify(k)}:${stringifyInternal(value3[k], currentValues, getAsyncContent)}`, "mapper");
      const stringifiedProperties = [
        ...safeMap(safeObjectKeys(value3), mapper),
        ...safeMap(safeFilter(safeObjectGetOwnPropertySymbols(value3), (s) => {
          const descriptor3 = safeObjectGetOwnPropertyDescriptor(value3, s);
          return descriptor3 && descriptor3.enumerable;
        }), mapper)
      ];
      const rawRepr = "{" + safeJoin(stringifiedProperties, ",") + "}";
      if (safeObjectGetPrototypeOf(value3) === null) {
        return rawRepr === "{}" ? "Object.create(null)" : `Object.assign(Object.create(null),${rawRepr})`;
      }
      return rawRepr;
    }
    case "[object Set]":
      return `new Set(${stringifyInternal(Array.from(value3), currentValues, getAsyncContent)})`;
    case "[object String]":
      return typeof value3 === "string" ? safeJsonStringify(value3) : `new String(${safeJsonStringify(value3)})`;
    case "[object Symbol]": {
      const s = value3;
      if (SSymbol.keyFor(s) !== void 0) {
        return `Symbol.for(${safeJsonStringify(SSymbol.keyFor(s))})`;
      }
      const desc2 = getSymbolDescription(s);
      if (desc2 === null) {
        return "Symbol()";
      }
      const knownSymbol = desc2.startsWith("Symbol.") && SSymbol[desc2.substring(7)];
      return s === knownSymbol ? desc2 : `Symbol(${safeJsonStringify(desc2)})`;
    }
    case "[object Promise]": {
      const promiseContent = getAsyncContent(value3);
      switch (promiseContent.state) {
        case "fulfilled":
          return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
        case "rejected":
          return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
        case "pending":
          return `new Promise(() => {/*pending*/})`;
        case "unknown":
        default:
          return `new Promise(() => {/*unknown*/})`;
      }
    }
    case "[object Error]":
      if (value3 instanceof Error) {
        return `new Error(${stringifyInternal(value3.message, currentValues, getAsyncContent)})`;
      }
      break;
    case "[object Undefined]":
      return `undefined`;
    case "[object Int8Array]":
    case "[object Uint8Array]":
    case "[object Uint8ClampedArray]":
    case "[object Int16Array]":
    case "[object Uint16Array]":
    case "[object Int32Array]":
    case "[object Uint32Array]":
    case "[object Float32Array]":
    case "[object Float64Array]":
    case "[object BigInt64Array]":
    case "[object BigUint64Array]": {
      if (typeof safeBufferIsBuffer === "function" && safeBufferIsBuffer(value3)) {
        return `Buffer.from(${stringifyInternal(safeArrayFrom(value3.values()), currentValues, getAsyncContent)})`;
      }
      const valuePrototype = safeObjectGetPrototypeOf(value3);
      const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;
      if (typeof className === "string") {
        const typedArray = value3;
        const valuesFromTypedArr = typedArray.values();
        return `${className}.from(${stringifyInternal(safeArrayFrom(valuesFromTypedArr), currentValues, getAsyncContent)})`;
      }
      break;
    }
  }
  try {
    return value3.toString();
  } catch (_a2) {
    return safeToString2(value3);
  }
}
function stringify(value3) {
  return stringifyInternal(value3, [], () => ({ state: "unknown", value: void 0 }));
}
var safeArrayFrom, safeBufferIsBuffer, safeJsonStringify, safeNumberIsNaN, safeObjectKeys, safeObjectGetOwnPropertySymbols, safeObjectGetOwnPropertyDescriptor, safeObjectGetPrototypeOf, safeNegativeInfinity, safePositiveInfinity, toStringMethod, asyncToStringMethod, findSymbolNameRegex;
var init_stringify = __esm({
  "node_modules/fast-check/lib/esm/utils/stringify.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    safeArrayFrom = Array.from;
    safeBufferIsBuffer = typeof Buffer !== "undefined" ? Buffer.isBuffer : void 0;
    safeJsonStringify = JSON.stringify;
    safeNumberIsNaN = Number.isNaN;
    safeObjectKeys = Object.keys;
    safeObjectGetOwnPropertySymbols = Object.getOwnPropertySymbols;
    safeObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    safeObjectGetPrototypeOf = Object.getPrototypeOf;
    safeNegativeInfinity = Number.NEGATIVE_INFINITY;
    safePositiveInfinity = Number.POSITIVE_INFINITY;
    toStringMethod = Symbol.for("fast-check/toStringMethod");
    __name(hasToStringMethod, "hasToStringMethod");
    asyncToStringMethod = Symbol.for("fast-check/asyncToStringMethod");
    __name(hasAsyncToStringMethod, "hasAsyncToStringMethod");
    findSymbolNameRegex = /^Symbol\((.*)\)$/;
    __name(getSymbolDescription, "getSymbolDescription");
    __name(stringifyNumber, "stringifyNumber");
    __name(isSparseArray, "isSparseArray");
    __name(stringifyInternal, "stringifyInternal");
    __name(stringify, "stringify");
  }
});

// node_modules/fast-check/lib/esm/check/property/IgnoreEqualValuesProperty.js
var init_IgnoreEqualValuesProperty = __esm({
  "node_modules/fast-check/lib/esm/check/property/IgnoreEqualValuesProperty.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_stringify();
    init_PreconditionFailure();
  }
});

// node_modules/fast-check/lib/esm/check/runner/DecorateProperty.js
var safeDateNow2;
var init_DecorateProperty = __esm({
  "node_modules/fast-check/lib/esm/check/runner/DecorateProperty.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_SkipAfterProperty();
    init_TimeoutProperty();
    init_UnbiasedProperty();
    init_IgnoreEqualValuesProperty();
    safeDateNow2 = Date.now;
  }
});

// node_modules/fast-check/lib/esm/check/runner/reporter/ExecutionStatus.js
var ExecutionStatus;
var init_ExecutionStatus = __esm({
  "node_modules/fast-check/lib/esm/check/runner/reporter/ExecutionStatus.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(ExecutionStatus2) {
      ExecutionStatus2[ExecutionStatus2["Success"] = 0] = "Success";
      ExecutionStatus2[ExecutionStatus2["Skipped"] = -1] = "Skipped";
      ExecutionStatus2[ExecutionStatus2["Failure"] = 1] = "Failure";
    })(ExecutionStatus || (ExecutionStatus = {}));
  }
});

// node_modules/fast-check/lib/esm/check/runner/reporter/RunExecution.js
var RunExecution;
var init_RunExecution = __esm({
  "node_modules/fast-check/lib/esm/check/runner/reporter/RunExecution.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_VerbosityLevel();
    init_ExecutionStatus();
    init_globals();
    RunExecution = class _RunExecution {
      static {
        __name(this, "RunExecution");
      }
      constructor(verbosity, interruptedAsFailure) {
        this.verbosity = verbosity;
        this.interruptedAsFailure = interruptedAsFailure;
        this.isSuccess = () => this.pathToFailure == null;
        this.firstFailure = () => this.pathToFailure ? +safeSplit(this.pathToFailure, ":")[0] : -1;
        this.numShrinks = () => this.pathToFailure ? safeSplit(this.pathToFailure, ":").length - 1 : 0;
        this.rootExecutionTrees = [];
        this.currentLevelExecutionTrees = this.rootExecutionTrees;
        this.failure = null;
        this.numSkips = 0;
        this.numSuccesses = 0;
        this.interrupted = false;
      }
      appendExecutionTree(status2, value3) {
        const currentTree = { status: status2, value: value3, children: [] };
        this.currentLevelExecutionTrees.push(currentTree);
        return currentTree;
      }
      fail(value3, id2, failure) {
        if (this.verbosity >= VerbosityLevel.Verbose) {
          const currentTree = this.appendExecutionTree(ExecutionStatus.Failure, value3);
          this.currentLevelExecutionTrees = currentTree.children;
        }
        if (this.pathToFailure == null)
          this.pathToFailure = `${id2}`;
        else
          this.pathToFailure += `:${id2}`;
        this.value = value3;
        this.failure = failure;
      }
      skip(value3) {
        if (this.verbosity >= VerbosityLevel.VeryVerbose) {
          this.appendExecutionTree(ExecutionStatus.Skipped, value3);
        }
        if (this.pathToFailure == null) {
          ++this.numSkips;
        }
      }
      success(value3) {
        if (this.verbosity >= VerbosityLevel.VeryVerbose) {
          this.appendExecutionTree(ExecutionStatus.Success, value3);
        }
        if (this.pathToFailure == null) {
          ++this.numSuccesses;
        }
      }
      interrupt() {
        this.interrupted = true;
      }
      extractFailures() {
        if (this.isSuccess()) {
          return [];
        }
        const failures2 = [];
        let cursor = this.rootExecutionTrees;
        while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus.Failure) {
          const failureTree = cursor[cursor.length - 1];
          failures2.push(failureTree.value);
          cursor = failureTree.children;
        }
        return failures2;
      }
      toRunDetails(seed, basePath, maxSkips, qParams) {
        if (!this.isSuccess()) {
          return {
            failed: true,
            interrupted: this.interrupted,
            numRuns: this.firstFailure() + 1 - this.numSkips,
            numSkips: this.numSkips,
            numShrinks: this.numShrinks(),
            seed,
            counterexample: this.value,
            counterexamplePath: _RunExecution.mergePaths(basePath, this.pathToFailure),
            error: this.failure.errorMessage,
            errorInstance: this.failure.error,
            failures: this.extractFailures(),
            executionSummary: this.rootExecutionTrees,
            verbose: this.verbosity,
            runConfiguration: qParams.toParameters()
          };
        }
        const considerInterruptedAsFailure = this.interruptedAsFailure || this.numSuccesses === 0;
        const failed = this.numSkips > maxSkips || this.interrupted && considerInterruptedAsFailure;
        const out = {
          failed,
          interrupted: this.interrupted,
          numRuns: this.numSuccesses,
          numSkips: this.numSkips,
          numShrinks: 0,
          seed,
          counterexample: null,
          counterexamplePath: null,
          error: null,
          errorInstance: null,
          failures: [],
          executionSummary: this.rootExecutionTrees,
          verbose: this.verbosity,
          runConfiguration: qParams.toParameters()
        };
        return out;
      }
    };
    RunExecution.mergePaths = (offsetPath, path) => {
      if (offsetPath.length === 0)
        return path;
      const offsetItems = offsetPath.split(":");
      const remainingItems = path.split(":");
      const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];
      return [...offsetItems.slice(0, offsetItems.length - 1), `${middle}`, ...remainingItems.slice(1)].join(":");
    };
  }
});

// node_modules/fast-check/lib/esm/check/runner/RunnerIterator.js
var init_RunnerIterator = __esm({
  "node_modules/fast-check/lib/esm/check/runner/RunnerIterator.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_PreconditionFailure();
    init_RunExecution();
  }
});

// node_modules/fast-check/lib/esm/check/runner/SourceValuesIterator.js
var init_SourceValuesIterator = __esm({
  "node_modules/fast-check/lib/esm/check/runner/SourceValuesIterator.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/fast-check/lib/esm/random/generator/Random.js
var Random;
var init_Random = __esm({
  "node_modules/fast-check/lib/esm/random/generator/Random.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pure_rand();
    Random = class _Random {
      static {
        __name(this, "Random");
      }
      constructor(sourceRng) {
        this.internalRng = sourceRng.clone();
      }
      clone() {
        return new _Random(this.internalRng);
      }
      next(bits) {
        return unsafeUniformIntDistribution(0, (1 << bits) - 1, this.internalRng);
      }
      nextBoolean() {
        return unsafeUniformIntDistribution(0, 1, this.internalRng) == 1;
      }
      nextInt(min4, max6) {
        return unsafeUniformIntDistribution(min4 == null ? _Random.MIN_INT : min4, max6 == null ? _Random.MAX_INT : max6, this.internalRng);
      }
      nextBigInt(min4, max6) {
        return unsafeUniformBigIntDistribution(min4, max6, this.internalRng);
      }
      nextArrayInt(min4, max6) {
        return unsafeUniformArrayIntDistribution(min4, max6, this.internalRng);
      }
      nextDouble() {
        const a = this.next(26);
        const b = this.next(27);
        return (a * _Random.DBL_FACTOR + b) * _Random.DBL_DIVISOR;
      }
      getState() {
        if ("getState" in this.internalRng && typeof this.internalRng.getState === "function") {
          return this.internalRng.getState();
        }
        return void 0;
      }
    };
    Random.MIN_INT = 2147483648 | 0;
    Random.MAX_INT = 2147483647 | 0;
    Random.DBL_FACTOR = Math.pow(2, 27);
    Random.DBL_DIVISOR = Math.pow(2, -53);
  }
});

// node_modules/fast-check/lib/esm/check/runner/Tosser.js
var init_Tosser = __esm({
  "node_modules/fast-check/lib/esm/check/runner/Tosser.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pure_rand();
    init_Random();
    init_Value();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/check/runner/utils/PathWalker.js
var init_PathWalker = __esm({
  "node_modules/fast-check/lib/esm/check/runner/utils/PathWalker.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/fast-check/lib/esm/check/runner/utils/RunDetailsFormatter.js
var init_RunDetailsFormatter = __esm({
  "node_modules/fast-check/lib/esm/check/runner/utils/RunDetailsFormatter.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_stringify();
    init_VerbosityLevel();
    init_ExecutionStatus();
  }
});

// node_modules/fast-check/lib/esm/check/runner/Runner.js
var init_Runner = __esm({
  "node_modules/fast-check/lib/esm/check/runner/Runner.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Stream();
    init_GlobalParameters();
    init_QualifiedParameters();
    init_DecorateProperty();
    init_RunnerIterator();
    init_SourceValuesIterator();
    init_Tosser();
    init_PathWalker();
    init_RunDetailsFormatter();
  }
});

// node_modules/fast-check/lib/esm/check/runner/Sampler.js
var init_Sampler = __esm({
  "node_modules/fast-check/lib/esm/check/runner/Sampler.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Stream();
    init_Property_generic();
    init_UnbiasedProperty();
    init_GlobalParameters();
    init_QualifiedParameters();
    init_Tosser();
    init_PathWalker();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/GeneratorValueBuilder.js
var init_GeneratorValueBuilder = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/builders/GeneratorValueBuilder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Value();
    init_symbols();
    init_globals();
    init_stringify();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/StableArbitraryGeneratorCache.js
var init_StableArbitraryGeneratorCache = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/builders/StableArbitraryGeneratorCache.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/GeneratorArbitrary.js
var init_GeneratorArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/GeneratorArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary();
    init_Stream();
    init_globals();
    init_GeneratorValueBuilder();
    init_StableArbitraryGeneratorCache();
    init_TupleArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/gen.js
var init_gen = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/gen.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_GeneratorArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BiasNumericRange.js
function integerLogLike(v) {
  return safeMathFloor(safeMathLog2(v) / safeMathLog2(2));
}
function biasNumericRange(min4, max6, logLike) {
  if (min4 === max6) {
    return [{ min: min4, max: max6 }];
  }
  if (min4 < 0 && max6 > 0) {
    const logMin = logLike(-min4);
    const logMax = logLike(max6);
    return [
      { min: -logMin, max: logMax },
      { min: max6 - logMax, max: max6 },
      { min: min4, max: min4 + logMin }
    ];
  }
  const logGap = logLike(max6 - min4);
  const arbCloseToMin = { min: min4, max: min4 + logGap };
  const arbCloseToMax = { min: max6 - logGap, max: max6 };
  return min4 < 0 ? [arbCloseToMax, arbCloseToMin] : [arbCloseToMin, arbCloseToMax];
}
var safeMathFloor, safeMathLog2;
var init_BiasNumericRange = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BiasNumericRange.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    safeMathFloor = Math.floor;
    safeMathLog2 = Math.log;
    __name(integerLogLike, "integerLogLike");
    __name(biasNumericRange, "biasNumericRange");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkInteger.js
function halvePosInteger(n) {
  return safeMathFloor2(n / 2);
}
function halveNegInteger(n) {
  return safeMathCeil(n / 2);
}
function shrinkInteger(current2, target, tryTargetAsap) {
  const realGap = current2 - target;
  function* shrinkDecr() {
    let previous2 = tryTargetAsap ? void 0 : target;
    const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);
    for (let toremove = gap; toremove > 0; toremove = halvePosInteger(toremove)) {
      const next4 = toremove === realGap ? target : current2 - toremove;
      yield new Value(next4, previous2);
      previous2 = next4;
    }
  }
  __name(shrinkDecr, "shrinkDecr");
  function* shrinkIncr() {
    let previous2 = tryTargetAsap ? void 0 : target;
    const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);
    for (let toremove = gap; toremove < 0; toremove = halveNegInteger(toremove)) {
      const next4 = toremove === realGap ? target : current2 - toremove;
      yield new Value(next4, previous2);
      previous2 = next4;
    }
  }
  __name(shrinkIncr, "shrinkIncr");
  return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());
}
var safeMathCeil, safeMathFloor2;
var init_ShrinkInteger = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkInteger.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Value();
    init_Stream();
    safeMathCeil = Math.ceil;
    safeMathFloor2 = Math.floor;
    __name(halvePosInteger, "halvePosInteger");
    __name(halveNegInteger, "halveNegInteger");
    __name(shrinkInteger, "shrinkInteger");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/IntegerArbitrary.js
var safeMathSign, safeNumberIsInteger, safeObjectIs, IntegerArbitrary;
var init_IntegerArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/IntegerArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary();
    init_Value();
    init_Stream();
    init_BiasNumericRange();
    init_ShrinkInteger();
    safeMathSign = Math.sign;
    safeNumberIsInteger = Number.isInteger;
    safeObjectIs = Object.is;
    IntegerArbitrary = class _IntegerArbitrary extends Arbitrary {
      static {
        __name(this, "IntegerArbitrary");
      }
      constructor(min4, max6) {
        super();
        this.min = min4;
        this.max = max6;
      }
      generate(mrng, biasFactor) {
        const range4 = this.computeGenerateRange(mrng, biasFactor);
        return new Value(mrng.nextInt(range4.min, range4.max), void 0);
      }
      canShrinkWithoutContext(value3) {
        return typeof value3 === "number" && safeNumberIsInteger(value3) && !safeObjectIs(value3, -0) && this.min <= value3 && value3 <= this.max;
      }
      shrink(current2, context10) {
        if (!_IntegerArbitrary.isValidContext(current2, context10)) {
          const target = this.defaultTarget();
          return shrinkInteger(current2, target, true);
        }
        if (this.isLastChanceTry(current2, context10)) {
          return Stream.of(new Value(context10, void 0));
        }
        return shrinkInteger(current2, context10, false);
      }
      defaultTarget() {
        if (this.min <= 0 && this.max >= 0) {
          return 0;
        }
        return this.min < 0 ? this.max : this.min;
      }
      computeGenerateRange(mrng, biasFactor) {
        if (biasFactor === void 0 || mrng.nextInt(1, biasFactor) !== 1) {
          return { min: this.min, max: this.max };
        }
        const ranges = biasNumericRange(this.min, this.max, integerLogLike);
        if (ranges.length === 1) {
          return ranges[0];
        }
        const id2 = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
        return id2 < 0 ? ranges[0] : ranges[id2 + 1];
      }
      isLastChanceTry(current2, context10) {
        if (current2 > 0)
          return current2 === context10 + 1 && current2 > this.min;
        if (current2 < 0)
          return current2 === context10 - 1 && current2 < this.max;
        return false;
      }
      static isValidContext(current2, context10) {
        if (context10 === void 0) {
          return false;
        }
        if (typeof context10 !== "number") {
          throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);
        }
        if (context10 !== 0 && safeMathSign(current2) !== safeMathSign(context10)) {
          throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);
        }
        return true;
      }
    };
  }
});

// node_modules/fast-check/lib/esm/arbitrary/integer.js
function buildCompleteIntegerConstraints(constraints) {
  const min4 = constraints.min !== void 0 ? constraints.min : -2147483648;
  const max6 = constraints.max !== void 0 ? constraints.max : 2147483647;
  return { min: min4, max: max6 };
}
function integer(constraints = {}) {
  const fullConstraints = buildCompleteIntegerConstraints(constraints);
  if (fullConstraints.min > fullConstraints.max) {
    throw new Error("fc.integer maximum value should be equal or greater than the minimum one");
  }
  if (!safeNumberIsInteger2(fullConstraints.min)) {
    throw new Error("fc.integer minimum value should be an integer");
  }
  if (!safeNumberIsInteger2(fullConstraints.max)) {
    throw new Error("fc.integer maximum value should be an integer");
  }
  return new IntegerArbitrary(fullConstraints.min, fullConstraints.max);
}
var safeNumberIsInteger2;
var init_integer = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/integer.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_IntegerArbitrary();
    safeNumberIsInteger2 = Number.isInteger;
    __name(buildCompleteIntegerConstraints, "buildCompleteIntegerConstraints");
    __name(integer, "integer");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DepthContext.js
function getDepthContextFor(contextMeta) {
  if (contextMeta === void 0) {
    return { depth: 0 };
  }
  if (typeof contextMeta !== "string") {
    return contextMeta;
  }
  const cachedContext = safeMapGet(depthContextCache, contextMeta);
  if (cachedContext !== void 0) {
    return cachedContext;
  }
  const context10 = { depth: 0 };
  safeMapSet(depthContextCache, contextMeta, context10);
  return context10;
}
var depthContextCache;
var init_DepthContext = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DepthContext.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    depthContextCache = /* @__PURE__ */ new Map();
    __name(getDepthContextFor, "getDepthContextFor");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/NoopSlicedGenerator.js
var NoopSlicedGenerator;
var init_NoopSlicedGenerator = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/NoopSlicedGenerator.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NoopSlicedGenerator = class {
      static {
        __name(this, "NoopSlicedGenerator");
      }
      constructor(arb, mrng, biasFactor) {
        this.arb = arb;
        this.mrng = mrng;
        this.biasFactor = biasFactor;
      }
      attemptExact() {
        return;
      }
      next() {
        return this.arb.generate(this.mrng, this.biasFactor);
      }
    };
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SlicedBasedGenerator.js
var safeMathMin2, safeMathMax, SlicedBasedGenerator;
var init_SlicedBasedGenerator = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SlicedBasedGenerator.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Value();
    init_globals();
    safeMathMin2 = Math.min;
    safeMathMax = Math.max;
    SlicedBasedGenerator = class {
      static {
        __name(this, "SlicedBasedGenerator");
      }
      constructor(arb, mrng, slices, biasFactor) {
        this.arb = arb;
        this.mrng = mrng;
        this.slices = slices;
        this.biasFactor = biasFactor;
        this.activeSliceIndex = 0;
        this.nextIndexInSlice = 0;
        this.lastIndexInSlice = -1;
      }
      attemptExact(targetLength) {
        if (targetLength !== 0 && this.mrng.nextInt(1, this.biasFactor) === 1) {
          const eligibleIndices = [];
          for (let index2 = 0; index2 !== this.slices.length; ++index2) {
            const slice = this.slices[index2];
            if (slice.length === targetLength) {
              safePush(eligibleIndices, index2);
            }
          }
          if (eligibleIndices.length === 0) {
            return;
          }
          this.activeSliceIndex = eligibleIndices[this.mrng.nextInt(0, eligibleIndices.length - 1)];
          this.nextIndexInSlice = 0;
          this.lastIndexInSlice = targetLength - 1;
        }
      }
      next() {
        if (this.nextIndexInSlice <= this.lastIndexInSlice) {
          return new Value(this.slices[this.activeSliceIndex][this.nextIndexInSlice++], void 0);
        }
        if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
          return this.arb.generate(this.mrng, this.biasFactor);
        }
        this.activeSliceIndex = this.mrng.nextInt(0, this.slices.length - 1);
        const slice = this.slices[this.activeSliceIndex];
        if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
          this.nextIndexInSlice = 1;
          this.lastIndexInSlice = slice.length - 1;
          return new Value(slice[0], void 0);
        }
        const rangeBoundaryA = this.mrng.nextInt(0, slice.length - 1);
        const rangeBoundaryB = this.mrng.nextInt(0, slice.length - 1);
        this.nextIndexInSlice = safeMathMin2(rangeBoundaryA, rangeBoundaryB);
        this.lastIndexInSlice = safeMathMax(rangeBoundaryA, rangeBoundaryB);
        return new Value(slice[this.nextIndexInSlice++], void 0);
      }
    };
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSlicedGenerator.js
function buildSlicedGenerator(arb, mrng, slices, biasFactor) {
  if (biasFactor === void 0 || slices.length === 0 || mrng.nextInt(1, biasFactor) !== 1) {
    return new NoopSlicedGenerator(arb, mrng, biasFactor);
  }
  return new SlicedBasedGenerator(arb, mrng, slices, biasFactor);
}
var init_BuildSlicedGenerator = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSlicedGenerator.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_NoopSlicedGenerator();
    init_SlicedBasedGenerator();
    __name(buildSlicedGenerator, "buildSlicedGenerator");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js
function biasedMaxLength(minLength2, maxLength2) {
  if (minLength2 === maxLength2) {
    return minLength2;
  }
  return minLength2 + safeMathFloor3(safeMathLog3(maxLength2 - minLength2) / safeMathLog3(2));
}
var safeMathFloor3, safeMathLog3, safeMathMax2, safeArrayIsArray, ArrayArbitrary;
var init_ArrayArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Stream();
    init_symbols();
    init_integer();
    init_LazyIterableIterator();
    init_Arbitrary();
    init_Value();
    init_DepthContext();
    init_BuildSlicedGenerator();
    init_globals();
    safeMathFloor3 = Math.floor;
    safeMathLog3 = Math.log;
    safeMathMax2 = Math.max;
    safeArrayIsArray = Array.isArray;
    __name(biasedMaxLength, "biasedMaxLength");
    ArrayArbitrary = class _ArrayArbitrary extends Arbitrary {
      static {
        __name(this, "ArrayArbitrary");
      }
      constructor(arb, minLength2, maxGeneratedLength, maxLength2, depthIdentifier, setBuilder, customSlices) {
        super();
        this.arb = arb;
        this.minLength = minLength2;
        this.maxGeneratedLength = maxGeneratedLength;
        this.maxLength = maxLength2;
        this.setBuilder = setBuilder;
        this.customSlices = customSlices;
        this.lengthArb = integer({ min: minLength2, max: maxGeneratedLength });
        this.depthContext = getDepthContextFor(depthIdentifier);
      }
      preFilter(tab) {
        if (this.setBuilder === void 0) {
          return tab;
        }
        const s = this.setBuilder();
        for (let index2 = 0; index2 !== tab.length; ++index2) {
          s.tryAdd(tab[index2]);
        }
        return s.getData();
      }
      static makeItCloneable(vs, shrinkables) {
        vs[cloneMethod] = () => {
          const cloned = [];
          for (let idx = 0; idx !== shrinkables.length; ++idx) {
            safePush(cloned, shrinkables[idx].value);
          }
          this.makeItCloneable(cloned, shrinkables);
          return cloned;
        };
        return vs;
      }
      generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
        let numSkippedInRow = 0;
        const s = setBuilder();
        const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
        while (s.size() < N && numSkippedInRow < this.maxGeneratedLength) {
          const current2 = slicedGenerator.next();
          if (s.tryAdd(current2)) {
            numSkippedInRow = 0;
          } else {
            numSkippedInRow += 1;
          }
        }
        return s.getData();
      }
      safeGenerateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
        const depthImpact = safeMathMax2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
        this.depthContext.depth += depthImpact;
        try {
          return this.generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems);
        } finally {
          this.depthContext.depth -= depthImpact;
        }
      }
      generateNItems(N, mrng, biasFactorItems) {
        const items = [];
        const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
        slicedGenerator.attemptExact(N);
        for (let index2 = 0; index2 !== N; ++index2) {
          const current2 = slicedGenerator.next();
          safePush(items, current2);
        }
        return items;
      }
      safeGenerateNItems(N, mrng, biasFactorItems) {
        const depthImpact = safeMathMax2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
        this.depthContext.depth += depthImpact;
        try {
          return this.generateNItems(N, mrng, biasFactorItems);
        } finally {
          this.depthContext.depth -= depthImpact;
        }
      }
      wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {
        const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;
        let cloneable = false;
        const vs = [];
        const itemsContexts = [];
        for (let idx = 0; idx !== items.length; ++idx) {
          const s = items[idx];
          cloneable = cloneable || s.hasToBeCloned;
          safePush(vs, s.value);
          safePush(itemsContexts, s.context);
        }
        if (cloneable) {
          _ArrayArbitrary.makeItCloneable(vs, items);
        }
        const context10 = {
          shrunkOnce,
          lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== void 0 ? itemsRawLengthContext : void 0,
          itemsContexts,
          startIndex
        };
        return new Value(vs, context10);
      }
      generate(mrng, biasFactor) {
        const biasMeta = this.applyBias(mrng, biasFactor);
        const targetSize = biasMeta.size;
        const items = this.setBuilder !== void 0 ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems) : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);
        return this.wrapper(items, false, void 0, 0);
      }
      applyBias(mrng, biasFactor) {
        if (biasFactor === void 0) {
          return { size: this.lengthArb.generate(mrng, void 0).value };
        }
        if (this.minLength === this.maxGeneratedLength) {
          return { size: this.lengthArb.generate(mrng, void 0).value, biasFactorItems: biasFactor };
        }
        if (mrng.nextInt(1, biasFactor) !== 1) {
          return { size: this.lengthArb.generate(mrng, void 0).value };
        }
        if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) {
          return { size: this.lengthArb.generate(mrng, void 0).value, biasFactorItems: biasFactor };
        }
        const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);
        const targetSizeValue = integer({ min: this.minLength, max: maxBiasedLength }).generate(mrng, void 0);
        return { size: targetSizeValue.value, biasFactorItems: biasFactor };
      }
      canShrinkWithoutContext(value3) {
        if (!safeArrayIsArray(value3) || this.minLength > value3.length || value3.length > this.maxLength) {
          return false;
        }
        for (let index2 = 0; index2 !== value3.length; ++index2) {
          if (!(index2 in value3)) {
            return false;
          }
          if (!this.arb.canShrinkWithoutContext(value3[index2])) {
            return false;
          }
        }
        const filtered = this.preFilter(safeMap(value3, (item) => new Value(item, void 0)));
        return filtered.length === value3.length;
      }
      shrinkItemByItem(value3, safeContext, endIndex) {
        const shrinks = [];
        for (let index2 = safeContext.startIndex; index2 < endIndex; ++index2) {
          safePush(shrinks, makeLazy(() => this.arb.shrink(value3[index2], safeContext.itemsContexts[index2]).map((v) => {
            const beforeCurrent = safeMap(safeSlice(value3, 0, index2), (v2, i) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[i]));
            const afterCurrent = safeMap(safeSlice(value3, index2 + 1), (v2, i) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[i + index2 + 1]));
            return [
              [...beforeCurrent, v, ...afterCurrent],
              void 0,
              index2
            ];
          })));
        }
        return Stream.nil().join(...shrinks);
      }
      shrinkImpl(value3, context10) {
        if (value3.length === 0) {
          return Stream.nil();
        }
        const safeContext = context10 !== void 0 ? context10 : { shrunkOnce: false, lengthContext: void 0, itemsContexts: [], startIndex: 0 };
        return this.lengthArb.shrink(value3.length, safeContext.lengthContext).drop(safeContext.shrunkOnce && safeContext.lengthContext === void 0 && value3.length > this.minLength + 1 ? 1 : 0).map((lengthValue) => {
          const sliceStart = value3.length - lengthValue.value;
          return [
            safeMap(safeSlice(value3, sliceStart), (v, index2) => new Value(cloneIfNeeded(v), safeContext.itemsContexts[index2 + sliceStart])),
            lengthValue.context,
            0
          ];
        }).join(makeLazy(() => value3.length > this.minLength ? this.shrinkItemByItem(value3, safeContext, 1) : this.shrinkItemByItem(value3, safeContext, value3.length))).join(value3.length > this.minLength ? makeLazy(() => {
          const subContext = {
            shrunkOnce: false,
            lengthContext: void 0,
            itemsContexts: safeSlice(safeContext.itemsContexts, 1),
            startIndex: 0
          };
          return this.shrinkImpl(safeSlice(value3, 1), subContext).filter((v) => this.minLength <= v[0].length + 1).map((v) => {
            return [[new Value(cloneIfNeeded(value3[0]), safeContext.itemsContexts[0]), ...v[0]], void 0, 0];
          });
        }) : Stream.nil());
      }
      shrink(value3, context10) {
        return this.shrinkImpl(value3, context10).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));
      }
    };
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/MaxLengthFromMinLength.js
function maxLengthFromMinLength(minLength2, size15) {
  switch (size15) {
    case "xsmall":
      return safeMathFloor4(1.1 * minLength2) + 1;
    case "small":
      return 2 * minLength2 + 10;
    case "medium":
      return 11 * minLength2 + 100;
    case "large":
      return 101 * minLength2 + 1e3;
    case "xlarge":
      return 1001 * minLength2 + 1e4;
    default:
      throw new Error(`Unable to compute lengths based on received size: ${size15}`);
  }
}
function relativeSizeToSize(size15, defaultSize) {
  const sizeInRelative = safeIndexOf(orderedRelativeSize, size15);
  if (sizeInRelative === -1) {
    return size15;
  }
  const defaultSizeInSize = safeIndexOf(orderedSize, defaultSize);
  if (defaultSizeInSize === -1) {
    throw new Error(`Unable to offset size based on the unknown defaulted one: ${defaultSize}`);
  }
  const resultingSizeInSize = defaultSizeInSize + sizeInRelative - 4;
  return resultingSizeInSize < 0 ? orderedSize[0] : resultingSizeInSize >= orderedSize.length ? orderedSize[orderedSize.length - 1] : orderedSize[resultingSizeInSize];
}
function maxGeneratedLengthFromSizeForArbitrary(size15, minLength2, maxLength2, specifiedMaxLength) {
  const { baseSize: defaultSize = DefaultSize, defaultSizeToMaxWhenMaxSpecified } = readConfigureGlobal() || {};
  const definedSize = size15 !== void 0 ? size15 : specifiedMaxLength && defaultSizeToMaxWhenMaxSpecified ? "max" : defaultSize;
  if (definedSize === "max") {
    return maxLength2;
  }
  const finalSize = relativeSizeToSize(definedSize, defaultSize);
  return safeMathMin3(maxLengthFromMinLength(minLength2, finalSize), maxLength2);
}
var safeMathFloor4, safeMathMin3, MaxLengthUpperBound, orderedSize, orderedRelativeSize, DefaultSize;
var init_MaxLengthFromMinLength = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/MaxLengthFromMinLength.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_GlobalParameters();
    init_globals();
    safeMathFloor4 = Math.floor;
    safeMathMin3 = Math.min;
    MaxLengthUpperBound = 2147483647;
    orderedSize = ["xsmall", "small", "medium", "large", "xlarge"];
    orderedRelativeSize = ["-4", "-3", "-2", "-1", "=", "+1", "+2", "+3", "+4"];
    DefaultSize = "small";
    __name(maxLengthFromMinLength, "maxLengthFromMinLength");
    __name(relativeSizeToSize, "relativeSizeToSize");
    __name(maxGeneratedLengthFromSizeForArbitrary, "maxGeneratedLengthFromSizeForArbitrary");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/array.js
function array3(arb, constraints = {}) {
  const size15 = constraints.size;
  const minLength2 = constraints.minLength || 0;
  const maxLengthOrUnset = constraints.maxLength;
  const depthIdentifier = constraints.depthIdentifier;
  const maxLength2 = maxLengthOrUnset !== void 0 ? maxLengthOrUnset : MaxLengthUpperBound;
  const specifiedMaxLength = maxLengthOrUnset !== void 0;
  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size15, minLength2, maxLength2, specifiedMaxLength);
  const customSlices = constraints.experimentalCustomSlices || [];
  return new ArrayArbitrary(arb, minLength2, maxGeneratedLength, maxLength2, depthIdentifier, void 0, customSlices);
}
var init_array2 = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_ArrayArbitrary();
    init_MaxLengthFromMinLength();
    __name(array3, "array");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkBigInt.js
var init_ShrinkBigInt = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkBigInt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Stream();
    init_Value();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/BigIntArbitrary.js
var init_BigIntArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/BigIntArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Stream();
    init_Arbitrary();
    init_Value();
    init_BiasNumericRange();
    init_ShrinkBigInt();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/bigInt.js
var init_bigInt = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/bigInt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_BigIntArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/bigIntN.js
var init_bigIntN = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/bigIntN.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_BigIntArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/bigUint.js
var init_bigUint = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/bigUint.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_BigIntArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/bigUintN.js
var init_bigUintN = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/bigUintN.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_BigIntArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/noBias.js
var init_noBias = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/noBias.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/boolean.js
var init_boolean = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/boolean.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_integer();
    init_noBias();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/ConstantArbitrary.js
var init_ConstantArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/ConstantArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Stream();
    init_Arbitrary();
    init_Value();
    init_symbols();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/constantFrom.js
var init_constantFrom = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/constantFrom.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_ConstantArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/falsy.js
var init_falsy = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/falsy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_constantFrom();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToCharString.js
function indexToCharStringUnmapper(c) {
  if (typeof c !== "string") {
    throw new Error("Cannot unmap non-string");
  }
  if (c.length === 0 || c.length > 2) {
    throw new Error("Cannot unmap string with more or less than one character");
  }
  const c1 = safeCharCodeAt(c, 0);
  if (c.length === 1) {
    return c1;
  }
  const c2 = safeCharCodeAt(c, 1);
  if (c1 < 55296 || c1 > 56319 || c2 < 56320 || c2 > 57343) {
    throw new Error("Cannot unmap invalid surrogate pairs");
  }
  return c.codePointAt(0);
}
var indexToCharStringMapper;
var init_IndexToCharString = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToCharString.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    indexToCharStringMapper = String.fromCodePoint;
    __name(indexToCharStringUnmapper, "indexToCharStringUnmapper");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterArbitraryBuilder.js
function buildCharacterArbitrary(min4, max6, mapToCode, unmapFromCode) {
  return integer({ min: min4, max: max6 }).map((n) => indexToCharStringMapper(mapToCode(n)), (c) => unmapFromCode(indexToCharStringUnmapper(c)));
}
var init_CharacterArbitraryBuilder = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterArbitraryBuilder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_integer();
    init_IndexToCharString();
    __name(buildCharacterArbitrary, "buildCharacterArbitrary");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToPrintableIndex.js
function indexToPrintableIndexMapper(v) {
  if (v < 95)
    return v + 32;
  if (v <= 126)
    return v - 95;
  return v;
}
function indexToPrintableIndexUnmapper(v) {
  if (v >= 32 && v <= 126)
    return v - 32;
  if (v >= 0 && v <= 31)
    return v + 95;
  return v;
}
var init_IndexToPrintableIndex = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToPrintableIndex.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(indexToPrintableIndexMapper, "indexToPrintableIndexMapper");
    __name(indexToPrintableIndexUnmapper, "indexToPrintableIndexUnmapper");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/ascii.js
var init_ascii = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/ascii.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_CharacterArbitraryBuilder();
    init_IndexToPrintableIndex();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/base64.js
var init_base64 = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/base64.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_CharacterArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/char.js
function identity2(v) {
  return v;
}
function char() {
  return buildCharacterArbitrary(32, 126, identity2, identity2);
}
var init_char = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/char.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_CharacterArbitraryBuilder();
    __name(identity2, "identity");
    __name(char, "char");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/char16bits.js
var init_char16bits = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/char16bits.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_CharacterArbitraryBuilder();
    init_IndexToPrintableIndex();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/fullUnicode.js
function unicodeMapper(v) {
  if (v < 55296)
    return indexToPrintableIndexMapper(v);
  return v + gapSize;
}
function unicodeUnmapper(v) {
  if (v < 55296)
    return indexToPrintableIndexUnmapper(v);
  if (v <= 57343)
    return -1;
  return v - gapSize;
}
function fullUnicode() {
  return buildCharacterArbitrary(0, 1114111 - gapSize, unicodeMapper, unicodeUnmapper);
}
var gapSize;
var init_fullUnicode = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/fullUnicode.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_CharacterArbitraryBuilder();
    init_IndexToPrintableIndex();
    gapSize = 57343 + 1 - 55296;
    __name(unicodeMapper, "unicodeMapper");
    __name(unicodeUnmapper, "unicodeUnmapper");
    __name(fullUnicode, "fullUnicode");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/hexa.js
var init_hexa = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/hexa.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_CharacterArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/unicode.js
var gapSize2;
var init_unicode = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/unicode.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_CharacterArbitraryBuilder();
    init_IndexToPrintableIndex();
    gapSize2 = 57343 + 1 - 55296;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/constant.js
var init_constant = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/constant.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_ConstantArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/context.js
var ContextImplem;
var init_context = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/context.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_symbols();
    init_constant();
    ContextImplem = class _ContextImplem {
      static {
        __name(this, "ContextImplem");
      }
      constructor() {
        this.receivedLogs = [];
      }
      log(data) {
        this.receivedLogs.push(data);
      }
      size() {
        return this.receivedLogs.length;
      }
      toString() {
        return JSON.stringify({ logs: this.receivedLogs });
      }
      [cloneMethod]() {
        return new _ContextImplem();
      }
    };
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/TimeToDate.js
var safeNaN, safeNumberIsNaN2;
var init_TimeToDate = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/TimeToDate.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    safeNaN = Number.NaN;
    safeNumberIsNaN2 = Number.isNaN;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/date.js
var safeNumberIsNaN3;
var init_date = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/date.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_integer();
    init_TimeToDate();
    safeNumberIsNaN3 = Number.isNaN;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/CloneArbitrary.js
var init_CloneArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/CloneArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary();
    init_Value();
    init_symbols();
    init_Stream();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/clone.js
var init_clone = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/clone.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_CloneArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/CustomEqualSet.js
var init_CustomEqualSet = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/CustomEqualSet.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/StrictlyEqualSet.js
var safeNumberIsNaN4;
var init_StrictlyEqualSet = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/StrictlyEqualSet.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    safeNumberIsNaN4 = Number.isNaN;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SameValueSet.js
var init_SameValueSet = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SameValueSet.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SameValueZeroSet.js
var init_SameValueZeroSet = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SameValueZeroSet.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/uniqueArray.js
var init_uniqueArray = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/uniqueArray.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_ArrayArbitrary();
    init_MaxLengthFromMinLength();
    init_CustomEqualSet();
    init_StrictlyEqualSet();
    init_SameValueSet();
    init_SameValueZeroSet();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/KeyValuePairsToObject.js
var init_KeyValuePairsToObject = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/KeyValuePairsToObject.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/dictionary.js
var init_dictionary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/dictionary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tuple();
    init_uniqueArray();
    init_KeyValuePairsToObject();
    init_constant();
    init_boolean();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/FrequencyArbitrary.js
var safePositiveInfinity2, safeMaxSafeInteger, safeNumberIsInteger3;
var init_FrequencyArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/FrequencyArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Stream();
    init_Arbitrary();
    init_Value();
    init_DepthContext();
    init_MaxLengthFromMinLength();
    init_globals();
    safePositiveInfinity2 = Number.POSITIVE_INFINITY;
    safeMaxSafeInteger = Number.MAX_SAFE_INTEGER;
    safeNumberIsInteger3 = Number.isInteger;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/oneof.js
var init_oneof = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/oneof.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary();
    init_globals();
    init_FrequencyArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/nat.js
var safeNumberIsInteger4;
var init_nat = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/nat.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_IntegerArbitrary();
    safeNumberIsInteger4 = Number.isInteger;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToMappedConstant.js
var init_IndexToMappedConstant = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToMappedConstant.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/mapToConstant.js
var init_mapToConstant = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/mapToConstant.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_nat();
    init_IndexToMappedConstant();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterRangeArbitraryBuilder.js
function percentCharArbMapper(c) {
  const encoded = SencodeURIComponent(c);
  return c !== encoded ? encoded : `%${safeNumberToString(safeCharCodeAt(c, 0), 16)}`;
}
function percentCharArbUnmapper(value3) {
  if (typeof value3 !== "string") {
    throw new Error("Unsupported");
  }
  const decoded = decodeURIComponent(value3);
  return decoded;
}
var safeStringFromCharCode, percentCharArb;
var init_CharacterRangeArbitraryBuilder = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterRangeArbitraryBuilder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_fullUnicode();
    init_oneof();
    init_mapToConstant();
    init_globals();
    safeStringFromCharCode = String.fromCharCode;
    __name(percentCharArbMapper, "percentCharArbMapper");
    __name(percentCharArbUnmapper, "percentCharArbUnmapper");
    percentCharArb = fullUnicode().map(percentCharArbMapper, percentCharArbUnmapper);
  }
});

// node_modules/fast-check/lib/esm/arbitrary/option.js
var init_option2 = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/option.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_constant();
    init_FrequencyArbitrary();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeString.js
var init_TokenizeString = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeString.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PatternsToString.js
var init_PatternsToString = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PatternsToString.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_MaxLengthFromMinLength();
    init_globals();
    init_TokenizeString();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SlicesForStringBuilder.js
var init_SlicesForStringBuilder = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SlicesForStringBuilder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_PatternsToString();
    init_MaxLengthFromMinLength();
    init_TokenizeString();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/data/GraphemeRanges.js
var init_GraphemeRanges = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/data/GraphemeRanges.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/GraphemeRangesHelpers.js
var safeStringFromCodePoint;
var init_GraphemeRangesHelpers = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/GraphemeRangesHelpers.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    safeStringFromCodePoint = String.fromCodePoint;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/StringUnitArbitrary.js
var init_StringUnitArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/StringUnitArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_mapToConstant();
    init_GraphemeRanges();
    init_GraphemeRangesHelpers();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/string.js
var init_string = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/string.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_array2();
    init_SlicesForStringBuilder();
    init_StringUnitArbitrary();
    init_PatternsToString();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/InvalidSubdomainLabelFiIter.js
var init_InvalidSubdomainLabelFiIter = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/InvalidSubdomainLabelFiIter.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/AdapterArbitrary.js
var AdaptedValue;
var init_AdapterArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/AdapterArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary();
    init_Value();
    init_Stream();
    AdaptedValue = Symbol("adapted-value");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/domain.js
var init_domain = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/domain.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_array2();
    init_CharacterRangeArbitraryBuilder();
    init_option2();
    init_string();
    init_tuple();
    init_InvalidSubdomainLabelFiIter();
    init_MaxLengthFromMinLength();
    init_AdapterArbitrary();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/emailAddress.js
var init_emailAddress = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/emailAddress.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_array2();
    init_CharacterRangeArbitraryBuilder();
    init_domain();
    init_string();
    init_tuple();
    init_AdapterArbitrary();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ArrayInt64.js
var init_ArrayInt64 = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ArrayInt64.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayInt64Arbitrary.js
var init_ArrayInt64Arbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayInt64Arbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Stream();
    init_Arbitrary();
    init_Value();
    init_ArrayInt64();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleHelpers.js
var safeNegativeInfinity2, safePositiveInfinity3, safeEpsilon, f64, u32;
var init_DoubleHelpers = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleHelpers.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_ArrayInt64();
    safeNegativeInfinity2 = Number.NEGATIVE_INFINITY;
    safePositiveInfinity3 = Number.POSITIVE_INFINITY;
    safeEpsilon = Number.EPSILON;
    f64 = new Float64Array(1);
    u32 = new Uint32Array(f64.buffer, f64.byteOffset);
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatingOnlyHelpers.js
var safeNumberIsInteger5, safeNegativeInfinity3, safePositiveInfinity4;
var init_FloatingOnlyHelpers = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatingOnlyHelpers.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    safeNumberIsInteger5 = Number.isInteger;
    safeNegativeInfinity3 = Number.NEGATIVE_INFINITY;
    safePositiveInfinity4 = Number.POSITIVE_INFINITY;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleOnlyHelpers.js
var safeNegativeInfinity4, safePositiveInfinity5, safeMaxValue;
var init_DoubleOnlyHelpers = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleOnlyHelpers.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_FloatingOnlyHelpers();
    safeNegativeInfinity4 = Number.NEGATIVE_INFINITY;
    safePositiveInfinity5 = Number.POSITIVE_INFINITY;
    safeMaxValue = Number.MAX_VALUE;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/double.js
var safeNumberIsInteger6, safeNumberIsNaN5, safeNegativeInfinity5, safePositiveInfinity6, safeMaxValue2, safeNaN2;
var init_double = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/double.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_ArrayInt64();
    init_ArrayInt64Arbitrary();
    init_DoubleHelpers();
    init_DoubleOnlyHelpers();
    safeNumberIsInteger6 = Number.isInteger;
    safeNumberIsNaN5 = Number.isNaN;
    safeNegativeInfinity5 = Number.NEGATIVE_INFINITY;
    safePositiveInfinity6 = Number.POSITIVE_INFINITY;
    safeMaxValue2 = Number.MAX_VALUE;
    safeNaN2 = Number.NaN;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatHelpers.js
var safeNegativeInfinity6, safePositiveInfinity7, MIN_VALUE_32, MAX_VALUE_32, EPSILON_32, f32, u322;
var init_FloatHelpers = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatHelpers.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    safeNegativeInfinity6 = Number.NEGATIVE_INFINITY;
    safePositiveInfinity7 = Number.POSITIVE_INFINITY;
    MIN_VALUE_32 = 2 ** -126 * 2 ** -23;
    MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);
    EPSILON_32 = 2 ** -23;
    f32 = new Float32Array(1);
    u322 = new Uint32Array(f32.buffer, f32.byteOffset);
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatOnlyHelpers.js
var safeNegativeInfinity7, safePositiveInfinity8;
var init_FloatOnlyHelpers = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatOnlyHelpers.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_FloatHelpers();
    init_FloatingOnlyHelpers();
    safeNegativeInfinity7 = Number.NEGATIVE_INFINITY;
    safePositiveInfinity8 = Number.POSITIVE_INFINITY;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/float.js
var safeNumberIsInteger7, safeNumberIsNaN6, safeNegativeInfinity8, safePositiveInfinity9, safeNaN3;
var init_float = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/float.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_integer();
    init_FloatHelpers();
    init_FloatOnlyHelpers();
    safeNumberIsInteger7 = Number.isInteger;
    safeNumberIsNaN6 = Number.isNaN;
    safeNegativeInfinity8 = Number.NEGATIVE_INFINITY;
    safePositiveInfinity9 = Number.POSITIVE_INFINITY;
    safeNaN3 = Number.NaN;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TextEscaper.js
function escapeForTemplateString(originalText) {
  return originalText.replace(/([$`\\])/g, "\\$1").replace(/\r/g, "\\r");
}
var init_TextEscaper = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TextEscaper.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(escapeForTemplateString, "escapeForTemplateString");
  }
});

// node_modules/fast-check/lib/esm/utils/hash.js
var init_hash = __esm({
  "node_modules/fast-check/lib/esm/utils/hash.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/noShrink.js
var init_noShrink = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/noShrink.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CompareFunctionArbitraryBuilder.js
var init_CompareFunctionArbitraryBuilder = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CompareFunctionArbitraryBuilder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_TextEscaper();
    init_symbols();
    init_hash();
    init_stringify();
    init_integer();
    init_noShrink();
    init_tuple();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/compareBooleanFunc.js
var init_compareBooleanFunc = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/compareBooleanFunc.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_CompareFunctionArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/compareFunc.js
var init_compareFunc = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/compareFunc.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_CompareFunctionArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/func.js
var init_func = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/func.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hash();
    init_stringify();
    init_symbols();
    init_array2();
    init_integer();
    init_noShrink();
    init_tuple();
    init_TextEscaper();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/maxSafeInteger.js
var safeMinSafeInteger, safeMaxSafeInteger2;
var init_maxSafeInteger = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/maxSafeInteger.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_IntegerArbitrary();
    safeMinSafeInteger = Number.MIN_SAFE_INTEGER;
    safeMaxSafeInteger2 = Number.MAX_SAFE_INTEGER;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/maxSafeNat.js
var safeMaxSafeInteger3;
var init_maxSafeNat = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/maxSafeNat.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_IntegerArbitrary();
    safeMaxSafeInteger3 = Number.MAX_SAFE_INTEGER;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/NatToStringifiedNat.js
var safeNumberParseInt;
var init_NatToStringifiedNat = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/NatToStringifiedNat.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    safeNumberParseInt = Number.parseInt;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/ipV4.js
var init_ipV4 = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/ipV4.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_nat();
    init_tuple();
    init_NatToStringifiedNat();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/StringifiedNatArbitraryBuilder.js
var init_StringifiedNatArbitraryBuilder = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/builders/StringifiedNatArbitraryBuilder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_constantFrom();
    init_nat();
    init_tuple();
    init_NatToStringifiedNat();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/ipV4Extended.js
var init_ipV4Extended = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/ipV4Extended.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_oneof();
    init_tuple();
    init_StringifiedNatArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/CodePointsToString.js
var init_CodePointsToString = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/CodePointsToString.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/hexaString.js
var init_hexaString = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/hexaString.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_array2();
    init_hexa();
    init_CodePointsToString();
    init_SlicesForStringBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/EntitiesToIPv6.js
var init_EntitiesToIPv6 = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/EntitiesToIPv6.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/ipV6.js
var init_ipV6 = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/ipV6.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_array2();
    init_oneof();
    init_hexaString();
    init_tuple();
    init_ipV4();
    init_EntitiesToIPv6();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/LazyArbitrary.js
var init_LazyArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/LazyArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/letrec.js
var init_letrec = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/letrec.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_LazyArbitrary();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/WordsToLorem.js
var init_WordsToLorem = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/WordsToLorem.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/lorem.js
var init_lorem = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/lorem.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_array2();
    init_constant();
    init_oneof();
    init_WordsToLorem();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/memo.js
var init_memo = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/memo.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ToggleFlags.js
var init_ToggleFlags = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ToggleFlags.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/MixedCaseArbitrary.js
var init_MixedCaseArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/MixedCaseArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_bigUintN();
    init_Arbitrary();
    init_Value();
    init_LazyIterableIterator();
    init_ToggleFlags();
    init_globals();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/mixedCase.js
var init_mixedCase = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/mixedCase.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_MixedCaseArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/float32Array.js
var init_float32Array = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/float32Array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_float();
    init_array2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/float64Array.js
var init_float64Array = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/float64Array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_double();
    init_array2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js
var init_TypedIntArrayArbitraryBuilder = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_array2();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/int16Array.js
var init_int16Array = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/int16Array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_integer();
    init_TypedIntArrayArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/int32Array.js
var init_int32Array = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/int32Array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_integer();
    init_TypedIntArrayArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/int8Array.js
var init_int8Array = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/int8Array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_integer();
    init_TypedIntArrayArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/uint16Array.js
var init_uint16Array = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/uint16Array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_integer();
    init_TypedIntArrayArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/uint32Array.js
var init_uint32Array = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/uint32Array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_integer();
    init_TypedIntArrayArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/uint8Array.js
var init_uint8Array = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/uint8Array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_integer();
    init_TypedIntArrayArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/uint8ClampedArray.js
var init_uint8ClampedArray = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/uint8ClampedArray.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_integer();
    init_TypedIntArrayArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/WithShrinkFromOtherArbitrary.js
var init_WithShrinkFromOtherArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/WithShrinkFromOtherArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary();
    init_Value();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/RestrictedIntegerArbitraryBuilder.js
var init_RestrictedIntegerArbitraryBuilder = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/builders/RestrictedIntegerArbitraryBuilder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_integer();
    init_WithShrinkFromOtherArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/sparseArray.js
var safeArrayIsArray2;
var init_sparseArray = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/sparseArray.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_tuple();
    init_uniqueArray();
    init_RestrictedIntegerArbitraryBuilder();
    init_MaxLengthFromMinLength();
    safeArrayIsArray2 = SArray.isArray;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ArrayToMap.js
var init_ArrayToMap = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ArrayToMap.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ArrayToSet.js
var init_ArrayToSet = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ArrayToSet.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/AnyArbitraryBuilder.js
var init_AnyArbitraryBuilder = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/builders/AnyArbitraryBuilder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_stringify();
    init_array2();
    init_oneof();
    init_tuple();
    init_bigInt();
    init_date();
    init_float32Array();
    init_float64Array();
    init_int16Array();
    init_int32Array();
    init_int8Array();
    init_uint16Array();
    init_uint32Array();
    init_uint8Array();
    init_uint8ClampedArray();
    init_sparseArray();
    init_ArrayToMap();
    init_ArrayToSet();
    init_letrec();
    init_uniqueArray();
    init_DepthContext();
    init_dictionary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/fullUnicodeString.js
var init_fullUnicodeString = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/fullUnicodeString.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_array2();
    init_fullUnicode();
    init_CodePointsToString();
    init_SlicesForStringBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/UnboxedToBoxed.js
var init_UnboxedToBoxed = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/UnboxedToBoxed.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/BoxedArbitraryBuilder.js
var init_BoxedArbitraryBuilder = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/builders/BoxedArbitraryBuilder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_UnboxedToBoxed();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/QualifiedObjectConstraints.js
var init_QualifiedObjectConstraints = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/QualifiedObjectConstraints.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_boolean();
    init_constant();
    init_double();
    init_fullUnicodeString();
    init_maxSafeInteger();
    init_oneof();
    init_string();
    init_BoxedArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/object.js
var init_object = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/object.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_dictionary();
    init_AnyArbitraryBuilder();
    init_QualifiedObjectConstraints();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/JsonConstraintsBuilder.js
var init_JsonConstraintsBuilder = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/JsonConstraintsBuilder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_boolean();
    init_constant();
    init_double();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/anything.js
var init_anything = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/anything.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_AnyArbitraryBuilder();
    init_QualifiedObjectConstraints();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/jsonValue.js
var init_jsonValue = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/jsonValue.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_string();
    init_JsonConstraintsBuilder();
    init_anything();
    init_fullUnicodeString();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/json.js
var init_json = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/json.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_jsonValue();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/unicodeString.js
var init_unicodeString = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/unicodeString.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_array2();
    init_unicode();
    init_CodePointsToString();
    init_SlicesForStringBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/unicodeJsonValue.js
var init_unicodeJsonValue = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/unicodeJsonValue.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_unicodeString();
    init_JsonConstraintsBuilder();
    init_anything();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/unicodeJson.js
var init_unicodeJson = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/unicodeJson.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_unicodeJsonValue();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/EnumerableKeysExtractor.js
var init_EnumerableKeysExtractor = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/EnumerableKeysExtractor.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ValuesAndSeparateKeysToObject.js
var init_ValuesAndSeparateKeysToObject = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ValuesAndSeparateKeysToObject.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js
var noKeyValue;
var init_PartialRecordArbitraryBuilder = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_boolean();
    init_constant();
    init_option2();
    init_tuple();
    init_EnumerableKeysExtractor();
    init_ValuesAndSeparateKeysToObject();
    noKeyValue = Symbol("no-key");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/record.js
var init_record = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/record.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_PartialRecordArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/StreamArbitrary.js
var init_StreamArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/StreamArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary();
    init_Value();
    init_symbols();
    init_Stream();
    init_globals();
    init_stringify();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/infiniteStream.js
var init_infiniteStream = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/infiniteStream.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_StreamArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/asciiString.js
var init_asciiString = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/asciiString.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_array2();
    init_ascii();
    init_CodePointsToString();
    init_SlicesForStringBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/StringToBase64.js
var init_StringToBase64 = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/StringToBase64.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/base64String.js
var init_base64String = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/base64String.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_array2();
    init_base64();
    init_MaxLengthFromMinLength();
    init_CodePointsToString();
    init_StringToBase64();
    init_SlicesForStringBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/CharsToString.js
var init_CharsToString = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/CharsToString.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/string16bits.js
var init_string16bits = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/string16bits.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_array2();
    init_char16bits();
    init_CharsToString();
    init_SlicesForStringBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/stringOf.js
var init_stringOf = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/stringOf.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_array2();
    init_PatternsToString();
    init_SlicesForStringBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/IsSubarrayOf.js
var init_IsSubarrayOf = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/IsSubarrayOf.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/SubarrayArbitrary.js
var init_SubarrayArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/SubarrayArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary();
    init_Value();
    init_LazyIterableIterator();
    init_Stream();
    init_globals();
    init_IsSubarrayOf();
    init_IntegerArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/subarray.js
var init_subarray = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/subarray.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_SubarrayArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/shuffledSubarray.js
var init_shuffledSubarray = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/shuffledSubarray.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_SubarrayArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/UintToBase32String.js
function encodeSymbol(symbol4) {
  return symbol4 < 10 ? SString(symbol4) : encodeSymbolLookupTable[symbol4];
}
function pad(value3, paddingLength) {
  let extraPadding = "";
  while (value3.length + extraPadding.length < paddingLength) {
    extraPadding += "0";
  }
  return extraPadding + value3;
}
function smallUintToBase32StringMapper(num) {
  let base32Str = "";
  for (let remaining = num; remaining !== 0; ) {
    const next4 = remaining >> 5;
    const current2 = remaining - (next4 << 5);
    base32Str = encodeSymbol(current2) + base32Str;
    remaining = next4;
  }
  return base32Str;
}
function uintToBase32StringMapper(num, paddingLength) {
  const head7 = ~~(num / 1073741824);
  const tail = num & 1073741823;
  return pad(smallUintToBase32StringMapper(head7), paddingLength - 6) + pad(smallUintToBase32StringMapper(tail), 6);
}
function paddedUintToBase32StringMapper(paddingLength) {
  return /* @__PURE__ */ __name(function padded(num) {
    return uintToBase32StringMapper(num, paddingLength);
  }, "padded");
}
var encodeSymbolLookupTable;
var init_UintToBase32String = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/UintToBase32String.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    encodeSymbolLookupTable = {
      10: "A",
      11: "B",
      12: "C",
      13: "D",
      14: "E",
      15: "F",
      16: "G",
      17: "H",
      18: "J",
      19: "K",
      20: "M",
      21: "N",
      22: "P",
      23: "Q",
      24: "R",
      25: "S",
      26: "T",
      27: "V",
      28: "W",
      29: "X",
      30: "Y",
      31: "Z"
    };
    __name(encodeSymbol, "encodeSymbol");
    __name(pad, "pad");
    __name(smallUintToBase32StringMapper, "smallUintToBase32StringMapper");
    __name(uintToBase32StringMapper, "uintToBase32StringMapper");
    __name(paddedUintToBase32StringMapper, "paddedUintToBase32StringMapper");
  }
});

// node_modules/fast-check/lib/esm/arbitrary/ulid.js
var padded10Mapper, padded8Mapper;
var init_ulid = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/ulid.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tuple();
    init_integer();
    init_UintToBase32String();
    padded10Mapper = paddedUintToBase32StringMapper(10);
    padded8Mapper = paddedUintToBase32StringMapper(8);
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/NumberToPaddedEight.js
var init_NumberToPaddedEight = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/NumberToPaddedEight.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PaddedNumberArbitraryBuilder.js
var init_PaddedNumberArbitraryBuilder = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PaddedNumberArbitraryBuilder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_integer();
    init_NumberToPaddedEight();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PaddedEightsToUuid.js
var init_PaddedEightsToUuid = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PaddedEightsToUuid.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/VersionsApplierForUuid.js
var init_VersionsApplierForUuid = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/VersionsApplierForUuid.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/uuid.js
var init_uuid = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/uuid.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tuple();
    init_PaddedNumberArbitraryBuilder();
    init_PaddedEightsToUuid();
    init_globals();
    init_VersionsApplierForUuid();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/uuidV.js
var init_uuidV = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/uuidV.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tuple();
    init_PaddedNumberArbitraryBuilder();
    init_PaddedEightsToUuid();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/webAuthority.js
var init_webAuthority = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/webAuthority.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_CharacterRangeArbitraryBuilder();
    init_constant();
    init_domain();
    init_ipV4();
    init_ipV4Extended();
    init_ipV6();
    init_nat();
    init_oneof();
    init_option2();
    init_string();
    init_tuple();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/UriQueryOrFragmentArbitraryBuilder.js
var init_UriQueryOrFragmentArbitraryBuilder = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/builders/UriQueryOrFragmentArbitraryBuilder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_CharacterRangeArbitraryBuilder();
    init_string();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/webFragments.js
var init_webFragments = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/webFragments.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_UriQueryOrFragmentArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/webSegment.js
var init_webSegment = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/webSegment.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_CharacterRangeArbitraryBuilder();
    init_string();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/SegmentsToPath.js
var init_SegmentsToPath = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/SegmentsToPath.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/builders/UriPathArbitraryBuilder.js
var init_UriPathArbitraryBuilder = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/builders/UriPathArbitraryBuilder.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_webSegment();
    init_array2();
    init_SegmentsToPath();
    init_oneof();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/webPath.js
var init_webPath = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/webPath.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_MaxLengthFromMinLength();
    init_UriPathArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/webQueryParameters.js
var init_webQueryParameters = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/webQueryParameters.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_UriQueryOrFragmentArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PartsToUrl.js
var init_PartsToUrl = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PartsToUrl.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/webUrl.js
var init_webUrl = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/webUrl.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_constantFrom();
    init_constant();
    init_option2();
    init_tuple();
    init_webQueryParameters();
    init_webFragments();
    init_webAuthority();
    init_PartsToUrl();
    init_MaxLengthFromMinLength();
    init_webPath();
  }
});

// node_modules/fast-check/lib/esm/check/model/commands/CommandsIterable.js
var CommandsIterable;
var init_CommandsIterable = __esm({
  "node_modules/fast-check/lib/esm/check/model/commands/CommandsIterable.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_symbols();
    CommandsIterable = class _CommandsIterable {
      static {
        __name(this, "CommandsIterable");
      }
      constructor(commands2, metadataForReplay) {
        this.commands = commands2;
        this.metadataForReplay = metadataForReplay;
      }
      [Symbol.iterator]() {
        return this.commands[Symbol.iterator]();
      }
      [cloneMethod]() {
        return new _CommandsIterable(this.commands.map((c) => c.clone()), this.metadataForReplay);
      }
      toString() {
        const serializedCommands = this.commands.filter((c) => c.hasRan).map((c) => c.toString()).join(",");
        const metadata = this.metadataForReplay();
        return metadata.length !== 0 ? `${serializedCommands} /*${metadata}*/` : serializedCommands;
      }
    };
  }
});

// node_modules/fast-check/lib/esm/check/model/commands/CommandWrapper.js
var init_CommandWrapper = __esm({
  "node_modules/fast-check/lib/esm/check/model/commands/CommandWrapper.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_stringify();
    init_symbols();
  }
});

// node_modules/fast-check/lib/esm/check/model/ReplayPath.js
var init_ReplayPath = __esm({
  "node_modules/fast-check/lib/esm/check/model/ReplayPath.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/CommandsArbitrary.js
var init_CommandsArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/CommandsArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary();
    init_Value();
    init_CommandsIterable();
    init_CommandWrapper();
    init_ReplayPath();
    init_LazyIterableIterator();
    init_Stream();
    init_oneof();
    init_RestrictedIntegerArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/commands.js
var init_commands = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/commands.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_CommandsArbitrary();
    init_MaxLengthFromMinLength();
  }
});

// node_modules/fast-check/lib/esm/check/model/commands/ScheduledCommand.js
var init_ScheduledCommand = __esm({
  "node_modules/fast-check/lib/esm/check/model/commands/ScheduledCommand.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/fast-check/lib/esm/check/model/ModelRunner.js
var init_ModelRunner = __esm({
  "node_modules/fast-check/lib/esm/check/model/ModelRunner.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_ScheduledCommand();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SchedulerImplem.js
var defaultSchedulerAct, SchedulerImplem;
var init_SchedulerImplem = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SchedulerImplem.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_TextEscaper();
    init_symbols();
    init_stringify();
    defaultSchedulerAct = /* @__PURE__ */ __name((f) => f(), "defaultSchedulerAct");
    SchedulerImplem = class _SchedulerImplem {
      static {
        __name(this, "SchedulerImplem");
      }
      constructor(act, taskSelector) {
        this.act = act;
        this.taskSelector = taskSelector;
        this.lastTaskId = 0;
        this.sourceTaskSelector = taskSelector.clone();
        this.scheduledTasks = [];
        this.triggeredTasks = [];
        this.scheduledWatchers = [];
      }
      static buildLog(reportItem) {
        return `[task\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== void 0 ? ` with value ${escapeForTemplateString(reportItem.outputValue)}` : ""}`;
      }
      log(schedulingType, taskId, label, metadata, status2, data) {
        this.triggeredTasks.push({
          status: status2,
          schedulingType,
          taskId,
          label,
          metadata,
          outputValue: data !== void 0 ? stringify(data) : void 0
        });
      }
      scheduleInternal(schedulingType, label, task, metadata, customAct, thenTaskToBeAwaited) {
        let trigger = null;
        const taskId = ++this.lastTaskId;
        const scheduledPromise = new Promise((resolve, reject) => {
          trigger = /* @__PURE__ */ __name(() => {
            (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then((data) => {
              this.log(schedulingType, taskId, label, metadata, "resolved", data);
              return resolve(data);
            }, (err) => {
              this.log(schedulingType, taskId, label, metadata, "rejected", err);
              return reject(err);
            });
          }, "trigger");
        });
        this.scheduledTasks.push({
          original: task,
          scheduled: scheduledPromise,
          trigger,
          schedulingType,
          taskId,
          label,
          metadata,
          customAct
        });
        if (this.scheduledWatchers.length !== 0) {
          this.scheduledWatchers[0]();
        }
        return scheduledPromise;
      }
      schedule(task, label, metadata, customAct) {
        return this.scheduleInternal("promise", label || "", task, metadata, customAct || defaultSchedulerAct);
      }
      scheduleFunction(asyncFunction, customAct) {
        return (...args2) => this.scheduleInternal("function", `${asyncFunction.name}(${args2.map(stringify).join(",")})`, asyncFunction(...args2), void 0, customAct || defaultSchedulerAct);
      }
      scheduleSequence(sequenceBuilders, customAct) {
        const status2 = { done: false, faulty: false };
        const dummyResolvedPromise = { then: /* @__PURE__ */ __name((f) => f(), "then") };
        let resolveSequenceTask = /* @__PURE__ */ __name(() => {
        }, "resolveSequenceTask");
        const sequenceTask = new Promise((resolve) => resolveSequenceTask = resolve);
        sequenceBuilders.reduce((previouslyScheduled, item) => {
          const [builder, label, metadata] = typeof item === "function" ? [item, item.name, void 0] : [item.builder, item.label, item.metadata];
          return previouslyScheduled.then(() => {
            const scheduled2 = this.scheduleInternal("sequence", label, dummyResolvedPromise, metadata, customAct || defaultSchedulerAct, () => builder());
            scheduled2.catch(() => {
              status2.faulty = true;
              resolveSequenceTask();
            });
            return scheduled2;
          });
        }, dummyResolvedPromise).then(() => {
          status2.done = true;
          resolveSequenceTask();
        }, () => {
        });
        return Object.assign(status2, {
          task: Promise.resolve(sequenceTask).then(() => {
            return { done: status2.done, faulty: status2.faulty };
          })
        });
      }
      count() {
        return this.scheduledTasks.length;
      }
      internalWaitOne() {
        if (this.scheduledTasks.length === 0) {
          throw new Error("No task scheduled");
        }
        const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);
        const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);
        return scheduledTask.customAct(async () => {
          scheduledTask.trigger();
          try {
            await scheduledTask.scheduled;
          } catch (_err) {
          }
        });
      }
      async waitOne(customAct) {
        const waitAct = customAct || defaultSchedulerAct;
        await this.act(() => waitAct(async () => await this.internalWaitOne()));
      }
      async waitAll(customAct) {
        while (this.scheduledTasks.length > 0) {
          await this.waitOne(customAct);
        }
      }
      async waitFor(unscheduledTask, customAct) {
        let taskResolved = false;
        let awaiterPromise = null;
        const awaiter = /* @__PURE__ */ __name(async () => {
          while (!taskResolved && this.scheduledTasks.length > 0) {
            await this.waitOne(customAct);
          }
          awaiterPromise = null;
        }, "awaiter");
        const handleNotified = /* @__PURE__ */ __name(() => {
          if (awaiterPromise !== null) {
            return;
          }
          awaiterPromise = Promise.resolve().then(awaiter);
        }, "handleNotified");
        const clearAndReplaceWatcher = /* @__PURE__ */ __name(() => {
          const handleNotifiedIndex = this.scheduledWatchers.indexOf(handleNotified);
          if (handleNotifiedIndex !== -1) {
            this.scheduledWatchers.splice(handleNotifiedIndex, 1);
          }
          if (handleNotifiedIndex === 0 && this.scheduledWatchers.length !== 0) {
            this.scheduledWatchers[0]();
          }
        }, "clearAndReplaceWatcher");
        const rewrappedTask = unscheduledTask.then((ret) => {
          taskResolved = true;
          if (awaiterPromise === null) {
            clearAndReplaceWatcher();
            return ret;
          }
          return awaiterPromise.then(() => {
            clearAndReplaceWatcher();
            return ret;
          });
        }, (err) => {
          taskResolved = true;
          if (awaiterPromise === null) {
            clearAndReplaceWatcher();
            throw err;
          }
          return awaiterPromise.then(() => {
            clearAndReplaceWatcher();
            throw err;
          });
        });
        if (this.scheduledTasks.length > 0 && this.scheduledWatchers.length === 0) {
          handleNotified();
        }
        this.scheduledWatchers.push(handleNotified);
        return rewrappedTask;
      }
      report() {
        return [
          ...this.triggeredTasks,
          ...this.scheduledTasks.map((t) => ({
            status: "pending",
            schedulingType: t.schedulingType,
            taskId: t.taskId,
            label: t.label,
            metadata: t.metadata
          }))
        ];
      }
      toString() {
        return "schedulerFor()`\n" + this.report().map(_SchedulerImplem.buildLog).map((log5) => `-> ${log5}`).join("\n") + "`";
      }
      [cloneMethod]() {
        return new _SchedulerImplem(this.act, this.sourceTaskSelector);
      }
    };
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSchedulerFor.js
var init_BuildSchedulerFor = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSchedulerFor.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_SchedulerImplem();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/SchedulerArbitrary.js
var init_SchedulerArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/SchedulerArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary();
    init_Value();
    init_Stream();
    init_SchedulerImplem();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/scheduler.js
var init_scheduler = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/scheduler.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_BuildSchedulerFor();
    init_SchedulerArbitrary();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/bigInt64Array.js
var init_bigInt64Array = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/bigInt64Array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_bigInt();
    init_TypedIntArrayArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/bigUint64Array.js
var init_bigUint64Array = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/bigUint64Array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_bigInt();
    init_TypedIntArrayArbitraryBuilder();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SanitizeRegexAst.js
var init_SanitizeRegexAst = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SanitizeRegexAst.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_stringify();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ReadRegex.js
var TokenizerBlockMode;
var init_ReadRegex = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ReadRegex.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(TokenizerBlockMode2) {
      TokenizerBlockMode2[TokenizerBlockMode2["Full"] = 0] = "Full";
      TokenizerBlockMode2[TokenizerBlockMode2["Character"] = 1] = "Character";
    })(TokenizerBlockMode || (TokenizerBlockMode = {}));
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeRegex.js
var safeStringFromCodePoint2;
var init_TokenizeRegex = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeRegex.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_ReadRegex();
    safeStringFromCodePoint2 = String.fromCodePoint;
  }
});

// node_modules/fast-check/lib/esm/arbitrary/stringMatching.js
var safeStringFromCodePoint3, wordChars, digitChars, spaceChars, newLineChars, terminatorChars, newLineAndTerminatorChars, defaultChar;
var init_stringMatching = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/stringMatching.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_globals();
    init_stringify();
    init_SanitizeRegexAst();
    init_TokenizeRegex();
    init_char();
    init_constant();
    init_constantFrom();
    init_integer();
    init_oneof();
    init_stringOf();
    init_tuple();
    safeStringFromCodePoint3 = String.fromCodePoint;
    wordChars = [..."abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"];
    digitChars = [..."0123456789"];
    spaceChars = [..." 	\r\n\v\f"];
    newLineChars = [..."\r\n"];
    terminatorChars = [...""];
    newLineAndTerminatorChars = [...newLineChars, ...terminatorChars];
    defaultChar = char();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ZipIterableIterators.js
var init_ZipIterableIterators = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ZipIterableIterators.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/_internals/LimitedShrinkArbitrary.js
var init_LimitedShrinkArbitrary = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/_internals/LimitedShrinkArbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary();
    init_Value();
    init_Stream();
    init_ZipIterableIterators();
  }
});

// node_modules/fast-check/lib/esm/arbitrary/limitShrink.js
var init_limitShrink = __esm({
  "node_modules/fast-check/lib/esm/arbitrary/limitShrink.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_LimitedShrinkArbitrary();
  }
});

// node_modules/fast-check/lib/esm/fast-check-default.js
var init_fast_check_default = __esm({
  "node_modules/fast-check/lib/esm/fast-check-default.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Pre();
    init_AsyncProperty();
    init_Property();
    init_Runner();
    init_Sampler();
    init_gen();
    init_array2();
    init_bigInt();
    init_bigIntN();
    init_bigUint();
    init_bigUintN();
    init_boolean();
    init_falsy();
    init_ascii();
    init_base64();
    init_char();
    init_char16bits();
    init_fullUnicode();
    init_hexa();
    init_unicode();
    init_constant();
    init_constantFrom();
    init_context();
    init_date();
    init_clone();
    init_dictionary();
    init_emailAddress();
    init_double();
    init_float();
    init_compareBooleanFunc();
    init_compareFunc();
    init_func();
    init_domain();
    init_integer();
    init_maxSafeInteger();
    init_maxSafeNat();
    init_nat();
    init_ipV4();
    init_ipV4Extended();
    init_ipV6();
    init_letrec();
    init_lorem();
    init_mapToConstant();
    init_memo();
    init_mixedCase();
    init_object();
    init_json();
    init_anything();
    init_unicodeJsonValue();
    init_jsonValue();
    init_unicodeJson();
    init_oneof();
    init_option2();
    init_record();
    init_uniqueArray();
    init_infiniteStream();
    init_asciiString();
    init_base64String();
    init_fullUnicodeString();
    init_hexaString();
    init_string();
    init_string16bits();
    init_stringOf();
    init_unicodeString();
    init_subarray();
    init_shuffledSubarray();
    init_tuple();
    init_ulid();
    init_uuid();
    init_uuidV();
    init_webAuthority();
    init_webFragments();
    init_webPath();
    init_webQueryParameters();
    init_webSegment();
    init_webUrl();
    init_commands();
    init_ModelRunner();
    init_Random();
    init_GlobalParameters();
    init_VerbosityLevel();
    init_ExecutionStatus();
    init_symbols();
    init_Stream();
    init_hash();
    init_stringify();
    init_scheduler();
    init_RunDetailsFormatter();
    init_PreconditionFailure();
    init_int8Array();
    init_int16Array();
    init_int32Array();
    init_uint8Array();
    init_uint8ClampedArray();
    init_uint16Array();
    init_uint32Array();
    init_float32Array();
    init_float64Array();
    init_sparseArray();
    init_Arbitrary();
    init_Value();
    init_DepthContext();
    init_bigInt64Array();
    init_bigUint64Array();
    init_stringMatching();
    init_noShrink();
    init_noBias();
    init_limitShrink();
  }
});

// node_modules/fast-check/lib/esm/fast-check.js
var init_fast_check = __esm({
  "node_modules/fast-check/lib/esm/fast-check.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_fast_check_default();
    init_fast_check_default();
  }
});

// node_modules/effect/dist/esm/FastCheck.js
var init_FastCheck = __esm({
  "node_modules/effect/dist/esm/FastCheck.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_fast_check();
  }
});

// node_modules/effect/dist/esm/internal/schema/util.js
var getKeysForIndexSignature, memoizeThunk, isNonEmpty, isSingle, formatPathKey, formatPath;
var init_util = __esm({
  "node_modules/effect/dist/esm/internal/schema/util.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Inspectable();
    getKeysForIndexSignature = /* @__PURE__ */ __name((input, parameter) => {
      switch (parameter._tag) {
        case "StringKeyword":
        case "TemplateLiteral":
          return Object.keys(input);
        case "SymbolKeyword":
          return Object.getOwnPropertySymbols(input);
        case "Refinement":
          return getKeysForIndexSignature(input, parameter.from);
      }
    }, "getKeysForIndexSignature");
    memoizeThunk = /* @__PURE__ */ __name((f) => {
      let done13 = false;
      let a;
      return () => {
        if (done13) {
          return a;
        }
        a = f();
        done13 = true;
        return a;
      };
    }, "memoizeThunk");
    isNonEmpty = /* @__PURE__ */ __name((x) => Array.isArray(x), "isNonEmpty");
    isSingle = /* @__PURE__ */ __name((x) => !Array.isArray(x), "isSingle");
    formatPathKey = /* @__PURE__ */ __name((key) => `[${formatPropertyKey(key)}]`, "formatPathKey");
    formatPath = /* @__PURE__ */ __name((path) => isNonEmpty(path) ? path.map(formatPathKey).join("") : formatPathKey(path), "formatPath");
  }
});

// node_modules/effect/dist/esm/internal/schema/errors.js
var getErrorMessage, getInvalidArgumentErrorMessage, getUnsupportedSchemaErrorMessage, getEquivalenceUnsupportedErrorMessage, getSchemaExtendErrorMessage, getSchemaUnsupportedLiteralSpanErrorMessage, getASTUnsupportedSchemaErrorMessage, getASTUnsupportedKeySchemaErrorMessage, getASTUnsupportedLiteralErrorMessage, getASTDuplicateIndexSignatureErrorMessage, getASTIndexSignatureParameterErrorMessage, getASTRequiredElementFollowinAnOptionalElementErrorMessage, getASTDuplicatePropertySignatureTransformationErrorMessage, getASTUnsupportedRenameSchemaErrorMessage, getASTDuplicatePropertySignatureErrorMessage;
var init_errors2 = __esm({
  "node_modules/effect/dist/esm/internal/schema/errors.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Inspectable();
    init_util();
    getErrorMessage = /* @__PURE__ */ __name((reason, details, path, ast) => {
      let out = reason;
      if (path && isNonEmptyReadonlyArray(path)) {
        out += `
at path: ${formatPath(path)}`;
      }
      if (details !== void 0) {
        out += `
details: ${details}`;
      }
      if (ast) {
        out += `
schema (${ast._tag}): ${ast}`;
      }
      return out;
    }, "getErrorMessage");
    getInvalidArgumentErrorMessage = /* @__PURE__ */ __name((details) => getErrorMessage("Invalid Argument", details), "getInvalidArgumentErrorMessage");
    getUnsupportedSchemaErrorMessage = /* @__PURE__ */ __name((details, path, ast) => getErrorMessage("Unsupported schema", details, path, ast), "getUnsupportedSchemaErrorMessage");
    getEquivalenceUnsupportedErrorMessage = /* @__PURE__ */ __name((ast, path) => getUnsupportedSchemaErrorMessage("Cannot build an Equivalence", path, ast), "getEquivalenceUnsupportedErrorMessage");
    getSchemaExtendErrorMessage = /* @__PURE__ */ __name((x, y, path) => getErrorMessage("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path), "getSchemaExtendErrorMessage");
    getSchemaUnsupportedLiteralSpanErrorMessage = /* @__PURE__ */ __name((ast) => getErrorMessage("Unsupported template literal span", void 0, void 0, ast), "getSchemaUnsupportedLiteralSpanErrorMessage");
    getASTUnsupportedSchemaErrorMessage = /* @__PURE__ */ __name((ast) => getUnsupportedSchemaErrorMessage(void 0, void 0, ast), "getASTUnsupportedSchemaErrorMessage");
    getASTUnsupportedKeySchemaErrorMessage = /* @__PURE__ */ __name((ast) => getErrorMessage("Unsupported key schema", void 0, void 0, ast), "getASTUnsupportedKeySchemaErrorMessage");
    getASTUnsupportedLiteralErrorMessage = /* @__PURE__ */ __name((literal3) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown(literal3)}`), "getASTUnsupportedLiteralErrorMessage");
    getASTDuplicateIndexSignatureErrorMessage = /* @__PURE__ */ __name((type) => getErrorMessage("Duplicate index signature", `${type} index signature`), "getASTDuplicateIndexSignatureErrorMessage");
    getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
    getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
    getASTDuplicatePropertySignatureTransformationErrorMessage = /* @__PURE__ */ __name((key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`), "getASTDuplicatePropertySignatureTransformationErrorMessage");
    getASTUnsupportedRenameSchemaErrorMessage = /* @__PURE__ */ __name((ast) => getUnsupportedSchemaErrorMessage(void 0, void 0, ast), "getASTUnsupportedRenameSchemaErrorMessage");
    getASTDuplicatePropertySignatureErrorMessage = /* @__PURE__ */ __name((key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`), "getASTDuplicatePropertySignatureErrorMessage");
  }
});

// node_modules/effect/dist/esm/internal/schema/schemaId.js
var DateFromSelfSchemaId, GreaterThanSchemaId, GreaterThanOrEqualToSchemaId, LessThanSchemaId, LessThanOrEqualToSchemaId, IntSchemaId, NonNaNSchemaId, FiniteSchemaId, JsonNumberSchemaId, BetweenSchemaId, GreaterThanBigintSchemaId, GreaterThanOrEqualToBigIntSchemaId, LessThanBigIntSchemaId, LessThanOrEqualToBigIntSchemaId, BetweenBigintSchemaId, MinLengthSchemaId, MaxLengthSchemaId, LengthSchemaId, MinItemsSchemaId, MaxItemsSchemaId, ItemsCountSchemaId;
var init_schemaId = __esm({
  "node_modules/effect/dist/esm/internal/schema/schemaId.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    DateFromSelfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");
    GreaterThanSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThan");
    GreaterThanOrEqualToSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanOrEqualTo");
    LessThanSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThan");
    LessThanOrEqualToSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanOrEqualTo");
    IntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Int");
    NonNaNSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/NonNaN");
    FiniteSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Finite");
    JsonNumberSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/JsonNumber");
    BetweenSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Between");
    GreaterThanBigintSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanBigint");
    GreaterThanOrEqualToBigIntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanOrEqualToBigint");
    LessThanBigIntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanBigint");
    LessThanOrEqualToBigIntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanOrEqualToBigint");
    BetweenBigintSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenBigint");
    MinLengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MinLength");
    MaxLengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MaxLength");
    LengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Length");
    MinItemsSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MinItems");
    MaxItemsSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MaxItems");
    ItemsCountSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ItemsCount");
  }
});

// node_modules/effect/dist/esm/Number.js
var Order, clamp3, remainder, nextPow2, parse;
var init_Number = __esm({
  "node_modules/effect/dist/esm/Number.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_option();
    init_Order();
    Order = number3;
    clamp3 = /* @__PURE__ */ clamp(Order);
    remainder = /* @__PURE__ */ dual(2, (dividend, divisor) => {
      const selfDecCount = (dividend.toString().split(".")[1] || "").length;
      const divisorDecCount = (divisor.toString().split(".")[1] || "").length;
      const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;
      const selfInt = parseInt(dividend.toFixed(decCount).replace(".", ""));
      const divisorInt = parseInt(divisor.toFixed(decCount).replace(".", ""));
      return selfInt % divisorInt / Math.pow(10, decCount);
    });
    nextPow2 = /* @__PURE__ */ __name((n) => {
      const nextPow = Math.ceil(Math.log(n) / Math.log(2));
      return Math.max(Math.pow(2, nextPow), 2);
    }, "nextPow2");
    parse = /* @__PURE__ */ __name((s) => {
      if (s === "NaN") {
        return some(NaN);
      }
      if (s === "Infinity") {
        return some(Infinity);
      }
      if (s === "-Infinity") {
        return some(-Infinity);
      }
      if (s.trim() === "") {
        return none;
      }
      const n = Number(s);
      return Number.isNaN(n) ? none : some(n);
    }, "parse");
  }
});

// node_modules/effect/dist/esm/RegExp.js
var escape2;
var init_RegExp = __esm({
  "node_modules/effect/dist/esm/RegExp.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    escape2 = /* @__PURE__ */ __name((string8) => string8.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&"), "escape");
  }
});

// node_modules/effect/dist/esm/SchemaAST.js
function changeMap(as12, f) {
  let changed = false;
  const out = allocate(as12.length);
  for (let i = 0; i < as12.length; i++) {
    const a = as12[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as12;
}
function getBrands(ast) {
  return match2(getBrandAnnotation(ast), {
    onNone: /* @__PURE__ */ __name(() => "", "onNone"),
    onSome: /* @__PURE__ */ __name((brands) => brands.map((brand2) => ` & Brand<${formatUnknown(brand2)}>`).join(""), "onSome")
  });
}
var TypeConstructorAnnotationId, BrandAnnotationId, SchemaIdAnnotationId, MessageAnnotationId, MissingMessageAnnotationId, IdentifierAnnotationId, TitleAnnotationId, AutoTitleAnnotationId, DescriptionAnnotationId, ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId, DocumentationAnnotationId, ConcurrencyAnnotationId, BatchingAnnotationId, ParseIssueTitleAnnotationId, ParseOptionsAnnotationId, DecodingFallbackAnnotationId, SurrogateAnnotationId, StableFilterAnnotationId, getAnnotation, getBrandAnnotation, getMessageAnnotation, getMissingMessageAnnotation, getTitleAnnotation, getAutoTitleAnnotation, getIdentifierAnnotation, getDescriptionAnnotation, getConcurrencyAnnotation, getBatchingAnnotation, getParseIssueTitleAnnotation, getParseOptionsAnnotation, getDecodingFallbackAnnotation, getSurrogateAnnotation, getStableFilterAnnotation, hasStableFilter, JSONIdentifierAnnotationId, getJSONIdentifierAnnotation, getJSONIdentifier, ParseJsonSchemaId, Declaration, createASTGuard, Literal, isLiteral, $null, UniqueSymbol, isUniqueSymbol, UndefinedKeyword, undefinedKeyword, VoidKeyword, voidKeyword, NeverKeyword, neverKeyword, isNeverKeyword, UnknownKeyword, unknownKeyword, AnyKeyword, anyKeyword, StringKeyword, stringKeyword, isStringKeyword, NumberKeyword, numberKeyword, isNumberKeyword, BooleanKeyword, booleanKeyword, isBooleanKeyword, BigIntKeyword, bigIntKeyword, SymbolKeyword, symbolKeyword, isSymbolKeyword, ObjectKeyword, objectKeyword, Enums, isEnums, isTemplateLiteralSpanType, templateLiteralSpanUnionTypeToString, templateLiteralSpanTypeToString, TemplateLiteralSpan, TemplateLiteral, formatTemplateLiteral, isTemplateLiteral, Type, OptionalType, getRestASTs, TupleType, formatTuple, PropertySignature, isParameter, IndexSignature, TypeLiteral, formatIndexSignatures, formatTypeLiteral, isTypeLiteral, sortCandidates, literalMap, flatten3, unify, Union, mapMembers, isMembers, isUnion, toJSONMemoMap, Suspend, Refinement, isRefinement, defaultParseOption, Transformation, isTransformation, FinalTransformation, createTransformationGuard, ComposeTransformation, composeTransformation, PropertySignatureTransformation, isRenamingPropertySignatureTransformation, TypeLiteralTransformation, isTypeLiteralTransformation, annotations, keyof, STRING_KEYWORD_PATTERN, NUMBER_KEYWORD_PATTERN, getTemplateLiteralSpanTypePattern, handleTemplateLiteralSpanTypeParens, getTemplateLiteralPattern, getTemplateLiteralRegExp, getTemplateLiteralCapturingRegExp, getIndexSignatures, getNumberIndexedAccess, getTypeLiteralPropertySignature, getPropertyKeyIndexedAccess, getPropertyKeys, record2, pick, omit, orUndefined, partial, required, mutable, pickAnnotations, omitAnnotations, preserveTransformationAnnotations, typeAST, getTransformationFrom, encodedAST_, encodedAST, encodedBoundAST, toJSONAnnotations, getEncodedParameter, equals2, equalsTemplateLiteralSpan, equalsEnums, equalsUnion, intersection2, _keyof, compose, rename, formatKeyword, getOrElseExpected, getExpected, pruneUndefined;
var init_SchemaAST = __esm({
  "node_modules/effect/dist/esm/SchemaAST.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Function();
    init_GlobalValue();
    init_Inspectable();
    init_errors2();
    init_util();
    init_Number();
    init_Option();
    init_Order();
    init_Predicate();
    init_RegExp();
    TypeConstructorAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/TypeConstructor");
    BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
    SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
    MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
    MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
    IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
    TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
    AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
    DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
    ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
    DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
    JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
    ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
    PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
    EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
    DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
    ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
    BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
    ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
    ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
    DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
    SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
    StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
    getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
    getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
    getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
    getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
    getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
    getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
    getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
    getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
    getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
    getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
    getParseIssueTitleAnnotation = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
    getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
    getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
    getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
    getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
    hasStableFilter = /* @__PURE__ */ __name((annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true), "hasStableFilter");
    JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
    getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
    getJSONIdentifier = /* @__PURE__ */ __name((annotated) => orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated)), "getJSONIdentifier");
    ParseJsonSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/ParseJson");
    Declaration = class {
      static {
        __name(this, "Declaration");
      }
      typeParameters;
      decodeUnknown;
      encodeUnknown;
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "Declaration";
      constructor(typeParameters, decodeUnknown3, encodeUnknown3, annotations3 = {}) {
        this.typeParameters = typeParameters;
        this.decodeUnknown = decodeUnknown3;
        this.encodeUnknown = encodeUnknown3;
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return getOrElse(getExpected(this), () => "<declaration schema>");
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    createASTGuard = /* @__PURE__ */ __name((tag2) => (ast) => ast._tag === tag2, "createASTGuard");
    Literal = class {
      static {
        __name(this, "Literal");
      }
      literal;
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "Literal";
      constructor(literal3, annotations3 = {}) {
        this.literal = literal3;
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return getOrElse(getExpected(this), () => formatUnknown(this.literal));
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    isLiteral = /* @__PURE__ */ createASTGuard("Literal");
    $null = /* @__PURE__ */ new Literal(null);
    UniqueSymbol = class {
      static {
        __name(this, "UniqueSymbol");
      }
      symbol;
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "UniqueSymbol";
      constructor(symbol4, annotations3 = {}) {
        this.symbol = symbol4;
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return getOrElse(getExpected(this), () => formatUnknown(this.symbol));
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          symbol: String(this.symbol),
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    isUniqueSymbol = /* @__PURE__ */ createASTGuard("UniqueSymbol");
    UndefinedKeyword = class {
      static {
        __name(this, "UndefinedKeyword");
      }
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "UndefinedKeyword";
      constructor(annotations3 = {}) {
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return formatKeyword(this);
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({
      [TitleAnnotationId]: "undefined"
    });
    VoidKeyword = class {
      static {
        __name(this, "VoidKeyword");
      }
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "VoidKeyword";
      constructor(annotations3 = {}) {
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return formatKeyword(this);
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    voidKeyword = /* @__PURE__ */ new VoidKeyword({
      [TitleAnnotationId]: "void"
    });
    NeverKeyword = class {
      static {
        __name(this, "NeverKeyword");
      }
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "NeverKeyword";
      constructor(annotations3 = {}) {
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return formatKeyword(this);
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    neverKeyword = /* @__PURE__ */ new NeverKeyword({
      [TitleAnnotationId]: "never"
    });
    isNeverKeyword = /* @__PURE__ */ createASTGuard("NeverKeyword");
    UnknownKeyword = class {
      static {
        __name(this, "UnknownKeyword");
      }
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "UnknownKeyword";
      constructor(annotations3 = {}) {
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return formatKeyword(this);
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    unknownKeyword = /* @__PURE__ */ new UnknownKeyword({
      [TitleAnnotationId]: "unknown"
    });
    AnyKeyword = class {
      static {
        __name(this, "AnyKeyword");
      }
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "AnyKeyword";
      constructor(annotations3 = {}) {
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return formatKeyword(this);
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    anyKeyword = /* @__PURE__ */ new AnyKeyword({
      [TitleAnnotationId]: "any"
    });
    StringKeyword = class {
      static {
        __name(this, "StringKeyword");
      }
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "StringKeyword";
      constructor(annotations3 = {}) {
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return formatKeyword(this);
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    stringKeyword = /* @__PURE__ */ new StringKeyword({
      [TitleAnnotationId]: "string",
      [DescriptionAnnotationId]: "a string"
    });
    isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");
    NumberKeyword = class {
      static {
        __name(this, "NumberKeyword");
      }
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "NumberKeyword";
      constructor(annotations3 = {}) {
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return formatKeyword(this);
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    numberKeyword = /* @__PURE__ */ new NumberKeyword({
      [TitleAnnotationId]: "number",
      [DescriptionAnnotationId]: "a number"
    });
    isNumberKeyword = /* @__PURE__ */ createASTGuard("NumberKeyword");
    BooleanKeyword = class {
      static {
        __name(this, "BooleanKeyword");
      }
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "BooleanKeyword";
      constructor(annotations3 = {}) {
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return formatKeyword(this);
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
      [TitleAnnotationId]: "boolean",
      [DescriptionAnnotationId]: "a boolean"
    });
    isBooleanKeyword = /* @__PURE__ */ createASTGuard("BooleanKeyword");
    BigIntKeyword = class {
      static {
        __name(this, "BigIntKeyword");
      }
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "BigIntKeyword";
      constructor(annotations3 = {}) {
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return formatKeyword(this);
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    bigIntKeyword = /* @__PURE__ */ new BigIntKeyword({
      [TitleAnnotationId]: "bigint",
      [DescriptionAnnotationId]: "a bigint"
    });
    SymbolKeyword = class {
      static {
        __name(this, "SymbolKeyword");
      }
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "SymbolKeyword";
      constructor(annotations3 = {}) {
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return formatKeyword(this);
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    symbolKeyword = /* @__PURE__ */ new SymbolKeyword({
      [TitleAnnotationId]: "symbol",
      [DescriptionAnnotationId]: "a symbol"
    });
    isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");
    ObjectKeyword = class {
      static {
        __name(this, "ObjectKeyword");
      }
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "ObjectKeyword";
      constructor(annotations3 = {}) {
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return formatKeyword(this);
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    objectKeyword = /* @__PURE__ */ new ObjectKeyword({
      [TitleAnnotationId]: "object",
      [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
    });
    Enums = class {
      static {
        __name(this, "Enums");
      }
      enums;
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "Enums";
      constructor(enums, annotations3 = {}) {
        this.enums = enums;
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return getOrElse(getExpected(this), () => `<enum ${this.enums.length} value(s): ${this.enums.map(([_, value3]) => JSON.stringify(value3)).join(" | ")}>`);
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          enums: this.enums,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    isEnums = /* @__PURE__ */ createASTGuard("Enums");
    isTemplateLiteralSpanType = /* @__PURE__ */ __name((ast) => {
      switch (ast._tag) {
        case "Literal":
        case "NumberKeyword":
        case "StringKeyword":
        case "TemplateLiteral":
          return true;
        case "Union":
          return ast.types.every(isTemplateLiteralSpanType);
      }
      return false;
    }, "isTemplateLiteralSpanType");
    templateLiteralSpanUnionTypeToString = /* @__PURE__ */ __name((type) => {
      switch (type._tag) {
        case "Literal":
          return JSON.stringify(String(type.literal));
        case "StringKeyword":
          return "string";
        case "NumberKeyword":
          return "number";
        case "TemplateLiteral":
          return String(type);
        case "Union":
          return type.types.map(templateLiteralSpanUnionTypeToString).join(" | ");
      }
    }, "templateLiteralSpanUnionTypeToString");
    templateLiteralSpanTypeToString = /* @__PURE__ */ __name((type) => {
      switch (type._tag) {
        case "Literal":
          return String(type.literal);
        case "StringKeyword":
          return "${string}";
        case "NumberKeyword":
          return "${number}";
        case "TemplateLiteral":
          return "${" + String(type) + "}";
        case "Union":
          return "${" + type.types.map(templateLiteralSpanUnionTypeToString).join(" | ") + "}";
      }
    }, "templateLiteralSpanTypeToString");
    TemplateLiteralSpan = class {
      static {
        __name(this, "TemplateLiteralSpan");
      }
      literal;
      /**
       * @since 3.10.0
       */
      type;
      constructor(type, literal3) {
        this.literal = literal3;
        if (isTemplateLiteralSpanType(type)) {
          this.type = type;
        } else {
          throw new Error(getSchemaUnsupportedLiteralSpanErrorMessage(type));
        }
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return templateLiteralSpanTypeToString(this.type) + this.literal;
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          type: this.type.toJSON(),
          literal: this.literal
        };
      }
    };
    TemplateLiteral = class {
      static {
        __name(this, "TemplateLiteral");
      }
      head;
      spans;
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "TemplateLiteral";
      constructor(head7, spans, annotations3 = {}) {
        this.head = head7;
        this.spans = spans;
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return getOrElse(getExpected(this), () => formatTemplateLiteral(this));
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          head: this.head,
          spans: this.spans.map((span4) => span4.toJSON()),
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    formatTemplateLiteral = /* @__PURE__ */ __name((ast) => "`" + ast.head + ast.spans.map(String).join("") + "`", "formatTemplateLiteral");
    isTemplateLiteral = /* @__PURE__ */ createASTGuard("TemplateLiteral");
    Type = class {
      static {
        __name(this, "Type");
      }
      type;
      annotations;
      constructor(type, annotations3 = {}) {
        this.type = type;
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          type: this.type.toJSON(),
          annotations: toJSONAnnotations(this.annotations)
        };
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return String(this.type);
      }
    };
    OptionalType = class extends Type {
      static {
        __name(this, "OptionalType");
      }
      isOptional;
      constructor(type, isOptional, annotations3 = {}) {
        super(type, annotations3);
        this.isOptional = isOptional;
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          type: this.type.toJSON(),
          isOptional: this.isOptional,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return String(this.type) + (this.isOptional ? "?" : "");
      }
    };
    getRestASTs = /* @__PURE__ */ __name((rest) => rest.map((annotatedAST) => annotatedAST.type), "getRestASTs");
    TupleType = class {
      static {
        __name(this, "TupleType");
      }
      elements;
      rest;
      isReadonly;
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "TupleType";
      constructor(elements, rest, isReadonly, annotations3 = {}) {
        this.elements = elements;
        this.rest = rest;
        this.isReadonly = isReadonly;
        this.annotations = annotations3;
        let hasOptionalElement = false;
        let hasIllegalRequiredElement = false;
        for (const e of elements) {
          if (e.isOptional) {
            hasOptionalElement = true;
          } else if (hasOptionalElement) {
            hasIllegalRequiredElement = true;
            break;
          }
        }
        if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
          throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
        }
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return getOrElse(getExpected(this), () => formatTuple(this));
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          elements: this.elements.map((e) => e.toJSON()),
          rest: this.rest.map((ast) => ast.toJSON()),
          isReadonly: this.isReadonly,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    formatTuple = /* @__PURE__ */ __name((ast) => {
      const formattedElements = ast.elements.map(String).join(", ");
      return matchLeft(ast.rest, {
        onEmpty: /* @__PURE__ */ __name(() => `readonly [${formattedElements}]`, "onEmpty"),
        onNonEmpty: /* @__PURE__ */ __name((head7, tail) => {
          const formattedHead = String(head7);
          const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
          if (tail.length > 0) {
            const formattedTail = tail.map(String).join(", ");
            if (ast.elements.length > 0) {
              return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
            } else {
              return `readonly [...${wrappedHead}[], ${formattedTail}]`;
            }
          } else {
            if (ast.elements.length > 0) {
              return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
            } else {
              return `ReadonlyArray<${formattedHead}>`;
            }
          }
        }, "onNonEmpty")
      });
    }, "formatTuple");
    PropertySignature = class extends OptionalType {
      static {
        __name(this, "PropertySignature");
      }
      name;
      isReadonly;
      constructor(name, type, isOptional, isReadonly, annotations3) {
        super(type, isOptional, annotations3);
        this.name = name;
        this.isReadonly = isReadonly;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          name: String(this.name),
          type: this.type.toJSON(),
          isOptional: this.isOptional,
          isReadonly: this.isReadonly,
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    isParameter = /* @__PURE__ */ __name((ast) => {
      switch (ast._tag) {
        case "StringKeyword":
        case "SymbolKeyword":
        case "TemplateLiteral":
          return true;
        case "Refinement":
          return isParameter(ast.from);
      }
      return false;
    }, "isParameter");
    IndexSignature = class {
      static {
        __name(this, "IndexSignature");
      }
      type;
      isReadonly;
      /**
       * @since 3.10.0
       */
      parameter;
      constructor(parameter, type, isReadonly) {
        this.type = type;
        this.isReadonly = isReadonly;
        if (isParameter(parameter)) {
          this.parameter = parameter;
        } else {
          throw new Error(getASTIndexSignatureParameterErrorMessage);
        }
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          parameter: this.parameter.toJSON(),
          type: this.type.toJSON(),
          isReadonly: this.isReadonly
        };
      }
    };
    TypeLiteral = class {
      static {
        __name(this, "TypeLiteral");
      }
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "TypeLiteral";
      /**
       * @since 3.10.0
       */
      propertySignatures;
      /**
       * @since 3.10.0
       */
      indexSignatures;
      constructor(propertySignatures, indexSignatures, annotations3 = {}) {
        this.annotations = annotations3;
        const keys5 = {};
        for (let i = 0; i < propertySignatures.length; i++) {
          const name = propertySignatures[i].name;
          if (Object.prototype.hasOwnProperty.call(keys5, name)) {
            throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
          }
          keys5[name] = null;
        }
        const parameters = {
          string: false,
          symbol: false
        };
        for (let i = 0; i < indexSignatures.length; i++) {
          const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
          if (isStringKeyword(encodedParameter)) {
            if (parameters.string) {
              throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
            }
            parameters.string = true;
          } else if (isSymbolKeyword(encodedParameter)) {
            if (parameters.symbol) {
              throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
            }
            parameters.symbol = true;
          }
        }
        this.propertySignatures = propertySignatures;
        this.indexSignatures = indexSignatures;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return getOrElse(getExpected(this), () => formatTypeLiteral(this));
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
          indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    formatIndexSignatures = /* @__PURE__ */ __name((iss) => iss.map(String).join("; "), "formatIndexSignatures");
    formatTypeLiteral = /* @__PURE__ */ __name((ast) => {
      if (ast.propertySignatures.length > 0) {
        const pss = ast.propertySignatures.map(String).join("; ");
        if (ast.indexSignatures.length > 0) {
          return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
        } else {
          return `{ ${pss} }`;
        }
      } else {
        if (ast.indexSignatures.length > 0) {
          return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
        } else {
          return "{}";
        }
      }
    }, "formatTypeLiteral");
    isTypeLiteral = /* @__PURE__ */ createASTGuard("TypeLiteral");
    sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order, (ast) => {
      switch (ast._tag) {
        case "AnyKeyword":
          return 0;
        case "UnknownKeyword":
          return 1;
        case "ObjectKeyword":
          return 2;
        case "StringKeyword":
        case "NumberKeyword":
        case "BooleanKeyword":
        case "BigIntKeyword":
        case "SymbolKeyword":
          return 3;
      }
      return 4;
    }));
    literalMap = {
      string: "StringKeyword",
      number: "NumberKeyword",
      boolean: "BooleanKeyword",
      bigint: "BigIntKeyword"
    };
    flatten3 = /* @__PURE__ */ __name((candidates) => flatMap2(candidates, (ast) => isUnion(ast) ? flatten3(ast.types) : [ast]), "flatten");
    unify = /* @__PURE__ */ __name((candidates) => {
      const cs = sortCandidates(candidates);
      const out = [];
      const uniques = {};
      const literals = [];
      for (const ast of cs) {
        switch (ast._tag) {
          case "NeverKeyword":
            break;
          case "AnyKeyword":
            return [anyKeyword];
          case "UnknownKeyword":
            return [unknownKeyword];
          // uniques
          case "ObjectKeyword":
          case "UndefinedKeyword":
          case "VoidKeyword":
          case "StringKeyword":
          case "NumberKeyword":
          case "BooleanKeyword":
          case "BigIntKeyword":
          case "SymbolKeyword": {
            if (!uniques[ast._tag]) {
              uniques[ast._tag] = ast;
              out.push(ast);
            }
            break;
          }
          case "Literal": {
            const type = typeof ast.literal;
            switch (type) {
              case "string":
              case "number":
              case "bigint":
              case "boolean": {
                const _tag = literalMap[type];
                if (!uniques[_tag] && !literals.includes(ast.literal)) {
                  literals.push(ast.literal);
                  out.push(ast);
                }
                break;
              }
              // null
              case "object": {
                if (!literals.includes(ast.literal)) {
                  literals.push(ast.literal);
                  out.push(ast);
                }
                break;
              }
            }
            break;
          }
          case "UniqueSymbol": {
            if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
              literals.push(ast.symbol);
              out.push(ast);
            }
            break;
          }
          case "TupleType": {
            if (!uniques["ObjectKeyword"]) {
              out.push(ast);
            }
            break;
          }
          case "TypeLiteral": {
            if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
              if (!uniques["{}"]) {
                uniques["{}"] = ast;
                out.push(ast);
              }
            } else if (!uniques["ObjectKeyword"]) {
              out.push(ast);
            }
            break;
          }
          default:
            out.push(ast);
        }
      }
      return out;
    }, "unify");
    Union = class _Union {
      static {
        __name(this, "Union");
      }
      types;
      annotations;
      static make = /* @__PURE__ */ __name((types, annotations3) => {
        return isMembers(types) ? new _Union(types, annotations3) : types.length === 1 ? types[0] : neverKeyword;
      }, "make");
      /** @internal */
      static unify = /* @__PURE__ */ __name((candidates, annotations3) => {
        return _Union.make(unify(flatten3(candidates)), annotations3);
      }, "unify");
      /**
       * @since 3.10.0
       */
      _tag = "Union";
      constructor(types, annotations3 = {}) {
        this.types = types;
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return getOrElse(getExpected(this), () => this.types.map(String).join(" | "));
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          types: this.types.map((ast) => ast.toJSON()),
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    mapMembers = /* @__PURE__ */ __name((members, f) => members.map(f), "mapMembers");
    isMembers = /* @__PURE__ */ __name((as12) => as12.length > 1, "isMembers");
    isUnion = /* @__PURE__ */ createASTGuard("Union");
    toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => /* @__PURE__ */ new WeakMap());
    Suspend = class {
      static {
        __name(this, "Suspend");
      }
      f;
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "Suspend";
      constructor(f, annotations3 = {}) {
        this.f = f;
        this.annotations = annotations3;
        this.f = memoizeThunk(f);
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return getExpected(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse(() => "<suspended schema>"));
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        const ast = this.f();
        let out = toJSONMemoMap.get(ast);
        if (out) {
          return out;
        }
        toJSONMemoMap.set(ast, {
          _tag: this._tag
        });
        out = {
          _tag: this._tag,
          ast: ast.toJSON(),
          annotations: toJSONAnnotations(this.annotations)
        };
        toJSONMemoMap.set(ast, out);
        return out;
      }
    };
    Refinement = class {
      static {
        __name(this, "Refinement");
      }
      from;
      filter;
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "Refinement";
      constructor(from2, filter14, annotations3 = {}) {
        this.from = from2;
        this.filter = filter14;
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return getIdentifierAnnotation(this).pipe(getOrElse(() => match2(getOrElseExpected(this), {
          onNone: /* @__PURE__ */ __name(() => `{ ${this.from} | filter }`, "onNone"),
          onSome: /* @__PURE__ */ __name((expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected, "onSome")
        })));
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          from: this.from.toJSON(),
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    isRefinement = /* @__PURE__ */ createASTGuard("Refinement");
    defaultParseOption = {};
    Transformation = class {
      static {
        __name(this, "Transformation");
      }
      from;
      to;
      transformation;
      annotations;
      /**
       * @since 3.10.0
       */
      _tag = "Transformation";
      constructor(from2, to, transformation, annotations3 = {}) {
        this.from = from2;
        this.to = to;
        this.transformation = transformation;
        this.annotations = annotations3;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return getOrElse(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _tag: this._tag,
          from: this.from.toJSON(),
          to: this.to.toJSON(),
          annotations: toJSONAnnotations(this.annotations)
        };
      }
    };
    isTransformation = /* @__PURE__ */ createASTGuard("Transformation");
    FinalTransformation = class {
      static {
        __name(this, "FinalTransformation");
      }
      decode;
      encode;
      /**
       * @since 3.10.0
       */
      _tag = "FinalTransformation";
      constructor(decode8, encode7) {
        this.decode = decode8;
        this.encode = encode7;
      }
    };
    createTransformationGuard = /* @__PURE__ */ __name((tag2) => (ast) => ast._tag === tag2, "createTransformationGuard");
    ComposeTransformation = class {
      static {
        __name(this, "ComposeTransformation");
      }
      /**
       * @since 3.10.0
       */
      _tag = "ComposeTransformation";
    };
    composeTransformation = /* @__PURE__ */ new ComposeTransformation();
    PropertySignatureTransformation = class {
      static {
        __name(this, "PropertySignatureTransformation");
      }
      from;
      to;
      decode;
      encode;
      constructor(from2, to, decode8, encode7) {
        this.from = from2;
        this.to = to;
        this.decode = decode8;
        this.encode = encode7;
      }
    };
    isRenamingPropertySignatureTransformation = /* @__PURE__ */ __name((t) => t.decode === identity && t.encode === identity, "isRenamingPropertySignatureTransformation");
    TypeLiteralTransformation = class {
      static {
        __name(this, "TypeLiteralTransformation");
      }
      propertySignatureTransformations;
      /**
       * @since 3.10.0
       */
      _tag = "TypeLiteralTransformation";
      constructor(propertySignatureTransformations) {
        this.propertySignatureTransformations = propertySignatureTransformations;
        const fromKeys = {};
        const toKeys = {};
        for (const pst of propertySignatureTransformations) {
          const from2 = pst.from;
          if (fromKeys[from2]) {
            throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from2));
          }
          fromKeys[from2] = true;
          const to = pst.to;
          if (toKeys[to]) {
            throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
          }
          toKeys[to] = true;
        }
      }
    };
    isTypeLiteralTransformation = /* @__PURE__ */ createTransformationGuard("TypeLiteralTransformation");
    annotations = /* @__PURE__ */ __name((ast, overrides) => {
      const d = Object.getOwnPropertyDescriptors(ast);
      const base = {
        ...ast.annotations
      };
      delete base[IdentifierAnnotationId];
      const value3 = {
        ...base,
        ...overrides
      };
      const surrogate = getSurrogateAnnotation(ast);
      if (isSome2(surrogate)) {
        value3[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
      }
      d.annotations.value = value3;
      return Object.create(Object.getPrototypeOf(ast), d);
    }, "annotations");
    keyof = /* @__PURE__ */ __name((ast) => Union.unify(_keyof(ast)), "keyof");
    STRING_KEYWORD_PATTERN = "[\\s\\S]*?";
    NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
    getTemplateLiteralSpanTypePattern = /* @__PURE__ */ __name((type, capture2) => {
      switch (type._tag) {
        case "Literal":
          return escape2(String(type.literal));
        case "StringKeyword":
          return STRING_KEYWORD_PATTERN;
        case "NumberKeyword":
          return NUMBER_KEYWORD_PATTERN;
        case "TemplateLiteral":
          return getTemplateLiteralPattern(type, capture2, false);
        case "Union":
          return type.types.map((type2) => getTemplateLiteralSpanTypePattern(type2, capture2)).join("|");
      }
    }, "getTemplateLiteralSpanTypePattern");
    handleTemplateLiteralSpanTypeParens = /* @__PURE__ */ __name((type, s, capture2, top) => {
      if (isUnion(type)) {
        if (capture2 && !top) {
          return `(?:${s})`;
        }
      } else if (!capture2 || !top) {
        return s;
      }
      return `(${s})`;
    }, "handleTemplateLiteralSpanTypeParens");
    getTemplateLiteralPattern = /* @__PURE__ */ __name((ast, capture2, top) => {
      let pattern2 = ``;
      if (ast.head !== "") {
        const head7 = escape2(ast.head);
        pattern2 += capture2 && top ? `(${head7})` : head7;
      }
      for (const span4 of ast.spans) {
        const spanPattern = getTemplateLiteralSpanTypePattern(span4.type, capture2);
        pattern2 += handleTemplateLiteralSpanTypeParens(span4.type, spanPattern, capture2, top);
        if (span4.literal !== "") {
          const literal3 = escape2(span4.literal);
          pattern2 += capture2 && top ? `(${literal3})` : literal3;
        }
      }
      return pattern2;
    }, "getTemplateLiteralPattern");
    getTemplateLiteralRegExp = /* @__PURE__ */ __name((ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`), "getTemplateLiteralRegExp");
    getTemplateLiteralCapturingRegExp = /* @__PURE__ */ __name((ast) => new RegExp(`^${getTemplateLiteralPattern(ast, true, true)}$`), "getTemplateLiteralCapturingRegExp");
    getIndexSignatures = /* @__PURE__ */ __name((ast) => {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getIndexSignatures(annotation.value);
      }
      switch (ast._tag) {
        case "TypeLiteral":
          return ast.indexSignatures.slice();
        case "Suspend":
          return getIndexSignatures(ast.f());
        case "Refinement":
          return getIndexSignatures(ast.from);
      }
      return [];
    }, "getIndexSignatures");
    getNumberIndexedAccess = /* @__PURE__ */ __name((ast) => {
      switch (ast._tag) {
        case "TupleType": {
          let hasOptional = false;
          let out = [];
          for (const e of ast.elements) {
            if (e.isOptional) {
              hasOptional = true;
            }
            out.push(e.type);
          }
          if (hasOptional) {
            out.push(undefinedKeyword);
          }
          out = out.concat(getRestASTs(ast.rest));
          return Union.make(out);
        }
        case "Refinement":
          return getNumberIndexedAccess(ast.from);
        case "Union":
          return Union.make(ast.types.map(getNumberIndexedAccess));
        case "Suspend":
          return getNumberIndexedAccess(ast.f());
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }, "getNumberIndexedAccess");
    getTypeLiteralPropertySignature = /* @__PURE__ */ __name((ast, name) => {
      const ops = findFirst2(ast.propertySignatures, (ps) => ps.name === name);
      if (isSome2(ops)) {
        return ops.value;
      }
      if (isString(name)) {
        let out = void 0;
        for (const is3 of ast.indexSignatures) {
          const encodedParameter = getEncodedParameter(is3.parameter);
          switch (encodedParameter._tag) {
            case "TemplateLiteral": {
              const regex = getTemplateLiteralRegExp(encodedParameter);
              if (regex.test(name)) {
                return new PropertySignature(name, is3.type, false, true);
              }
              break;
            }
            case "StringKeyword": {
              if (out === void 0) {
                out = new PropertySignature(name, is3.type, false, true);
              }
            }
          }
        }
        if (out) {
          return out;
        }
      } else if (isSymbol(name)) {
        for (const is3 of ast.indexSignatures) {
          const encodedParameter = getEncodedParameter(is3.parameter);
          if (isSymbolKeyword(encodedParameter)) {
            return new PropertySignature(name, is3.type, false, true);
          }
        }
      }
    }, "getTypeLiteralPropertySignature");
    getPropertyKeyIndexedAccess = /* @__PURE__ */ __name((ast, name) => {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getPropertyKeyIndexedAccess(annotation.value, name);
      }
      switch (ast._tag) {
        case "TypeLiteral": {
          const ps = getTypeLiteralPropertySignature(ast, name);
          if (ps) {
            return ps;
          }
          break;
        }
        case "Union":
          return new PropertySignature(name, Union.make(ast.types.map((ast2) => getPropertyKeyIndexedAccess(ast2, name).type)), false, true);
        case "Suspend":
          return getPropertyKeyIndexedAccess(ast.f(), name);
        case "Refinement":
          return getPropertyKeyIndexedAccess(ast.from, name);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }, "getPropertyKeyIndexedAccess");
    getPropertyKeys = /* @__PURE__ */ __name((ast) => {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getPropertyKeys(annotation.value);
      }
      switch (ast._tag) {
        case "TypeLiteral":
          return ast.propertySignatures.map((ps) => ps.name);
        case "Union":
          return ast.types.slice(1).reduce((out, ast2) => intersection(out, getPropertyKeys(ast2)), getPropertyKeys(ast.types[0]));
        case "Suspend":
          return getPropertyKeys(ast.f());
        case "Refinement":
          return getPropertyKeys(ast.from);
        case "Transformation":
          return getPropertyKeys(ast.to);
      }
      return [];
    }, "getPropertyKeys");
    record2 = /* @__PURE__ */ __name((key, value3) => {
      const propertySignatures = [];
      const indexSignatures = [];
      const go3 = /* @__PURE__ */ __name((key2) => {
        switch (key2._tag) {
          case "NeverKeyword":
            break;
          case "StringKeyword":
          case "SymbolKeyword":
          case "TemplateLiteral":
          case "Refinement":
            indexSignatures.push(new IndexSignature(key2, value3, true));
            break;
          case "Literal":
            if (isString(key2.literal) || isNumber(key2.literal)) {
              propertySignatures.push(new PropertySignature(key2.literal, value3, false, true));
            } else {
              throw new Error(getASTUnsupportedLiteralErrorMessage(key2.literal));
            }
            break;
          case "Enums": {
            for (const [_, name] of key2.enums) {
              propertySignatures.push(new PropertySignature(name, value3, false, true));
            }
            break;
          }
          case "UniqueSymbol":
            propertySignatures.push(new PropertySignature(key2.symbol, value3, false, true));
            break;
          case "Union":
            key2.types.forEach(go3);
            break;
          default:
            throw new Error(getASTUnsupportedKeySchemaErrorMessage(key2));
        }
      }, "go");
      go3(key);
      return {
        propertySignatures,
        indexSignatures
      };
    }, "record");
    pick = /* @__PURE__ */ __name((ast, keys5) => {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return pick(annotation.value, keys5);
      }
      switch (ast._tag) {
        case "TypeLiteral": {
          const pss = [];
          const names = {};
          for (const ps of ast.propertySignatures) {
            names[ps.name] = null;
            if (keys5.includes(ps.name)) {
              pss.push(ps);
            }
          }
          for (const key of keys5) {
            if (!(key in names)) {
              const ps = getTypeLiteralPropertySignature(ast, key);
              if (ps) {
                pss.push(ps);
              }
            }
          }
          return new TypeLiteral(pss, []);
        }
        case "Union":
          return new TypeLiteral(keys5.map((name) => getPropertyKeyIndexedAccess(ast, name)), []);
        case "Suspend":
          return pick(ast.f(), keys5);
        case "Refinement":
          return pick(ast.from, keys5);
        case "Transformation": {
          switch (ast.transformation._tag) {
            case "ComposeTransformation":
              return new Transformation(pick(ast.from, keys5), pick(ast.to, keys5), composeTransformation);
            case "TypeLiteralTransformation": {
              const ts = [];
              const fromKeys = [];
              for (const k of keys5) {
                const t = ast.transformation.propertySignatureTransformations.find((t2) => t2.to === k);
                if (t) {
                  ts.push(t);
                  fromKeys.push(t.from);
                } else {
                  fromKeys.push(k);
                }
              }
              return isNonEmptyReadonlyArray(ts) ? new Transformation(pick(ast.from, fromKeys), pick(ast.to, keys5), new TypeLiteralTransformation(ts)) : pick(ast.from, fromKeys);
            }
          }
        }
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }, "pick");
    omit = /* @__PURE__ */ __name((ast, keys5) => {
      let indexSignatures = getIndexSignatures(ast);
      if (indexSignatures.length > 0) {
        if (indexSignatures.some((is3) => isStringKeyword(getEncodedParameter(is3.parameter)))) {
          indexSignatures = indexSignatures.filter((is3) => !isTemplateLiteral(getEncodedParameter(is3.parameter)));
        }
        return new TypeLiteral([], indexSignatures);
      }
      return pick(ast, getPropertyKeys(ast).filter((name) => !keys5.includes(name)));
    }, "omit");
    orUndefined = /* @__PURE__ */ __name((ast) => Union.make([ast, undefinedKeyword]), "orUndefined");
    partial = /* @__PURE__ */ __name((ast, options) => {
      const exact = options?.exact === true;
      switch (ast._tag) {
        case "TupleType":
          return new TupleType(ast.elements.map((e) => new OptionalType(exact ? e.type : orUndefined(e.type), true)), match3(ast.rest, {
            onEmpty: /* @__PURE__ */ __name(() => ast.rest, "onEmpty"),
            onNonEmpty: /* @__PURE__ */ __name((rest) => [new Type(Union.make([...getRestASTs(rest), undefinedKeyword]))], "onNonEmpty")
          }), ast.isReadonly);
        case "TypeLiteral":
          return new TypeLiteral(ast.propertySignatures.map((ps) => new PropertySignature(ps.name, exact ? ps.type : orUndefined(ps.type), true, ps.isReadonly, ps.annotations)), ast.indexSignatures.map((is3) => new IndexSignature(is3.parameter, orUndefined(is3.type), is3.isReadonly)));
        case "Union":
          return Union.make(ast.types.map((member) => partial(member, options)));
        case "Suspend":
          return new Suspend(() => partial(ast.f(), options));
        case "Declaration":
        case "Refinement":
          throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
        case "Transformation": {
          if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
            return new Transformation(partial(ast.from, options), partial(ast.to, options), ast.transformation);
          }
          throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
        }
      }
      return ast;
    }, "partial");
    required = /* @__PURE__ */ __name((ast) => {
      switch (ast._tag) {
        case "TupleType":
          return new TupleType(ast.elements.map((e) => new OptionalType(e.type, false)), ast.rest, ast.isReadonly);
        case "TypeLiteral":
          return new TypeLiteral(ast.propertySignatures.map((f) => new PropertySignature(f.name, f.type, false, f.isReadonly, f.annotations)), ast.indexSignatures);
        case "Union":
          return Union.make(ast.types.map((member) => required(member)));
        case "Suspend":
          return new Suspend(() => required(ast.f()));
        case "Declaration":
        case "Refinement":
          throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
        case "Transformation": {
          if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
            return new Transformation(required(ast.from), required(ast.to), ast.transformation);
          }
          throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
        }
      }
      return ast;
    }, "required");
    mutable = /* @__PURE__ */ __name((ast) => {
      switch (ast._tag) {
        case "TupleType":
          return ast.isReadonly === false ? ast : new TupleType(ast.elements, ast.rest, false, ast.annotations);
        case "TypeLiteral": {
          const propertySignatures = changeMap(ast.propertySignatures, (ps) => ps.isReadonly === false ? ps : new PropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations));
          const indexSignatures = changeMap(ast.indexSignatures, (is3) => is3.isReadonly === false ? is3 : new IndexSignature(is3.parameter, is3.type, false));
          return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
        }
        case "Union": {
          const types = changeMap(ast.types, mutable);
          return types === ast.types ? ast : Union.make(types, ast.annotations);
        }
        case "Suspend":
          return new Suspend(() => mutable(ast.f()), ast.annotations);
        case "Refinement": {
          const from2 = mutable(ast.from);
          return from2 === ast.from ? ast : new Refinement(from2, ast.filter, ast.annotations);
        }
        case "Transformation": {
          const from2 = mutable(ast.from);
          const to = mutable(ast.to);
          return from2 === ast.from && to === ast.to ? ast : new Transformation(from2, to, ast.transformation, ast.annotations);
        }
      }
      return ast;
    }, "mutable");
    pickAnnotations = /* @__PURE__ */ __name((annotationIds) => (annotated) => {
      let out = void 0;
      for (const id2 of annotationIds) {
        if (Object.prototype.hasOwnProperty.call(annotated.annotations, id2)) {
          if (out === void 0) {
            out = {};
          }
          out[id2] = annotated.annotations[id2];
        }
      }
      return out;
    }, "pickAnnotations");
    omitAnnotations = /* @__PURE__ */ __name((annotationIds) => (annotated) => {
      const out = {
        ...annotated.annotations
      };
      for (const id2 of annotationIds) {
        delete out[id2];
      }
      return out;
    }, "omitAnnotations");
    preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
    typeAST = /* @__PURE__ */ __name((ast) => {
      switch (ast._tag) {
        case "Declaration": {
          const typeParameters = changeMap(ast.typeParameters, typeAST);
          return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
        }
        case "TupleType": {
          const elements = changeMap(ast.elements, (e) => {
            const type = typeAST(e.type);
            return type === e.type ? e : new OptionalType(type, e.isOptional);
          });
          const restASTs = getRestASTs(ast.rest);
          const rest = changeMap(restASTs, typeAST);
          return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type) => new Type(type)), ast.isReadonly, ast.annotations);
        }
        case "TypeLiteral": {
          const propertySignatures = changeMap(ast.propertySignatures, (p) => {
            const type = typeAST(p.type);
            return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
          });
          const indexSignatures = changeMap(ast.indexSignatures, (is3) => {
            const type = typeAST(is3.type);
            return type === is3.type ? is3 : new IndexSignature(is3.parameter, type, is3.isReadonly);
          });
          return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
        }
        case "Union": {
          const types = changeMap(ast.types, typeAST);
          return types === ast.types ? ast : Union.make(types, ast.annotations);
        }
        case "Suspend":
          return new Suspend(() => typeAST(ast.f()), ast.annotations);
        case "Refinement": {
          const from2 = typeAST(ast.from);
          return from2 === ast.from ? ast : new Refinement(from2, ast.filter, ast.annotations);
        }
        case "Transformation": {
          const preserve = preserveTransformationAnnotations(ast);
          return typeAST(preserve !== void 0 ? annotations(ast.to, preserve) : ast.to);
        }
      }
      return ast;
    }, "typeAST");
    __name(changeMap, "changeMap");
    getTransformationFrom = /* @__PURE__ */ __name((ast) => {
      switch (ast._tag) {
        case "Transformation":
          return ast.from;
        case "Refinement":
          return getTransformationFrom(ast.from);
        case "Suspend":
          return getTransformationFrom(ast.f());
      }
    }, "getTransformationFrom");
    encodedAST_ = /* @__PURE__ */ __name((ast, isBound) => {
      switch (ast._tag) {
        case "Declaration": {
          const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
          return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown);
        }
        case "TupleType": {
          const elements = changeMap(ast.elements, (e) => {
            const type = encodedAST_(e.type, isBound);
            return type === e.type ? e : new OptionalType(type, e.isOptional);
          });
          const restASTs = getRestASTs(ast.rest);
          const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
          return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly);
        }
        case "TypeLiteral": {
          const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
            const type = encodedAST_(ps.type, isBound);
            return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
          });
          const indexSignatures = changeMap(ast.indexSignatures, (is3) => {
            const type = encodedAST_(is3.type, isBound);
            return type === is3.type ? is3 : new IndexSignature(is3.parameter, type, is3.isReadonly);
          });
          return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures);
        }
        case "Union": {
          const types = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
          return types === ast.types ? ast : Union.make(types);
        }
        case "Suspend": {
          let borrowedAnnotations = void 0;
          const identifier2 = getJSONIdentifier(ast);
          if (isSome2(identifier2)) {
            const suffix = isBound ? "Bound" : "";
            borrowedAnnotations = {
              [JSONIdentifierAnnotationId]: `${identifier2.value}Encoded${suffix}`
            };
          }
          return new Suspend(() => encodedAST_(ast.f(), isBound), borrowedAnnotations);
        }
        case "Refinement": {
          const from2 = encodedAST_(ast.from, isBound);
          if (isBound) {
            if (from2 === ast.from) return ast;
            if (getTransformationFrom(ast.from) === void 0 && hasStableFilter(ast)) {
              return new Refinement(from2, ast.filter, ast.annotations);
            }
            return from2;
          } else {
            return from2;
          }
        }
        case "Transformation":
          return encodedAST_(ast.from, isBound);
      }
      return ast;
    }, "encodedAST_");
    encodedAST = /* @__PURE__ */ __name((ast) => encodedAST_(ast, false), "encodedAST");
    encodedBoundAST = /* @__PURE__ */ __name((ast) => encodedAST_(ast, true), "encodedBoundAST");
    toJSONAnnotations = /* @__PURE__ */ __name((annotations3) => {
      const out = {};
      for (const k of Object.getOwnPropertySymbols(annotations3)) {
        out[String(k)] = annotations3[k];
      }
      return out;
    }, "toJSONAnnotations");
    getEncodedParameter = /* @__PURE__ */ __name((ast) => {
      switch (ast._tag) {
        case "StringKeyword":
        case "SymbolKeyword":
        case "TemplateLiteral":
          return ast;
        case "Refinement":
          return getEncodedParameter(ast.from);
      }
    }, "getEncodedParameter");
    equals2 = /* @__PURE__ */ __name((self2, that) => {
      switch (self2._tag) {
        case "Literal":
          return isLiteral(that) && that.literal === self2.literal;
        case "UniqueSymbol":
          return isUniqueSymbol(that) && that.symbol === self2.symbol;
        case "UndefinedKeyword":
        case "VoidKeyword":
        case "NeverKeyword":
        case "UnknownKeyword":
        case "AnyKeyword":
        case "StringKeyword":
        case "NumberKeyword":
        case "BooleanKeyword":
        case "BigIntKeyword":
        case "SymbolKeyword":
        case "ObjectKeyword":
          return that._tag === self2._tag;
        case "TemplateLiteral":
          return isTemplateLiteral(that) && that.head === self2.head && equalsTemplateLiteralSpan(that.spans, self2.spans);
        case "Enums":
          return isEnums(that) && equalsEnums(that.enums, self2.enums);
        case "Union":
          return isUnion(that) && equalsUnion(self2.types, that.types);
        case "Refinement":
        case "TupleType":
        case "TypeLiteral":
        case "Suspend":
        case "Transformation":
        case "Declaration":
          return self2 === that;
      }
    }, "equals");
    equalsTemplateLiteralSpan = /* @__PURE__ */ getEquivalence3((self2, that) => {
      return self2.literal === that.literal && equals2(self2.type, that.type);
    });
    equalsEnums = /* @__PURE__ */ getEquivalence3((self2, that) => that[0] === self2[0] && that[1] === self2[1]);
    equalsUnion = /* @__PURE__ */ getEquivalence3(equals2);
    intersection2 = /* @__PURE__ */ intersectionWith(equals2);
    _keyof = /* @__PURE__ */ __name((ast) => {
      switch (ast._tag) {
        case "Declaration": {
          const annotation = getSurrogateAnnotation(ast);
          if (isSome2(annotation)) {
            return _keyof(annotation.value);
          }
          break;
        }
        case "TypeLiteral":
          return ast.propertySignatures.map((p) => isSymbol(p.name) ? new UniqueSymbol(p.name) : new Literal(p.name)).concat(ast.indexSignatures.map((is3) => getEncodedParameter(is3.parameter)));
        case "Suspend":
          return _keyof(ast.f());
        case "Union":
          return ast.types.slice(1).reduce((out, ast2) => intersection2(out, _keyof(ast2)), _keyof(ast.types[0]));
        case "Transformation":
          return _keyof(ast.to);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }, "_keyof");
    compose = /* @__PURE__ */ __name((ab, cd) => new Transformation(ab, cd, composeTransformation), "compose");
    rename = /* @__PURE__ */ __name((ast, mapping) => {
      switch (ast._tag) {
        case "TypeLiteral": {
          const propertySignatureTransformations = [];
          for (const key of Reflect.ownKeys(mapping)) {
            const name = mapping[key];
            if (name !== void 0) {
              propertySignatureTransformations.push(new PropertySignatureTransformation(key, name, identity, identity));
            }
          }
          if (propertySignatureTransformations.length === 0) {
            return ast;
          }
          return new Transformation(ast, new TypeLiteral(ast.propertySignatures.map((ps) => {
            const name = mapping[ps.name];
            return new PropertySignature(name === void 0 ? ps.name : name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations);
          }), ast.indexSignatures), new TypeLiteralTransformation(propertySignatureTransformations));
        }
        case "Union":
          return Union.make(ast.types.map((ast2) => rename(ast2, mapping)));
        case "Suspend":
          return new Suspend(() => rename(ast.f(), mapping));
        case "Transformation":
          return compose(ast, rename(typeAST(ast), mapping));
      }
      throw new Error(getASTUnsupportedRenameSchemaErrorMessage(ast));
    }, "rename");
    formatKeyword = /* @__PURE__ */ __name((ast) => getOrElse(getExpected(ast), () => ast._tag), "formatKeyword");
    __name(getBrands, "getBrands");
    getOrElseExpected = /* @__PURE__ */ __name((ast) => getTitleAnnotation(ast).pipe(orElse(() => getDescriptionAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast))), "getOrElseExpected");
    getExpected = /* @__PURE__ */ __name((ast) => orElse(getIdentifierAnnotation(ast), () => getOrElseExpected(ast)), "getExpected");
    pruneUndefined = /* @__PURE__ */ __name((ast, self2, onTransformation) => {
      switch (ast._tag) {
        case "UndefinedKeyword":
          return neverKeyword;
        case "Union": {
          const types = [];
          let hasUndefined = false;
          for (const type of ast.types) {
            const pruned = self2(type);
            if (pruned) {
              hasUndefined = true;
              if (!isNeverKeyword(pruned)) {
                types.push(pruned);
              }
            } else {
              types.push(type);
            }
          }
          if (hasUndefined) {
            return Union.make(types);
          }
          break;
        }
        case "Suspend":
          return self2(ast.f());
        case "Transformation":
          return onTransformation(ast);
      }
    }, "pruneUndefined");
  }
});

// node_modules/effect/dist/esm/Arbitrary.js
var init_Arbitrary2 = __esm({
  "node_modules/effect/dist/esm/Arbitrary.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/BigDecimal.js
var FINITE_INT_REGEX, TypeId4, BigDecimalProto, isBigDecimal, make4, unsafeMakeNormalized, bigint0, bigint10, zero, normalize, scale, Order2, lessThan2, lessThanOrEqualTo2, greaterThan2, greaterThanOrEqualTo2, between2, clamp4, sign, abs, Equivalence, equals3, unsafeFromNumber, safeFromNumber, fromString, format2, toExponential, unsafeToNumber, isZero, isNegative, isPositive;
var init_BigDecimal = __esm({
  "node_modules/effect/dist/esm/BigDecimal.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Equivalence();
    init_Function();
    init_Hash();
    init_Inspectable();
    init_Option();
    init_Order();
    init_Pipeable();
    init_Predicate();
    FINITE_INT_REGEX = /^[+-]?\d+$/;
    TypeId4 = /* @__PURE__ */ Symbol.for("effect/BigDecimal");
    BigDecimalProto = {
      [TypeId4]: TypeId4,
      [symbol]() {
        const normalized = normalize(this);
        return pipe(hash(normalized.value), combine(number2(normalized.scale)), cached(this));
      },
      [symbol2](that) {
        return isBigDecimal(that) && equals3(this, that);
      },
      toString() {
        return `BigDecimal(${format2(this)})`;
      },
      toJSON() {
        return {
          _id: "BigDecimal",
          value: String(this.value),
          scale: this.scale
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    isBigDecimal = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId4), "isBigDecimal");
    make4 = /* @__PURE__ */ __name((value3, scale2) => {
      const o = Object.create(BigDecimalProto);
      o.value = value3;
      o.scale = scale2;
      return o;
    }, "make");
    unsafeMakeNormalized = /* @__PURE__ */ __name((value3, scale2) => {
      if (value3 !== bigint0 && value3 % bigint10 === bigint0) {
        throw new RangeError("Value must be normalized");
      }
      const o = make4(value3, scale2);
      o.normalized = o;
      return o;
    }, "unsafeMakeNormalized");
    bigint0 = /* @__PURE__ */ BigInt(0);
    bigint10 = /* @__PURE__ */ BigInt(10);
    zero = /* @__PURE__ */ unsafeMakeNormalized(bigint0, 0);
    normalize = /* @__PURE__ */ __name((self2) => {
      if (self2.normalized === void 0) {
        if (self2.value === bigint0) {
          self2.normalized = zero;
        } else {
          const digits = `${self2.value}`;
          let trail = 0;
          for (let i = digits.length - 1; i >= 0; i--) {
            if (digits[i] === "0") {
              trail++;
            } else {
              break;
            }
          }
          if (trail === 0) {
            self2.normalized = self2;
          }
          const value3 = BigInt(digits.substring(0, digits.length - trail));
          const scale2 = self2.scale - trail;
          self2.normalized = unsafeMakeNormalized(value3, scale2);
        }
      }
      return self2.normalized;
    }, "normalize");
    scale = /* @__PURE__ */ dual(2, (self2, scale2) => {
      if (scale2 > self2.scale) {
        return make4(self2.value * bigint10 ** BigInt(scale2 - self2.scale), scale2);
      }
      if (scale2 < self2.scale) {
        return make4(self2.value / bigint10 ** BigInt(self2.scale - scale2), scale2);
      }
      return self2;
    });
    Order2 = /* @__PURE__ */ make2((self2, that) => {
      const scmp = number3(sign(self2), sign(that));
      if (scmp !== 0) {
        return scmp;
      }
      if (self2.scale > that.scale) {
        return bigint2(self2.value, scale(that, self2.scale).value);
      }
      if (self2.scale < that.scale) {
        return bigint2(scale(self2, that.scale).value, that.value);
      }
      return bigint2(self2.value, that.value);
    });
    lessThan2 = /* @__PURE__ */ lessThan(Order2);
    lessThanOrEqualTo2 = /* @__PURE__ */ lessThanOrEqualTo(Order2);
    greaterThan2 = /* @__PURE__ */ greaterThan(Order2);
    greaterThanOrEqualTo2 = /* @__PURE__ */ greaterThanOrEqualTo(Order2);
    between2 = /* @__PURE__ */ between(Order2);
    clamp4 = /* @__PURE__ */ clamp(Order2);
    sign = /* @__PURE__ */ __name((n) => n.value === bigint0 ? 0 : n.value < bigint0 ? -1 : 1, "sign");
    abs = /* @__PURE__ */ __name((n) => n.value < bigint0 ? make4(-n.value, n.scale) : n, "abs");
    Equivalence = /* @__PURE__ */ make((self2, that) => {
      if (self2.scale > that.scale) {
        return scale(that, self2.scale).value === self2.value;
      }
      if (self2.scale < that.scale) {
        return scale(self2, that.scale).value === that.value;
      }
      return self2.value === that.value;
    });
    equals3 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence(self2, that));
    unsafeFromNumber = /* @__PURE__ */ __name((n) => getOrThrowWith2(safeFromNumber(n), () => new RangeError(`Number must be finite, got ${n}`)), "unsafeFromNumber");
    safeFromNumber = /* @__PURE__ */ __name((n) => {
      if (!Number.isFinite(n)) {
        return none2();
      }
      const string8 = `${n}`;
      if (string8.includes("e")) {
        return fromString(string8);
      }
      const [lead, trail = ""] = string8.split(".");
      return some2(make4(BigInt(`${lead}${trail}`), trail.length));
    }, "safeFromNumber");
    fromString = /* @__PURE__ */ __name((s) => {
      if (s === "") {
        return some2(zero);
      }
      let base;
      let exp;
      const seperator = s.search(/[eE]/);
      if (seperator !== -1) {
        const trail = s.slice(seperator + 1);
        base = s.slice(0, seperator);
        exp = Number(trail);
        if (base === "" || !Number.isSafeInteger(exp) || !FINITE_INT_REGEX.test(trail)) {
          return none2();
        }
      } else {
        base = s;
        exp = 0;
      }
      let digits;
      let offset;
      const dot = base.search(/\./);
      if (dot !== -1) {
        const lead = base.slice(0, dot);
        const trail = base.slice(dot + 1);
        digits = `${lead}${trail}`;
        offset = trail.length;
      } else {
        digits = base;
        offset = 0;
      }
      if (!FINITE_INT_REGEX.test(digits)) {
        return none2();
      }
      const scale2 = offset - exp;
      if (!Number.isSafeInteger(scale2)) {
        return none2();
      }
      return some2(make4(BigInt(digits), scale2));
    }, "fromString");
    format2 = /* @__PURE__ */ __name((n) => {
      const normalized = normalize(n);
      if (Math.abs(normalized.scale) >= 16) {
        return toExponential(normalized);
      }
      const negative2 = normalized.value < bigint0;
      const absolute = negative2 ? `${normalized.value}`.substring(1) : `${normalized.value}`;
      let before2;
      let after3;
      if (normalized.scale >= absolute.length) {
        before2 = "0";
        after3 = "0".repeat(normalized.scale - absolute.length) + absolute;
      } else {
        const location = absolute.length - normalized.scale;
        if (location > absolute.length) {
          const zeros = location - absolute.length;
          before2 = `${absolute}${"0".repeat(zeros)}`;
          after3 = "";
        } else {
          after3 = absolute.slice(location);
          before2 = absolute.slice(0, location);
        }
      }
      const complete3 = after3 === "" ? before2 : `${before2}.${after3}`;
      return negative2 ? `-${complete3}` : complete3;
    }, "format");
    toExponential = /* @__PURE__ */ __name((n) => {
      if (isZero(n)) {
        return "0e+0";
      }
      const normalized = normalize(n);
      const digits = `${abs(normalized).value}`;
      const head7 = digits.slice(0, 1);
      const tail = digits.slice(1);
      let output = `${isNegative(normalized) ? "-" : ""}${head7}`;
      if (tail !== "") {
        output += `.${tail}`;
      }
      const exp = tail.length - normalized.scale;
      return `${output}e${exp >= 0 ? "+" : ""}${exp}`;
    }, "toExponential");
    unsafeToNumber = /* @__PURE__ */ __name((n) => Number(format2(n)), "unsafeToNumber");
    isZero = /* @__PURE__ */ __name((n) => n.value === bigint0, "isZero");
    isNegative = /* @__PURE__ */ __name((n) => n.value < bigint0, "isNegative");
    isPositive = /* @__PURE__ */ __name((n) => n.value > bigint0, "isPositive");
  }
});

// node_modules/effect/dist/esm/BigInt.js
var Order3, clamp5, toNumber, fromString2, fromNumber;
var init_BigInt = __esm({
  "node_modules/effect/dist/esm/BigInt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Option();
    init_Order();
    Order3 = bigint2;
    clamp5 = /* @__PURE__ */ clamp(Order3);
    toNumber = /* @__PURE__ */ __name((b) => {
      if (b > BigInt(Number.MAX_SAFE_INTEGER) || b < BigInt(Number.MIN_SAFE_INTEGER)) {
        return none2();
      }
      return some2(Number(b));
    }, "toNumber");
    fromString2 = /* @__PURE__ */ __name((s) => {
      try {
        return s.trim() === "" ? none2() : some2(BigInt(s));
      } catch {
        return none2();
      }
    }, "fromString");
    fromNumber = /* @__PURE__ */ __name((n) => {
      if (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER) {
        return none2();
      }
      try {
        return some2(BigInt(n));
      } catch {
        return none2();
      }
    }, "fromNumber");
  }
});

// node_modules/effect/dist/esm/Boolean.js
var not;
var init_Boolean = __esm({
  "node_modules/effect/dist/esm/Boolean.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    not = /* @__PURE__ */ __name((self2) => !self2, "not");
  }
});

// node_modules/effect/dist/esm/Brand.js
var init_Brand = __esm({
  "node_modules/effect/dist/esm/Brand.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/internal/context.js
var TagTypeId, ReferenceTypeId, STMSymbolKey, STMTypeId, TagProto, ReferenceProto, makeGenericTag, Tag, Reference, TypeId5, ContextProto, makeContext, serviceNotFoundError, isContext, isTag, isReference, _empty, empty3, make5, add, defaultValueCache, getDefaultValue, unsafeGetReference, unsafeGet2, get2, getOrElse2, getOption, merge2, mergeAll, pick2, omit2;
var init_context2 = __esm({
  "node_modules/effect/dist/esm/internal/context.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_GlobalValue();
    init_Hash();
    init_Inspectable();
    init_Pipeable();
    init_Predicate();
    init_effectable();
    init_option();
    TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
    ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
    STMSymbolKey = "effect/STM";
    STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
    TagProto = {
      ...EffectPrototype,
      _op: "Tag",
      [STMTypeId]: effectVariance,
      [TagTypeId]: {
        _Service: /* @__PURE__ */ __name((_) => _, "_Service"),
        _Identifier: /* @__PURE__ */ __name((_) => _, "_Identifier")
      },
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "Tag",
          key: this.key,
          stack: this.stack
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      of(self2) {
        return self2;
      },
      context(self2) {
        return make5(this, self2);
      }
    };
    ReferenceProto = {
      ...TagProto,
      [ReferenceTypeId]: ReferenceTypeId
    };
    makeGenericTag = /* @__PURE__ */ __name((key) => {
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const creationError = new Error();
      Error.stackTraceLimit = limit;
      const tag2 = Object.create(TagProto);
      Object.defineProperty(tag2, "stack", {
        get() {
          return creationError.stack;
        }
      });
      tag2.key = key;
      return tag2;
    }, "makeGenericTag");
    Tag = /* @__PURE__ */ __name((id2) => () => {
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const creationError = new Error();
      Error.stackTraceLimit = limit;
      function TagClass() {
      }
      __name(TagClass, "TagClass");
      Object.setPrototypeOf(TagClass, TagProto);
      TagClass.key = id2;
      Object.defineProperty(TagClass, "stack", {
        get() {
          return creationError.stack;
        }
      });
      return TagClass;
    }, "Tag");
    Reference = /* @__PURE__ */ __name(() => (id2, options) => {
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const creationError = new Error();
      Error.stackTraceLimit = limit;
      function ReferenceClass() {
      }
      __name(ReferenceClass, "ReferenceClass");
      Object.setPrototypeOf(ReferenceClass, ReferenceProto);
      ReferenceClass.key = id2;
      ReferenceClass.defaultValue = options.defaultValue;
      Object.defineProperty(ReferenceClass, "stack", {
        get() {
          return creationError.stack;
        }
      });
      return ReferenceClass;
    }, "Reference");
    TypeId5 = /* @__PURE__ */ Symbol.for("effect/Context");
    ContextProto = {
      [TypeId5]: {
        _Services: /* @__PURE__ */ __name((_) => _, "_Services")
      },
      [symbol2](that) {
        if (isContext(that)) {
          if (this.unsafeMap.size === that.unsafeMap.size) {
            for (const k of this.unsafeMap.keys()) {
              if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
                return false;
              }
            }
            return true;
          }
        }
        return false;
      },
      [symbol]() {
        return cached(this, number2(this.unsafeMap.size));
      },
      pipe() {
        return pipeArguments(this, arguments);
      },
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "Context",
          services: Array.from(this.unsafeMap).map(toJSON)
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      }
    };
    makeContext = /* @__PURE__ */ __name((unsafeMap) => {
      const context10 = Object.create(ContextProto);
      context10.unsafeMap = unsafeMap;
      return context10;
    }, "makeContext");
    serviceNotFoundError = /* @__PURE__ */ __name((tag2) => {
      const error50 = new Error(`Service not found${tag2.key ? `: ${String(tag2.key)}` : ""}`);
      if (tag2.stack) {
        const lines = tag2.stack.split("\n");
        if (lines.length > 2) {
          const afterAt = lines[2].match(/at (.*)/);
          if (afterAt) {
            error50.message = error50.message + ` (defined at ${afterAt[1]})`;
          }
        }
      }
      if (error50.stack) {
        const lines = error50.stack.split("\n");
        lines.splice(1, 3);
        error50.stack = lines.join("\n");
      }
      return error50;
    }, "serviceNotFoundError");
    isContext = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId5), "isContext");
    isTag = /* @__PURE__ */ __name((u) => hasProperty(u, TagTypeId), "isTag");
    isReference = /* @__PURE__ */ __name((u) => hasProperty(u, ReferenceTypeId), "isReference");
    _empty = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map());
    empty3 = /* @__PURE__ */ __name(() => _empty, "empty");
    make5 = /* @__PURE__ */ __name((tag2, service3) => makeContext(/* @__PURE__ */ new Map([[tag2.key, service3]])), "make");
    add = /* @__PURE__ */ dual(3, (self2, tag2, service3) => {
      const map31 = new Map(self2.unsafeMap);
      map31.set(tag2.key, service3);
      return makeContext(map31);
    });
    defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
    getDefaultValue = /* @__PURE__ */ __name((tag2) => {
      if (defaultValueCache.has(tag2.key)) {
        return defaultValueCache.get(tag2.key);
      }
      const value3 = tag2.defaultValue();
      defaultValueCache.set(tag2.key, value3);
      return value3;
    }, "getDefaultValue");
    unsafeGetReference = /* @__PURE__ */ __name((self2, tag2) => {
      return self2.unsafeMap.has(tag2.key) ? self2.unsafeMap.get(tag2.key) : getDefaultValue(tag2);
    }, "unsafeGetReference");
    unsafeGet2 = /* @__PURE__ */ dual(2, (self2, tag2) => {
      if (!self2.unsafeMap.has(tag2.key)) {
        if (ReferenceTypeId in tag2) return getDefaultValue(tag2);
        throw serviceNotFoundError(tag2);
      }
      return self2.unsafeMap.get(tag2.key);
    });
    get2 = unsafeGet2;
    getOrElse2 = /* @__PURE__ */ dual(3, (self2, tag2, orElse12) => {
      if (!self2.unsafeMap.has(tag2.key)) {
        return isReference(tag2) ? getDefaultValue(tag2) : orElse12();
      }
      return self2.unsafeMap.get(tag2.key);
    });
    getOption = /* @__PURE__ */ dual(2, (self2, tag2) => {
      if (!self2.unsafeMap.has(tag2.key)) {
        return isReference(tag2) ? some(getDefaultValue(tag2)) : none;
      }
      return some(self2.unsafeMap.get(tag2.key));
    });
    merge2 = /* @__PURE__ */ dual(2, (self2, that) => {
      const map31 = new Map(self2.unsafeMap);
      for (const [tag2, s] of that.unsafeMap) {
        map31.set(tag2, s);
      }
      return makeContext(map31);
    });
    mergeAll = /* @__PURE__ */ __name((...ctxs) => {
      const map31 = /* @__PURE__ */ new Map();
      for (let i = 0; i < ctxs.length; i++) {
        ctxs[i].unsafeMap.forEach((value3, key) => {
          map31.set(key, value3);
        });
      }
      return makeContext(map31);
    }, "mergeAll");
    pick2 = /* @__PURE__ */ __name((...tags) => (self2) => {
      const tagSet = new Set(tags.map((_) => _.key));
      const newEnv = /* @__PURE__ */ new Map();
      for (const [tag2, s] of self2.unsafeMap.entries()) {
        if (tagSet.has(tag2)) {
          newEnv.set(tag2, s);
        }
      }
      return makeContext(newEnv);
    }, "pick");
    omit2 = /* @__PURE__ */ __name((...tags) => (self2) => {
      const newEnv = new Map(self2.unsafeMap);
      for (const tag2 of tags) {
        newEnv.delete(tag2.key);
      }
      return makeContext(newEnv);
    }, "omit");
  }
});

// node_modules/effect/dist/esm/Context.js
var Context_exports = {};
__export(Context_exports, {
  GenericTag: () => GenericTag,
  Reference: () => Reference2,
  ReferenceTypeId: () => ReferenceTypeId2,
  Tag: () => Tag2,
  TagTypeId: () => TagTypeId2,
  add: () => add2,
  empty: () => empty4,
  get: () => get3,
  getOption: () => getOption2,
  getOrElse: () => getOrElse3,
  isContext: () => isContext2,
  isReference: () => isReference2,
  isTag: () => isTag2,
  make: () => make6,
  merge: () => merge3,
  mergeAll: () => mergeAll2,
  omit: () => omit3,
  pick: () => pick3,
  unsafeGet: () => unsafeGet3,
  unsafeMake: () => unsafeMake
});
var TagTypeId2, ReferenceTypeId2, GenericTag, unsafeMake, isContext2, isTag2, isReference2, empty4, make6, add2, get3, getOrElse3, unsafeGet3, getOption2, merge3, mergeAll2, pick3, omit3, Tag2, Reference2;
var init_Context = __esm({
  "node_modules/effect/dist/esm/Context.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_context2();
    TagTypeId2 = TagTypeId;
    ReferenceTypeId2 = ReferenceTypeId;
    GenericTag = makeGenericTag;
    unsafeMake = makeContext;
    isContext2 = isContext;
    isTag2 = isTag;
    isReference2 = isReference;
    empty4 = empty3;
    make6 = make5;
    add2 = add;
    get3 = get2;
    getOrElse3 = getOrElse2;
    unsafeGet3 = unsafeGet2;
    getOption2 = getOption;
    merge3 = merge2;
    mergeAll2 = mergeAll;
    pick3 = pick2;
    omit3 = omit2;
    Tag2 = Tag;
    Reference2 = Reference;
  }
});

// node_modules/effect/dist/esm/Chunk.js
function copy2(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var TypeId6, emptyArray, getEquivalence4, _equivalence3, ChunkProto, makeChunk, isChunk, _empty2, empty5, make7, of2, fromIterable3, copyToArray, toReadonlyArray_, toReadonlyArray, reverseChunk, reverse2, get4, unsafeFromArray, unsafeFromNonEmptyArray, unsafeGet4, append2, prepend2, take, drop2, dropWhile, appendAll2, filterMap3, filter3, filterMapWhile2, flatMap3, flatten4, isEmpty, isNonEmpty2, head2, unsafeHead, headNonEmpty2, last2, unsafeLast, map5, mapAccum2, sort2, splitAt2, splitWhere, tailNonEmpty2, takeRight, takeWhile, zipWith3, makeBy2, range, findFirst3, reduce2, reduceRight2;
var init_Chunk = __esm({
  "node_modules/effect/dist/esm/Chunk.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Equal();
    init_Equivalence();
    init_Function();
    init_Hash();
    init_Inspectable();
    init_Option();
    init_Pipeable();
    init_Predicate();
    TypeId6 = /* @__PURE__ */ Symbol.for("effect/Chunk");
    __name(copy2, "copy");
    emptyArray = [];
    getEquivalence4 = /* @__PURE__ */ __name((isEquivalent) => make((self2, that) => self2.length === that.length && toReadonlyArray(self2).every((value3, i) => isEquivalent(value3, unsafeGet4(that, i)))), "getEquivalence");
    _equivalence3 = /* @__PURE__ */ getEquivalence4(equals);
    ChunkProto = {
      [TypeId6]: {
        _A: /* @__PURE__ */ __name((_) => _, "_A")
      },
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "Chunk",
          values: toReadonlyArray(this).map(toJSON)
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      [symbol2](that) {
        return isChunk(that) && _equivalence3(this, that);
      },
      [symbol]() {
        return cached(this, array2(toReadonlyArray(this)));
      },
      [Symbol.iterator]() {
        switch (this.backing._tag) {
          case "IArray": {
            return this.backing.array[Symbol.iterator]();
          }
          case "IEmpty": {
            return emptyArray[Symbol.iterator]();
          }
          default: {
            return toReadonlyArray(this)[Symbol.iterator]();
          }
        }
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    makeChunk = /* @__PURE__ */ __name((backing) => {
      const chunk4 = Object.create(ChunkProto);
      chunk4.backing = backing;
      switch (backing._tag) {
        case "IEmpty": {
          chunk4.length = 0;
          chunk4.depth = 0;
          chunk4.left = chunk4;
          chunk4.right = chunk4;
          break;
        }
        case "IConcat": {
          chunk4.length = backing.left.length + backing.right.length;
          chunk4.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
          chunk4.left = backing.left;
          chunk4.right = backing.right;
          break;
        }
        case "IArray": {
          chunk4.length = backing.array.length;
          chunk4.depth = 0;
          chunk4.left = _empty2;
          chunk4.right = _empty2;
          break;
        }
        case "ISingleton": {
          chunk4.length = 1;
          chunk4.depth = 0;
          chunk4.left = _empty2;
          chunk4.right = _empty2;
          break;
        }
        case "ISlice": {
          chunk4.length = backing.length;
          chunk4.depth = backing.chunk.depth + 1;
          chunk4.left = _empty2;
          chunk4.right = _empty2;
          break;
        }
      }
      return chunk4;
    }, "makeChunk");
    isChunk = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId6), "isChunk");
    _empty2 = /* @__PURE__ */ makeChunk({
      _tag: "IEmpty"
    });
    empty5 = /* @__PURE__ */ __name(() => _empty2, "empty");
    make7 = /* @__PURE__ */ __name((...as12) => unsafeFromNonEmptyArray(as12), "make");
    of2 = /* @__PURE__ */ __name((a) => makeChunk({
      _tag: "ISingleton",
      a
    }), "of");
    fromIterable3 = /* @__PURE__ */ __name((self2) => isChunk(self2) ? self2 : unsafeFromArray(fromIterable2(self2)), "fromIterable");
    copyToArray = /* @__PURE__ */ __name((self2, array7, initial) => {
      switch (self2.backing._tag) {
        case "IArray": {
          copy2(self2.backing.array, 0, array7, initial, self2.length);
          break;
        }
        case "IConcat": {
          copyToArray(self2.left, array7, initial);
          copyToArray(self2.right, array7, initial + self2.left.length);
          break;
        }
        case "ISingleton": {
          array7[initial] = self2.backing.a;
          break;
        }
        case "ISlice": {
          let i = 0;
          let j = initial;
          while (i < self2.length) {
            array7[j] = unsafeGet4(self2, i);
            i += 1;
            j += 1;
          }
          break;
        }
      }
    }, "copyToArray");
    toReadonlyArray_ = /* @__PURE__ */ __name((self2) => {
      switch (self2.backing._tag) {
        case "IEmpty": {
          return emptyArray;
        }
        case "IArray": {
          return self2.backing.array;
        }
        default: {
          const arr = new Array(self2.length);
          copyToArray(self2, arr, 0);
          self2.backing = {
            _tag: "IArray",
            array: arr
          };
          self2.left = _empty2;
          self2.right = _empty2;
          self2.depth = 0;
          return arr;
        }
      }
    }, "toReadonlyArray_");
    toReadonlyArray = toReadonlyArray_;
    reverseChunk = /* @__PURE__ */ __name((self2) => {
      switch (self2.backing._tag) {
        case "IEmpty":
        case "ISingleton":
          return self2;
        case "IArray": {
          return makeChunk({
            _tag: "IArray",
            array: reverse(self2.backing.array)
          });
        }
        case "IConcat": {
          return makeChunk({
            _tag: "IConcat",
            left: reverse2(self2.backing.right),
            right: reverse2(self2.backing.left)
          });
        }
        case "ISlice":
          return unsafeFromArray(reverse(toReadonlyArray(self2)));
      }
    }, "reverseChunk");
    reverse2 = reverseChunk;
    get4 = /* @__PURE__ */ dual(2, (self2, index2) => index2 < 0 || index2 >= self2.length ? none2() : some2(unsafeGet4(self2, index2)));
    unsafeFromArray = /* @__PURE__ */ __name((self2) => self2.length === 0 ? empty5() : self2.length === 1 ? of2(self2[0]) : makeChunk({
      _tag: "IArray",
      array: self2
    }), "unsafeFromArray");
    unsafeFromNonEmptyArray = /* @__PURE__ */ __name((self2) => unsafeFromArray(self2), "unsafeFromNonEmptyArray");
    unsafeGet4 = /* @__PURE__ */ dual(2, (self2, index2) => {
      switch (self2.backing._tag) {
        case "IEmpty": {
          throw new Error(`Index out of bounds`);
        }
        case "ISingleton": {
          if (index2 !== 0) {
            throw new Error(`Index out of bounds`);
          }
          return self2.backing.a;
        }
        case "IArray": {
          if (index2 >= self2.length || index2 < 0) {
            throw new Error(`Index out of bounds`);
          }
          return self2.backing.array[index2];
        }
        case "IConcat": {
          return index2 < self2.left.length ? unsafeGet4(self2.left, index2) : unsafeGet4(self2.right, index2 - self2.left.length);
        }
        case "ISlice": {
          return unsafeGet4(self2.backing.chunk, index2 + self2.backing.offset);
        }
      }
    });
    append2 = /* @__PURE__ */ dual(2, (self2, a) => appendAll2(self2, of2(a)));
    prepend2 = /* @__PURE__ */ dual(2, (self2, elem) => appendAll2(of2(elem), self2));
    take = /* @__PURE__ */ dual(2, (self2, n) => {
      if (n <= 0) {
        return _empty2;
      } else if (n >= self2.length) {
        return self2;
      } else {
        switch (self2.backing._tag) {
          case "ISlice": {
            return makeChunk({
              _tag: "ISlice",
              chunk: self2.backing.chunk,
              length: n,
              offset: self2.backing.offset
            });
          }
          case "IConcat": {
            if (n > self2.left.length) {
              return makeChunk({
                _tag: "IConcat",
                left: self2.left,
                right: take(self2.right, n - self2.left.length)
              });
            }
            return take(self2.left, n);
          }
          default: {
            return makeChunk({
              _tag: "ISlice",
              chunk: self2,
              offset: 0,
              length: n
            });
          }
        }
      }
    });
    drop2 = /* @__PURE__ */ dual(2, (self2, n) => {
      if (n <= 0) {
        return self2;
      } else if (n >= self2.length) {
        return _empty2;
      } else {
        switch (self2.backing._tag) {
          case "ISlice": {
            return makeChunk({
              _tag: "ISlice",
              chunk: self2.backing.chunk,
              offset: self2.backing.offset + n,
              length: self2.backing.length - n
            });
          }
          case "IConcat": {
            if (n > self2.left.length) {
              return drop2(self2.right, n - self2.left.length);
            }
            return makeChunk({
              _tag: "IConcat",
              left: drop2(self2.left, n),
              right: self2.right
            });
          }
          default: {
            return makeChunk({
              _tag: "ISlice",
              chunk: self2,
              offset: n,
              length: self2.length - n
            });
          }
        }
      }
    });
    dropWhile = /* @__PURE__ */ dual(2, (self2, predicate) => {
      const arr = toReadonlyArray(self2);
      const len = arr.length;
      let i = 0;
      while (i < len && predicate(arr[i])) {
        i++;
      }
      return drop2(self2, i);
    });
    appendAll2 = /* @__PURE__ */ dual(2, (self2, that) => {
      if (self2.backing._tag === "IEmpty") {
        return that;
      }
      if (that.backing._tag === "IEmpty") {
        return self2;
      }
      const diff8 = that.depth - self2.depth;
      if (Math.abs(diff8) <= 1) {
        return makeChunk({
          _tag: "IConcat",
          left: self2,
          right: that
        });
      } else if (diff8 < -1) {
        if (self2.left.depth >= self2.right.depth) {
          const nr = appendAll2(self2.right, that);
          return makeChunk({
            _tag: "IConcat",
            left: self2.left,
            right: nr
          });
        } else {
          const nrr = appendAll2(self2.right.right, that);
          if (nrr.depth === self2.depth - 3) {
            const nr = makeChunk({
              _tag: "IConcat",
              left: self2.right.left,
              right: nrr
            });
            return makeChunk({
              _tag: "IConcat",
              left: self2.left,
              right: nr
            });
          } else {
            const nl = makeChunk({
              _tag: "IConcat",
              left: self2.left,
              right: self2.right.left
            });
            return makeChunk({
              _tag: "IConcat",
              left: nl,
              right: nrr
            });
          }
        }
      } else {
        if (that.right.depth >= that.left.depth) {
          const nl = appendAll2(self2, that.left);
          return makeChunk({
            _tag: "IConcat",
            left: nl,
            right: that.right
          });
        } else {
          const nll = appendAll2(self2, that.left.left);
          if (nll.depth === that.depth - 3) {
            const nl = makeChunk({
              _tag: "IConcat",
              left: nll,
              right: that.left.right
            });
            return makeChunk({
              _tag: "IConcat",
              left: nl,
              right: that.right
            });
          } else {
            const nr = makeChunk({
              _tag: "IConcat",
              left: that.left.right,
              right: that.right
            });
            return makeChunk({
              _tag: "IConcat",
              left: nll,
              right: nr
            });
          }
        }
      }
    });
    filterMap3 = /* @__PURE__ */ dual(2, (self2, f) => unsafeFromArray(filterMap2(self2, f)));
    filter3 = /* @__PURE__ */ dual(2, (self2, predicate) => unsafeFromArray(filter2(self2, predicate)));
    filterMapWhile2 = /* @__PURE__ */ dual(2, (self2, f) => unsafeFromArray(filterMapWhile(self2, f)));
    flatMap3 = /* @__PURE__ */ dual(2, (self2, f) => {
      if (self2.backing._tag === "ISingleton") {
        return f(self2.backing.a, 0);
      }
      let out = _empty2;
      let i = 0;
      for (const k of self2) {
        out = appendAll2(out, f(k, i++));
      }
      return out;
    });
    flatten4 = /* @__PURE__ */ flatMap3(identity);
    isEmpty = /* @__PURE__ */ __name((self2) => self2.length === 0, "isEmpty");
    isNonEmpty2 = /* @__PURE__ */ __name((self2) => self2.length > 0, "isNonEmpty");
    head2 = /* @__PURE__ */ get4(0);
    unsafeHead = /* @__PURE__ */ __name((self2) => unsafeGet4(self2, 0), "unsafeHead");
    headNonEmpty2 = unsafeHead;
    last2 = /* @__PURE__ */ __name((self2) => get4(self2, self2.length - 1), "last");
    unsafeLast = /* @__PURE__ */ __name((self2) => unsafeGet4(self2, self2.length - 1), "unsafeLast");
    map5 = /* @__PURE__ */ dual(2, (self2, f) => self2.backing._tag === "ISingleton" ? of2(f(self2.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self2), map4((a, i) => f(a, i)))));
    mapAccum2 = /* @__PURE__ */ dual(3, (self2, s, f) => {
      const [s1, as12] = mapAccum(self2, s, f);
      return [s1, unsafeFromArray(as12)];
    });
    sort2 = /* @__PURE__ */ dual(2, (self2, O) => unsafeFromArray(sort(toReadonlyArray(self2), O)));
    splitAt2 = /* @__PURE__ */ dual(2, (self2, n) => [take(self2, n), drop2(self2, n)]);
    splitWhere = /* @__PURE__ */ dual(2, (self2, predicate) => {
      let i = 0;
      for (const a of toReadonlyArray(self2)) {
        if (predicate(a)) {
          break;
        } else {
          i++;
        }
      }
      return splitAt2(self2, i);
    });
    tailNonEmpty2 = /* @__PURE__ */ __name((self2) => drop2(self2, 1), "tailNonEmpty");
    takeRight = /* @__PURE__ */ dual(2, (self2, n) => drop2(self2, self2.length - n));
    takeWhile = /* @__PURE__ */ dual(2, (self2, predicate) => {
      const out = [];
      for (const a of toReadonlyArray(self2)) {
        if (predicate(a)) {
          out.push(a);
        } else {
          break;
        }
      }
      return unsafeFromArray(out);
    });
    zipWith3 = /* @__PURE__ */ dual(3, (self2, that, f) => unsafeFromArray(zipWith2(self2, that, f)));
    makeBy2 = /* @__PURE__ */ dual(2, (n, f) => fromIterable3(makeBy(n, f)));
    range = /* @__PURE__ */ __name((start5, end6) => start5 <= end6 ? makeBy2(end6 - start5 + 1, (i) => start5 + i) : of2(start5), "range");
    findFirst3 = findFirst2;
    reduce2 = reduce;
    reduceRight2 = reduceRight;
  }
});

// node_modules/effect/dist/esm/Duration.js
var TypeId7, bigint02, bigint24, bigint60, bigint1e3, bigint1e6, bigint1e9, DURATION_REGEX, decode, zeroValue, infinityValue, DurationProto, make8, isDuration, isFinite2, isZero2, zero2, infinity, nanos, micros, millis, seconds, minutes, hours, days, weeks, toMillis, toNanos, unsafeToNanos, toHrTime, match4, matchWith, Order4, between3, Equivalence2, _clamp, clamp6, times, sum, lessThan3, lessThanOrEqualTo3, greaterThan3, greaterThanOrEqualTo3, equals4, parts, format3;
var init_Duration = __esm({
  "node_modules/effect/dist/esm/Duration.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_Hash();
    init_Inspectable();
    init_Option();
    init_Order();
    init_Pipeable();
    init_Predicate();
    TypeId7 = /* @__PURE__ */ Symbol.for("effect/Duration");
    bigint02 = /* @__PURE__ */ BigInt(0);
    bigint24 = /* @__PURE__ */ BigInt(24);
    bigint60 = /* @__PURE__ */ BigInt(60);
    bigint1e3 = /* @__PURE__ */ BigInt(1e3);
    bigint1e6 = /* @__PURE__ */ BigInt(1e6);
    bigint1e9 = /* @__PURE__ */ BigInt(1e9);
    DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
    decode = /* @__PURE__ */ __name((input) => {
      if (isDuration(input)) {
        return input;
      } else if (isNumber(input)) {
        return millis(input);
      } else if (isBigInt(input)) {
        return nanos(input);
      } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
        if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
          return zero2;
        }
        if (input[0] === Infinity || input[1] === Infinity) {
          return infinity;
        }
        return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
      } else if (isString(input)) {
        const match20 = DURATION_REGEX.exec(input);
        if (match20) {
          const [_, valueStr, unit] = match20;
          const value3 = Number(valueStr);
          switch (unit) {
            case "nano":
            case "nanos":
              return nanos(BigInt(valueStr));
            case "micro":
            case "micros":
              return micros(BigInt(valueStr));
            case "milli":
            case "millis":
              return millis(value3);
            case "second":
            case "seconds":
              return seconds(value3);
            case "minute":
            case "minutes":
              return minutes(value3);
            case "hour":
            case "hours":
              return hours(value3);
            case "day":
            case "days":
              return days(value3);
            case "week":
            case "weeks":
              return weeks(value3);
          }
        }
      }
      throw new Error("Invalid DurationInput");
    }, "decode");
    zeroValue = {
      _tag: "Millis",
      millis: 0
    };
    infinityValue = {
      _tag: "Infinity"
    };
    DurationProto = {
      [TypeId7]: TypeId7,
      [symbol]() {
        return cached(this, structure(this.value));
      },
      [symbol2](that) {
        return isDuration(that) && equals4(this, that);
      },
      toString() {
        return `Duration(${format3(this)})`;
      },
      toJSON() {
        switch (this.value._tag) {
          case "Millis":
            return {
              _id: "Duration",
              _tag: "Millis",
              millis: this.value.millis
            };
          case "Nanos":
            return {
              _id: "Duration",
              _tag: "Nanos",
              hrtime: toHrTime(this)
            };
          case "Infinity":
            return {
              _id: "Duration",
              _tag: "Infinity"
            };
        }
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    make8 = /* @__PURE__ */ __name((input) => {
      const duration6 = Object.create(DurationProto);
      if (isNumber(input)) {
        if (isNaN(input) || input <= 0) {
          duration6.value = zeroValue;
        } else if (!Number.isFinite(input)) {
          duration6.value = infinityValue;
        } else if (!Number.isInteger(input)) {
          duration6.value = {
            _tag: "Nanos",
            nanos: BigInt(Math.round(input * 1e6))
          };
        } else {
          duration6.value = {
            _tag: "Millis",
            millis: input
          };
        }
      } else if (input <= bigint02) {
        duration6.value = zeroValue;
      } else {
        duration6.value = {
          _tag: "Nanos",
          nanos: input
        };
      }
      return duration6;
    }, "make");
    isDuration = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId7), "isDuration");
    isFinite2 = /* @__PURE__ */ __name((self2) => self2.value._tag !== "Infinity", "isFinite");
    isZero2 = /* @__PURE__ */ __name((self2) => {
      switch (self2.value._tag) {
        case "Millis": {
          return self2.value.millis === 0;
        }
        case "Nanos": {
          return self2.value.nanos === bigint02;
        }
        case "Infinity": {
          return false;
        }
      }
    }, "isZero");
    zero2 = /* @__PURE__ */ make8(0);
    infinity = /* @__PURE__ */ make8(Infinity);
    nanos = /* @__PURE__ */ __name((nanos2) => make8(nanos2), "nanos");
    micros = /* @__PURE__ */ __name((micros2) => make8(micros2 * bigint1e3), "micros");
    millis = /* @__PURE__ */ __name((millis2) => make8(millis2), "millis");
    seconds = /* @__PURE__ */ __name((seconds2) => make8(seconds2 * 1e3), "seconds");
    minutes = /* @__PURE__ */ __name((minutes2) => make8(minutes2 * 6e4), "minutes");
    hours = /* @__PURE__ */ __name((hours2) => make8(hours2 * 36e5), "hours");
    days = /* @__PURE__ */ __name((days2) => make8(days2 * 864e5), "days");
    weeks = /* @__PURE__ */ __name((weeks2) => make8(weeks2 * 6048e5), "weeks");
    toMillis = /* @__PURE__ */ __name((self2) => match4(self2, {
      onMillis: /* @__PURE__ */ __name((millis2) => millis2, "onMillis"),
      onNanos: /* @__PURE__ */ __name((nanos2) => Number(nanos2) / 1e6, "onNanos")
    }), "toMillis");
    toNanos = /* @__PURE__ */ __name((self2) => {
      const _self = decode(self2);
      switch (_self.value._tag) {
        case "Infinity":
          return none2();
        case "Nanos":
          return some2(_self.value.nanos);
        case "Millis":
          return some2(BigInt(Math.round(_self.value.millis * 1e6)));
      }
    }, "toNanos");
    unsafeToNanos = /* @__PURE__ */ __name((self2) => {
      const _self = decode(self2);
      switch (_self.value._tag) {
        case "Infinity":
          throw new Error("Cannot convert infinite duration to nanos");
        case "Nanos":
          return _self.value.nanos;
        case "Millis":
          return BigInt(Math.round(_self.value.millis * 1e6));
      }
    }, "unsafeToNanos");
    toHrTime = /* @__PURE__ */ __name((self2) => {
      const _self = decode(self2);
      switch (_self.value._tag) {
        case "Infinity":
          return [Infinity, 0];
        case "Nanos":
          return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
        case "Millis":
          return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
      }
    }, "toHrTime");
    match4 = /* @__PURE__ */ dual(2, (self2, options) => {
      const _self = decode(self2);
      switch (_self.value._tag) {
        case "Nanos":
          return options.onNanos(_self.value.nanos);
        case "Infinity":
          return options.onMillis(Infinity);
        case "Millis":
          return options.onMillis(_self.value.millis);
      }
    });
    matchWith = /* @__PURE__ */ dual(3, (self2, that, options) => {
      const _self = decode(self2);
      const _that = decode(that);
      if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
        return options.onMillis(toMillis(_self), toMillis(_that));
      } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
        const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
        const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
        return options.onNanos(selfNanos, thatNanos);
      }
      return options.onMillis(_self.value.millis, _that.value.millis);
    });
    Order4 = /* @__PURE__ */ make2((self2, that) => matchWith(self2, that, {
      onMillis: /* @__PURE__ */ __name((self3, that2) => self3 < that2 ? -1 : self3 > that2 ? 1 : 0, "onMillis"),
      onNanos: /* @__PURE__ */ __name((self3, that2) => self3 < that2 ? -1 : self3 > that2 ? 1 : 0, "onNanos")
    }));
    between3 = /* @__PURE__ */ between(/* @__PURE__ */ mapInput2(Order4, decode));
    Equivalence2 = /* @__PURE__ */ __name((self2, that) => matchWith(self2, that, {
      onMillis: /* @__PURE__ */ __name((self3, that2) => self3 === that2, "onMillis"),
      onNanos: /* @__PURE__ */ __name((self3, that2) => self3 === that2, "onNanos")
    }), "Equivalence");
    _clamp = /* @__PURE__ */ clamp(Order4);
    clamp6 = /* @__PURE__ */ dual(2, (self2, options) => _clamp(decode(self2), {
      minimum: decode(options.minimum),
      maximum: decode(options.maximum)
    }));
    times = /* @__PURE__ */ dual(2, (self2, times2) => match4(self2, {
      onMillis: /* @__PURE__ */ __name((millis2) => make8(millis2 * times2), "onMillis"),
      onNanos: /* @__PURE__ */ __name((nanos2) => make8(nanos2 * BigInt(times2)), "onNanos")
    }));
    sum = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
      onMillis: /* @__PURE__ */ __name((self3, that2) => make8(self3 + that2), "onMillis"),
      onNanos: /* @__PURE__ */ __name((self3, that2) => make8(self3 + that2), "onNanos")
    }));
    lessThan3 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
      onMillis: /* @__PURE__ */ __name((self3, that2) => self3 < that2, "onMillis"),
      onNanos: /* @__PURE__ */ __name((self3, that2) => self3 < that2, "onNanos")
    }));
    lessThanOrEqualTo3 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
      onMillis: /* @__PURE__ */ __name((self3, that2) => self3 <= that2, "onMillis"),
      onNanos: /* @__PURE__ */ __name((self3, that2) => self3 <= that2, "onNanos")
    }));
    greaterThan3 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
      onMillis: /* @__PURE__ */ __name((self3, that2) => self3 > that2, "onMillis"),
      onNanos: /* @__PURE__ */ __name((self3, that2) => self3 > that2, "onNanos")
    }));
    greaterThanOrEqualTo3 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
      onMillis: /* @__PURE__ */ __name((self3, that2) => self3 >= that2, "onMillis"),
      onNanos: /* @__PURE__ */ __name((self3, that2) => self3 >= that2, "onNanos")
    }));
    equals4 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence2(decode(self2), decode(that)));
    parts = /* @__PURE__ */ __name((self2) => {
      const duration6 = decode(self2);
      if (duration6.value._tag === "Infinity") {
        return {
          days: Infinity,
          hours: Infinity,
          minutes: Infinity,
          seconds: Infinity,
          millis: Infinity,
          nanos: Infinity
        };
      }
      const nanos2 = unsafeToNanos(duration6);
      const ms = nanos2 / bigint1e6;
      const sec = ms / bigint1e3;
      const min4 = sec / bigint60;
      const hr = min4 / bigint60;
      const days2 = hr / bigint24;
      return {
        days: Number(days2),
        hours: Number(hr % bigint24),
        minutes: Number(min4 % bigint60),
        seconds: Number(sec % bigint60),
        millis: Number(ms % bigint1e3),
        nanos: Number(nanos2 % bigint1e6)
      };
    }, "parts");
    format3 = /* @__PURE__ */ __name((self2) => {
      const duration6 = decode(self2);
      if (duration6.value._tag === "Infinity") {
        return "Infinity";
      }
      if (isZero2(duration6)) {
        return "0";
      }
      const fragments = parts(duration6);
      const pieces = [];
      if (fragments.days !== 0) {
        pieces.push(`${fragments.days}d`);
      }
      if (fragments.hours !== 0) {
        pieces.push(`${fragments.hours}h`);
      }
      if (fragments.minutes !== 0) {
        pieces.push(`${fragments.minutes}m`);
      }
      if (fragments.seconds !== 0) {
        pieces.push(`${fragments.seconds}s`);
      }
      if (fragments.millis !== 0) {
        pieces.push(`${fragments.millis}ms`);
      }
      if (fragments.nanos !== 0) {
        pieces.push(`${fragments.nanos}ns`);
      }
      return pieces.join(" ");
    }, "format");
  }
});

// node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE, BUCKET_SIZE, MASK2, MAX_INDEX_NODE, MIN_ARRAY_NODE;
var init_config = __esm({
  "node_modules/effect/dist/esm/internal/hashMap/config.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SIZE = 5;
    BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
    MASK2 = BUCKET_SIZE - 1;
    MAX_INDEX_NODE = BUCKET_SIZE / 2;
    MIN_ARRAY_NODE = BUCKET_SIZE / 4;
  }
});

// node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function hashFragment(shift2, h) {
  return h >>> shift2 & MASK2;
}
function toBitmap(x) {
  return 1 << x;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}
var init_bitwise = __esm({
  "node_modules/effect/dist/esm/internal/hashMap/bitwise.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_config();
    __name(popcount, "popcount");
    __name(hashFragment, "hashFragment");
    __name(toBitmap, "toBitmap");
    __name(fromBitmap, "fromBitmap");
  }
});

// node_modules/effect/dist/esm/internal/stack.js
var make9;
var init_stack = __esm({
  "node_modules/effect/dist/esm/internal/stack.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    make9 = /* @__PURE__ */ __name((value3, previous2) => ({
      value: value3,
      previous: previous2
    }), "make");
  }
});

// node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate5, at, v, arr) {
  let out = arr;
  if (!mutate5) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i) out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
function arraySpliceOut(mutate5, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate5) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at) out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen) out[g++] = arr[i++];
  if (mutate5) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate5, at, v, arr) {
  const len = arr.length;
  if (mutate5) {
    let i2 = len;
    while (i2 >= at) arr[i2--] = arr[i2];
    arr[at] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at) out[g++] = arr[i++];
  out[at] = v;
  while (i < len) out[++g] = arr[i++];
  return out;
}
var init_array3 = __esm({
  "node_modules/effect/dist/esm/internal/hashMap/array.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(arrayUpdate, "arrayUpdate");
    __name(arraySpliceOut, "arraySpliceOut");
    __name(arraySpliceIn, "arraySpliceIn");
  }
});

// node_modules/effect/dist/esm/internal/hashMap/node.js
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
function pack(edit, count6, removed, elements) {
  const children2 = new Array(count6 - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children2[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children2);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count6 = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count6++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count6 + 1, arr);
}
function mergeLeavesInner(edit, shift2, h1, n1, h2, n2) {
  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift2, h1);
  const subH2 = hashFragment(shift2, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children2 = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children2);
  }
}
function mergeLeaves(edit, shift2, h1, n1, h2, n2) {
  let stack = void 0;
  let currentShift = shift2;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make9(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}
var EmptyNode, LeafNode, CollisionNode, IndexedNode, ArrayNode;
var init_node = __esm({
  "node_modules/effect/dist/esm/internal/hashMap/node.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Option();
    init_Predicate();
    init_stack();
    init_array3();
    init_bitwise();
    init_config();
    EmptyNode = class _EmptyNode {
      static {
        __name(this, "EmptyNode");
      }
      _tag = "EmptyNode";
      modify(edit, _shift, f, hash4, key, size15) {
        const v = f(none2());
        if (isNone2(v)) return new _EmptyNode();
        ++size15.value;
        return new LeafNode(edit, hash4, key, v);
      }
    };
    __name(isEmptyNode, "isEmptyNode");
    __name(isLeafNode, "isLeafNode");
    __name(canEditNode, "canEditNode");
    LeafNode = class _LeafNode {
      static {
        __name(this, "LeafNode");
      }
      edit;
      hash;
      key;
      value;
      _tag = "LeafNode";
      constructor(edit, hash4, key, value3) {
        this.edit = edit;
        this.hash = hash4;
        this.key = key;
        this.value = value3;
      }
      modify(edit, shift2, f, hash4, key, size15) {
        if (equals(key, this.key)) {
          const v2 = f(this.value);
          if (v2 === this.value) return this;
          else if (isNone2(v2)) {
            --size15.value;
            return new EmptyNode();
          }
          if (canEditNode(this, edit)) {
            this.value = v2;
            return this;
          }
          return new _LeafNode(edit, hash4, key, v2);
        }
        const v = f(none2());
        if (isNone2(v)) return this;
        ++size15.value;
        return mergeLeaves(edit, shift2, this.hash, this, hash4, new _LeafNode(edit, hash4, key, v));
      }
    };
    CollisionNode = class _CollisionNode {
      static {
        __name(this, "CollisionNode");
      }
      edit;
      hash;
      children;
      _tag = "CollisionNode";
      constructor(edit, hash4, children2) {
        this.edit = edit;
        this.hash = hash4;
        this.children = children2;
      }
      modify(edit, shift2, f, hash4, key, size15) {
        if (hash4 === this.hash) {
          const canEdit = canEditNode(this, edit);
          const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size15);
          if (list === this.children) return this;
          return list.length > 1 ? new _CollisionNode(edit, this.hash, list) : list[0];
        }
        const v = f(none2());
        if (isNone2(v)) return this;
        ++size15.value;
        return mergeLeaves(edit, shift2, this.hash, this, hash4, new LeafNode(edit, hash4, key, v));
      }
      updateCollisionList(mutate5, edit, hash4, list, f, key, size15) {
        const len = list.length;
        for (let i = 0; i < len; ++i) {
          const child = list[i];
          if ("key" in child && equals(key, child.key)) {
            const value3 = child.value;
            const newValue2 = f(value3);
            if (newValue2 === value3) return list;
            if (isNone2(newValue2)) {
              --size15.value;
              return arraySpliceOut(mutate5, i, list);
            }
            return arrayUpdate(mutate5, i, new LeafNode(edit, hash4, key, newValue2), list);
          }
        }
        const newValue = f(none2());
        if (isNone2(newValue)) return list;
        ++size15.value;
        return arrayUpdate(mutate5, len, new LeafNode(edit, hash4, key, newValue), list);
      }
    };
    IndexedNode = class _IndexedNode {
      static {
        __name(this, "IndexedNode");
      }
      edit;
      mask;
      children;
      _tag = "IndexedNode";
      constructor(edit, mask, children2) {
        this.edit = edit;
        this.mask = mask;
        this.children = children2;
      }
      modify(edit, shift2, f, hash4, key, size15) {
        const mask = this.mask;
        const children2 = this.children;
        const frag = hashFragment(shift2, hash4);
        const bit = toBitmap(frag);
        const indx = fromBitmap(mask, bit);
        const exists5 = mask & bit;
        const canEdit = canEditNode(this, edit);
        if (!exists5) {
          const _newChild = new EmptyNode().modify(edit, shift2 + SIZE, f, hash4, key, size15);
          if (!_newChild) return this;
          return children2.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children2) : new _IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children2));
        }
        const current2 = children2[indx];
        const child = current2.modify(edit, shift2 + SIZE, f, hash4, key, size15);
        if (current2 === child) return this;
        let bitmap = mask;
        let newChildren;
        if (isEmptyNode(child)) {
          bitmap &= ~bit;
          if (!bitmap) return new EmptyNode();
          if (children2.length <= 2 && isLeafNode(children2[indx ^ 1])) {
            return children2[indx ^ 1];
          }
          newChildren = arraySpliceOut(canEdit, indx, children2);
        } else {
          newChildren = arrayUpdate(canEdit, indx, child, children2);
        }
        if (canEdit) {
          this.mask = bitmap;
          this.children = newChildren;
          return this;
        }
        return new _IndexedNode(edit, bitmap, newChildren);
      }
    };
    ArrayNode = class _ArrayNode {
      static {
        __name(this, "ArrayNode");
      }
      edit;
      size;
      children;
      _tag = "ArrayNode";
      constructor(edit, size15, children2) {
        this.edit = edit;
        this.size = size15;
        this.children = children2;
      }
      modify(edit, shift2, f, hash4, key, size15) {
        let count6 = this.size;
        const children2 = this.children;
        const frag = hashFragment(shift2, hash4);
        const child = children2[frag];
        const newChild = (child || new EmptyNode()).modify(edit, shift2 + SIZE, f, hash4, key, size15);
        if (child === newChild) return this;
        const canEdit = canEditNode(this, edit);
        let newChildren;
        if (isEmptyNode(child) && !isEmptyNode(newChild)) {
          ++count6;
          newChildren = arrayUpdate(canEdit, frag, newChild, children2);
        } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
          --count6;
          if (count6 <= MIN_ARRAY_NODE) {
            return pack(edit, count6, frag, children2);
          }
          newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children2);
        } else {
          newChildren = arrayUpdate(canEdit, frag, newChild, children2);
        }
        if (canEdit) {
          this.size = count6;
          this.children = newChildren;
          return this;
        }
        return new _ArrayNode(edit, count6, newChildren);
      }
    };
    __name(pack, "pack");
    __name(expand, "expand");
    __name(mergeLeavesInner, "mergeLeavesInner");
    __name(mergeLeaves, "mergeLeaves");
  }
});

// node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey, HashMapTypeId, HashMapProto, makeImpl, HashMapIterator, applyCont, visitLazy, visitLazyChildren, _empty3, empty6, fromIterable4, isHashMap, isEmpty2, get5, getHash, unsafeGet5, has, set, setTree, keys, size, beginMutation, endMutation, mutate, modifyAt, modifyHash, remove2, map6, forEach, reduce3;
var init_hashMap = __esm({
  "node_modules/effect/dist/esm/internal/hashMap.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_Function();
    init_Hash();
    init_Inspectable();
    init_Option();
    init_Pipeable();
    init_Predicate();
    init_bitwise();
    init_config();
    init_node();
    HashMapSymbolKey = "effect/HashMap";
    HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
    HashMapProto = {
      [HashMapTypeId]: HashMapTypeId,
      [Symbol.iterator]() {
        return new HashMapIterator(this, (k, v) => [k, v]);
      },
      [symbol]() {
        let hash4 = hash(HashMapSymbolKey);
        for (const item of this) {
          hash4 ^= pipe(hash(item[0]), combine(hash(item[1])));
        }
        return cached(this, hash4);
      },
      [symbol2](that) {
        if (isHashMap(that)) {
          if (that._size !== this._size) {
            return false;
          }
          for (const item of this) {
            const elem = pipe(that, getHash(item[0], hash(item[0])));
            if (isNone2(elem)) {
              return false;
            } else {
              if (!equals(item[1], elem.value)) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      },
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "HashMap",
          values: Array.from(this).map(toJSON)
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    makeImpl = /* @__PURE__ */ __name((editable, edit, root, size15) => {
      const map31 = Object.create(HashMapProto);
      map31._editable = editable;
      map31._edit = edit;
      map31._root = root;
      map31._size = size15;
      return map31;
    }, "makeImpl");
    HashMapIterator = class _HashMapIterator {
      static {
        __name(this, "HashMapIterator");
      }
      map;
      f;
      v;
      constructor(map31, f) {
        this.map = map31;
        this.f = f;
        this.v = visitLazy(this.map._root, this.f, void 0);
      }
      next() {
        if (isNone2(this.v)) {
          return {
            done: true,
            value: void 0
          };
        }
        const v0 = this.v.value;
        this.v = applyCont(v0.cont);
        return {
          done: false,
          value: v0.value
        };
      }
      [Symbol.iterator]() {
        return new _HashMapIterator(this.map, this.f);
      }
    };
    applyCont = /* @__PURE__ */ __name((cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2(), "applyCont");
    visitLazy = /* @__PURE__ */ __name((node, f, cont = void 0) => {
      switch (node._tag) {
        case "LeafNode": {
          if (isSome2(node.value)) {
            return some2({
              value: f(node.key, node.value.value),
              cont
            });
          }
          return applyCont(cont);
        }
        case "CollisionNode":
        case "ArrayNode":
        case "IndexedNode": {
          const children2 = node.children;
          return visitLazyChildren(children2.length, children2, 0, f, cont);
        }
        default: {
          return applyCont(cont);
        }
      }
    }, "visitLazy");
    visitLazyChildren = /* @__PURE__ */ __name((len, children2, i, f, cont) => {
      while (i < len) {
        const child = children2[i++];
        if (child && !isEmptyNode(child)) {
          return visitLazy(child, f, [len, children2, i, f, cont]);
        }
      }
      return applyCont(cont);
    }, "visitLazyChildren");
    _empty3 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode(), 0);
    empty6 = /* @__PURE__ */ __name(() => _empty3, "empty");
    fromIterable4 = /* @__PURE__ */ __name((entries2) => {
      const map31 = beginMutation(empty6());
      for (const entry of entries2) {
        set(map31, entry[0], entry[1]);
      }
      return endMutation(map31);
    }, "fromIterable");
    isHashMap = /* @__PURE__ */ __name((u) => hasProperty(u, HashMapTypeId), "isHashMap");
    isEmpty2 = /* @__PURE__ */ __name((self2) => self2 && isEmptyNode(self2._root), "isEmpty");
    get5 = /* @__PURE__ */ dual(2, (self2, key) => getHash(self2, key, hash(key)));
    getHash = /* @__PURE__ */ dual(3, (self2, key, hash4) => {
      let node = self2._root;
      let shift2 = 0;
      while (true) {
        switch (node._tag) {
          case "LeafNode": {
            return equals(key, node.key) ? node.value : none2();
          }
          case "CollisionNode": {
            if (hash4 === node.hash) {
              const children2 = node.children;
              for (let i = 0, len = children2.length; i < len; ++i) {
                const child = children2[i];
                if ("key" in child && equals(key, child.key)) {
                  return child.value;
                }
              }
            }
            return none2();
          }
          case "IndexedNode": {
            const frag = hashFragment(shift2, hash4);
            const bit = toBitmap(frag);
            if (node.mask & bit) {
              node = node.children[fromBitmap(node.mask, bit)];
              shift2 += SIZE;
              break;
            }
            return none2();
          }
          case "ArrayNode": {
            node = node.children[hashFragment(shift2, hash4)];
            if (node) {
              shift2 += SIZE;
              break;
            }
            return none2();
          }
          default:
            return none2();
        }
      }
    });
    unsafeGet5 = /* @__PURE__ */ dual(2, (self2, key) => {
      const element2 = getHash(self2, key, hash(key));
      if (isNone2(element2)) {
        throw new Error("Expected map to contain key");
      }
      return element2.value;
    });
    has = /* @__PURE__ */ dual(2, (self2, key) => isSome2(getHash(self2, key, hash(key))));
    set = /* @__PURE__ */ dual(3, (self2, key, value3) => modifyAt(self2, key, () => some2(value3)));
    setTree = /* @__PURE__ */ dual(3, (self2, newRoot, newSize) => {
      if (self2._editable) {
        ;
        self2._root = newRoot;
        self2._size = newSize;
        return self2;
      }
      return newRoot === self2._root ? self2 : makeImpl(self2._editable, self2._edit, newRoot, newSize);
    });
    keys = /* @__PURE__ */ __name((self2) => new HashMapIterator(self2, (key) => key), "keys");
    size = /* @__PURE__ */ __name((self2) => self2._size, "size");
    beginMutation = /* @__PURE__ */ __name((self2) => makeImpl(true, self2._edit + 1, self2._root, self2._size), "beginMutation");
    endMutation = /* @__PURE__ */ __name((self2) => {
      ;
      self2._editable = false;
      return self2;
    }, "endMutation");
    mutate = /* @__PURE__ */ dual(2, (self2, f) => {
      const transient = beginMutation(self2);
      f(transient);
      return endMutation(transient);
    });
    modifyAt = /* @__PURE__ */ dual(3, (self2, key, f) => modifyHash(self2, key, hash(key), f));
    modifyHash = /* @__PURE__ */ dual(4, (self2, key, hash4, f) => {
      const size15 = {
        value: self2._size
      };
      const newRoot = self2._root.modify(self2._editable ? self2._edit : NaN, 0, f, hash4, key, size15);
      return pipe(self2, setTree(newRoot, size15.value));
    });
    remove2 = /* @__PURE__ */ dual(2, (self2, key) => modifyAt(self2, key, none2));
    map6 = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, empty6(), (map31, value3, key) => set(map31, key, f(value3, key))));
    forEach = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, void 0, (_, value3, key) => f(value3, key)));
    reduce3 = /* @__PURE__ */ dual(3, (self2, zero3, f) => {
      const root = self2._root;
      if (root._tag === "LeafNode") {
        return isSome2(root.value) ? f(zero3, root.value.value, root.key) : zero3;
      }
      if (root._tag === "EmptyNode") {
        return zero3;
      }
      const toVisit = [root.children];
      let children2;
      while (children2 = toVisit.pop()) {
        for (let i = 0, len = children2.length; i < len; ) {
          const child = children2[i++];
          if (child && !isEmptyNode(child)) {
            if (child._tag === "LeafNode") {
              if (isSome2(child.value)) {
                zero3 = f(zero3, child.value.value, child.key);
              }
            } else {
              toVisit.push(child.children);
            }
          }
        }
      }
      return zero3;
    });
  }
});

// node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey, HashSetTypeId, HashSetProto, makeImpl2, isHashSet, _empty4, empty7, fromIterable5, make10, has2, size2, beginMutation2, endMutation2, mutate2, add3, remove3, difference2, union2, forEach2, reduce4;
var init_hashSet = __esm({
  "node_modules/effect/dist/esm/internal/hashSet.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_Hash();
    init_Inspectable();
    init_Pipeable();
    init_Predicate();
    init_hashMap();
    HashSetSymbolKey = "effect/HashSet";
    HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
    HashSetProto = {
      [HashSetTypeId]: HashSetTypeId,
      [Symbol.iterator]() {
        return keys(this._keyMap);
      },
      [symbol]() {
        return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
      },
      [symbol2](that) {
        if (isHashSet(that)) {
          return size(this._keyMap) === size(that._keyMap) && equals(this._keyMap, that._keyMap);
        }
        return false;
      },
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "HashSet",
          values: Array.from(this).map(toJSON)
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    makeImpl2 = /* @__PURE__ */ __name((keyMap) => {
      const set10 = Object.create(HashSetProto);
      set10._keyMap = keyMap;
      return set10;
    }, "makeImpl");
    isHashSet = /* @__PURE__ */ __name((u) => hasProperty(u, HashSetTypeId), "isHashSet");
    _empty4 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty6());
    empty7 = /* @__PURE__ */ __name(() => _empty4, "empty");
    fromIterable5 = /* @__PURE__ */ __name((elements) => {
      const set10 = beginMutation2(empty7());
      for (const value3 of elements) {
        add3(set10, value3);
      }
      return endMutation2(set10);
    }, "fromIterable");
    make10 = /* @__PURE__ */ __name((...elements) => {
      const set10 = beginMutation2(empty7());
      for (const value3 of elements) {
        add3(set10, value3);
      }
      return endMutation2(set10);
    }, "make");
    has2 = /* @__PURE__ */ dual(2, (self2, value3) => has(self2._keyMap, value3));
    size2 = /* @__PURE__ */ __name((self2) => size(self2._keyMap), "size");
    beginMutation2 = /* @__PURE__ */ __name((self2) => makeImpl2(beginMutation(self2._keyMap)), "beginMutation");
    endMutation2 = /* @__PURE__ */ __name((self2) => {
      ;
      self2._keyMap._editable = false;
      return self2;
    }, "endMutation");
    mutate2 = /* @__PURE__ */ dual(2, (self2, f) => {
      const transient = beginMutation2(self2);
      f(transient);
      return endMutation2(transient);
    });
    add3 = /* @__PURE__ */ dual(2, (self2, value3) => self2._keyMap._editable ? (set(value3, true)(self2._keyMap), self2) : makeImpl2(set(value3, true)(self2._keyMap)));
    remove3 = /* @__PURE__ */ dual(2, (self2, value3) => self2._keyMap._editable ? (remove2(value3)(self2._keyMap), self2) : makeImpl2(remove2(value3)(self2._keyMap)));
    difference2 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(self2, (set10) => {
      for (const value3 of that) {
        remove3(set10, value3);
      }
    }));
    union2 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(empty7(), (set10) => {
      forEach2(self2, (value3) => add3(set10, value3));
      for (const value3 of that) {
        add3(set10, value3);
      }
    }));
    forEach2 = /* @__PURE__ */ dual(2, (self2, f) => forEach(self2._keyMap, (_, k) => f(k)));
    reduce4 = /* @__PURE__ */ dual(3, (self2, zero3, f) => reduce3(self2._keyMap, zero3, (z2, _, a) => f(z2, a)));
  }
});

// node_modules/effect/dist/esm/HashSet.js
var isHashSet2, empty8, fromIterable6, make11, has3, size3, add4, remove4, difference3, union3, forEach3, reduce5;
var init_HashSet = __esm({
  "node_modules/effect/dist/esm/HashSet.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hashSet();
    isHashSet2 = isHashSet;
    empty8 = empty7;
    fromIterable6 = fromIterable5;
    make11 = make10;
    has3 = has2;
    size3 = size2;
    add4 = add3;
    remove4 = remove3;
    difference3 = difference2;
    union3 = union2;
    forEach3 = forEach2;
    reduce5 = reduce4;
  }
});

// node_modules/effect/dist/esm/MutableRef.js
var TypeId8, MutableRefProto, make12, compareAndSet, get6, set2;
var init_MutableRef = __esm({
  "node_modules/effect/dist/esm/MutableRef.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_Inspectable();
    init_Pipeable();
    TypeId8 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
    MutableRefProto = {
      [TypeId8]: TypeId8,
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "MutableRef",
          current: toJSON(this.current)
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    make12 = /* @__PURE__ */ __name((value3) => {
      const ref2 = Object.create(MutableRefProto);
      ref2.current = value3;
      return ref2;
    }, "make");
    compareAndSet = /* @__PURE__ */ dual(3, (self2, oldValue, newValue) => {
      if (equals(oldValue, self2.current)) {
        self2.current = newValue;
        return true;
      }
      return false;
    });
    get6 = /* @__PURE__ */ __name((self2) => self2.current, "get");
    set2 = /* @__PURE__ */ dual(2, (self2, value3) => {
      self2.current = value3;
      return self2;
    });
  }
});

// node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey, FiberIdTypeId, OP_NONE, OP_RUNTIME, OP_COMPOSITE, emptyHash, None, Runtime, Composite, none3, runtime, composite, isFiberId, combine2, combineAll, ids, _fiberCounter, threadName, unsafeMake2;
var init_fiberId = __esm({
  "node_modules/effect/dist/esm/internal/fiberId.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_GlobalValue();
    init_Hash();
    init_HashSet();
    init_Inspectable();
    init_MutableRef();
    init_Predicate();
    FiberIdSymbolKey = "effect/FiberId";
    FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
    OP_NONE = "None";
    OP_RUNTIME = "Runtime";
    OP_COMPOSITE = "Composite";
    emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);
    None = class {
      static {
        __name(this, "None");
      }
      [FiberIdTypeId] = FiberIdTypeId;
      _tag = OP_NONE;
      id = -1;
      startTimeMillis = -1;
      [symbol]() {
        return emptyHash;
      }
      [symbol2](that) {
        return isFiberId(that) && that._tag === OP_NONE;
      }
      toString() {
        return format(this.toJSON());
      }
      toJSON() {
        return {
          _id: "FiberId",
          _tag: this._tag
        };
      }
      [NodeInspectSymbol]() {
        return this.toJSON();
      }
    };
    Runtime = class {
      static {
        __name(this, "Runtime");
      }
      id;
      startTimeMillis;
      [FiberIdTypeId] = FiberIdTypeId;
      _tag = OP_RUNTIME;
      constructor(id2, startTimeMillis) {
        this.id = id2;
        this.startTimeMillis = startTimeMillis;
      }
      [symbol]() {
        return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
      }
      [symbol2](that) {
        return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
      }
      toString() {
        return format(this.toJSON());
      }
      toJSON() {
        return {
          _id: "FiberId",
          _tag: this._tag,
          id: this.id,
          startTimeMillis: this.startTimeMillis
        };
      }
      [NodeInspectSymbol]() {
        return this.toJSON();
      }
    };
    Composite = class {
      static {
        __name(this, "Composite");
      }
      left;
      right;
      [FiberIdTypeId] = FiberIdTypeId;
      _tag = OP_COMPOSITE;
      constructor(left3, right3) {
        this.left = left3;
        this.right = right3;
      }
      _hash;
      [symbol]() {
        return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
      }
      [symbol2](that) {
        return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
      }
      toString() {
        return format(this.toJSON());
      }
      toJSON() {
        return {
          _id: "FiberId",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
      }
      [NodeInspectSymbol]() {
        return this.toJSON();
      }
    };
    none3 = /* @__PURE__ */ new None();
    runtime = /* @__PURE__ */ __name((id2, startTimeMillis) => {
      return new Runtime(id2, startTimeMillis);
    }, "runtime");
    composite = /* @__PURE__ */ __name((left3, right3) => {
      return new Composite(left3, right3);
    }, "composite");
    isFiberId = /* @__PURE__ */ __name((self2) => hasProperty(self2, FiberIdTypeId), "isFiberId");
    combine2 = /* @__PURE__ */ dual(2, (self2, that) => {
      if (self2._tag === OP_NONE) {
        return that;
      }
      if (that._tag === OP_NONE) {
        return self2;
      }
      return new Composite(self2, that);
    });
    combineAll = /* @__PURE__ */ __name((fiberIds) => {
      return pipe(fiberIds, reduce5(none3, (a, b) => combine2(b)(a)));
    }, "combineAll");
    ids = /* @__PURE__ */ __name((self2) => {
      switch (self2._tag) {
        case OP_NONE: {
          return empty8();
        }
        case OP_RUNTIME: {
          return make11(self2.id);
        }
        case OP_COMPOSITE: {
          return pipe(ids(self2.left), union3(ids(self2.right)));
        }
      }
    }, "ids");
    _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make12(0));
    threadName = /* @__PURE__ */ __name((self2) => {
      const identifiers = Array.from(ids(self2)).map((n) => `#${n}`).join(",");
      return identifiers;
    }, "threadName");
    unsafeMake2 = /* @__PURE__ */ __name(() => {
      const id2 = get6(_fiberCounter);
      pipe(_fiberCounter, set2(id2 + 1));
      return new Runtime(id2, Date.now());
    }, "unsafeMake");
  }
});

// node_modules/effect/dist/esm/FiberId.js
var none4, runtime2, composite2, isFiberId2, combine3, combineAll2, ids2, threadName2, unsafeMake3;
var init_FiberId = __esm({
  "node_modules/effect/dist/esm/FiberId.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_fiberId();
    none4 = none3;
    runtime2 = runtime;
    composite2 = composite;
    isFiberId2 = isFiberId;
    combine3 = combine2;
    combineAll2 = combineAll;
    ids2 = ids;
    threadName2 = threadName;
    unsafeMake3 = unsafeMake2;
  }
});

// node_modules/effect/dist/esm/HashMap.js
var isHashMap2, empty9, fromIterable7, isEmpty3, get7, unsafeGet6, has4, set3, keys2, mutate3, modifyAt2, map8, forEach4, reduce6;
var init_HashMap = __esm({
  "node_modules/effect/dist/esm/HashMap.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hashMap();
    isHashMap2 = isHashMap;
    empty9 = empty6;
    fromIterable7 = fromIterable4;
    isEmpty3 = isEmpty2;
    get7 = get5;
    unsafeGet6 = unsafeGet5;
    has4 = has;
    set3 = set;
    keys2 = keys;
    mutate3 = mutate;
    modifyAt2 = modifyAt;
    map8 = map6;
    forEach4 = forEach;
    reduce6 = reduce3;
  }
});

// node_modules/effect/dist/esm/List.js
var TypeId9, toArray2, getEquivalence5, _equivalence4, ConsProto, makeCons, NilHash, NilProto, _Nil, isList, isNil, isCons, nil, cons, empty10, of3, fromIterable8, appendAll3, prepend3, prependAll, reduce7, reverse3;
var init_List = __esm({
  "node_modules/effect/dist/esm/List.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Equal();
    init_Equivalence();
    init_Function();
    init_Hash();
    init_Inspectable();
    init_Pipeable();
    init_Predicate();
    TypeId9 = /* @__PURE__ */ Symbol.for("effect/List");
    toArray2 = /* @__PURE__ */ __name((self2) => fromIterable2(self2), "toArray");
    getEquivalence5 = /* @__PURE__ */ __name((isEquivalent) => mapInput(getEquivalence3(isEquivalent), toArray2), "getEquivalence");
    _equivalence4 = /* @__PURE__ */ getEquivalence5(equals);
    ConsProto = {
      [TypeId9]: TypeId9,
      _tag: "Cons",
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "List",
          _tag: "Cons",
          values: toArray2(this).map(toJSON)
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      [symbol2](that) {
        return isList(that) && this._tag === that._tag && _equivalence4(this, that);
      },
      [symbol]() {
        return cached(this, array2(toArray2(this)));
      },
      [Symbol.iterator]() {
        let done13 = false;
        let self2 = this;
        return {
          next() {
            if (done13) {
              return this.return();
            }
            if (self2._tag === "Nil") {
              done13 = true;
              return this.return();
            }
            const value3 = self2.head;
            self2 = self2.tail;
            return {
              done: done13,
              value: value3
            };
          },
          return(value3) {
            if (!done13) {
              done13 = true;
            }
            return {
              done: true,
              value: value3
            };
          }
        };
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    makeCons = /* @__PURE__ */ __name((head7, tail) => {
      const cons2 = Object.create(ConsProto);
      cons2.head = head7;
      cons2.tail = tail;
      return cons2;
    }, "makeCons");
    NilHash = /* @__PURE__ */ string("Nil");
    NilProto = {
      [TypeId9]: TypeId9,
      _tag: "Nil",
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "List",
          _tag: "Nil"
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      [symbol]() {
        return NilHash;
      },
      [symbol2](that) {
        return isList(that) && this._tag === that._tag;
      },
      [Symbol.iterator]() {
        return {
          next() {
            return {
              done: true,
              value: void 0
            };
          }
        };
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    _Nil = /* @__PURE__ */ Object.create(NilProto);
    isList = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId9), "isList");
    isNil = /* @__PURE__ */ __name((self2) => self2._tag === "Nil", "isNil");
    isCons = /* @__PURE__ */ __name((self2) => self2._tag === "Cons", "isCons");
    nil = /* @__PURE__ */ __name(() => _Nil, "nil");
    cons = /* @__PURE__ */ __name((head7, tail) => makeCons(head7, tail), "cons");
    empty10 = nil;
    of3 = /* @__PURE__ */ __name((value3) => makeCons(value3, _Nil), "of");
    fromIterable8 = /* @__PURE__ */ __name((prefix) => {
      const iterator2 = prefix[Symbol.iterator]();
      let next4;
      if ((next4 = iterator2.next()) && !next4.done) {
        const result = makeCons(next4.value, _Nil);
        let curr = result;
        while ((next4 = iterator2.next()) && !next4.done) {
          const temp = makeCons(next4.value, _Nil);
          curr.tail = temp;
          curr = temp;
        }
        return result;
      } else {
        return _Nil;
      }
    }, "fromIterable");
    appendAll3 = /* @__PURE__ */ dual(2, (self2, that) => prependAll(that, self2));
    prepend3 = /* @__PURE__ */ dual(2, (self2, element2) => cons(element2, self2));
    prependAll = /* @__PURE__ */ dual(2, (self2, prefix) => {
      if (isNil(self2)) {
        return prefix;
      } else if (isNil(prefix)) {
        return self2;
      } else {
        const result = makeCons(prefix.head, self2);
        let curr = result;
        let that = prefix.tail;
        while (!isNil(that)) {
          const temp = makeCons(that.head, self2);
          curr.tail = temp;
          curr = temp;
          that = that.tail;
        }
        return result;
      }
    });
    reduce7 = /* @__PURE__ */ dual(3, (self2, zero3, f) => {
      let acc = zero3;
      let these = self2;
      while (!isNil(these)) {
        acc = f(acc, these.head);
        these = these.tail;
      }
      return acc;
    });
    reverse3 = /* @__PURE__ */ __name((self2) => {
      let result = empty10();
      let these = self2;
      while (!isNil(these)) {
        result = prepend3(result, these.head);
        these = these.tail;
      }
      return result;
    }, "reverse");
  }
});

// node_modules/effect/dist/esm/internal/data.js
var ArrayProto, Structural, struct;
var init_data = __esm({
  "node_modules/effect/dist/esm/internal/data.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Hash();
    init_effectable();
    ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
      [symbol]() {
        return cached(this, array2(this));
      },
      [symbol2](that) {
        if (Array.isArray(that) && this.length === that.length) {
          return this.every((v, i) => equals(v, that[i]));
        } else {
          return false;
        }
      }
    });
    Structural = /* @__PURE__ */ (function() {
      function Structural2(args2) {
        if (args2) {
          Object.assign(this, args2);
        }
      }
      __name(Structural2, "Structural");
      Structural2.prototype = StructuralPrototype;
      return Structural2;
    })();
    struct = /* @__PURE__ */ __name((as12) => Object.assign(Object.create(StructuralPrototype), as12), "struct");
  }
});

// node_modules/effect/dist/esm/internal/differ/contextPatch.js
function variance(a) {
  return a;
}
var ContextPatchTypeId, PatchProto, EmptyProto, _empty5, empty11, AndThenProto, makeAndThen, AddServiceProto, makeAddService, RemoveServiceProto, makeRemoveService, UpdateServiceProto, makeUpdateService, diff, combine4, patch;
var init_contextPatch = __esm({
  "node_modules/effect/dist/esm/internal/differ/contextPatch.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Chunk();
    init_Equal();
    init_Function();
    init_context2();
    init_data();
    ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
    __name(variance, "variance");
    PatchProto = {
      ...Structural.prototype,
      [ContextPatchTypeId]: {
        _Value: variance,
        _Patch: variance
      }
    };
    EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
      _tag: "Empty"
    });
    _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
    empty11 = /* @__PURE__ */ __name(() => _empty5, "empty");
    AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
      _tag: "AndThen"
    });
    makeAndThen = /* @__PURE__ */ __name((first3, second) => {
      const o = Object.create(AndThenProto);
      o.first = first3;
      o.second = second;
      return o;
    }, "makeAndThen");
    AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
      _tag: "AddService"
    });
    makeAddService = /* @__PURE__ */ __name((key, service3) => {
      const o = Object.create(AddServiceProto);
      o.key = key;
      o.service = service3;
      return o;
    }, "makeAddService");
    RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
      _tag: "RemoveService"
    });
    makeRemoveService = /* @__PURE__ */ __name((key) => {
      const o = Object.create(RemoveServiceProto);
      o.key = key;
      return o;
    }, "makeRemoveService");
    UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
      _tag: "UpdateService"
    });
    makeUpdateService = /* @__PURE__ */ __name((key, update6) => {
      const o = Object.create(UpdateServiceProto);
      o.key = key;
      o.update = update6;
      return o;
    }, "makeUpdateService");
    diff = /* @__PURE__ */ __name((oldValue, newValue) => {
      const missingServices = new Map(oldValue.unsafeMap);
      let patch9 = empty11();
      for (const [tag2, newService] of newValue.unsafeMap.entries()) {
        if (missingServices.has(tag2)) {
          const old = missingServices.get(tag2);
          missingServices.delete(tag2);
          if (!equals(old, newService)) {
            patch9 = combine4(makeUpdateService(tag2, () => newService))(patch9);
          }
        } else {
          missingServices.delete(tag2);
          patch9 = combine4(makeAddService(tag2, newService))(patch9);
        }
      }
      for (const [tag2] of missingServices.entries()) {
        patch9 = combine4(makeRemoveService(tag2))(patch9);
      }
      return patch9;
    }, "diff");
    combine4 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen(self2, that));
    patch = /* @__PURE__ */ dual(2, (self2, context10) => {
      if (self2._tag === "Empty") {
        return context10;
      }
      let wasServiceUpdated = false;
      let patches = of2(self2);
      const updatedContext = new Map(context10.unsafeMap);
      while (isNonEmpty2(patches)) {
        const head7 = headNonEmpty2(patches);
        const tail = tailNonEmpty2(patches);
        switch (head7._tag) {
          case "Empty": {
            patches = tail;
            break;
          }
          case "AddService": {
            updatedContext.set(head7.key, head7.service);
            patches = tail;
            break;
          }
          case "AndThen": {
            patches = prepend2(prepend2(tail, head7.second), head7.first);
            break;
          }
          case "RemoveService": {
            updatedContext.delete(head7.key);
            patches = tail;
            break;
          }
          case "UpdateService": {
            updatedContext.set(head7.key, head7.update(updatedContext.get(head7.key)));
            wasServiceUpdated = true;
            patches = tail;
            break;
          }
        }
      }
      if (!wasServiceUpdated) {
        return makeContext(updatedContext);
      }
      const map31 = /* @__PURE__ */ new Map();
      for (const [tag2] of context10.unsafeMap) {
        if (updatedContext.has(tag2)) {
          map31.set(tag2, updatedContext.get(tag2));
          updatedContext.delete(tag2);
        }
      }
      for (const [tag2, s] of updatedContext) {
        map31.set(tag2, s);
      }
      return makeContext(map31);
    });
  }
});

// node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
function variance2(a) {
  return a;
}
var HashSetPatchTypeId, PatchProto2, EmptyProto2, _empty6, empty12, AndThenProto2, makeAndThen2, AddProto, makeAdd, RemoveProto, makeRemove, diff2, combine5, patch2;
var init_hashSetPatch = __esm({
  "node_modules/effect/dist/esm/internal/differ/hashSetPatch.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Chunk();
    init_Function();
    init_HashSet();
    init_data();
    HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
    __name(variance2, "variance");
    PatchProto2 = {
      ...Structural.prototype,
      [HashSetPatchTypeId]: {
        _Value: variance2,
        _Key: variance2,
        _Patch: variance2
      }
    };
    EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
      _tag: "Empty"
    });
    _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
    empty12 = /* @__PURE__ */ __name(() => _empty6, "empty");
    AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
      _tag: "AndThen"
    });
    makeAndThen2 = /* @__PURE__ */ __name((first3, second) => {
      const o = Object.create(AndThenProto2);
      o.first = first3;
      o.second = second;
      return o;
    }, "makeAndThen");
    AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
      _tag: "Add"
    });
    makeAdd = /* @__PURE__ */ __name((value3) => {
      const o = Object.create(AddProto);
      o.value = value3;
      return o;
    }, "makeAdd");
    RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
      _tag: "Remove"
    });
    makeRemove = /* @__PURE__ */ __name((value3) => {
      const o = Object.create(RemoveProto);
      o.value = value3;
      return o;
    }, "makeRemove");
    diff2 = /* @__PURE__ */ __name((oldValue, newValue) => {
      const [removed, patch9] = reduce5([oldValue, empty12()], ([set10, patch10], value3) => {
        if (has3(value3)(set10)) {
          return [remove4(value3)(set10), patch10];
        }
        return [set10, combine5(makeAdd(value3))(patch10)];
      })(newValue);
      return reduce5(patch9, (patch10, value3) => combine5(makeRemove(value3))(patch10))(removed);
    }, "diff");
    combine5 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen2(self2, that));
    patch2 = /* @__PURE__ */ dual(2, (self2, oldValue) => {
      if (self2._tag === "Empty") {
        return oldValue;
      }
      let set10 = oldValue;
      let patches = of2(self2);
      while (isNonEmpty2(patches)) {
        const head7 = headNonEmpty2(patches);
        const tail = tailNonEmpty2(patches);
        switch (head7._tag) {
          case "Empty": {
            patches = tail;
            break;
          }
          case "AndThen": {
            patches = prepend2(head7.first)(prepend2(head7.second)(tail));
            break;
          }
          case "Add": {
            set10 = add4(head7.value)(set10);
            patches = tail;
            break;
          }
          case "Remove": {
            set10 = remove4(head7.value)(set10);
            patches = tail;
          }
        }
      }
      return set10;
    });
  }
});

// node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
function variance3(a) {
  return a;
}
var ReadonlyArrayPatchTypeId, PatchProto3, EmptyProto3, _empty7, empty13, AndThenProto3, makeAndThen3, AppendProto, makeAppend, SliceProto, makeSlice, UpdateProto, makeUpdate, diff3, combine6, patch3;
var init_readonlyArrayPatch = __esm({
  "node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Equal();
    init_Function();
    init_data();
    ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
    __name(variance3, "variance");
    PatchProto3 = {
      ...Structural.prototype,
      [ReadonlyArrayPatchTypeId]: {
        _Value: variance3,
        _Patch: variance3
      }
    };
    EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
      _tag: "Empty"
    });
    _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
    empty13 = /* @__PURE__ */ __name(() => _empty7, "empty");
    AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
      _tag: "AndThen"
    });
    makeAndThen3 = /* @__PURE__ */ __name((first3, second) => {
      const o = Object.create(AndThenProto3);
      o.first = first3;
      o.second = second;
      return o;
    }, "makeAndThen");
    AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
      _tag: "Append"
    });
    makeAppend = /* @__PURE__ */ __name((values4) => {
      const o = Object.create(AppendProto);
      o.values = values4;
      return o;
    }, "makeAppend");
    SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
      _tag: "Slice"
    });
    makeSlice = /* @__PURE__ */ __name((from2, until) => {
      const o = Object.create(SliceProto);
      o.from = from2;
      o.until = until;
      return o;
    }, "makeSlice");
    UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
      _tag: "Update"
    });
    makeUpdate = /* @__PURE__ */ __name((index2, patch9) => {
      const o = Object.create(UpdateProto);
      o.index = index2;
      o.patch = patch9;
      return o;
    }, "makeUpdate");
    diff3 = /* @__PURE__ */ __name((options) => {
      let i = 0;
      let patch9 = empty13();
      while (i < options.oldValue.length && i < options.newValue.length) {
        const oldElement = options.oldValue[i];
        const newElement = options.newValue[i];
        const valuePatch = options.differ.diff(oldElement, newElement);
        if (!equals(valuePatch, options.differ.empty)) {
          patch9 = combine6(patch9, makeUpdate(i, valuePatch));
        }
        i = i + 1;
      }
      if (i < options.oldValue.length) {
        patch9 = combine6(patch9, makeSlice(0, i));
      }
      if (i < options.newValue.length) {
        patch9 = combine6(patch9, makeAppend(drop(i)(options.newValue)));
      }
      return patch9;
    }, "diff");
    combine6 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen3(self2, that));
    patch3 = /* @__PURE__ */ dual(3, (self2, oldValue, differ3) => {
      if (self2._tag === "Empty") {
        return oldValue;
      }
      let readonlyArray2 = oldValue.slice();
      let patches = of(self2);
      while (isNonEmptyArray2(patches)) {
        const head7 = headNonEmpty(patches);
        const tail = tailNonEmpty(patches);
        switch (head7._tag) {
          case "Empty": {
            patches = tail;
            break;
          }
          case "AndThen": {
            tail.unshift(head7.first, head7.second);
            patches = tail;
            break;
          }
          case "Append": {
            for (const value3 of head7.values) {
              readonlyArray2.push(value3);
            }
            patches = tail;
            break;
          }
          case "Slice": {
            readonlyArray2 = readonlyArray2.slice(head7.from, head7.until);
            patches = tail;
            break;
          }
          case "Update": {
            readonlyArray2[head7.index] = differ3.patch(head7.patch, readonlyArray2[head7.index]);
            patches = tail;
            break;
          }
        }
      }
      return readonlyArray2;
    });
  }
});

// node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId, DifferProto, make15, environment, hashSet, readonlyArray, update, updateWith;
var init_differ = __esm({
  "node_modules/effect/dist/esm/internal/differ.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_Pipeable();
    init_contextPatch();
    init_hashSetPatch();
    init_readonlyArrayPatch();
    DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
    DifferProto = {
      [DifferTypeId]: {
        _P: identity,
        _V: identity
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    make15 = /* @__PURE__ */ __name((params) => {
      const differ3 = Object.create(DifferProto);
      differ3.empty = params.empty;
      differ3.diff = params.diff;
      differ3.combine = params.combine;
      differ3.patch = params.patch;
      return differ3;
    }, "make");
    environment = /* @__PURE__ */ __name(() => make15({
      empty: empty11(),
      combine: /* @__PURE__ */ __name((first3, second) => combine4(second)(first3), "combine"),
      diff: /* @__PURE__ */ __name((oldValue, newValue) => diff(oldValue, newValue), "diff"),
      patch: /* @__PURE__ */ __name((patch9, oldValue) => patch(oldValue)(patch9), "patch")
    }), "environment");
    hashSet = /* @__PURE__ */ __name(() => make15({
      empty: empty12(),
      combine: /* @__PURE__ */ __name((first3, second) => combine5(second)(first3), "combine"),
      diff: /* @__PURE__ */ __name((oldValue, newValue) => diff2(oldValue, newValue), "diff"),
      patch: /* @__PURE__ */ __name((patch9, oldValue) => patch2(oldValue)(patch9), "patch")
    }), "hashSet");
    readonlyArray = /* @__PURE__ */ __name((differ3) => make15({
      empty: empty13(),
      combine: /* @__PURE__ */ __name((first3, second) => combine6(first3, second), "combine"),
      diff: /* @__PURE__ */ __name((oldValue, newValue) => diff3({
        oldValue,
        newValue,
        differ: differ3
      }), "diff"),
      patch: /* @__PURE__ */ __name((patch9, oldValue) => patch3(patch9, oldValue, differ3), "patch")
    }), "readonlyArray");
    update = /* @__PURE__ */ __name(() => updateWith((_, a) => a), "update");
    updateWith = /* @__PURE__ */ __name((f) => make15({
      empty: identity,
      combine: /* @__PURE__ */ __name((first3, second) => {
        if (first3 === identity) {
          return second;
        }
        if (second === identity) {
          return first3;
        }
        return (a) => second(first3(a));
      }, "combine"),
      diff: /* @__PURE__ */ __name((oldValue, newValue) => {
        if (equals(oldValue, newValue)) {
          return identity;
        }
        return constant(newValue);
      }, "diff"),
      patch: /* @__PURE__ */ __name((patch9, oldValue) => f(oldValue, patch9(oldValue)), "patch")
    }), "updateWith");
  }
});

// node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK, BIT_SHIFT, active, enabled, make16, empty14, enable, disable, exclude, andThen2, invert;
var init_runtimeFlagsPatch = __esm({
  "node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    BIT_MASK = 255;
    BIT_SHIFT = 8;
    active = /* @__PURE__ */ __name((patch9) => patch9 & BIT_MASK, "active");
    enabled = /* @__PURE__ */ __name((patch9) => patch9 >> BIT_SHIFT & BIT_MASK, "enabled");
    make16 = /* @__PURE__ */ __name((active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT), "make");
    empty14 = /* @__PURE__ */ make16(0, 0);
    enable = /* @__PURE__ */ __name((flag) => make16(flag, flag), "enable");
    disable = /* @__PURE__ */ __name((flag) => make16(flag, 0), "disable");
    exclude = /* @__PURE__ */ dual(2, (self2, flag) => make16(active(self2) & ~flag, enabled(self2)));
    andThen2 = /* @__PURE__ */ dual(2, (self2, that) => self2 | that);
    invert = /* @__PURE__ */ __name((n) => ~n >>> 0 & BIT_MASK, "invert");
  }
});

// node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2, Interruption, OpSupervision, RuntimeMetrics, WindDown, CooperativeYielding, cooperativeYielding, disable2, enable2, interruptible, interruption, isEnabled, make17, none5, runtimeMetrics, windDown, diff4, patch4, differ;
var init_runtimeFlags = __esm({
  "node_modules/effect/dist/esm/internal/runtimeFlags.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_differ();
    init_runtimeFlagsPatch();
    None2 = 0;
    Interruption = 1 << 0;
    OpSupervision = 1 << 1;
    RuntimeMetrics = 1 << 2;
    WindDown = 1 << 4;
    CooperativeYielding = 1 << 5;
    cooperativeYielding = /* @__PURE__ */ __name((self2) => isEnabled(self2, CooperativeYielding), "cooperativeYielding");
    disable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 & ~flag);
    enable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 | flag);
    interruptible = /* @__PURE__ */ __name((self2) => interruption(self2) && !windDown(self2), "interruptible");
    interruption = /* @__PURE__ */ __name((self2) => isEnabled(self2, Interruption), "interruption");
    isEnabled = /* @__PURE__ */ dual(2, (self2, flag) => (self2 & flag) !== 0);
    make17 = /* @__PURE__ */ __name((...flags) => flags.reduce((a, b) => a | b, 0), "make");
    none5 = /* @__PURE__ */ make17(None2);
    runtimeMetrics = /* @__PURE__ */ __name((self2) => isEnabled(self2, RuntimeMetrics), "runtimeMetrics");
    windDown = /* @__PURE__ */ __name((self2) => isEnabled(self2, WindDown), "windDown");
    diff4 = /* @__PURE__ */ dual(2, (self2, that) => make16(self2 ^ that, that));
    patch4 = /* @__PURE__ */ dual(2, (self2, patch9) => self2 & (invert(active(patch9)) | enabled(patch9)) | active(patch9) & enabled(patch9));
    differ = /* @__PURE__ */ make15({
      empty: empty14,
      diff: /* @__PURE__ */ __name((oldValue, newValue) => diff4(oldValue, newValue), "diff"),
      combine: /* @__PURE__ */ __name((first3, second) => andThen2(second)(first3), "combine"),
      patch: /* @__PURE__ */ __name((_patch, oldValue) => patch4(oldValue, _patch), "patch")
    });
  }
});

// node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty15, enable3, disable3, exclude2;
var init_RuntimeFlagsPatch = __esm({
  "node_modules/effect/dist/esm/RuntimeFlagsPatch.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_runtimeFlagsPatch();
    empty15 = empty14;
    enable3 = enable;
    disable3 = disable;
    exclude2 = exclude;
  }
});

// node_modules/effect/dist/esm/internal/blockedRequests.js
var empty16, par, seq, single, flatten5, step, merge4, EntryTypeId, EntryImpl, blockedRequestVariance, makeEntry, RequestBlockParallelTypeId, parallelVariance, ParallelImpl, parallelCollectionEmpty, parallelCollectionAdd, parallelCollectionCombine, parallelCollectionIsEmpty, parallelCollectionKeys, parallelCollectionToSequentialCollection, SequentialCollectionTypeId, sequentialVariance, SequentialImpl, sequentialCollectionMake, sequentialCollectionCombine, sequentialCollectionKeys, sequentialCollectionToChunk;
var init_blockedRequests = __esm({
  "node_modules/effect/dist/esm/internal/blockedRequests.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Chunk();
    init_Equal();
    init_HashMap();
    init_List();
    init_Option();
    empty16 = {
      _tag: "Empty"
    };
    par = /* @__PURE__ */ __name((self2, that) => ({
      _tag: "Par",
      left: self2,
      right: that
    }), "par");
    seq = /* @__PURE__ */ __name((self2, that) => ({
      _tag: "Seq",
      left: self2,
      right: that
    }), "seq");
    single = /* @__PURE__ */ __name((dataSource, blockedRequest) => ({
      _tag: "Single",
      dataSource,
      blockedRequest
    }), "single");
    flatten5 = /* @__PURE__ */ __name((self2) => {
      let current2 = of3(self2);
      let updated = empty10();
      while (1) {
        const [parallel5, sequential5] = reduce7(current2, [parallelCollectionEmpty(), empty10()], ([parallel6, sequential6], blockedRequest) => {
          const [par2, seq2] = step(blockedRequest);
          return [parallelCollectionCombine(parallel6, par2), appendAll3(sequential6, seq2)];
        });
        updated = merge4(updated, parallel5);
        if (isNil(sequential5)) {
          return reverse3(updated);
        }
        current2 = sequential5;
      }
      throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
    }, "flatten");
    step = /* @__PURE__ */ __name((requests) => {
      let current2 = requests;
      let parallel5 = parallelCollectionEmpty();
      let stack = empty10();
      let sequential5 = empty10();
      while (1) {
        switch (current2._tag) {
          case "Empty": {
            if (isNil(stack)) {
              return [parallel5, sequential5];
            }
            current2 = stack.head;
            stack = stack.tail;
            break;
          }
          case "Par": {
            stack = cons(current2.right, stack);
            current2 = current2.left;
            break;
          }
          case "Seq": {
            const left3 = current2.left;
            const right3 = current2.right;
            switch (left3._tag) {
              case "Empty": {
                current2 = right3;
                break;
              }
              case "Par": {
                const l = left3.left;
                const r = left3.right;
                current2 = par(seq(l, right3), seq(r, right3));
                break;
              }
              case "Seq": {
                const l = left3.left;
                const r = left3.right;
                current2 = seq(l, seq(r, right3));
                break;
              }
              case "Single": {
                current2 = left3;
                sequential5 = cons(right3, sequential5);
                break;
              }
            }
            break;
          }
          case "Single": {
            parallel5 = parallelCollectionAdd(parallel5, current2);
            if (isNil(stack)) {
              return [parallel5, sequential5];
            }
            current2 = stack.head;
            stack = stack.tail;
            break;
          }
        }
      }
      throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
    }, "step");
    merge4 = /* @__PURE__ */ __name((sequential5, parallel5) => {
      if (isNil(sequential5)) {
        return of3(parallelCollectionToSequentialCollection(parallel5));
      }
      if (parallelCollectionIsEmpty(parallel5)) {
        return sequential5;
      }
      const seqHeadKeys = sequentialCollectionKeys(sequential5.head);
      const parKeys = parallelCollectionKeys(parallel5);
      if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
        return cons(sequentialCollectionCombine(sequential5.head, parallelCollectionToSequentialCollection(parallel5)), sequential5.tail);
      }
      return cons(parallelCollectionToSequentialCollection(parallel5), sequential5);
    }, "merge");
    EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");
    EntryImpl = class {
      static {
        __name(this, "EntryImpl");
      }
      request;
      result;
      listeners;
      ownerId;
      state;
      [EntryTypeId] = blockedRequestVariance;
      constructor(request2, result, listeners2, ownerId, state) {
        this.request = request2;
        this.result = result;
        this.listeners = listeners2;
        this.ownerId = ownerId;
        this.state = state;
      }
    };
    blockedRequestVariance = {
      /* c8 ignore next */
      _R: /* @__PURE__ */ __name((_) => _, "_R")
    };
    makeEntry = /* @__PURE__ */ __name((options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state), "makeEntry");
    RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
    parallelVariance = {
      /* c8 ignore next */
      _R: /* @__PURE__ */ __name((_) => _, "_R")
    };
    ParallelImpl = class {
      static {
        __name(this, "ParallelImpl");
      }
      map;
      [RequestBlockParallelTypeId] = parallelVariance;
      constructor(map31) {
        this.map = map31;
      }
    };
    parallelCollectionEmpty = /* @__PURE__ */ __name(() => new ParallelImpl(empty9()), "parallelCollectionEmpty");
    parallelCollectionAdd = /* @__PURE__ */ __name((self2, blockedRequest) => new ParallelImpl(modifyAt2(self2.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest)))), "parallelCollectionAdd");
    parallelCollectionCombine = /* @__PURE__ */ __name((self2, that) => new ParallelImpl(reduce6(self2.map, that.map, (map31, value3, key) => set3(map31, key, match2(get7(map31, key), {
      onNone: /* @__PURE__ */ __name(() => value3, "onNone"),
      onSome: /* @__PURE__ */ __name((other) => appendAll2(value3, other), "onSome")
    })))), "parallelCollectionCombine");
    parallelCollectionIsEmpty = /* @__PURE__ */ __name((self2) => isEmpty3(self2.map), "parallelCollectionIsEmpty");
    parallelCollectionKeys = /* @__PURE__ */ __name((self2) => Array.from(keys2(self2.map)), "parallelCollectionKeys");
    parallelCollectionToSequentialCollection = /* @__PURE__ */ __name((self2) => sequentialCollectionMake(map8(self2.map, (x) => of2(x))), "parallelCollectionToSequentialCollection");
    SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
    sequentialVariance = {
      /* c8 ignore next */
      _R: /* @__PURE__ */ __name((_) => _, "_R")
    };
    SequentialImpl = class {
      static {
        __name(this, "SequentialImpl");
      }
      map;
      [SequentialCollectionTypeId] = sequentialVariance;
      constructor(map31) {
        this.map = map31;
      }
    };
    sequentialCollectionMake = /* @__PURE__ */ __name((map31) => new SequentialImpl(map31), "sequentialCollectionMake");
    sequentialCollectionCombine = /* @__PURE__ */ __name((self2, that) => new SequentialImpl(reduce6(that.map, self2.map, (map31, value3, key) => set3(map31, key, match2(get7(map31, key), {
      onNone: /* @__PURE__ */ __name(() => empty5(), "onNone"),
      onSome: /* @__PURE__ */ __name((a) => appendAll2(a, value3), "onSome")
    })))), "sequentialCollectionCombine");
    sequentialCollectionKeys = /* @__PURE__ */ __name((self2) => Array.from(keys2(self2.map)), "sequentialCollectionKeys");
    sequentialCollectionToChunk = /* @__PURE__ */ __name((self2) => Array.from(self2.map), "sequentialCollectionToChunk");
  }
});

// node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE, OP_EMPTY, OP_FAIL, OP_INTERRUPT, OP_PARALLEL, OP_SEQUENTIAL;
var init_cause = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/cause.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_DIE = "Die";
    OP_EMPTY = "Empty";
    OP_FAIL = "Fail";
    OP_INTERRUPT = "Interrupt";
    OP_PARALLEL = "Parallel";
    OP_SEQUENTIAL = "Sequential";
  }
});

// node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey, CauseTypeId, variance4, proto, empty17, fail, die, interrupt, parallel, sequential, isCause, isEmptyType, isFailType, isDieType, isEmpty5, isInterrupted, isInterruptedOnly, failures, defects, interruptors, failureOption, failureOrCause, flipCauseOption, interruptOption, keepDefects, keepDefectsAndElectFailures, stripFailures, electFailures, map10, flatMap7, flatten6, causeEquals, flattenCause, flattenCauseLoop, find, evaluateCause, IsInterruptedOnlyCauseReducer, OP_SEQUENTIAL_CASE, OP_PARALLEL_CASE, match5, reduce8, reduceWithContext, pretty, renderErrorCause, PrettyError, prettyErrorMessage, locationRegex, spanToTrace, prettyErrorStack, spanSymbol, prettyErrors;
var init_cause2 = __esm({
  "node_modules/effect/dist/esm/internal/cause.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Chunk();
    init_Either();
    init_Equal();
    init_Function();
    init_GlobalValue();
    init_Hash();
    init_HashSet();
    init_Inspectable();
    init_Option();
    init_Pipeable();
    init_Predicate();
    init_errors();
    init_cause();
    CauseSymbolKey = "effect/Cause";
    CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
    variance4 = {
      /* c8 ignore next */
      _E: /* @__PURE__ */ __name((_) => _, "_E")
    };
    proto = {
      [CauseTypeId]: variance4,
      [symbol]() {
        return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
      },
      [symbol2](that) {
        return isCause(that) && causeEquals(this, that);
      },
      pipe() {
        return pipeArguments(this, arguments);
      },
      toJSON() {
        switch (this._tag) {
          case "Empty":
            return {
              _id: "Cause",
              _tag: this._tag
            };
          case "Die":
            return {
              _id: "Cause",
              _tag: this._tag,
              defect: toJSON(this.defect)
            };
          case "Interrupt":
            return {
              _id: "Cause",
              _tag: this._tag,
              fiberId: this.fiberId.toJSON()
            };
          case "Fail":
            return {
              _id: "Cause",
              _tag: this._tag,
              failure: toJSON(this.error)
            };
          case "Sequential":
          case "Parallel":
            return {
              _id: "Cause",
              _tag: this._tag,
              left: toJSON(this.left),
              right: toJSON(this.right)
            };
        }
      },
      toString() {
        return pretty(this);
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      }
    };
    empty17 = /* @__PURE__ */ (() => {
      const o = /* @__PURE__ */ Object.create(proto);
      o._tag = OP_EMPTY;
      return o;
    })();
    fail = /* @__PURE__ */ __name((error50) => {
      const o = Object.create(proto);
      o._tag = OP_FAIL;
      o.error = error50;
      return o;
    }, "fail");
    die = /* @__PURE__ */ __name((defect) => {
      const o = Object.create(proto);
      o._tag = OP_DIE;
      o.defect = defect;
      return o;
    }, "die");
    interrupt = /* @__PURE__ */ __name((fiberId3) => {
      const o = Object.create(proto);
      o._tag = OP_INTERRUPT;
      o.fiberId = fiberId3;
      return o;
    }, "interrupt");
    parallel = /* @__PURE__ */ __name((left3, right3) => {
      const o = Object.create(proto);
      o._tag = OP_PARALLEL;
      o.left = left3;
      o.right = right3;
      return o;
    }, "parallel");
    sequential = /* @__PURE__ */ __name((left3, right3) => {
      const o = Object.create(proto);
      o._tag = OP_SEQUENTIAL;
      o.left = left3;
      o.right = right3;
      return o;
    }, "sequential");
    isCause = /* @__PURE__ */ __name((u) => hasProperty(u, CauseTypeId), "isCause");
    isEmptyType = /* @__PURE__ */ __name((self2) => self2._tag === OP_EMPTY, "isEmptyType");
    isFailType = /* @__PURE__ */ __name((self2) => self2._tag === OP_FAIL, "isFailType");
    isDieType = /* @__PURE__ */ __name((self2) => self2._tag === OP_DIE, "isDieType");
    isEmpty5 = /* @__PURE__ */ __name((self2) => {
      if (self2._tag === OP_EMPTY) {
        return true;
      }
      return reduce8(self2, true, (acc, cause3) => {
        switch (cause3._tag) {
          case OP_EMPTY: {
            return some2(acc);
          }
          case OP_DIE:
          case OP_FAIL:
          case OP_INTERRUPT: {
            return some2(false);
          }
          default: {
            return none2();
          }
        }
      });
    }, "isEmpty");
    isInterrupted = /* @__PURE__ */ __name((self2) => isSome2(interruptOption(self2)), "isInterrupted");
    isInterruptedOnly = /* @__PURE__ */ __name((self2) => reduceWithContext(void 0, IsInterruptedOnlyCauseReducer)(self2), "isInterruptedOnly");
    failures = /* @__PURE__ */ __name((self2) => reverse2(reduce8(self2, empty5(), (list, cause3) => cause3._tag === OP_FAIL ? some2(pipe(list, prepend2(cause3.error))) : none2())), "failures");
    defects = /* @__PURE__ */ __name((self2) => reverse2(reduce8(self2, empty5(), (list, cause3) => cause3._tag === OP_DIE ? some2(pipe(list, prepend2(cause3.defect))) : none2())), "defects");
    interruptors = /* @__PURE__ */ __name((self2) => reduce8(self2, empty8(), (set10, cause3) => cause3._tag === OP_INTERRUPT ? some2(pipe(set10, add4(cause3.fiberId))) : none2()), "interruptors");
    failureOption = /* @__PURE__ */ __name((self2) => find(self2, (cause3) => cause3._tag === OP_FAIL ? some2(cause3.error) : none2()), "failureOption");
    failureOrCause = /* @__PURE__ */ __name((self2) => {
      const option5 = failureOption(self2);
      switch (option5._tag) {
        case "None": {
          return right2(self2);
        }
        case "Some": {
          return left2(option5.value);
        }
      }
    }, "failureOrCause");
    flipCauseOption = /* @__PURE__ */ __name((self2) => match5(self2, {
      onEmpty: some2(empty17),
      onFail: map2(fail),
      onDie: /* @__PURE__ */ __name((defect) => some2(die(defect)), "onDie"),
      onInterrupt: /* @__PURE__ */ __name((fiberId3) => some2(interrupt(fiberId3)), "onInterrupt"),
      onSequential: mergeWith(sequential),
      onParallel: mergeWith(parallel)
    }), "flipCauseOption");
    interruptOption = /* @__PURE__ */ __name((self2) => find(self2, (cause3) => cause3._tag === OP_INTERRUPT ? some2(cause3.fiberId) : none2()), "interruptOption");
    keepDefects = /* @__PURE__ */ __name((self2) => match5(self2, {
      onEmpty: none2(),
      onFail: /* @__PURE__ */ __name(() => none2(), "onFail"),
      onDie: /* @__PURE__ */ __name((defect) => some2(die(defect)), "onDie"),
      onInterrupt: /* @__PURE__ */ __name(() => none2(), "onInterrupt"),
      onSequential: mergeWith(sequential),
      onParallel: mergeWith(parallel)
    }), "keepDefects");
    keepDefectsAndElectFailures = /* @__PURE__ */ __name((self2) => match5(self2, {
      onEmpty: none2(),
      onFail: /* @__PURE__ */ __name((failure) => some2(die(failure)), "onFail"),
      onDie: /* @__PURE__ */ __name((defect) => some2(die(defect)), "onDie"),
      onInterrupt: /* @__PURE__ */ __name(() => none2(), "onInterrupt"),
      onSequential: mergeWith(sequential),
      onParallel: mergeWith(parallel)
    }), "keepDefectsAndElectFailures");
    stripFailures = /* @__PURE__ */ __name((self2) => match5(self2, {
      onEmpty: empty17,
      onFail: /* @__PURE__ */ __name(() => empty17, "onFail"),
      onDie: die,
      onInterrupt: interrupt,
      onSequential: sequential,
      onParallel: parallel
    }), "stripFailures");
    electFailures = /* @__PURE__ */ __name((self2) => match5(self2, {
      onEmpty: empty17,
      onFail: die,
      onDie: die,
      onInterrupt: interrupt,
      onSequential: sequential,
      onParallel: parallel
    }), "electFailures");
    map10 = /* @__PURE__ */ dual(2, (self2, f) => flatMap7(self2, (e) => fail(f(e))));
    flatMap7 = /* @__PURE__ */ dual(2, (self2, f) => match5(self2, {
      onEmpty: empty17,
      onFail: /* @__PURE__ */ __name((error50) => f(error50), "onFail"),
      onDie: /* @__PURE__ */ __name((defect) => die(defect), "onDie"),
      onInterrupt: /* @__PURE__ */ __name((fiberId3) => interrupt(fiberId3), "onInterrupt"),
      onSequential: /* @__PURE__ */ __name((left3, right3) => sequential(left3, right3), "onSequential"),
      onParallel: /* @__PURE__ */ __name((left3, right3) => parallel(left3, right3), "onParallel")
    }));
    flatten6 = /* @__PURE__ */ __name((self2) => flatMap7(self2, identity), "flatten");
    causeEquals = /* @__PURE__ */ __name((left3, right3) => {
      let leftStack = of2(left3);
      let rightStack = of2(right3);
      while (isNonEmpty2(leftStack) && isNonEmpty2(rightStack)) {
        const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce8([empty8(), empty5()], ([parallel5, sequential5], cause3) => {
          const [par2, seq2] = evaluateCause(cause3);
          return some2([pipe(parallel5, union3(par2)), pipe(sequential5, appendAll2(seq2))]);
        }));
        const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce8([empty8(), empty5()], ([parallel5, sequential5], cause3) => {
          const [par2, seq2] = evaluateCause(cause3);
          return some2([pipe(parallel5, union3(par2)), pipe(sequential5, appendAll2(seq2))]);
        }));
        if (!equals(leftParallel, rightParallel)) {
          return false;
        }
        leftStack = leftSequential;
        rightStack = rightSequential;
      }
      return true;
    }, "causeEquals");
    flattenCause = /* @__PURE__ */ __name((cause3) => {
      return flattenCauseLoop(of2(cause3), empty5());
    }, "flattenCause");
    flattenCauseLoop = /* @__PURE__ */ __name((causes, flattened) => {
      while (1) {
        const [parallel5, sequential5] = pipe(causes, reduce([empty8(), empty5()], ([parallel6, sequential6], cause3) => {
          const [par2, seq2] = evaluateCause(cause3);
          return [pipe(parallel6, union3(par2)), pipe(sequential6, appendAll2(seq2))];
        }));
        const updated = size3(parallel5) > 0 ? pipe(flattened, prepend2(parallel5)) : flattened;
        if (isEmpty(sequential5)) {
          return reverse2(updated);
        }
        causes = sequential5;
        flattened = updated;
      }
      throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
    }, "flattenCauseLoop");
    find = /* @__PURE__ */ dual(2, (self2, pf) => {
      const stack = [self2];
      while (stack.length > 0) {
        const item = stack.pop();
        const option5 = pf(item);
        switch (option5._tag) {
          case "None": {
            switch (item._tag) {
              case OP_SEQUENTIAL:
              case OP_PARALLEL: {
                stack.push(item.right);
                stack.push(item.left);
                break;
              }
            }
            break;
          }
          case "Some": {
            return option5;
          }
        }
      }
      return none2();
    });
    evaluateCause = /* @__PURE__ */ __name((self2) => {
      let cause3 = self2;
      const stack = [];
      let _parallel = empty8();
      let _sequential = empty5();
      while (cause3 !== void 0) {
        switch (cause3._tag) {
          case OP_EMPTY: {
            if (stack.length === 0) {
              return [_parallel, _sequential];
            }
            cause3 = stack.pop();
            break;
          }
          case OP_FAIL: {
            _parallel = add4(_parallel, make7(cause3._tag, cause3.error));
            if (stack.length === 0) {
              return [_parallel, _sequential];
            }
            cause3 = stack.pop();
            break;
          }
          case OP_DIE: {
            _parallel = add4(_parallel, make7(cause3._tag, cause3.defect));
            if (stack.length === 0) {
              return [_parallel, _sequential];
            }
            cause3 = stack.pop();
            break;
          }
          case OP_INTERRUPT: {
            _parallel = add4(_parallel, make7(cause3._tag, cause3.fiberId));
            if (stack.length === 0) {
              return [_parallel, _sequential];
            }
            cause3 = stack.pop();
            break;
          }
          case OP_SEQUENTIAL: {
            switch (cause3.left._tag) {
              case OP_EMPTY: {
                cause3 = cause3.right;
                break;
              }
              case OP_SEQUENTIAL: {
                cause3 = sequential(cause3.left.left, sequential(cause3.left.right, cause3.right));
                break;
              }
              case OP_PARALLEL: {
                cause3 = parallel(sequential(cause3.left.left, cause3.right), sequential(cause3.left.right, cause3.right));
                break;
              }
              default: {
                _sequential = prepend2(_sequential, cause3.right);
                cause3 = cause3.left;
                break;
              }
            }
            break;
          }
          case OP_PARALLEL: {
            stack.push(cause3.right);
            cause3 = cause3.left;
            break;
          }
        }
      }
      throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
    }, "evaluateCause");
    IsInterruptedOnlyCauseReducer = {
      emptyCase: constTrue,
      failCase: constFalse,
      dieCase: constFalse,
      interruptCase: constTrue,
      sequentialCase: /* @__PURE__ */ __name((_, left3, right3) => left3 && right3, "sequentialCase"),
      parallelCase: /* @__PURE__ */ __name((_, left3, right3) => left3 && right3, "parallelCase")
    };
    OP_SEQUENTIAL_CASE = "SequentialCase";
    OP_PARALLEL_CASE = "ParallelCase";
    match5 = /* @__PURE__ */ dual(2, (self2, {
      onDie,
      onEmpty,
      onFail,
      onInterrupt: onInterrupt3,
      onParallel,
      onSequential
    }) => {
      return reduceWithContext(self2, void 0, {
        emptyCase: /* @__PURE__ */ __name(() => onEmpty, "emptyCase"),
        failCase: /* @__PURE__ */ __name((_, error50) => onFail(error50), "failCase"),
        dieCase: /* @__PURE__ */ __name((_, defect) => onDie(defect), "dieCase"),
        interruptCase: /* @__PURE__ */ __name((_, fiberId3) => onInterrupt3(fiberId3), "interruptCase"),
        sequentialCase: /* @__PURE__ */ __name((_, left3, right3) => onSequential(left3, right3), "sequentialCase"),
        parallelCase: /* @__PURE__ */ __name((_, left3, right3) => onParallel(left3, right3), "parallelCase")
      });
    });
    reduce8 = /* @__PURE__ */ dual(3, (self2, zero3, pf) => {
      let accumulator = zero3;
      let cause3 = self2;
      const causes = [];
      while (cause3 !== void 0) {
        const option5 = pf(accumulator, cause3);
        accumulator = isSome2(option5) ? option5.value : accumulator;
        switch (cause3._tag) {
          case OP_SEQUENTIAL: {
            causes.push(cause3.right);
            cause3 = cause3.left;
            break;
          }
          case OP_PARALLEL: {
            causes.push(cause3.right);
            cause3 = cause3.left;
            break;
          }
          default: {
            cause3 = void 0;
            break;
          }
        }
        if (cause3 === void 0 && causes.length > 0) {
          cause3 = causes.pop();
        }
      }
      return accumulator;
    });
    reduceWithContext = /* @__PURE__ */ dual(3, (self2, context10, reducer) => {
      const input = [self2];
      const output = [];
      while (input.length > 0) {
        const cause3 = input.pop();
        switch (cause3._tag) {
          case OP_EMPTY: {
            output.push(right2(reducer.emptyCase(context10)));
            break;
          }
          case OP_FAIL: {
            output.push(right2(reducer.failCase(context10, cause3.error)));
            break;
          }
          case OP_DIE: {
            output.push(right2(reducer.dieCase(context10, cause3.defect)));
            break;
          }
          case OP_INTERRUPT: {
            output.push(right2(reducer.interruptCase(context10, cause3.fiberId)));
            break;
          }
          case OP_SEQUENTIAL: {
            input.push(cause3.right);
            input.push(cause3.left);
            output.push(left2({
              _tag: OP_SEQUENTIAL_CASE
            }));
            break;
          }
          case OP_PARALLEL: {
            input.push(cause3.right);
            input.push(cause3.left);
            output.push(left2({
              _tag: OP_PARALLEL_CASE
            }));
            break;
          }
        }
      }
      const accumulator = [];
      while (output.length > 0) {
        const either8 = output.pop();
        switch (either8._tag) {
          case "Left": {
            switch (either8.left._tag) {
              case OP_SEQUENTIAL_CASE: {
                const left3 = accumulator.pop();
                const right3 = accumulator.pop();
                const value3 = reducer.sequentialCase(context10, left3, right3);
                accumulator.push(value3);
                break;
              }
              case OP_PARALLEL_CASE: {
                const left3 = accumulator.pop();
                const right3 = accumulator.pop();
                const value3 = reducer.parallelCase(context10, left3, right3);
                accumulator.push(value3);
                break;
              }
            }
            break;
          }
          case "Right": {
            accumulator.push(either8.right);
            break;
          }
        }
      }
      if (accumulator.length === 0) {
        throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
      }
      return accumulator.pop();
    });
    pretty = /* @__PURE__ */ __name((cause3, options) => {
      if (isInterruptedOnly(cause3)) {
        return "All fibers interrupted without errors.";
      }
      return prettyErrors(cause3).map(function(e) {
        if (options?.renderErrorCause !== true || e.cause === void 0) {
          return e.stack;
        }
        return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
      }).join("\n");
    }, "pretty");
    renderErrorCause = /* @__PURE__ */ __name((cause3, prefix) => {
      const lines = cause3.stack.split("\n");
      let stack = `${prefix}[cause]: ${lines[0]}`;
      for (let i = 1, len = lines.length; i < len; i++) {
        stack += `
${prefix}${lines[i]}`;
      }
      if (cause3.cause) {
        stack += ` {
${renderErrorCause(cause3.cause, `${prefix}  `)}
${prefix}}`;
      }
      return stack;
    }, "renderErrorCause");
    PrettyError = class _PrettyError extends globalThis.Error {
      static {
        __name(this, "PrettyError");
      }
      span = void 0;
      constructor(originalError) {
        const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
        const prevLimit = Error.stackTraceLimit;
        Error.stackTraceLimit = 1;
        super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
          cause: new _PrettyError(originalError.cause)
        } : void 0);
        if (this.message === "") {
          this.message = "An error has occurred";
        }
        Error.stackTraceLimit = prevLimit;
        this.name = originalError instanceof Error ? originalError.name : "Error";
        if (originalErrorIsObject) {
          if (spanSymbol in originalError) {
            this.span = originalError[spanSymbol];
          }
          Object.keys(originalError).forEach((key) => {
            if (!(key in this)) {
              this[key] = originalError[key];
            }
          });
        }
        this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
      }
    };
    prettyErrorMessage = /* @__PURE__ */ __name((u) => {
      if (typeof u === "string") {
        return u;
      }
      if (typeof u === "object" && u !== null && u instanceof Error) {
        return u.message;
      }
      try {
        if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
          return u["toString"]();
        }
      } catch {
      }
      return stringifyCircular(u);
    }, "prettyErrorMessage");
    locationRegex = /\((.*)\)/g;
    spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
    prettyErrorStack = /* @__PURE__ */ __name((message, stack, span4) => {
      const out = [message];
      const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
      for (let i = 1; i < lines.length; i++) {
        if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
          i++;
          continue;
        }
        if (lines[i].includes("Generator.next")) {
          break;
        }
        if (lines[i].includes("effect_internal_function")) {
          break;
        }
        out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
      }
      if (span4) {
        let current2 = span4;
        let i = 0;
        while (current2 && current2._tag === "Span" && i < 10) {
          const stackFn = spanToTrace.get(current2);
          if (typeof stackFn === "function") {
            const stack2 = stackFn();
            if (typeof stack2 === "string") {
              const locationMatchAll = stack2.matchAll(locationRegex);
              let match20 = false;
              for (const [, location] of locationMatchAll) {
                match20 = true;
                out.push(`    at ${current2.name} (${location})`);
              }
              if (!match20) {
                out.push(`    at ${current2.name} (${stack2.replace(/^at /, "")})`);
              }
            } else {
              out.push(`    at ${current2.name}`);
            }
          } else {
            out.push(`    at ${current2.name}`);
          }
          current2 = getOrUndefined(current2.parent);
          i++;
        }
      }
      return out.join("\n");
    }, "prettyErrorStack");
    spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
    prettyErrors = /* @__PURE__ */ __name((cause3) => reduceWithContext(cause3, void 0, {
      emptyCase: /* @__PURE__ */ __name(() => [], "emptyCase"),
      dieCase: /* @__PURE__ */ __name((_, unknownError) => {
        return [new PrettyError(unknownError)];
      }, "dieCase"),
      failCase: /* @__PURE__ */ __name((_, error50) => {
        return [new PrettyError(error50)];
      }, "failCase"),
      interruptCase: /* @__PURE__ */ __name(() => [], "interruptCase"),
      parallelCase: /* @__PURE__ */ __name((_, l, r) => [...l, ...r], "parallelCase"),
      sequentialCase: /* @__PURE__ */ __name((_, l, r) => [...l, ...r], "sequentialCase")
    }), "prettyErrors");
  }
});

// node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING, OP_STATE_DONE;
var init_deferred = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/deferred.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_STATE_PENDING = "Pending";
    OP_STATE_DONE = "Done";
  }
});

// node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey, DeferredTypeId, deferredVariance, pending, done;
var init_deferred2 = __esm({
  "node_modules/effect/dist/esm/internal/deferred.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_deferred();
    DeferredSymbolKey = "effect/Deferred";
    DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
    deferredVariance = {
      /* c8 ignore next */
      _E: /* @__PURE__ */ __name((_) => _, "_E"),
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    pending = /* @__PURE__ */ __name((joiners) => {
      return {
        _tag: OP_STATE_PENDING,
        joiners
      };
    }, "pending");
    done = /* @__PURE__ */ __name((effect4) => {
      return {
        _tag: OP_STATE_DONE,
        effect: effect4
      };
    }, "done");
  }
});

// node_modules/effect/dist/esm/internal/singleShotGen.js
var SingleShotGen2;
var init_singleShotGen = __esm({
  "node_modules/effect/dist/esm/internal/singleShotGen.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SingleShotGen2 = class _SingleShotGen {
      static {
        __name(this, "SingleShotGen");
      }
      self;
      called = false;
      constructor(self2) {
        this.self = self2;
      }
      next(a) {
        return this.called ? {
          value: a,
          done: true
        } : (this.called = true, {
          value: this.self,
          done: false
        });
      }
      return(a) {
        return {
          value: a,
          done: true
        };
      }
      throw(e) {
        throw e;
      }
      [Symbol.iterator]() {
        return new _SingleShotGen(this.self);
      }
    };
  }
});

// node_modules/effect/dist/esm/internal/core.js
var blocked, runRequestBlock, EffectTypeId2, RevertFlags, EffectPrimitive, EffectPrimitiveFailure, EffectPrimitiveSuccess, isEffect, withFiberRuntime, acquireUseRelease, as2, asVoid2, custom, unsafeAsync, asyncInterrupt, async_, catchAllCause, catchAll, catchIf, catchSome, checkInterruptible, originalSymbol, capture, die2, dieMessage, dieSync, either2, exit2, fail2, failSync, failCause, failCauseSync, fiberId, fiberIdWith, flatMap8, andThen3, step2, flatten7, flip, matchCause, matchCauseEffect, matchEffect, forEachSequential, forEachSequentialDiscard, if_, interrupt2, interruptWith, interruptible2, interruptibleMask, intoDeferred, map11, mapBoth2, mapError, onError, onExit, onInterrupt, orElse2, orDie, orDieWith, partitionMap3, runtimeFlags, succeed, suspend, sync, tap2, transplant, attemptOrElse, uninterruptible, uninterruptibleMask, void_2, updateRuntimeFlags, whenEffect, whileLoop, fromIterator, gen3, fnUntraced, withConcurrency, withRequestBatching, withRuntimeFlags, withTracerEnabled, withTracerTiming, yieldNow, zip2, zipLeft2, zipRight2, zipWith4, never, interruptFiber, interruptAsFiber, logLevelAll, logLevelFatal, logLevelError, logLevelWarning, logLevelInfo, logLevelDebug, logLevelTrace, logLevelNone, FiberRefSymbolKey, FiberRefTypeId, fiberRefVariance, fiberRefGet, fiberRefGetWith, fiberRefSet, fiberRefModify, RequestResolverSymbolKey, RequestResolverTypeId, requestResolverVariance, RequestResolverImpl, isRequestResolver, fiberRefLocally, fiberRefLocallyWith, fiberRefUnsafeMake, fiberRefUnsafeMakeHashSet, fiberRefUnsafeMakeReadonlyArray, fiberRefUnsafeMakeContext, fiberRefUnsafeMakePatch, fiberRefUnsafeMakeRuntimeFlags, currentContext, currentSchedulingPriority, currentMaxOpsBeforeYield, currentLogAnnotations, currentLogLevel, currentLogSpan, withSchedulingPriority, withMaxOpsBeforeYield, currentConcurrency, currentRequestBatching, currentUnhandledErrorLogLevel, currentVersionMismatchErrorLogLevel, withUnhandledErrorLogLevel, currentMetricLabels, metricLabels, currentForkScopeOverride, currentInterruptedCause, currentTracerEnabled, currentTracerTimingEnabled, currentTracerSpanAnnotations, currentTracerSpanLinks, ScopeTypeId, CloseableScopeTypeId, scopeAddFinalizer, scopeAddFinalizerExit, scopeClose, scopeFork, causeSquash, causeSquashWith, YieldableError, makeException, RuntimeExceptionTypeId, RuntimeException, isRuntimeException, InterruptedExceptionTypeId, InterruptedException, isInterruptedException, IllegalArgumentExceptionTypeId, IllegalArgumentException, NoSuchElementExceptionTypeId, NoSuchElementException, isNoSuchElementException, InvalidPubSubCapacityExceptionTypeId, InvalidPubSubCapacityException, ExceededCapacityExceptionTypeId, ExceededCapacityException, TimeoutExceptionTypeId, TimeoutException, timeoutExceptionFromDuration, UnknownExceptionTypeId, UnknownException, exitIsExit, exitIsFailure, exitIsSuccess, exitAs, exitAsVoid, exitCollectAll, exitDie, exitFail, exitFailCause, exitFlatMap, exitFlatten, exitInterrupt, exitMap, exitMapBoth, exitMatch, exitMatchEffect, exitSucceed, exitVoid, exitZip, exitZipRight, exitZipWith, exitCollectAllInternal, deferredUnsafeMake, deferredMake, deferredMakeAs, deferredAwait, deferredComplete, deferredCompleteWith, deferredDone, deferredFail, deferredFailCause, deferredInterrupt, deferredInterruptWith, deferredIsDone, deferredPoll, deferredSucceed, deferredUnsafeDone, deferredInterruptJoiner, constContext, context3, contextWithEffect, provideContext, provideSomeContext, mapInputContext, filterEffectOrElse, filterEffectOrFail, currentSpanFromFiber, NoopSpanProto, noopSpan;
var init_core = __esm({
  "node_modules/effect/dist/esm/internal/core.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Chunk();
    init_Context();
    init_Duration();
    init_Either();
    init_Equal();
    init_FiberId();
    init_Function();
    init_GlobalValue();
    init_Hash();
    init_HashMap();
    init_Inspectable();
    init_List();
    init_MutableRef();
    init_Option();
    init_Pipeable();
    init_Predicate();
    init_RuntimeFlagsPatch();
    init_Utils();
    init_cause2();
    init_deferred2();
    init_differ();
    init_effectable();
    init_errors();
    init_deferred();
    init_effect();
    init_runtimeFlags();
    init_singleShotGen();
    blocked = /* @__PURE__ */ __name((blockedRequests, _continue3) => {
      const effect4 = new EffectPrimitive("Blocked");
      effect4.effect_instruction_i0 = blockedRequests;
      effect4.effect_instruction_i1 = _continue3;
      return effect4;
    }, "blocked");
    runRequestBlock = /* @__PURE__ */ __name((blockedRequests) => {
      const effect4 = new EffectPrimitive("RunBlocked");
      effect4.effect_instruction_i0 = blockedRequests;
      return effect4;
    }, "runRequestBlock");
    EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");
    RevertFlags = class {
      static {
        __name(this, "RevertFlags");
      }
      patch;
      op;
      _op = OP_REVERT_FLAGS;
      constructor(patch9, op) {
        this.patch = patch9;
        this.op = op;
      }
    };
    EffectPrimitive = class {
      static {
        __name(this, "EffectPrimitive");
      }
      _op;
      effect_instruction_i0 = void 0;
      effect_instruction_i1 = void 0;
      effect_instruction_i2 = void 0;
      trace = void 0;
      [EffectTypeId2] = effectVariance;
      constructor(_op) {
        this._op = _op;
      }
      [symbol2](that) {
        return this === that;
      }
      [symbol]() {
        return cached(this, random(this));
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
      toJSON() {
        return {
          _id: "Effect",
          _op: this._op,
          effect_instruction_i0: toJSON(this.effect_instruction_i0),
          effect_instruction_i1: toJSON(this.effect_instruction_i1),
          effect_instruction_i2: toJSON(this.effect_instruction_i2)
        };
      }
      toString() {
        return format(this.toJSON());
      }
      [NodeInspectSymbol]() {
        return this.toJSON();
      }
      [Symbol.iterator]() {
        return new SingleShotGen2(new YieldWrap(this));
      }
    };
    EffectPrimitiveFailure = class {
      static {
        __name(this, "EffectPrimitiveFailure");
      }
      _op;
      effect_instruction_i0 = void 0;
      effect_instruction_i1 = void 0;
      effect_instruction_i2 = void 0;
      trace = void 0;
      [EffectTypeId2] = effectVariance;
      constructor(_op) {
        this._op = _op;
        this._tag = _op;
      }
      [symbol2](that) {
        return exitIsExit(that) && that._op === "Failure" && // @ts-expect-error
        equals(this.effect_instruction_i0, that.effect_instruction_i0);
      }
      [symbol]() {
        return pipe(
          // @ts-expect-error
          string(this._tag),
          // @ts-expect-error
          combine(hash(this.effect_instruction_i0)),
          cached(this)
        );
      }
      get cause() {
        return this.effect_instruction_i0;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
      toJSON() {
        return {
          _id: "Exit",
          _tag: this._op,
          cause: this.cause.toJSON()
        };
      }
      toString() {
        return format(this.toJSON());
      }
      [NodeInspectSymbol]() {
        return this.toJSON();
      }
      [Symbol.iterator]() {
        return new SingleShotGen2(new YieldWrap(this));
      }
    };
    EffectPrimitiveSuccess = class {
      static {
        __name(this, "EffectPrimitiveSuccess");
      }
      _op;
      effect_instruction_i0 = void 0;
      effect_instruction_i1 = void 0;
      effect_instruction_i2 = void 0;
      trace = void 0;
      [EffectTypeId2] = effectVariance;
      constructor(_op) {
        this._op = _op;
        this._tag = _op;
      }
      [symbol2](that) {
        return exitIsExit(that) && that._op === "Success" && // @ts-expect-error
        equals(this.effect_instruction_i0, that.effect_instruction_i0);
      }
      [symbol]() {
        return pipe(
          // @ts-expect-error
          string(this._tag),
          // @ts-expect-error
          combine(hash(this.effect_instruction_i0)),
          cached(this)
        );
      }
      get value() {
        return this.effect_instruction_i0;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
      toJSON() {
        return {
          _id: "Exit",
          _tag: this._op,
          value: toJSON(this.value)
        };
      }
      toString() {
        return format(this.toJSON());
      }
      [NodeInspectSymbol]() {
        return this.toJSON();
      }
      [Symbol.iterator]() {
        return new SingleShotGen2(new YieldWrap(this));
      }
    };
    isEffect = /* @__PURE__ */ __name((u) => hasProperty(u, EffectTypeId2), "isEffect");
    withFiberRuntime = /* @__PURE__ */ __name((withRuntime) => {
      const effect4 = new EffectPrimitive(OP_WITH_RUNTIME);
      effect4.effect_instruction_i0 = withRuntime;
      return effect4;
    }, "withFiberRuntime");
    acquireUseRelease = /* @__PURE__ */ dual(3, (acquire2, use, release2) => uninterruptibleMask((restore) => flatMap8(acquire2, (a) => flatMap8(exit2(suspend(() => restore(use(a)))), (exit5) => {
      return suspend(() => release2(a, exit5)).pipe(matchCauseEffect({
        onFailure: /* @__PURE__ */ __name((cause3) => {
          switch (exit5._tag) {
            case OP_FAILURE:
              return failCause(sequential(exit5.effect_instruction_i0, cause3));
            case OP_SUCCESS:
              return failCause(cause3);
          }
        }, "onFailure"),
        onSuccess: /* @__PURE__ */ __name(() => exit5, "onSuccess")
      }));
    }))));
    as2 = /* @__PURE__ */ dual(2, (self2, value3) => flatMap8(self2, () => succeed(value3)));
    asVoid2 = /* @__PURE__ */ __name((self2) => as2(self2, void 0), "asVoid");
    custom = /* @__PURE__ */ __name(function() {
      const wrapper = new EffectPrimitive(OP_COMMIT);
      switch (arguments.length) {
        case 2: {
          wrapper.effect_instruction_i0 = arguments[0];
          wrapper.commit = arguments[1];
          break;
        }
        case 3: {
          wrapper.effect_instruction_i0 = arguments[0];
          wrapper.effect_instruction_i1 = arguments[1];
          wrapper.commit = arguments[2];
          break;
        }
        case 4: {
          wrapper.effect_instruction_i0 = arguments[0];
          wrapper.effect_instruction_i1 = arguments[1];
          wrapper.effect_instruction_i2 = arguments[2];
          wrapper.commit = arguments[3];
          break;
        }
        default: {
          throw new Error(getBugErrorMessage("you're not supposed to end up here"));
        }
      }
      return wrapper;
    }, "custom");
    unsafeAsync = /* @__PURE__ */ __name((register, blockingOn = none4) => {
      const effect4 = new EffectPrimitive(OP_ASYNC);
      let cancelerRef = void 0;
      effect4.effect_instruction_i0 = (resume2) => {
        cancelerRef = register(resume2);
      };
      effect4.effect_instruction_i1 = blockingOn;
      return onInterrupt(effect4, (_) => isEffect(cancelerRef) ? cancelerRef : void_2);
    }, "unsafeAsync");
    asyncInterrupt = /* @__PURE__ */ __name((register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn)), "asyncInterrupt");
    async_ = /* @__PURE__ */ __name((resume2, blockingOn = none4) => {
      return custom(resume2, function() {
        let backingResume = void 0;
        let pendingEffect = void 0;
        function proxyResume(effect5) {
          if (backingResume) {
            backingResume(effect5);
          } else if (pendingEffect === void 0) {
            pendingEffect = effect5;
          }
        }
        __name(proxyResume, "proxyResume");
        const effect4 = new EffectPrimitive(OP_ASYNC);
        effect4.effect_instruction_i0 = (resume3) => {
          backingResume = resume3;
          if (pendingEffect) {
            resume3(pendingEffect);
          }
        };
        effect4.effect_instruction_i1 = blockingOn;
        let cancelerRef = void 0;
        let controllerRef = void 0;
        if (this.effect_instruction_i0.length !== 1) {
          controllerRef = new AbortController();
          cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
        } else {
          cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
        }
        return cancelerRef || controllerRef ? onInterrupt(effect4, (_) => {
          if (controllerRef) {
            controllerRef.abort();
          }
          return cancelerRef ?? void_2;
        }) : effect4;
      });
    }, "async_");
    catchAllCause = /* @__PURE__ */ dual(2, (self2, f) => {
      const effect4 = new EffectPrimitive(OP_ON_FAILURE);
      effect4.effect_instruction_i0 = self2;
      effect4.effect_instruction_i1 = f;
      return effect4;
    });
    catchAll = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
      onFailure: f,
      onSuccess: succeed
    }));
    catchIf = /* @__PURE__ */ dual(3, (self2, predicate, f) => catchAllCause(self2, (cause3) => {
      const either8 = failureOrCause(cause3);
      switch (either8._tag) {
        case "Left":
          return predicate(either8.left) ? f(either8.left) : failCause(cause3);
        case "Right":
          return failCause(either8.right);
      }
    }));
    catchSome = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause3) => {
      const either8 = failureOrCause(cause3);
      switch (either8._tag) {
        case "Left":
          return pipe(pf(either8.left), getOrElse(() => failCause(cause3)));
        case "Right":
          return failCause(either8.right);
      }
    }));
    checkInterruptible = /* @__PURE__ */ __name((f) => withFiberRuntime((_, status2) => f(interruption(status2.runtimeFlags))), "checkInterruptible");
    originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
    capture = /* @__PURE__ */ __name((obj, span4) => {
      if (isSome2(span4)) {
        return new Proxy(obj, {
          has(target, p) {
            return p === spanSymbol || p === originalSymbol || p in target;
          },
          get(target, p) {
            if (p === spanSymbol) {
              return span4.value;
            }
            if (p === originalSymbol) {
              return obj;
            }
            return target[p];
          }
        });
      }
      return obj;
    }, "capture");
    die2 = /* @__PURE__ */ __name((defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect)), "die");
    dieMessage = /* @__PURE__ */ __name((message) => failCauseSync(() => die(new RuntimeException(message))), "dieMessage");
    dieSync = /* @__PURE__ */ __name((evaluate3) => flatMap8(sync(evaluate3), die2), "dieSync");
    either2 = /* @__PURE__ */ __name((self2) => matchEffect(self2, {
      onFailure: /* @__PURE__ */ __name((e) => succeed(left2(e)), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((a) => succeed(right2(a)), "onSuccess")
    }), "either");
    exit2 = /* @__PURE__ */ __name((self2) => matchCause(self2, {
      onFailure: exitFailCause,
      onSuccess: exitSucceed
    }), "exit");
    fail2 = /* @__PURE__ */ __name((error50) => isObject(error50) && !(spanSymbol in error50) ? withFiberRuntime((fiber) => failCause(fail(capture(error50, currentSpanFromFiber(fiber))))) : failCause(fail(error50)), "fail");
    failSync = /* @__PURE__ */ __name((evaluate3) => flatMap8(sync(evaluate3), fail2), "failSync");
    failCause = /* @__PURE__ */ __name((cause3) => {
      const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
      effect4.effect_instruction_i0 = cause3;
      return effect4;
    }, "failCause");
    failCauseSync = /* @__PURE__ */ __name((evaluate3) => flatMap8(sync(evaluate3), failCause), "failCauseSync");
    fiberId = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.id()));
    fiberIdWith = /* @__PURE__ */ __name((f) => withFiberRuntime((state) => f(state.id())), "fiberIdWith");
    flatMap8 = /* @__PURE__ */ dual(2, (self2, f) => {
      const effect4 = new EffectPrimitive(OP_ON_SUCCESS);
      effect4.effect_instruction_i0 = self2;
      effect4.effect_instruction_i1 = f;
      return effect4;
    });
    andThen3 = /* @__PURE__ */ dual(2, (self2, f) => flatMap8(self2, (a) => {
      const b = typeof f === "function" ? f(a) : f;
      if (isEffect(b)) {
        return b;
      } else if (isPromiseLike(b)) {
        return unsafeAsync((resume2) => {
          b.then((a2) => resume2(succeed(a2)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
        });
      }
      return succeed(b);
    }));
    step2 = /* @__PURE__ */ __name((self2) => {
      const effect4 = new EffectPrimitive("OnStep");
      effect4.effect_instruction_i0 = self2;
      return effect4;
    }, "step");
    flatten7 = /* @__PURE__ */ __name((self2) => flatMap8(self2, identity), "flatten");
    flip = /* @__PURE__ */ __name((self2) => matchEffect(self2, {
      onFailure: succeed,
      onSuccess: fail2
    }), "flip");
    matchCause = /* @__PURE__ */ dual(2, (self2, options) => matchCauseEffect(self2, {
      onFailure: /* @__PURE__ */ __name((cause3) => succeed(options.onFailure(cause3)), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((a) => succeed(options.onSuccess(a)), "onSuccess")
    }));
    matchCauseEffect = /* @__PURE__ */ dual(2, (self2, options) => {
      const effect4 = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
      effect4.effect_instruction_i0 = self2;
      effect4.effect_instruction_i1 = options.onFailure;
      effect4.effect_instruction_i2 = options.onSuccess;
      return effect4;
    });
    matchEffect = /* @__PURE__ */ dual(2, (self2, options) => matchCauseEffect(self2, {
      onFailure: /* @__PURE__ */ __name((cause3) => {
        const defects2 = defects(cause3);
        if (defects2.length > 0) {
          return failCause(electFailures(cause3));
        }
        const failures2 = failures(cause3);
        if (failures2.length > 0) {
          return options.onFailure(unsafeHead(failures2));
        }
        return failCause(cause3);
      }, "onFailure"),
      onSuccess: options.onSuccess
    }));
    forEachSequential = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
      const arr = fromIterable2(self2);
      const ret = allocate(arr.length);
      let i = 0;
      return as2(whileLoop({
        while: /* @__PURE__ */ __name(() => i < arr.length, "while"),
        body: /* @__PURE__ */ __name(() => f(arr[i], i), "body"),
        step: /* @__PURE__ */ __name((b) => {
          ret[i++] = b;
        }, "step")
      }), ret);
    }));
    forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
      const arr = fromIterable2(self2);
      let i = 0;
      return whileLoop({
        while: /* @__PURE__ */ __name(() => i < arr.length, "while"),
        body: /* @__PURE__ */ __name(() => f(arr[i], i), "body"),
        step: /* @__PURE__ */ __name(() => {
          i++;
        }, "step")
      });
    }));
    if_ = /* @__PURE__ */ dual((args2) => typeof args2[0] === "boolean" || isEffect(args2[0]), (self2, options) => isEffect(self2) ? flatMap8(self2, (b) => b ? options.onTrue() : options.onFalse()) : self2 ? options.onTrue() : options.onFalse());
    interrupt2 = /* @__PURE__ */ flatMap8(fiberId, (fiberId3) => interruptWith(fiberId3));
    interruptWith = /* @__PURE__ */ __name((fiberId3) => failCause(interrupt(fiberId3)), "interruptWith");
    interruptible2 = /* @__PURE__ */ __name((self2) => {
      const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
      effect4.effect_instruction_i0 = enable3(Interruption);
      effect4.effect_instruction_i1 = () => self2;
      return effect4;
    }, "interruptible");
    interruptibleMask = /* @__PURE__ */ __name((f) => custom(f, function() {
      const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
      effect4.effect_instruction_i0 = enable3(Interruption);
      effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
      return effect4;
    }), "interruptibleMask");
    intoDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => uninterruptibleMask((restore) => flatMap8(exit2(restore(self2)), (exit5) => deferredDone(deferred, exit5))));
    map11 = /* @__PURE__ */ dual(2, (self2, f) => flatMap8(self2, (a) => sync(() => f(a))));
    mapBoth2 = /* @__PURE__ */ dual(2, (self2, options) => matchEffect(self2, {
      onFailure: /* @__PURE__ */ __name((e) => failSync(() => options.onFailure(e)), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((a) => sync(() => options.onSuccess(a)), "onSuccess")
    }));
    mapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
      onFailure: /* @__PURE__ */ __name((cause3) => {
        const either8 = failureOrCause(cause3);
        switch (either8._tag) {
          case "Left": {
            return failSync(() => f(either8.left));
          }
          case "Right": {
            return failCause(either8.right);
          }
        }
      }, "onFailure"),
      onSuccess: succeed
    }));
    onError = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, (exit5) => exitIsSuccess(exit5) ? void_2 : cleanup(exit5.effect_instruction_i0)));
    onExit = /* @__PURE__ */ dual(2, (self2, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
      onFailure: /* @__PURE__ */ __name((cause1) => {
        const result = exitFailCause(cause1);
        return matchCauseEffect(cleanup(result), {
          onFailure: /* @__PURE__ */ __name((cause22) => exitFailCause(sequential(cause1, cause22)), "onFailure"),
          onSuccess: /* @__PURE__ */ __name(() => result, "onSuccess")
        });
      }, "onFailure"),
      onSuccess: /* @__PURE__ */ __name((success2) => {
        const result = exitSucceed(success2);
        return zipRight2(cleanup(result), result);
      }, "onSuccess")
    })));
    onInterrupt = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, exitMatch({
      onFailure: /* @__PURE__ */ __name((cause3) => isInterruptedOnly(cause3) ? asVoid2(cleanup(interruptors(cause3))) : void_2, "onFailure"),
      onSuccess: /* @__PURE__ */ __name(() => void_2, "onSuccess")
    })));
    orElse2 = /* @__PURE__ */ dual(2, (self2, that) => attemptOrElse(self2, that, succeed));
    orDie = /* @__PURE__ */ __name((self2) => orDieWith(self2, identity), "orDie");
    orDieWith = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
      onFailure: /* @__PURE__ */ __name((e) => die2(f(e)), "onFailure"),
      onSuccess: succeed
    }));
    partitionMap3 = partitionMap2;
    runtimeFlags = /* @__PURE__ */ withFiberRuntime((_, status2) => succeed(status2.runtimeFlags));
    succeed = /* @__PURE__ */ __name((value3) => {
      const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
      effect4.effect_instruction_i0 = value3;
      return effect4;
    }, "succeed");
    suspend = /* @__PURE__ */ __name((evaluate3) => {
      const effect4 = new EffectPrimitive(OP_COMMIT);
      effect4.commit = evaluate3;
      return effect4;
    }, "suspend");
    sync = /* @__PURE__ */ __name((thunk) => {
      const effect4 = new EffectPrimitive(OP_SYNC);
      effect4.effect_instruction_i0 = thunk;
      return effect4;
    }, "sync");
    tap2 = /* @__PURE__ */ dual((args2) => args2.length === 3 || args2.length === 2 && !(isObject(args2[1]) && "onlyEffect" in args2[1]), (self2, f) => flatMap8(self2, (a) => {
      const b = typeof f === "function" ? f(a) : f;
      if (isEffect(b)) {
        return as2(b, a);
      } else if (isPromiseLike(b)) {
        return unsafeAsync((resume2) => {
          b.then((_) => resume2(succeed(a)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
        });
      }
      return succeed(a);
    }));
    transplant = /* @__PURE__ */ __name((f) => withFiberRuntime((state) => {
      const scopeOverride = state.getFiberRef(currentForkScopeOverride);
      const scope5 = pipe(scopeOverride, getOrElse(() => state.scope()));
      return f(fiberRefLocally(currentForkScopeOverride, some2(scope5)));
    }), "transplant");
    attemptOrElse = /* @__PURE__ */ dual(3, (self2, that, onSuccess) => matchCauseEffect(self2, {
      onFailure: /* @__PURE__ */ __name((cause3) => {
        const defects2 = defects(cause3);
        if (defects2.length > 0) {
          return failCause(getOrThrow2(keepDefectsAndElectFailures(cause3)));
        }
        return that();
      }, "onFailure"),
      onSuccess
    }));
    uninterruptible = /* @__PURE__ */ __name((self2) => {
      const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
      effect4.effect_instruction_i0 = disable3(Interruption);
      effect4.effect_instruction_i1 = () => self2;
      return effect4;
    }, "uninterruptible");
    uninterruptibleMask = /* @__PURE__ */ __name((f) => custom(f, function() {
      const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
      effect4.effect_instruction_i0 = disable3(Interruption);
      effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
      return effect4;
    }), "uninterruptibleMask");
    void_2 = /* @__PURE__ */ succeed(void 0);
    updateRuntimeFlags = /* @__PURE__ */ __name((patch9) => {
      const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
      effect4.effect_instruction_i0 = patch9;
      effect4.effect_instruction_i1 = void 0;
      return effect4;
    }, "updateRuntimeFlags");
    whenEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap8(condition, (b) => {
      if (b) {
        return pipe(self2, map11(some2));
      }
      return succeed(none2());
    }));
    whileLoop = /* @__PURE__ */ __name((options) => {
      const effect4 = new EffectPrimitive(OP_WHILE);
      effect4.effect_instruction_i0 = options.while;
      effect4.effect_instruction_i1 = options.body;
      effect4.effect_instruction_i2 = options.step;
      return effect4;
    }, "whileLoop");
    fromIterator = /* @__PURE__ */ __name((iterator2) => suspend(() => {
      const effect4 = new EffectPrimitive(OP_ITERATOR);
      effect4.effect_instruction_i0 = iterator2();
      return effect4;
    }), "fromIterator");
    gen3 = /* @__PURE__ */ __name(function() {
      const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
      return fromIterator(() => f(pipe));
    }, "gen");
    fnUntraced = /* @__PURE__ */ __name((body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args2) {
      return fromIterator(() => body.apply(this, args2));
    } : function(...args2) {
      let effect4 = fromIterator(() => body.apply(this, args2));
      for (const x of pipeables) {
        effect4 = x(effect4, ...args2);
      }
      return effect4;
    }, "length", {
      value: body.length,
      configurable: true
    }), "fnUntraced");
    withConcurrency = /* @__PURE__ */ dual(2, (self2, concurrency) => fiberRefLocally(self2, currentConcurrency, concurrency));
    withRequestBatching = /* @__PURE__ */ dual(2, (self2, requestBatching) => fiberRefLocally(self2, currentRequestBatching, requestBatching));
    withRuntimeFlags = /* @__PURE__ */ dual(2, (self2, update6) => {
      const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
      effect4.effect_instruction_i0 = update6;
      effect4.effect_instruction_i1 = () => self2;
      return effect4;
    });
    withTracerEnabled = /* @__PURE__ */ dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerEnabled, enabled2));
    withTracerTiming = /* @__PURE__ */ dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerTimingEnabled, enabled2));
    yieldNow = /* @__PURE__ */ __name((options) => {
      const effect4 = new EffectPrimitive(OP_YIELD);
      return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect4, options.priority) : effect4;
    }, "yieldNow");
    zip2 = /* @__PURE__ */ dual(2, (self2, that) => flatMap8(self2, (a) => map11(that, (b) => [a, b])));
    zipLeft2 = /* @__PURE__ */ dual(2, (self2, that) => flatMap8(self2, (a) => as2(that, a)));
    zipRight2 = /* @__PURE__ */ dual(2, (self2, that) => flatMap8(self2, () => that));
    zipWith4 = /* @__PURE__ */ dual(3, (self2, that, f) => flatMap8(self2, (a) => map11(that, (b) => f(a, b))));
    never = /* @__PURE__ */ asyncInterrupt(() => {
      const interval = setInterval(() => {
      }, 2 ** 31 - 1);
      return sync(() => clearInterval(interval));
    });
    interruptFiber = /* @__PURE__ */ __name((self2) => flatMap8(fiberId, (fiberId3) => pipe(self2, interruptAsFiber(fiberId3))), "interruptFiber");
    interruptAsFiber = /* @__PURE__ */ dual(2, (self2, fiberId3) => flatMap8(self2.interruptAsFork(fiberId3), () => self2.await));
    logLevelAll = {
      _tag: "All",
      syslog: 0,
      label: "ALL",
      ordinal: Number.MIN_SAFE_INTEGER,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    logLevelFatal = {
      _tag: "Fatal",
      syslog: 2,
      label: "FATAL",
      ordinal: 5e4,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    logLevelError = {
      _tag: "Error",
      syslog: 3,
      label: "ERROR",
      ordinal: 4e4,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    logLevelWarning = {
      _tag: "Warning",
      syslog: 4,
      label: "WARN",
      ordinal: 3e4,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    logLevelInfo = {
      _tag: "Info",
      syslog: 6,
      label: "INFO",
      ordinal: 2e4,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    logLevelDebug = {
      _tag: "Debug",
      syslog: 7,
      label: "DEBUG",
      ordinal: 1e4,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    logLevelTrace = {
      _tag: "Trace",
      syslog: 7,
      label: "TRACE",
      ordinal: 0,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    logLevelNone = {
      _tag: "None",
      syslog: 7,
      label: "OFF",
      ordinal: Number.MAX_SAFE_INTEGER,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    FiberRefSymbolKey = "effect/FiberRef";
    FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
    fiberRefVariance = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    fiberRefGet = /* @__PURE__ */ __name((self2) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self2))), "fiberRefGet");
    fiberRefGetWith = /* @__PURE__ */ dual(2, (self2, f) => flatMap8(fiberRefGet(self2), f));
    fiberRefSet = /* @__PURE__ */ dual(2, (self2, value3) => fiberRefModify(self2, () => [void 0, value3]));
    fiberRefModify = /* @__PURE__ */ dual(2, (self2, f) => withFiberRuntime((state) => {
      const [b, a] = f(state.getFiberRef(self2));
      state.setFiberRef(self2, a);
      return succeed(b);
    }));
    RequestResolverSymbolKey = "effect/RequestResolver";
    RequestResolverTypeId = /* @__PURE__ */ Symbol.for(RequestResolverSymbolKey);
    requestResolverVariance = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A"),
      /* c8 ignore next */
      _R: /* @__PURE__ */ __name((_) => _, "_R")
    };
    RequestResolverImpl = class _RequestResolverImpl {
      static {
        __name(this, "RequestResolverImpl");
      }
      runAll;
      target;
      [RequestResolverTypeId] = requestResolverVariance;
      constructor(runAll, target) {
        this.runAll = runAll;
        this.target = target;
      }
      [symbol]() {
        return cached(this, this.target ? hash(this.target) : random(this));
      }
      [symbol2](that) {
        return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;
      }
      identified(...ids3) {
        return new _RequestResolverImpl(this.runAll, fromIterable3(ids3));
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    isRequestResolver = /* @__PURE__ */ __name((u) => hasProperty(u, RequestResolverTypeId), "isRequestResolver");
    fiberRefLocally = /* @__PURE__ */ dual(3, (use, self2, value3) => acquireUseRelease(zipLeft2(fiberRefGet(self2), fiberRefSet(self2, value3)), () => use, (oldValue) => fiberRefSet(self2, oldValue)));
    fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use, self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocally(use, self2, f(a))));
    fiberRefUnsafeMake = /* @__PURE__ */ __name((initial, options) => fiberRefUnsafeMakePatch(initial, {
      differ: update(),
      fork: options?.fork ?? identity,
      join: options?.join
    }), "fiberRefUnsafeMake");
    fiberRefUnsafeMakeHashSet = /* @__PURE__ */ __name((initial) => {
      const differ3 = hashSet();
      return fiberRefUnsafeMakePatch(initial, {
        differ: differ3,
        fork: differ3.empty
      });
    }, "fiberRefUnsafeMakeHashSet");
    fiberRefUnsafeMakeReadonlyArray = /* @__PURE__ */ __name((initial) => {
      const differ3 = readonlyArray(update());
      return fiberRefUnsafeMakePatch(initial, {
        differ: differ3,
        fork: differ3.empty
      });
    }, "fiberRefUnsafeMakeReadonlyArray");
    fiberRefUnsafeMakeContext = /* @__PURE__ */ __name((initial) => {
      const differ3 = environment();
      return fiberRefUnsafeMakePatch(initial, {
        differ: differ3,
        fork: differ3.empty
      });
    }, "fiberRefUnsafeMakeContext");
    fiberRefUnsafeMakePatch = /* @__PURE__ */ __name((initial, options) => {
      const _fiberRef = {
        ...CommitPrototype,
        [FiberRefTypeId]: fiberRefVariance,
        initial,
        commit() {
          return fiberRefGet(this);
        },
        diff: /* @__PURE__ */ __name((oldValue, newValue) => options.differ.diff(oldValue, newValue), "diff"),
        combine: /* @__PURE__ */ __name((first3, second) => options.differ.combine(first3, second), "combine"),
        patch: /* @__PURE__ */ __name((patch9) => (oldValue) => options.differ.patch(patch9, oldValue), "patch"),
        fork: options.fork,
        join: options.join ?? ((_, n) => n)
      };
      return _fiberRef;
    }, "fiberRefUnsafeMakePatch");
    fiberRefUnsafeMakeRuntimeFlags = /* @__PURE__ */ __name((initial) => fiberRefUnsafeMakePatch(initial, {
      differ,
      fork: differ.empty
    }), "fiberRefUnsafeMakeRuntimeFlags");
    currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty4()));
    currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
    currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
    currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty9()));
    currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
    currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty10()));
    withSchedulingPriority = /* @__PURE__ */ dual(2, (self2, scheduler2) => fiberRefLocally(self2, currentSchedulingPriority, scheduler2));
    withMaxOpsBeforeYield = /* @__PURE__ */ dual(2, (self2, scheduler2) => fiberRefLocally(self2, currentMaxOpsBeforeYield, scheduler2));
    currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
    currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
    currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
    currentVersionMismatchErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelWarning)));
    withUnhandledErrorLogLevel = /* @__PURE__ */ dual(2, (self2, level) => fiberRefLocally(self2, currentUnhandledErrorLogLevel, level));
    currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty2()));
    metricLabels = /* @__PURE__ */ fiberRefGet(currentMetricLabels);
    currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
      fork: /* @__PURE__ */ __name(() => none2(), "fork"),
      join: /* @__PURE__ */ __name((parent, _) => parent, "join")
    }));
    currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty17, {
      fork: /* @__PURE__ */ __name(() => empty17, "fork"),
      join: /* @__PURE__ */ __name((parent, _) => parent, "join")
    }));
    currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
    currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
    currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty9()));
    currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty5()));
    ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
    CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
    scopeAddFinalizer = /* @__PURE__ */ __name((self2, finalizer3) => self2.addFinalizer(() => asVoid2(finalizer3)), "scopeAddFinalizer");
    scopeAddFinalizerExit = /* @__PURE__ */ __name((self2, finalizer3) => self2.addFinalizer(finalizer3), "scopeAddFinalizerExit");
    scopeClose = /* @__PURE__ */ __name((self2, exit5) => self2.close(exit5), "scopeClose");
    scopeFork = /* @__PURE__ */ __name((self2, strategy) => self2.fork(strategy), "scopeFork");
    causeSquash = /* @__PURE__ */ __name((self2) => {
      return causeSquashWith(identity)(self2);
    }, "causeSquash");
    causeSquashWith = /* @__PURE__ */ dual(2, (self2, f) => {
      const option5 = pipe(self2, failureOption, map2(f));
      switch (option5._tag) {
        case "None": {
          return pipe(defects(self2), head2, match2({
            onNone: /* @__PURE__ */ __name(() => {
              const interrupts = fromIterable2(interruptors(self2)).flatMap((fiberId3) => fromIterable2(ids2(fiberId3)).map((id2) => `#${id2}`));
              return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : void 0);
            }, "onNone"),
            onSome: identity
          }));
        }
        case "Some": {
          return option5.value;
        }
      }
    });
    YieldableError = /* @__PURE__ */ (function() {
      class YieldableError2 extends globalThis.Error {
        static {
          __name(this, "YieldableError");
        }
        commit() {
          return fail2(this);
        }
        toJSON() {
          const obj = {
            ...this
          };
          if (this.message) obj.message = this.message;
          if (this.cause) obj.cause = this.cause;
          return obj;
        }
        [NodeInspectSymbol]() {
          if (this.toString !== globalThis.Error.prototype.toString) {
            return this.stack ? `${this.toString()}
${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
          } else if ("Bun" in globalThis) {
            return pretty(fail(this), {
              renderErrorCause: true
            });
          }
          return this;
        }
      }
      Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
      return YieldableError2;
    })();
    makeException = /* @__PURE__ */ __name((proto14, tag2) => {
      class Base3 extends YieldableError {
        static {
          __name(this, "Base");
        }
        _tag = tag2;
      }
      Object.assign(Base3.prototype, proto14);
      Base3.prototype.name = tag2;
      return Base3;
    }, "makeException");
    RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
    RuntimeException = /* @__PURE__ */ makeException({
      [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
    }, "RuntimeException");
    isRuntimeException = /* @__PURE__ */ __name((u) => hasProperty(u, RuntimeExceptionTypeId), "isRuntimeException");
    InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
    InterruptedException = /* @__PURE__ */ makeException({
      [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
    }, "InterruptedException");
    isInterruptedException = /* @__PURE__ */ __name((u) => hasProperty(u, InterruptedExceptionTypeId), "isInterruptedException");
    IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
    IllegalArgumentException = /* @__PURE__ */ makeException({
      [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
    }, "IllegalArgumentException");
    NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
    NoSuchElementException = /* @__PURE__ */ makeException({
      [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
    }, "NoSuchElementException");
    isNoSuchElementException = /* @__PURE__ */ __name((u) => hasProperty(u, NoSuchElementExceptionTypeId), "isNoSuchElementException");
    InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
    InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
      [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
    }, "InvalidPubSubCapacityException");
    ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
    ExceededCapacityException = /* @__PURE__ */ makeException({
      [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
    }, "ExceededCapacityException");
    TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
    TimeoutException = /* @__PURE__ */ makeException({
      [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
    }, "TimeoutException");
    timeoutExceptionFromDuration = /* @__PURE__ */ __name((duration6) => new TimeoutException(`Operation timed out after '${format3(duration6)}'`), "timeoutExceptionFromDuration");
    UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
    UnknownException = /* @__PURE__ */ (function() {
      class UnknownException2 extends YieldableError {
        static {
          __name(this, "UnknownException");
        }
        _tag = "UnknownException";
        error;
        constructor(cause3, message) {
          super(message ?? "An unknown error occurred", {
            cause: cause3
          });
          this.error = cause3;
        }
      }
      Object.assign(UnknownException2.prototype, {
        [UnknownExceptionTypeId]: UnknownExceptionTypeId,
        name: "UnknownException"
      });
      return UnknownException2;
    })();
    exitIsExit = /* @__PURE__ */ __name((u) => isEffect(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure"), "exitIsExit");
    exitIsFailure = /* @__PURE__ */ __name((self2) => self2._tag === "Failure", "exitIsFailure");
    exitIsSuccess = /* @__PURE__ */ __name((self2) => self2._tag === "Success", "exitIsSuccess");
    exitAs = /* @__PURE__ */ dual(2, (self2, value3) => {
      switch (self2._tag) {
        case OP_FAILURE: {
          return exitFailCause(self2.effect_instruction_i0);
        }
        case OP_SUCCESS: {
          return exitSucceed(value3);
        }
      }
    });
    exitAsVoid = /* @__PURE__ */ __name((self2) => exitAs(self2, void 0), "exitAsVoid");
    exitCollectAll = /* @__PURE__ */ __name((exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential), "exitCollectAll");
    exitDie = /* @__PURE__ */ __name((defect) => exitFailCause(die(defect)), "exitDie");
    exitFail = /* @__PURE__ */ __name((error50) => exitFailCause(fail(error50)), "exitFail");
    exitFailCause = /* @__PURE__ */ __name((cause3) => {
      const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
      effect4.effect_instruction_i0 = cause3;
      return effect4;
    }, "exitFailCause");
    exitFlatMap = /* @__PURE__ */ dual(2, (self2, f) => {
      switch (self2._tag) {
        case OP_FAILURE: {
          return exitFailCause(self2.effect_instruction_i0);
        }
        case OP_SUCCESS: {
          return f(self2.effect_instruction_i0);
        }
      }
    });
    exitFlatten = /* @__PURE__ */ __name((self2) => pipe(self2, exitFlatMap(identity)), "exitFlatten");
    exitInterrupt = /* @__PURE__ */ __name((fiberId3) => exitFailCause(interrupt(fiberId3)), "exitInterrupt");
    exitMap = /* @__PURE__ */ dual(2, (self2, f) => {
      switch (self2._tag) {
        case OP_FAILURE:
          return exitFailCause(self2.effect_instruction_i0);
        case OP_SUCCESS:
          return exitSucceed(f(self2.effect_instruction_i0));
      }
    });
    exitMapBoth = /* @__PURE__ */ dual(2, (self2, {
      onFailure,
      onSuccess
    }) => {
      switch (self2._tag) {
        case OP_FAILURE:
          return exitFailCause(pipe(self2.effect_instruction_i0, map10(onFailure)));
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self2.effect_instruction_i0));
      }
    });
    exitMatch = /* @__PURE__ */ dual(2, (self2, {
      onFailure,
      onSuccess
    }) => {
      switch (self2._tag) {
        case OP_FAILURE:
          return onFailure(self2.effect_instruction_i0);
        case OP_SUCCESS:
          return onSuccess(self2.effect_instruction_i0);
      }
    });
    exitMatchEffect = /* @__PURE__ */ dual(2, (self2, {
      onFailure,
      onSuccess
    }) => {
      switch (self2._tag) {
        case OP_FAILURE:
          return onFailure(self2.effect_instruction_i0);
        case OP_SUCCESS:
          return onSuccess(self2.effect_instruction_i0);
      }
    });
    exitSucceed = /* @__PURE__ */ __name((value3) => {
      const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
      effect4.effect_instruction_i0 = value3;
      return effect4;
    }, "exitSucceed");
    exitVoid = /* @__PURE__ */ exitSucceed(void 0);
    exitZip = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
      onSuccess: /* @__PURE__ */ __name((a, a2) => [a, a2], "onSuccess"),
      onFailure: sequential
    }));
    exitZipRight = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
      onSuccess: /* @__PURE__ */ __name((_, a2) => a2, "onSuccess"),
      onFailure: sequential
    }));
    exitZipWith = /* @__PURE__ */ dual(3, (self2, that, {
      onFailure,
      onSuccess
    }) => {
      switch (self2._tag) {
        case OP_FAILURE: {
          switch (that._tag) {
            case OP_SUCCESS:
              return exitFailCause(self2.effect_instruction_i0);
            case OP_FAILURE: {
              return exitFailCause(onFailure(self2.effect_instruction_i0, that.effect_instruction_i0));
            }
          }
        }
        case OP_SUCCESS: {
          switch (that._tag) {
            case OP_SUCCESS:
              return exitSucceed(onSuccess(self2.effect_instruction_i0, that.effect_instruction_i0));
            case OP_FAILURE:
              return exitFailCause(that.effect_instruction_i0);
          }
        }
      }
    });
    exitCollectAllInternal = /* @__PURE__ */ __name((exits, combineCauses) => {
      const list = fromIterable3(exits);
      if (!isNonEmpty2(list)) {
        return none2();
      }
      return pipe(tailNonEmpty2(list), reduce(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current2) => pipe(accumulator, exitZipWith(current2, {
        onSuccess: /* @__PURE__ */ __name((list2, value3) => pipe(list2, prepend2(value3)), "onSuccess"),
        onFailure: combineCauses
      }))), exitMap(reverse2), exitMap((chunk4) => toReadonlyArray(chunk4)), some2);
    }, "exitCollectAllInternal");
    deferredUnsafeMake = /* @__PURE__ */ __name((fiberId3) => {
      const _deferred = {
        ...CommitPrototype,
        [DeferredTypeId]: deferredVariance,
        state: make12(pending([])),
        commit() {
          return deferredAwait(this);
        },
        blockingOn: fiberId3
      };
      return _deferred;
    }, "deferredUnsafeMake");
    deferredMake = /* @__PURE__ */ __name(() => flatMap8(fiberId, (id2) => deferredMakeAs(id2)), "deferredMake");
    deferredMakeAs = /* @__PURE__ */ __name((fiberId3) => sync(() => deferredUnsafeMake(fiberId3)), "deferredMakeAs");
    deferredAwait = /* @__PURE__ */ __name((self2) => asyncInterrupt((resume2) => {
      const state = get6(self2.state);
      switch (state._tag) {
        case OP_STATE_DONE: {
          return resume2(state.effect);
        }
        case OP_STATE_PENDING: {
          state.joiners.push(resume2);
          return deferredInterruptJoiner(self2, resume2);
        }
      }
    }, self2.blockingOn), "deferredAwait");
    deferredComplete = /* @__PURE__ */ dual(2, (self2, effect4) => intoDeferred(effect4, self2));
    deferredCompleteWith = /* @__PURE__ */ dual(2, (self2, effect4) => sync(() => {
      const state = get6(self2.state);
      switch (state._tag) {
        case OP_STATE_DONE: {
          return false;
        }
        case OP_STATE_PENDING: {
          set2(self2.state, done(effect4));
          for (let i = 0, len = state.joiners.length; i < len; i++) {
            state.joiners[i](effect4);
          }
          return true;
        }
      }
    }));
    deferredDone = /* @__PURE__ */ dual(2, (self2, exit5) => deferredCompleteWith(self2, exit5));
    deferredFail = /* @__PURE__ */ dual(2, (self2, error50) => deferredCompleteWith(self2, fail2(error50)));
    deferredFailCause = /* @__PURE__ */ dual(2, (self2, cause3) => deferredCompleteWith(self2, failCause(cause3)));
    deferredInterrupt = /* @__PURE__ */ __name((self2) => flatMap8(fiberId, (fiberId3) => deferredCompleteWith(self2, interruptWith(fiberId3))), "deferredInterrupt");
    deferredInterruptWith = /* @__PURE__ */ dual(2, (self2, fiberId3) => deferredCompleteWith(self2, interruptWith(fiberId3)));
    deferredIsDone = /* @__PURE__ */ __name((self2) => sync(() => get6(self2.state)._tag === OP_STATE_DONE), "deferredIsDone");
    deferredPoll = /* @__PURE__ */ __name((self2) => sync(() => {
      const state = get6(self2.state);
      switch (state._tag) {
        case OP_STATE_DONE: {
          return some2(state.effect);
        }
        case OP_STATE_PENDING: {
          return none2();
        }
      }
    }), "deferredPoll");
    deferredSucceed = /* @__PURE__ */ dual(2, (self2, value3) => deferredCompleteWith(self2, succeed(value3)));
    deferredUnsafeDone = /* @__PURE__ */ __name((self2, effect4) => {
      const state = get6(self2.state);
      if (state._tag === OP_STATE_PENDING) {
        set2(self2.state, done(effect4));
        for (let i = 0, len = state.joiners.length; i < len; i++) {
          state.joiners[i](effect4);
        }
      }
    }, "deferredUnsafeDone");
    deferredInterruptJoiner = /* @__PURE__ */ __name((self2, joiner) => sync(() => {
      const state = get6(self2.state);
      if (state._tag === OP_STATE_PENDING) {
        const index2 = state.joiners.indexOf(joiner);
        if (index2 >= 0) {
          state.joiners.splice(index2, 1);
        }
      }
    }), "deferredInterruptJoiner");
    constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
    context3 = /* @__PURE__ */ __name(() => constContext, "context");
    contextWithEffect = /* @__PURE__ */ __name((f) => flatMap8(context3(), f), "contextWithEffect");
    provideContext = /* @__PURE__ */ dual(2, (self2, context10) => fiberRefLocally(currentContext, context10)(self2));
    provideSomeContext = /* @__PURE__ */ dual(2, (self2, context10) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context10))(self2));
    mapInputContext = /* @__PURE__ */ dual(2, (self2, f) => contextWithEffect((context10) => provideContext(self2, f(context10))));
    filterEffectOrElse = /* @__PURE__ */ dual(2, (self2, options) => flatMap8(self2, (a) => flatMap8(options.predicate(a), (pass) => pass ? succeed(a) : options.orElse(a))));
    filterEffectOrFail = /* @__PURE__ */ dual(2, (self2, options) => filterEffectOrElse(self2, {
      predicate: options.predicate,
      orElse: /* @__PURE__ */ __name((a) => fail2(options.orFailWith(a)), "orElse")
    }));
    currentSpanFromFiber = /* @__PURE__ */ __name((fiber) => {
      const span4 = fiber.currentSpan;
      return span4 !== void 0 && span4._tag === "Span" ? some2(span4) : none2();
    }, "currentSpanFromFiber");
    NoopSpanProto = {
      _tag: "Span",
      spanId: "noop",
      traceId: "noop",
      sampled: false,
      status: {
        _tag: "Ended",
        startTime: /* @__PURE__ */ BigInt(0),
        endTime: /* @__PURE__ */ BigInt(0),
        exit: exitVoid
      },
      attributes: /* @__PURE__ */ new Map(),
      links: [],
      kind: "internal",
      attribute() {
      },
      event() {
      },
      end() {
      },
      addLinks() {
      }
    };
    noopSpan = /* @__PURE__ */ __name((options) => Object.assign(Object.create(NoopSpanProto), options), "noopSpan");
  }
});

// node_modules/effect/dist/esm/Deferred.js
var make19, _await, done2, fail3, failCause2, interrupt3, isDone, poll, succeed2, unsafeMake4, unsafeDone;
var init_Deferred = __esm({
  "node_modules/effect/dist/esm/Deferred.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_core();
    make19 = deferredMake;
    _await = deferredAwait;
    done2 = deferredDone;
    fail3 = deferredFail;
    failCause2 = deferredFailCause;
    interrupt3 = deferredInterrupt;
    isDone = deferredIsDone;
    poll = deferredPoll;
    succeed2 = deferredSucceed;
    unsafeMake4 = deferredUnsafeMake;
    unsafeDone = deferredUnsafeDone;
  }
});

// node_modules/effect/dist/esm/Exit.js
var isExit, isFailure, isSuccess, all4, die3, fail4, failCause3, flatten8, interrupt4, map12, mapBoth3, match6, succeed3, void_3, zip3, zipRight3;
var init_Exit = __esm({
  "node_modules/effect/dist/esm/Exit.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_core();
    isExit = exitIsExit;
    isFailure = exitIsFailure;
    isSuccess = exitIsSuccess;
    all4 = exitCollectAll;
    die3 = exitDie;
    fail4 = exitFail;
    failCause3 = exitFailCause;
    flatten8 = exitFlatten;
    interrupt4 = exitInterrupt;
    map12 = exitMap;
    mapBoth3 = exitMapBoth;
    match6 = exitMatch;
    succeed3 = exitSucceed;
    void_3 = exitVoid;
    zip3 = exitZip;
    zipRight3 = exitZipRight;
  }
});

// node_modules/effect/dist/esm/MutableHashMap.js
var TypeId10, MutableHashMapProto, MutableHashMapIterator, BucketIterator, empty18, get8, getFromBucket, has5, set4, removeFromBucket, remove5, size4;
var init_MutableHashMap = __esm({
  "node_modules/effect/dist/esm/MutableHashMap.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_Hash();
    init_Inspectable();
    init_Option();
    init_Pipeable();
    TypeId10 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
    MutableHashMapProto = {
      [TypeId10]: TypeId10,
      [Symbol.iterator]() {
        return new MutableHashMapIterator(this);
      },
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "MutableHashMap",
          values: Array.from(this).map(toJSON)
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    MutableHashMapIterator = class _MutableHashMapIterator {
      static {
        __name(this, "MutableHashMapIterator");
      }
      self;
      referentialIterator;
      bucketIterator;
      constructor(self2) {
        this.self = self2;
        this.referentialIterator = self2.referential[Symbol.iterator]();
      }
      next() {
        if (this.bucketIterator !== void 0) {
          return this.bucketIterator.next();
        }
        const result = this.referentialIterator.next();
        if (result.done) {
          this.bucketIterator = new BucketIterator(this.self.buckets.values());
          return this.next();
        }
        return result;
      }
      [Symbol.iterator]() {
        return new _MutableHashMapIterator(this.self);
      }
    };
    BucketIterator = class {
      static {
        __name(this, "BucketIterator");
      }
      backing;
      constructor(backing) {
        this.backing = backing;
      }
      currentBucket;
      next() {
        if (this.currentBucket === void 0) {
          const result2 = this.backing.next();
          if (result2.done) {
            return result2;
          }
          this.currentBucket = result2.value[Symbol.iterator]();
        }
        const result = this.currentBucket.next();
        if (result.done) {
          this.currentBucket = void 0;
          return this.next();
        }
        return result;
      }
    };
    empty18 = /* @__PURE__ */ __name(() => {
      const self2 = Object.create(MutableHashMapProto);
      self2.referential = /* @__PURE__ */ new Map();
      self2.buckets = /* @__PURE__ */ new Map();
      self2.bucketsSize = 0;
      return self2;
    }, "empty");
    get8 = /* @__PURE__ */ dual(2, (self2, key) => {
      if (isEqual(key) === false) {
        return self2.referential.has(key) ? some2(self2.referential.get(key)) : none2();
      }
      const hash4 = key[symbol]();
      const bucket = self2.buckets.get(hash4);
      if (bucket === void 0) {
        return none2();
      }
      return getFromBucket(self2, bucket, key);
    });
    getFromBucket = /* @__PURE__ */ __name((self2, bucket, key, remove8 = false) => {
      for (let i = 0, len = bucket.length; i < len; i++) {
        if (key[symbol2](bucket[i][0])) {
          const value3 = bucket[i][1];
          if (remove8) {
            bucket.splice(i, 1);
            self2.bucketsSize--;
          }
          return some2(value3);
        }
      }
      return none2();
    }, "getFromBucket");
    has5 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(get8(self2, key)));
    set4 = /* @__PURE__ */ dual(3, (self2, key, value3) => {
      if (isEqual(key) === false) {
        self2.referential.set(key, value3);
        return self2;
      }
      const hash4 = key[symbol]();
      const bucket = self2.buckets.get(hash4);
      if (bucket === void 0) {
        self2.buckets.set(hash4, [[key, value3]]);
        self2.bucketsSize++;
        return self2;
      }
      removeFromBucket(self2, bucket, key);
      bucket.push([key, value3]);
      self2.bucketsSize++;
      return self2;
    });
    removeFromBucket = /* @__PURE__ */ __name((self2, bucket, key) => {
      for (let i = 0, len = bucket.length; i < len; i++) {
        if (key[symbol2](bucket[i][0])) {
          bucket.splice(i, 1);
          self2.bucketsSize--;
          return;
        }
      }
    }, "removeFromBucket");
    remove5 = /* @__PURE__ */ dual(2, (self2, key) => {
      if (isEqual(key) === false) {
        self2.referential.delete(key);
        return self2;
      }
      const hash4 = key[symbol]();
      const bucket = self2.buckets.get(hash4);
      if (bucket === void 0) {
        return self2;
      }
      removeFromBucket(self2, bucket, key);
      if (bucket.length === 0) {
        self2.buckets.delete(hash4);
      }
      return self2;
    });
    size4 = /* @__PURE__ */ __name((self2) => {
      return self2.referential.size + self2.bucketsSize;
    }, "size");
  }
});

// node_modules/effect/dist/esm/MutableList.js
var TypeId11, MutableListProto, makeNode, empty19, isEmpty6, length, append3, shift, remove6;
var init_MutableList = __esm({
  "node_modules/effect/dist/esm/MutableList.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_Inspectable();
    init_Pipeable();
    TypeId11 = /* @__PURE__ */ Symbol.for("effect/MutableList");
    MutableListProto = {
      [TypeId11]: TypeId11,
      [Symbol.iterator]() {
        let done13 = false;
        let head7 = this.head;
        return {
          next() {
            if (done13) {
              return this.return();
            }
            if (head7 == null) {
              done13 = true;
              return this.return();
            }
            const value3 = head7.value;
            head7 = head7.next;
            return {
              done: done13,
              value: value3
            };
          },
          return(value3) {
            if (!done13) {
              done13 = true;
            }
            return {
              done: true,
              value: value3
            };
          }
        };
      },
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "MutableList",
          values: Array.from(this).map(toJSON)
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    makeNode = /* @__PURE__ */ __name((value3) => ({
      value: value3,
      removed: false,
      prev: void 0,
      next: void 0
    }), "makeNode");
    empty19 = /* @__PURE__ */ __name(() => {
      const list = Object.create(MutableListProto);
      list.head = void 0;
      list.tail = void 0;
      list._length = 0;
      return list;
    }, "empty");
    isEmpty6 = /* @__PURE__ */ __name((self2) => length(self2) === 0, "isEmpty");
    length = /* @__PURE__ */ __name((self2) => self2._length, "length");
    append3 = /* @__PURE__ */ dual(2, (self2, value3) => {
      const node = makeNode(value3);
      if (self2.head === void 0) {
        self2.head = node;
      }
      if (self2.tail === void 0) {
        self2.tail = node;
      } else {
        self2.tail.next = node;
        node.prev = self2.tail;
        self2.tail = node;
      }
      ;
      self2._length += 1;
      return self2;
    });
    shift = /* @__PURE__ */ __name((self2) => {
      const head7 = self2.head;
      if (head7 !== void 0) {
        remove6(self2, head7);
        return head7.value;
      }
      return void 0;
    }, "shift");
    remove6 = /* @__PURE__ */ __name((self2, node) => {
      if (node.removed) {
        return;
      }
      node.removed = true;
      if (node.prev !== void 0 && node.next !== void 0) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
      } else if (node.prev !== void 0) {
        self2.tail = node.prev;
        node.prev.next = void 0;
      } else if (node.next !== void 0) {
        self2.head = node.next;
        node.next.prev = void 0;
      } else {
        self2.tail = void 0;
        self2.head = void 0;
      }
      if (self2._length > 0) {
        ;
        self2._length -= 1;
      }
    }, "remove");
  }
});

// node_modules/effect/dist/esm/MutableQueue.js
var TypeId12, EmptyMutableQueue, MutableQueueProto, make20, bounded, unbounded, length2, isEmpty7, capacity, offer, offerAll, poll2, pollUpTo;
var init_MutableQueue = __esm({
  "node_modules/effect/dist/esm/MutableQueue.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Chunk();
    init_Function();
    init_Inspectable();
    init_MutableList();
    init_Pipeable();
    TypeId12 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
    EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
    MutableQueueProto = {
      [TypeId12]: TypeId12,
      [Symbol.iterator]() {
        return Array.from(this.queue)[Symbol.iterator]();
      },
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "MutableQueue",
          values: Array.from(this).map(toJSON)
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    make20 = /* @__PURE__ */ __name((capacity7) => {
      const queue = Object.create(MutableQueueProto);
      queue.queue = empty19();
      queue.capacity = capacity7;
      return queue;
    }, "make");
    bounded = /* @__PURE__ */ __name((capacity7) => make20(capacity7), "bounded");
    unbounded = /* @__PURE__ */ __name(() => make20(void 0), "unbounded");
    length2 = /* @__PURE__ */ __name((self2) => length(self2.queue), "length");
    isEmpty7 = /* @__PURE__ */ __name((self2) => isEmpty6(self2.queue), "isEmpty");
    capacity = /* @__PURE__ */ __name((self2) => self2.capacity === void 0 ? Infinity : self2.capacity, "capacity");
    offer = /* @__PURE__ */ dual(2, (self2, value3) => {
      const queueLength = length(self2.queue);
      if (self2.capacity !== void 0 && queueLength === self2.capacity) {
        return false;
      }
      append3(value3)(self2.queue);
      return true;
    });
    offerAll = /* @__PURE__ */ dual(2, (self2, values4) => {
      const iterator2 = values4[Symbol.iterator]();
      let next4;
      let remainder2 = empty5();
      let offering = true;
      while (offering && (next4 = iterator2.next()) && !next4.done) {
        offering = offer(next4.value)(self2);
      }
      while (next4 != null && !next4.done) {
        remainder2 = prepend2(next4.value)(remainder2);
        next4 = iterator2.next();
      }
      return reverse2(remainder2);
    });
    poll2 = /* @__PURE__ */ dual(2, (self2, def) => {
      if (isEmpty6(self2.queue)) {
        return def;
      }
      return shift(self2.queue);
    });
    pollUpTo = /* @__PURE__ */ dual(2, (self2, n) => {
      let result = empty5();
      let count6 = 0;
      while (count6 < n) {
        const element2 = poll2(EmptyMutableQueue)(self2);
        if (element2 === EmptyMutableQueue) {
          break;
        }
        result = prepend2(element2)(result);
        count6 += 1;
      }
      return reverse2(result);
    });
  }
});

// node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey, ClockTypeId, clockTag, MAX_TIMER_MILLIS, globalClockScheduler, performanceNowNanos, processOrPerformanceNow, ClockImpl, make21;
var init_clock = __esm({
  "node_modules/effect/dist/esm/internal/clock.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Context();
    init_Duration();
    init_Function();
    init_core();
    ClockSymbolKey = "effect/Clock";
    ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
    clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
    MAX_TIMER_MILLIS = 2 ** 31 - 1;
    globalClockScheduler = {
      unsafeSchedule(task, duration6) {
        const millis2 = toMillis(duration6);
        if (millis2 > MAX_TIMER_MILLIS) {
          return constFalse;
        }
        let completed = false;
        const handle = setTimeout(() => {
          completed = true;
          task();
        }, millis2);
        return () => {
          clearTimeout(handle);
          return !completed;
        };
      }
    };
    performanceNowNanos = /* @__PURE__ */ (function() {
      const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
      if (typeof performance === "undefined" || typeof performance.now !== "function") {
        return () => BigInt(Date.now()) * bigint1e62;
      }
      let origin;
      return () => {
        if (origin === void 0) {
          origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
        }
        return origin + BigInt(Math.round(performance.now() * 1e6));
      };
    })();
    processOrPerformanceNow = /* @__PURE__ */ (function() {
      const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
      if (!processHrtime) {
        return performanceNowNanos;
      }
      const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
      return () => origin + processHrtime.bigint();
    })();
    ClockImpl = class {
      static {
        __name(this, "ClockImpl");
      }
      [ClockTypeId] = ClockTypeId;
      unsafeCurrentTimeMillis() {
        return Date.now();
      }
      unsafeCurrentTimeNanos() {
        return processOrPerformanceNow();
      }
      currentTimeMillis = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis());
      currentTimeNanos = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos());
      scheduler() {
        return succeed(globalClockScheduler);
      }
      sleep(duration6) {
        return async_((resume2) => {
          const canceler = globalClockScheduler.unsafeSchedule(() => resume2(void_2), duration6);
          return asVoid2(sync(canceler));
        });
      }
    };
    make21 = /* @__PURE__ */ __name(() => new ClockImpl(), "make");
  }
});

// node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND, OP_OR, OP_INVALID_DATA, OP_MISSING_DATA, OP_SOURCE_UNAVAILABLE, OP_UNSUPPORTED;
var init_configError = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/configError.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_AND = "And";
    OP_OR = "Or";
    OP_INVALID_DATA = "InvalidData";
    OP_MISSING_DATA = "MissingData";
    OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
    OP_UNSUPPORTED = "Unsupported";
  }
});

// node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey, ConfigErrorTypeId, proto2, And, Or, InvalidData, MissingData, SourceUnavailable, Unsupported, prefixed;
var init_configError2 = __esm({
  "node_modules/effect/dist/esm/internal/configError.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Function();
    init_configError();
    ConfigErrorSymbolKey = "effect/ConfigError";
    ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
    proto2 = {
      _tag: "ConfigError",
      [ConfigErrorTypeId]: ConfigErrorTypeId
    };
    And = /* @__PURE__ */ __name((self2, that) => {
      const error50 = Object.create(proto2);
      error50._op = OP_AND;
      error50.left = self2;
      error50.right = that;
      Object.defineProperty(error50, "toString", {
        enumerable: false,
        value() {
          return `${this.left} and ${this.right}`;
        }
      });
      Object.defineProperty(error50, "message", {
        enumerable: false,
        get() {
          return this.toString();
        }
      });
      return error50;
    }, "And");
    Or = /* @__PURE__ */ __name((self2, that) => {
      const error50 = Object.create(proto2);
      error50._op = OP_OR;
      error50.left = self2;
      error50.right = that;
      Object.defineProperty(error50, "toString", {
        enumerable: false,
        value() {
          return `${this.left} or ${this.right}`;
        }
      });
      Object.defineProperty(error50, "message", {
        enumerable: false,
        get() {
          return this.toString();
        }
      });
      return error50;
    }, "Or");
    InvalidData = /* @__PURE__ */ __name((path, message, options = {
      pathDelim: "."
    }) => {
      const error50 = Object.create(proto2);
      error50._op = OP_INVALID_DATA;
      error50.path = path;
      error50.message = message;
      Object.defineProperty(error50, "toString", {
        enumerable: false,
        value() {
          const path2 = pipe(this.path, join(options.pathDelim));
          return `(Invalid data at ${path2}: "${this.message}")`;
        }
      });
      return error50;
    }, "InvalidData");
    MissingData = /* @__PURE__ */ __name((path, message, options = {
      pathDelim: "."
    }) => {
      const error50 = Object.create(proto2);
      error50._op = OP_MISSING_DATA;
      error50.path = path;
      error50.message = message;
      Object.defineProperty(error50, "toString", {
        enumerable: false,
        value() {
          const path2 = pipe(this.path, join(options.pathDelim));
          return `(Missing data at ${path2}: "${this.message}")`;
        }
      });
      return error50;
    }, "MissingData");
    SourceUnavailable = /* @__PURE__ */ __name((path, message, cause3, options = {
      pathDelim: "."
    }) => {
      const error50 = Object.create(proto2);
      error50._op = OP_SOURCE_UNAVAILABLE;
      error50.path = path;
      error50.message = message;
      error50.cause = cause3;
      Object.defineProperty(error50, "toString", {
        enumerable: false,
        value() {
          const path2 = pipe(this.path, join(options.pathDelim));
          return `(Source unavailable at ${path2}: "${this.message}")`;
        }
      });
      return error50;
    }, "SourceUnavailable");
    Unsupported = /* @__PURE__ */ __name((path, message, options = {
      pathDelim: "."
    }) => {
      const error50 = Object.create(proto2);
      error50._op = OP_UNSUPPORTED;
      error50.path = path;
      error50.message = message;
      Object.defineProperty(error50, "toString", {
        enumerable: false,
        value() {
          const path2 = pipe(this.path, join(options.pathDelim));
          return `(Unsupported operation at ${path2}: "${this.message}")`;
        }
      });
      return error50;
    }, "Unsupported");
    prefixed = /* @__PURE__ */ dual(2, (self2, prefix) => {
      switch (self2._op) {
        case OP_AND: {
          return And(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
        }
        case OP_OR: {
          return Or(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
        }
        case OP_INVALID_DATA: {
          return InvalidData([...prefix, ...self2.path], self2.message);
        }
        case OP_MISSING_DATA: {
          return MissingData([...prefix, ...self2.path], self2.message);
        }
        case OP_SOURCE_UNAVAILABLE: {
          return SourceUnavailable([...prefix, ...self2.path], self2.message, self2.cause);
        }
        case OP_UNSUPPORTED: {
          return Unsupported([...prefix, ...self2.path], self2.message);
        }
      }
    });
  }
});

// node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty20, patch5;
var init_pathPatch = __esm({
  "node_modules/effect/dist/esm/internal/configProvider/pathPatch.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Either();
    init_Function();
    init_List();
    init_Option();
    init_configError2();
    empty20 = {
      _tag: "Empty"
    };
    patch5 = /* @__PURE__ */ dual(2, (path, patch9) => {
      let input = of3(patch9);
      let output = path;
      while (isCons(input)) {
        const patch10 = input.head;
        switch (patch10._tag) {
          case "Empty": {
            input = input.tail;
            break;
          }
          case "AndThen": {
            input = cons(patch10.first, cons(patch10.second, input.tail));
            break;
          }
          case "MapName": {
            output = map4(output, patch10.f);
            input = input.tail;
            break;
          }
          case "Nested": {
            output = prepend(output, patch10.name);
            input = input.tail;
            break;
          }
          case "Unnested": {
            const containsName = pipe(head(output), contains(patch10.name));
            if (containsName) {
              output = tailNonEmpty(output);
              input = input.tail;
            } else {
              return left2(MissingData(output, `Expected ${patch10.name} to be in path in ConfigProvider#unnested`));
            }
            break;
          }
        }
      }
      return right2(output);
    });
  }
});

// node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT, OP_FAIL2, OP_FALLBACK, OP_DESCRIBED, OP_LAZY, OP_MAP_OR_FAIL, OP_NESTED, OP_PRIMITIVE, OP_SEQUENCE, OP_HASHMAP, OP_ZIP_WITH;
var init_config2 = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/config.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_CONSTANT = "Constant";
    OP_FAIL2 = "Fail";
    OP_FALLBACK = "Fallback";
    OP_DESCRIBED = "Described";
    OP_LAZY = "Lazy";
    OP_MAP_OR_FAIL = "MapOrFail";
    OP_NESTED = "Nested";
    OP_PRIMITIVE = "Primitive";
    OP_SEQUENCE = "Sequence";
    OP_HASHMAP = "HashMap";
    OP_ZIP_WITH = "ZipWith";
  }
});

// node_modules/effect/dist/esm/internal/configProvider.js
var concat, ConfigProviderSymbolKey, ConfigProviderTypeId, configProviderTag, FlatConfigProviderSymbolKey, FlatConfigProviderTypeId, make23, makeFlat, fromFlat, fromEnv, extend, appendConfigPath, fromFlatLoop, fromFlatLoopFail, splitPathString, parsePrimitive, transpose, indicesFrom, QUOTED_INDEX_REGEX, parseQuotedIndex, parseInteger;
var init_configProvider = __esm({
  "node_modules/effect/dist/esm/internal/configProvider.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Context();
    init_Either();
    init_Function();
    init_HashMap();
    init_HashSet();
    init_Number();
    init_Option();
    init_Pipeable();
    init_RegExp();
    init_configError2();
    init_pathPatch();
    init_core();
    init_config2();
    concat = /* @__PURE__ */ __name((l, r) => [...l, ...r], "concat");
    ConfigProviderSymbolKey = "effect/ConfigProvider";
    ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
    configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
    FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
    FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
    make23 = /* @__PURE__ */ __name((options) => ({
      [ConfigProviderTypeId]: ConfigProviderTypeId,
      pipe() {
        return pipeArguments(this, arguments);
      },
      ...options
    }), "make");
    makeFlat = /* @__PURE__ */ __name((options) => ({
      [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
      patch: options.patch,
      load: /* @__PURE__ */ __name((path, config5, split4 = true) => options.load(path, config5, split4), "load"),
      enumerateChildren: options.enumerateChildren
    }), "makeFlat");
    fromFlat = /* @__PURE__ */ __name((flat) => make23({
      load: /* @__PURE__ */ __name((config5) => flatMap8(fromFlatLoop(flat, empty2(), config5, false), (chunk4) => match2(head(chunk4), {
        onNone: /* @__PURE__ */ __name(() => fail2(MissingData(empty2(), `Expected a single value having structure: ${config5}`)), "onNone"),
        onSome: succeed
      })), "load"),
      flattened: flat
    }), "fromFlat");
    fromEnv = /* @__PURE__ */ __name((options) => {
      const {
        pathDelim,
        seqDelim
      } = Object.assign({}, {
        pathDelim: "_",
        seqDelim: ","
      }, options);
      const makePathString = /* @__PURE__ */ __name((path) => pipe(path, join(pathDelim)), "makePathString");
      const unmakePathString = /* @__PURE__ */ __name((pathString) => pathString.split(pathDelim), "unmakePathString");
      const getEnv = /* @__PURE__ */ __name(() => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {}, "getEnv");
      const load = /* @__PURE__ */ __name((path, primitive2, split4 = true) => {
        const pathString = makePathString(path);
        const current2 = getEnv();
        const valueOpt = pathString in current2 ? some2(current2[pathString]) : none2();
        return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap8((value3) => parsePrimitive(value3, path, primitive2, seqDelim, split4)));
      }, "load");
      const enumerateChildren = /* @__PURE__ */ __name((path) => sync(() => {
        const current2 = getEnv();
        const keys5 = Object.keys(current2);
        const keyPaths = keys5.map((value3) => unmakePathString(value3.toUpperCase()));
        const filteredKeyPaths = keyPaths.filter((keyPath) => {
          for (let i = 0; i < path.length; i++) {
            const pathComponent = pipe(path, unsafeGet(i));
            const currentElement = keyPath[i];
            if (currentElement === void 0 || pathComponent !== currentElement) {
              return false;
            }
          }
          return true;
        }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
        return fromIterable6(filteredKeyPaths);
      }), "enumerateChildren");
      return fromFlat(makeFlat({
        load,
        enumerateChildren,
        patch: empty20
      }));
    }, "fromEnv");
    extend = /* @__PURE__ */ __name((leftDef, rightDef, left3, right3) => {
      const leftPad = unfold(left3.length, (index2) => index2 >= right3.length ? none2() : some2([leftDef(index2), index2 + 1]));
      const rightPad = unfold(right3.length, (index2) => index2 >= left3.length ? none2() : some2([rightDef(index2), index2 + 1]));
      const leftExtension = concat(left3, leftPad);
      const rightExtension = concat(right3, rightPad);
      return [leftExtension, rightExtension];
    }, "extend");
    appendConfigPath = /* @__PURE__ */ __name((path, config5) => {
      let op = config5;
      if (op._tag === "Nested") {
        const out = path.slice();
        while (op._tag === "Nested") {
          out.push(op.name);
          op = op.config;
        }
        return out;
      }
      return path;
    }, "appendConfigPath");
    fromFlatLoop = /* @__PURE__ */ __name((flat, prefix, config5, split4) => {
      const op = config5;
      switch (op._tag) {
        case OP_CONSTANT: {
          return succeed(of(op.value));
        }
        case OP_DESCRIBED: {
          return suspend(() => fromFlatLoop(flat, prefix, op.config, split4));
        }
        case OP_FAIL2: {
          return fail2(MissingData(prefix, op.message));
        }
        case OP_FALLBACK: {
          return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split4)), catchAll((error1) => {
            if (op.condition(error1)) {
              return pipe(fromFlatLoop(flat, prefix, op.second, split4), catchAll((error210) => fail2(Or(error1, error210))));
            }
            return fail2(error1);
          }));
        }
        case OP_LAZY: {
          return suspend(() => fromFlatLoop(flat, prefix, op.config(), split4));
        }
        case OP_MAP_OR_FAIL: {
          return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split4), flatMap8(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
        }
        case OP_NESTED: {
          return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split4));
        }
        case OP_PRIMITIVE: {
          return pipe(patch5(prefix, flat.patch), flatMap8((prefix2) => pipe(flat.load(prefix2, op, split4), flatMap8((values4) => {
            if (values4.length === 0) {
              const name = pipe(last(prefix2), getOrElse(() => "<n/a>"));
              return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
            }
            return succeed(values4);
          }))));
        }
        case OP_SEQUENCE: {
          return pipe(patch5(prefix, flat.patch), flatMap8((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap8(indicesFrom), flatMap8((indices) => {
            if (indices.length === 0) {
              return suspend(() => map11(fromFlatLoop(flat, prefix, op.config, true), of));
            }
            return pipe(forEachSequential(indices, (index2) => fromFlatLoop(flat, append(prefix, `[${index2}]`), op.config, true)), map11((chunkChunk) => {
              const flattened = flatten2(chunkChunk);
              if (flattened.length === 0) {
                return of(empty2());
              }
              return of(flattened);
            }));
          }))));
        }
        case OP_HASHMAP: {
          return suspend(() => pipe(patch5(prefix, flat.patch), flatMap8((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap8((keys5) => {
            return pipe(keys5, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split4)), map11((matrix) => {
              if (matrix.length === 0) {
                return of(empty9());
              }
              return pipe(transpose(matrix), map4((values4) => fromIterable7(zip(fromIterable2(keys5), values4))));
            }));
          })))));
        }
        case OP_ZIP_WITH: {
          return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split4), either2, flatMap8((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split4), either2, flatMap8((right3) => {
            if (isLeft2(left3) && isLeft2(right3)) {
              return fail2(And(left3.left, right3.left));
            }
            if (isLeft2(left3) && isRight2(right3)) {
              return fail2(left3.left);
            }
            if (isRight2(left3) && isLeft2(right3)) {
              return fail2(right3.left);
            }
            if (isRight2(left3) && isRight2(right3)) {
              const path = pipe(prefix, join("."));
              const fail19 = fromFlatLoopFail(prefix, path);
              const [lefts, rights] = extend(fail19, fail19, pipe(left3.right, map4(right2)), pipe(right3.right, map4(right2)));
              return pipe(lefts, zip(rights), forEachSequential(([left4, right4]) => pipe(zip2(left4, right4), map11(([left5, right5]) => op.zip(left5, right5)))));
            }
            throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
          })))));
        }
      }
    }, "fromFlatLoop");
    fromFlatLoopFail = /* @__PURE__ */ __name((prefix, path) => (index2) => left2(MissingData(prefix, `The element at index ${index2} in a sequence at path "${path}" was missing`)), "fromFlatLoopFail");
    splitPathString = /* @__PURE__ */ __name((text2, delim) => {
      const split4 = text2.split(new RegExp(`\\s*${escape2(delim)}\\s*`));
      return split4;
    }, "splitPathString");
    parsePrimitive = /* @__PURE__ */ __name((text2, path, primitive2, delimiter, split4) => {
      if (!split4) {
        return pipe(primitive2.parse(text2), mapBoth2({
          onFailure: prefixed(path),
          onSuccess: of
        }));
      }
      return pipe(splitPathString(text2, delimiter), forEachSequential((char2) => primitive2.parse(char2.trim())), mapError(prefixed(path)));
    }, "parsePrimitive");
    transpose = /* @__PURE__ */ __name((array7) => {
      return Object.keys(array7[0]).map((column) => array7.map((row) => row[column]));
    }, "transpose");
    indicesFrom = /* @__PURE__ */ __name((quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth2({
      onFailure: /* @__PURE__ */ __name(() => empty2(), "onFailure"),
      onSuccess: sort(Order)
    }), either2, map11(merge)), "indicesFrom");
    QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
    parseQuotedIndex = /* @__PURE__ */ __name((str) => {
      const match20 = str.match(QUOTED_INDEX_REGEX);
      if (match20 !== null) {
        const matchedIndex = match20[2];
        return pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
      }
      return none2();
    }, "parseQuotedIndex");
    parseInteger = /* @__PURE__ */ __name((str) => {
      const parsedIndex = Number.parseInt(str);
      return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
    }, "parseInteger");
  }
});

// node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId13, consoleTag, defaultConsole;
var init_console3 = __esm({
  "node_modules/effect/dist/esm/internal/defaultServices/console.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Context();
    init_core();
    TypeId13 = /* @__PURE__ */ Symbol.for("effect/Console");
    consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
    defaultConsole = {
      [TypeId13]: TypeId13,
      assert(condition, ...args2) {
        return sync(() => {
          console.assert(condition, ...args2);
        });
      },
      clear: /* @__PURE__ */ sync(() => {
        console.clear();
      }),
      count(label) {
        return sync(() => {
          console.count(label);
        });
      },
      countReset(label) {
        return sync(() => {
          console.countReset(label);
        });
      },
      debug(...args2) {
        return sync(() => {
          console.debug(...args2);
        });
      },
      dir(item, options) {
        return sync(() => {
          console.dir(item, options);
        });
      },
      dirxml(...args2) {
        return sync(() => {
          console.dirxml(...args2);
        });
      },
      error(...args2) {
        return sync(() => {
          console.error(...args2);
        });
      },
      group(options) {
        return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
      },
      groupEnd: /* @__PURE__ */ sync(() => {
        console.groupEnd();
      }),
      info(...args2) {
        return sync(() => {
          console.info(...args2);
        });
      },
      log(...args2) {
        return sync(() => {
          console.log(...args2);
        });
      },
      table(tabularData, properties) {
        return sync(() => {
          console.table(tabularData, properties);
        });
      },
      time(label) {
        return sync(() => console.time(label));
      },
      timeEnd(label) {
        return sync(() => console.timeEnd(label));
      },
      timeLog(label, ...args2) {
        return sync(() => {
          console.timeLog(label, ...args2);
        });
      },
      trace(...args2) {
        return sync(() => {
          console.trace(...args2);
        });
      },
      warn(...args2) {
        return sync(() => {
          console.warn(...args2);
        });
      },
      unsafe: console
    };
  }
});

// node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey, RandomTypeId, randomTag, RandomImpl, shuffleWith, swap, make24, FixedRandomImpl, fixed;
var init_random = __esm({
  "node_modules/effect/dist/esm/internal/random.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Chunk();
    init_Context();
    init_Function();
    init_Hash();
    init_Utils();
    init_core();
    RandomSymbolKey = "effect/Random";
    RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
    randomTag = /* @__PURE__ */ GenericTag("effect/Random");
    RandomImpl = class {
      static {
        __name(this, "RandomImpl");
      }
      seed;
      [RandomTypeId] = RandomTypeId;
      PRNG;
      constructor(seed) {
        this.seed = seed;
        this.PRNG = new PCGRandom(seed);
      }
      get next() {
        return sync(() => this.PRNG.number());
      }
      get nextBoolean() {
        return map11(this.next, (n) => n > 0.5);
      }
      get nextInt() {
        return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
      }
      nextRange(min4, max6) {
        return map11(this.next, (n) => (max6 - min4) * n + min4);
      }
      nextIntBetween(min4, max6) {
        return sync(() => this.PRNG.integer(max6 - min4) + min4);
      }
      shuffle(elements) {
        return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
      }
    };
    shuffleWith = /* @__PURE__ */ __name((elements, nextIntBounded) => {
      return suspend(() => pipe(sync(() => Array.from(elements)), flatMap8((buffer3) => {
        const numbers = [];
        for (let i = buffer3.length; i >= 2; i = i - 1) {
          numbers.push(i);
        }
        return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map11((k) => swap(buffer3, n - 1, k)))), as2(fromIterable3(buffer3)));
      })));
    }, "shuffleWith");
    swap = /* @__PURE__ */ __name((buffer3, index1, index2) => {
      const tmp = buffer3[index1];
      buffer3[index1] = buffer3[index2];
      buffer3[index2] = tmp;
      return buffer3;
    }, "swap");
    make24 = /* @__PURE__ */ __name((seed) => new RandomImpl(hash(seed)), "make");
    FixedRandomImpl = class {
      static {
        __name(this, "FixedRandomImpl");
      }
      values;
      [RandomTypeId] = RandomTypeId;
      index = 0;
      constructor(values4) {
        this.values = values4;
        if (values4.length === 0) {
          throw new Error("Requires at least one value");
        }
      }
      getNextValue() {
        const value3 = this.values[this.index];
        this.index = (this.index + 1) % this.values.length;
        return value3;
      }
      get next() {
        return sync(() => {
          const value3 = this.getNextValue();
          if (typeof value3 === "number") {
            return Math.max(0, Math.min(1, value3));
          }
          return hash(value3) / 2147483647;
        });
      }
      get nextBoolean() {
        return sync(() => {
          const value3 = this.getNextValue();
          if (typeof value3 === "boolean") {
            return value3;
          }
          return hash(value3) % 2 === 0;
        });
      }
      get nextInt() {
        return sync(() => {
          const value3 = this.getNextValue();
          if (typeof value3 === "number" && Number.isFinite(value3)) {
            return Math.round(value3);
          }
          return Math.abs(hash(value3));
        });
      }
      nextRange(min4, max6) {
        return map11(this.next, (n) => (max6 - min4) * n + min4);
      }
      nextIntBetween(min4, max6) {
        return sync(() => {
          const value3 = this.getNextValue();
          if (typeof value3 === "number" && Number.isFinite(value3)) {
            return Math.max(min4, Math.min(max6 - 1, Math.round(value3)));
          }
          const hash4 = Math.abs(hash(value3));
          return min4 + hash4 % (max6 - min4);
        });
      }
      shuffle(elements) {
        return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
      }
    };
    fixed = /* @__PURE__ */ __name((values4) => new FixedRandomImpl(values4), "fixed");
  }
});

// node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId, make25, tracerTag, spanTag, randomHexString, NativeSpan, nativeTracer, addSpanStackTrace, DisablePropagation;
var init_tracer = __esm({
  "node_modules/effect/dist/esm/internal/tracer.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Context();
    init_Function();
    TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
    make25 = /* @__PURE__ */ __name((options) => ({
      [TracerTypeId]: TracerTypeId,
      ...options
    }), "make");
    tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
    spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
    randomHexString = /* @__PURE__ */ (function() {
      const characters = "abcdef0123456789";
      const charactersLength = characters.length;
      return function(length4) {
        let result = "";
        for (let i = 0; i < length4; i++) {
          result += characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return result;
      };
    })();
    NativeSpan = class {
      static {
        __name(this, "NativeSpan");
      }
      name;
      parent;
      context;
      startTime;
      kind;
      _tag = "Span";
      spanId;
      traceId = "native";
      sampled = true;
      status;
      attributes;
      events = [];
      links;
      constructor(name, parent, context10, links, startTime, kind) {
        this.name = name;
        this.parent = parent;
        this.context = context10;
        this.startTime = startTime;
        this.kind = kind;
        this.status = {
          _tag: "Started",
          startTime
        };
        this.attributes = /* @__PURE__ */ new Map();
        this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
        this.spanId = randomHexString(16);
        this.links = Array.from(links);
      }
      end(endTime, exit5) {
        this.status = {
          _tag: "Ended",
          endTime,
          exit: exit5,
          startTime: this.status.startTime
        };
      }
      attribute(key, value3) {
        this.attributes.set(key, value3);
      }
      event(name, startTime, attributes) {
        this.events.push([name, startTime, attributes ?? {}]);
      }
      addLinks(links) {
        this.links.push(...links);
      }
    };
    nativeTracer = /* @__PURE__ */ make25({
      span: /* @__PURE__ */ __name((name, parent, context10, links, startTime, kind) => new NativeSpan(name, parent, context10, links, startTime, kind), "span"),
      context: /* @__PURE__ */ __name((f) => f(), "context")
    });
    addSpanStackTrace = /* @__PURE__ */ __name((options) => {
      if (options?.captureStackTrace === false) {
        return options;
      } else if (options?.captureStackTrace !== void 0 && typeof options.captureStackTrace !== "boolean") {
        return options;
      }
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 3;
      const traceError = new Error();
      Error.stackTraceLimit = limit;
      let cache = false;
      return {
        ...options,
        captureStackTrace: /* @__PURE__ */ __name(() => {
          if (cache !== false) {
            return cache;
          }
          if (traceError.stack !== void 0) {
            const stack = traceError.stack.split("\n");
            if (stack[3] !== void 0) {
              cache = stack[3].trim();
              return cache;
            }
          }
        }, "captureStackTrace")
      };
    }, "addSpanStackTrace");
    DisablePropagation = /* @__PURE__ */ Reference2()("effect/Tracer/DisablePropagation", {
      defaultValue: constFalse
    });
  }
});

// node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices, currentServices, sleep, defaultServicesWith, clockWith, currentTimeMillis, currentTimeNanos, withClock, withConfigProvider, configProviderWith, config2, randomWith, withRandom, next, tracerWith, withTracer;
var init_defaultServices = __esm({
  "node_modules/effect/dist/esm/internal/defaultServices.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Context();
    init_Duration();
    init_Function();
    init_GlobalValue();
    init_clock();
    init_configProvider();
    init_core();
    init_console3();
    init_random();
    init_tracer();
    liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty4(), /* @__PURE__ */ add2(clockTag, /* @__PURE__ */ make21()), /* @__PURE__ */ add2(consoleTag, defaultConsole), /* @__PURE__ */ add2(randomTag, /* @__PURE__ */ make24(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add2(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add2(tracerTag, nativeTracer));
    currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
    sleep = /* @__PURE__ */ __name((duration6) => {
      const decodedDuration = decode(duration6);
      return clockWith((clock3) => clock3.sleep(decodedDuration));
    }, "sleep");
    defaultServicesWith = /* @__PURE__ */ __name((f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices)), "defaultServicesWith");
    clockWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key))), "clockWith");
    currentTimeMillis = /* @__PURE__ */ clockWith((clock3) => clock3.currentTimeMillis);
    currentTimeNanos = /* @__PURE__ */ clockWith((clock3) => clock3.currentTimeNanos);
    withClock = /* @__PURE__ */ dual(2, (effect4, c) => fiberRefLocallyWith(currentServices, add2(clockTag, c))(effect4));
    withConfigProvider = /* @__PURE__ */ dual(2, (self2, provider) => fiberRefLocallyWith(currentServices, add2(configProviderTag, provider))(self2));
    configProviderWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key))), "configProviderWith");
    config2 = /* @__PURE__ */ __name((config5) => configProviderWith((_) => _.load(config5)), "config");
    randomWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(randomTag.key))), "randomWith");
    withRandom = /* @__PURE__ */ dual(2, (effect4, value3) => fiberRefLocallyWith(currentServices, add2(randomTag, value3))(effect4));
    next = /* @__PURE__ */ randomWith((random4) => random4.next);
    tracerWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(tracerTag.key))), "tracerWith");
    withTracer = /* @__PURE__ */ dual(2, (effect4, value3) => fiberRefLocallyWith(currentServices, add2(tracerTag, value3))(effect4));
  }
});

// node_modules/effect/dist/esm/Clock.js
var sleep2, currentTimeMillis2, currentTimeNanos2, clockWith2, Clock;
var init_Clock = __esm({
  "node_modules/effect/dist/esm/Clock.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_clock();
    init_defaultServices();
    sleep2 = sleep;
    currentTimeMillis2 = currentTimeMillis;
    currentTimeNanos2 = currentTimeNanos;
    clockWith2 = clockWith;
    Clock = clockTag;
  }
});

// node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake5(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
function empty21() {
  return unsafeMake5(/* @__PURE__ */ new Map());
}
var FiberRefsSym, FiberRefsImpl, findAncestor, joinAs, forkAs, unsafeForkAs, fiberRefs, setAll, delete_, get9, getOrDefault, updateAs, unsafeUpdateAs, updateManyAs;
var init_fiberRefs = __esm({
  "node_modules/effect/dist/esm/internal/fiberRefs.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Equal();
    init_Function();
    init_HashSet();
    init_Option();
    init_Pipeable();
    init_core();
    __name(unsafeMake5, "unsafeMake");
    __name(empty21, "empty");
    FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");
    FiberRefsImpl = class {
      static {
        __name(this, "FiberRefsImpl");
      }
      locals;
      [FiberRefsSym] = FiberRefsSym;
      constructor(locals) {
        this.locals = locals;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    findAncestor = /* @__PURE__ */ __name((_ref, _parentStack, _childStack, _childModified = false) => {
      const ref2 = _ref;
      let parentStack = _parentStack;
      let childStack = _childStack;
      let childModified = _childModified;
      let ret = void 0;
      while (ret === void 0) {
        if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
          const parentFiberId = headNonEmpty(parentStack)[0];
          const parentAncestors = tailNonEmpty(parentStack);
          const childFiberId = headNonEmpty(childStack)[0];
          const childRefValue = headNonEmpty(childStack)[1];
          const childAncestors = tailNonEmpty(childStack);
          if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
            childStack = childAncestors;
            childModified = true;
          } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
            parentStack = parentAncestors;
          } else {
            if (parentFiberId.id < childFiberId.id) {
              childStack = childAncestors;
              childModified = true;
            } else if (parentFiberId.id > childFiberId.id) {
              parentStack = parentAncestors;
            } else {
              ret = [childRefValue, childModified];
            }
          }
        } else {
          ret = [ref2.initial, true];
        }
      }
      return ret;
    }, "findAncestor");
    joinAs = /* @__PURE__ */ dual(3, (self2, fiberId3, that) => {
      const parentFiberRefs = new Map(self2.locals);
      that.locals.forEach((childStack, fiberRef) => {
        const childValue = childStack[0][1];
        if (!childStack[0][0][symbol2](fiberId3)) {
          if (!parentFiberRefs.has(fiberRef)) {
            if (equals(childValue, fiberRef.initial)) {
              return;
            }
            parentFiberRefs.set(fiberRef, [[fiberId3, fiberRef.join(fiberRef.initial, childValue)]]);
            return;
          }
          const parentStack = parentFiberRefs.get(fiberRef);
          const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
          if (wasModified) {
            const patch9 = fiberRef.diff(ancestor, childValue);
            const oldValue = parentStack[0][1];
            const newValue = fiberRef.join(oldValue, fiberRef.patch(patch9)(oldValue));
            if (!equals(oldValue, newValue)) {
              let newStack;
              const parentFiberId = parentStack[0][0];
              if (parentFiberId[symbol2](fiberId3)) {
                newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
              } else {
                newStack = [[fiberId3, newValue], ...parentStack];
              }
              parentFiberRefs.set(fiberRef, newStack);
            }
          }
        }
      });
      return new FiberRefsImpl(parentFiberRefs);
    });
    forkAs = /* @__PURE__ */ dual(2, (self2, childId) => {
      const map31 = /* @__PURE__ */ new Map();
      unsafeForkAs(self2, map31, childId);
      return new FiberRefsImpl(map31);
    });
    unsafeForkAs = /* @__PURE__ */ __name((self2, map31, fiberId3) => {
      self2.locals.forEach((stack, fiberRef) => {
        const oldValue = stack[0][1];
        const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
        if (equals(oldValue, newValue)) {
          map31.set(fiberRef, stack);
        } else {
          map31.set(fiberRef, [[fiberId3, newValue], ...stack]);
        }
      });
    }, "unsafeForkAs");
    fiberRefs = /* @__PURE__ */ __name((self2) => fromIterable6(self2.locals.keys()), "fiberRefs");
    setAll = /* @__PURE__ */ __name((self2) => forEachSequentialDiscard(fiberRefs(self2), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self2, fiberRef))), "setAll");
    delete_ = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
      const locals = new Map(self2.locals);
      locals.delete(fiberRef);
      return new FiberRefsImpl(locals);
    });
    get9 = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
      if (!self2.locals.has(fiberRef)) {
        return none2();
      }
      return some2(headNonEmpty(self2.locals.get(fiberRef))[1]);
    });
    getOrDefault = /* @__PURE__ */ dual(2, (self2, fiberRef) => pipe(get9(self2, fiberRef), getOrElse(() => fiberRef.initial)));
    updateAs = /* @__PURE__ */ dual(2, (self2, {
      fiberId: fiberId3,
      fiberRef,
      value: value3
    }) => {
      if (self2.locals.size === 0) {
        return new FiberRefsImpl(/* @__PURE__ */ new Map([[fiberRef, [[fiberId3, value3]]]]));
      }
      const locals = new Map(self2.locals);
      unsafeUpdateAs(locals, fiberId3, fiberRef, value3);
      return new FiberRefsImpl(locals);
    });
    unsafeUpdateAs = /* @__PURE__ */ __name((locals, fiberId3, fiberRef, value3) => {
      const oldStack = locals.get(fiberRef) ?? [];
      let newStack;
      if (isNonEmptyReadonlyArray(oldStack)) {
        const [currentId, currentValue] = headNonEmpty(oldStack);
        if (currentId[symbol2](fiberId3)) {
          if (equals(currentValue, value3)) {
            return;
          } else {
            newStack = [[fiberId3, value3], ...oldStack.slice(1)];
          }
        } else {
          newStack = [[fiberId3, value3], ...oldStack];
        }
      } else {
        newStack = [[fiberId3, value3]];
      }
      locals.set(fiberRef, newStack);
    }, "unsafeUpdateAs");
    updateManyAs = /* @__PURE__ */ dual(2, (self2, {
      entries: entries2,
      forkAs: forkAs2
    }) => {
      if (self2.locals.size === 0) {
        return new FiberRefsImpl(new Map(entries2));
      }
      const locals = new Map(self2.locals);
      if (forkAs2 !== void 0) {
        unsafeForkAs(self2, locals, forkAs2);
      }
      entries2.forEach(([fiberRef, values4]) => {
        if (values4.length === 1) {
          unsafeUpdateAs(locals, values4[0][0], fiberRef, values4[0][1]);
        } else {
          values4.forEach(([fiberId3, value3]) => {
            unsafeUpdateAs(locals, fiberId3, fiberRef, value3);
          });
        }
      });
      return new FiberRefsImpl(locals);
    });
  }
});

// node_modules/effect/dist/esm/FiberRefs.js
var get10, getOrDefault2, joinAs2, setAll2, updateManyAs2, empty22;
var init_FiberRefs = __esm({
  "node_modules/effect/dist/esm/FiberRefs.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_fiberRefs();
    get10 = get9;
    getOrDefault2 = getOrDefault;
    joinAs2 = joinAs;
    setAll2 = setAll;
    updateManyAs2 = updateManyAs;
    empty22 = empty21;
  }
});

// node_modules/effect/dist/esm/LogLevel.js
var All, Fatal, Error2, Warning, Info, Debug, Trace, None3, Order5, greaterThan4, fromLiteral;
var init_LogLevel = __esm({
  "node_modules/effect/dist/esm/LogLevel.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_core();
    init_Number();
    init_Order();
    All = logLevelAll;
    Fatal = logLevelFatal;
    Error2 = logLevelError;
    Warning = logLevelWarning;
    Info = logLevelInfo;
    Debug = logLevelDebug;
    Trace = logLevelTrace;
    None3 = logLevelNone;
    Order5 = /* @__PURE__ */ pipe(Order, /* @__PURE__ */ mapInput2((level) => level.ordinal));
    greaterThan4 = /* @__PURE__ */ greaterThan(Order5);
    fromLiteral = /* @__PURE__ */ __name((literal3) => {
      switch (literal3) {
        case "All":
          return All;
        case "Debug":
          return Debug;
        case "Error":
          return Error2;
        case "Fatal":
          return Fatal;
        case "Info":
          return Info;
        case "Trace":
          return Trace;
        case "None":
          return None3;
        case "Warning":
          return Warning;
      }
    }, "fromLiteral");
  }
});

// node_modules/effect/dist/esm/internal/logSpan.js
var make26, formatLabel, render;
var init_logSpan = __esm({
  "node_modules/effect/dist/esm/internal/logSpan.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    make26 = /* @__PURE__ */ __name((label, startTime) => ({
      label,
      startTime
    }), "make");
    formatLabel = /* @__PURE__ */ __name((key) => key.replace(/[\s="]/g, "_"), "formatLabel");
    render = /* @__PURE__ */ __name((now2) => (self2) => {
      const label = formatLabel(self2.label);
      return `${label}=${now2 - self2.startTime}ms`;
    }, "render");
  }
});

// node_modules/effect/dist/esm/LogSpan.js
var make27;
var init_LogSpan = __esm({
  "node_modules/effect/dist/esm/LogSpan.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_logSpan();
    make27 = make26;
  }
});

// node_modules/effect/dist/esm/Effectable.js
var EffectPrototype2, CommitPrototype2, Base2, Class2;
var init_Effectable = __esm({
  "node_modules/effect/dist/esm/Effectable.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_effectable();
    EffectPrototype2 = EffectPrototype;
    CommitPrototype2 = CommitPrototype;
    Base2 = Base;
    Class2 = class extends Base2 {
      static {
        __name(this, "Class");
      }
    };
  }
});

// node_modules/effect/dist/esm/Readable.js
var TypeId14, Proto;
var init_Readable = __esm({
  "node_modules/effect/dist/esm/Readable.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Pipeable();
    TypeId14 = /* @__PURE__ */ Symbol.for("effect/Readable");
    Proto = {
      [TypeId14]: TypeId14,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
  }
});

// node_modules/effect/dist/esm/internal/ref.js
var RefTypeId, refVariance, RefImpl, unsafeMake6, make28, get11, set5, getAndSet, getAndUpdate, getAndUpdateSome, setAndGet, modify3, modifySome, update2, updateAndGet, updateSome, updateSomeAndGet, unsafeGet7;
var init_ref = __esm({
  "node_modules/effect/dist/esm/internal/ref.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Effectable();
    init_Function();
    init_MutableRef();
    init_Option();
    init_Readable();
    init_core();
    RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
    refVariance = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    RefImpl = class extends Class2 {
      static {
        __name(this, "RefImpl");
      }
      ref;
      commit() {
        return this.get;
      }
      [RefTypeId] = refVariance;
      [TypeId14] = TypeId14;
      constructor(ref2) {
        super();
        this.ref = ref2;
        this.get = sync(() => get6(this.ref));
      }
      get;
      modify(f) {
        return sync(() => {
          const current2 = get6(this.ref);
          const [b, a] = f(current2);
          if (current2 !== a) {
            set2(a)(this.ref);
          }
          return b;
        });
      }
    };
    unsafeMake6 = /* @__PURE__ */ __name((value3) => new RefImpl(make12(value3)), "unsafeMake");
    make28 = /* @__PURE__ */ __name((value3) => sync(() => unsafeMake6(value3)), "make");
    get11 = /* @__PURE__ */ __name((self2) => self2.get, "get");
    set5 = /* @__PURE__ */ dual(2, (self2, value3) => self2.modify(() => [void 0, value3]));
    getAndSet = /* @__PURE__ */ dual(2, (self2, value3) => self2.modify((a) => [a, value3]));
    getAndUpdate = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [a, f(a)]));
    getAndUpdateSome = /* @__PURE__ */ dual(2, (self2, pf) => self2.modify((value3) => {
      const option5 = pf(value3);
      switch (option5._tag) {
        case "None": {
          return [value3, value3];
        }
        case "Some": {
          return [value3, option5.value];
        }
      }
    }));
    setAndGet = /* @__PURE__ */ dual(2, (self2, value3) => self2.modify(() => [value3, value3]));
    modify3 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify(f));
    modifySome = /* @__PURE__ */ dual(3, (self2, fallback, pf) => self2.modify((value3) => {
      const option5 = pf(value3);
      switch (option5._tag) {
        case "None": {
          return [fallback, value3];
        }
        case "Some": {
          return option5.value;
        }
      }
    }));
    update2 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [void 0, f(a)]));
    updateAndGet = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => {
      const result = f(a);
      return [result, result];
    }));
    updateSome = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [void 0, match2(f(a), {
      onNone: /* @__PURE__ */ __name(() => a, "onNone"),
      onSome: /* @__PURE__ */ __name((b) => b, "onSome")
    })]));
    updateSomeAndGet = /* @__PURE__ */ dual(2, (self2, pf) => self2.modify((value3) => {
      const option5 = pf(value3);
      switch (option5._tag) {
        case "None": {
          return [value3, value3];
        }
        case "Some": {
          return [option5.value, option5.value];
        }
      }
    }));
    unsafeGet7 = /* @__PURE__ */ __name((self2) => get6(self2.ref), "unsafeGet");
  }
});

// node_modules/effect/dist/esm/Ref.js
var Ref_exports = {};
__export(Ref_exports, {
  RefTypeId: () => RefTypeId2,
  get: () => get12,
  getAndSet: () => getAndSet2,
  getAndUpdate: () => getAndUpdate2,
  getAndUpdateSome: () => getAndUpdateSome2,
  make: () => make29,
  modify: () => modify4,
  modifySome: () => modifySome2,
  set: () => set6,
  setAndGet: () => setAndGet2,
  unsafeMake: () => unsafeMake7,
  update: () => update3,
  updateAndGet: () => updateAndGet2,
  updateSome: () => updateSome2,
  updateSomeAndGet: () => updateSomeAndGet2
});
var RefTypeId2, make29, get12, getAndSet2, getAndUpdate2, getAndUpdateSome2, modify4, modifySome2, set6, setAndGet2, update3, updateAndGet2, updateSome2, updateSomeAndGet2, unsafeMake7;
var init_Ref = __esm({
  "node_modules/effect/dist/esm/Ref.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_ref();
    RefTypeId2 = RefTypeId;
    make29 = make28;
    get12 = get11;
    getAndSet2 = getAndSet;
    getAndUpdate2 = getAndUpdate;
    getAndUpdateSome2 = getAndUpdateSome;
    modify4 = modify3;
    modifySome2 = modifySome;
    set6 = set5;
    setAndGet2 = setAndGet;
    update3 = update2;
    updateAndGet2 = updateAndGet;
    updateSome2 = updateSome;
    updateSomeAndGet2 = updateSomeAndGet;
    unsafeMake7 = unsafeMake6;
  }
});

// node_modules/effect/dist/esm/Tracer.js
var tracerWith2;
var init_Tracer = __esm({
  "node_modules/effect/dist/esm/Tracer.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_defaultServices();
    tracerWith2 = tracerWith;
  }
});

// node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2, OP_ADD, OP_REMOVE, OP_UPDATE, OP_AND_THEN, empty23, diff5, combine7, patch6;
var init_patch = __esm({
  "node_modules/effect/dist/esm/internal/fiberRefs/patch.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Equal();
    init_Function();
    init_fiberRefs();
    OP_EMPTY2 = "Empty";
    OP_ADD = "Add";
    OP_REMOVE = "Remove";
    OP_UPDATE = "Update";
    OP_AND_THEN = "AndThen";
    empty23 = {
      _tag: OP_EMPTY2
    };
    diff5 = /* @__PURE__ */ __name((oldValue, newValue) => {
      const missingLocals = new Map(oldValue.locals);
      let patch9 = empty23;
      for (const [fiberRef, pairs] of newValue.locals.entries()) {
        const newValue2 = headNonEmpty(pairs)[1];
        const old = missingLocals.get(fiberRef);
        if (old !== void 0) {
          const oldValue2 = headNonEmpty(old)[1];
          if (!equals(oldValue2, newValue2)) {
            patch9 = combine7({
              _tag: OP_UPDATE,
              fiberRef,
              patch: fiberRef.diff(oldValue2, newValue2)
            })(patch9);
          }
        } else {
          patch9 = combine7({
            _tag: OP_ADD,
            fiberRef,
            value: newValue2
          })(patch9);
        }
        missingLocals.delete(fiberRef);
      }
      for (const [fiberRef] of missingLocals.entries()) {
        patch9 = combine7({
          _tag: OP_REMOVE,
          fiberRef
        })(patch9);
      }
      return patch9;
    }, "diff");
    combine7 = /* @__PURE__ */ dual(2, (self2, that) => ({
      _tag: OP_AND_THEN,
      first: self2,
      second: that
    }));
    patch6 = /* @__PURE__ */ dual(3, (self2, fiberId3, oldValue) => {
      let fiberRefs3 = oldValue;
      let patches = of(self2);
      while (isNonEmptyReadonlyArray(patches)) {
        const head7 = headNonEmpty(patches);
        const tail = tailNonEmpty(patches);
        switch (head7._tag) {
          case OP_EMPTY2: {
            patches = tail;
            break;
          }
          case OP_ADD: {
            fiberRefs3 = updateAs(fiberRefs3, {
              fiberId: fiberId3,
              fiberRef: head7.fiberRef,
              value: head7.value
            });
            patches = tail;
            break;
          }
          case OP_REMOVE: {
            fiberRefs3 = delete_(fiberRefs3, head7.fiberRef);
            patches = tail;
            break;
          }
          case OP_UPDATE: {
            const value3 = getOrDefault(fiberRefs3, head7.fiberRef);
            fiberRefs3 = updateAs(fiberRefs3, {
              fiberId: fiberId3,
              fiberRef: head7.fiberRef,
              value: head7.fiberRef.patch(head7.patch)(value3)
            });
            patches = tail;
            break;
          }
          case OP_AND_THEN: {
            patches = prepend(head7.first)(prepend(head7.second)(tail));
            break;
          }
        }
      }
      return fiberRefs3;
    });
  }
});

// node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey, MetricLabelTypeId, MetricLabelImpl, make30, isMetricLabel;
var init_label = __esm({
  "node_modules/effect/dist/esm/internal/metric/label.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Hash();
    init_Pipeable();
    init_Predicate();
    MetricLabelSymbolKey = "effect/MetricLabel";
    MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);
    MetricLabelImpl = class {
      static {
        __name(this, "MetricLabelImpl");
      }
      key;
      value;
      [MetricLabelTypeId] = MetricLabelTypeId;
      _hash;
      constructor(key, value3) {
        this.key = key;
        this.value = value3;
        this._hash = string(MetricLabelSymbolKey + this.key + this.value);
      }
      [symbol]() {
        return this._hash;
      }
      [symbol2](that) {
        return isMetricLabel(that) && this.key === that.key && this.value === that.value;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    make30 = /* @__PURE__ */ __name((key, value3) => {
      return new MetricLabelImpl(key, value3);
    }, "make");
    isMetricLabel = /* @__PURE__ */ __name((u) => hasProperty(u, MetricLabelTypeId), "isMetricLabel");
  }
});

// node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs, asSome, asSomeError, try_2, _catch, catchAllDefect, catchSomeCause, catchSomeDefect, catchTag, catchTags, cause, clockWith3, clock, delay, descriptorWith, allowInterrupt, descriptor, diffFiberRefs, diffFiberRefsAndRuntimeFlags, Do2, bind3, bindTo3, let_3, dropUntil, dropWhile2, contextWith, eventually, filterMap5, filterOrDie, filterOrDieMessage, filterOrElse, liftPredicate2, filterOrFail, findFirst5, findLoop, firstSuccessOf, flipWith, match7, every5, forAllLoop, forever, fiberRefs2, head3, ignore, ignoreLogged, inheritFiberRefs, isFailure2, isSuccess2, iterate, logWithLevel, log3, logTrace, logDebug, logInfo, logWarning, logError, logFatal, withLogSpan, logAnnotations, loop, loopInternal, loopDiscard, mapAccum3, mapErrorCause, memoize, merge5, negate, none6, once2, option2, orElseFail, orElseSucceed, parallelErrors, patchFiberRefs, promise, provideService, provideServiceEffect, random2, reduce9, reduceRight3, reduceWhile, reduceWhileLoop, repeatN, repeatNLoop, sandbox, setFiberRefs, sleep3, succeedNone, succeedSome, summarized, tagMetrics, labelMetrics, takeUntil, takeWhile2, tapBoth, tapDefect, tapError, tapErrorTag, tapErrorCause, timed, timedWith, tracerWith3, tracer, tryPromise, tryMap, tryMapPromise, unless, unlessEffect, unsandbox, updateFiberRefs, updateService, when, whenFiberRef, whenRef, withMetric, serviceFunctionEffect, serviceFunction, serviceFunctions, serviceConstants, serviceMembers, serviceOption, serviceOptional, annotateCurrentSpan, linkSpanCurrent, annotateSpans, currentParentSpan, currentSpan, linkSpans, bigint03, filterDisablePropagation, unsafeMakeSpan, makeSpan, spanAnnotations, spanLinks, endSpan, useSpan, withParentSpan, withSpan, functionWithSpan, fromNullable2, optionFromOptional;
var init_core_effect = __esm({
  "node_modules/effect/dist/esm/internal/core-effect.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Chunk();
    init_Clock();
    init_Context();
    init_Duration();
    init_FiberRefs();
    init_Function();
    init_HashMap();
    init_HashSet();
    init_List();
    init_LogLevel();
    init_LogSpan();
    init_Option();
    init_Predicate();
    init_Ref();
    init_Tracer();
    init_Utils();
    init_cause2();
    init_clock();
    init_core();
    init_defaultServices();
    init_doNotation();
    init_patch();
    init_label();
    init_runtimeFlags();
    init_tracer();
    annotateLogs = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
      const args2 = arguments;
      return fiberRefLocallyWith(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value3]) => set3(acc, key, value3), annotations3));
    });
    asSome = /* @__PURE__ */ __name((self2) => map11(self2, some2), "asSome");
    asSomeError = /* @__PURE__ */ __name((self2) => mapError(self2, some2), "asSomeError");
    try_2 = /* @__PURE__ */ __name((arg) => {
      let evaluate3;
      let onFailure = void 0;
      if (typeof arg === "function") {
        evaluate3 = arg;
      } else {
        evaluate3 = arg.try;
        onFailure = arg.catch;
      }
      return suspend(() => {
        try {
          return succeed(internalCall(evaluate3));
        } catch (error50) {
          return fail2(onFailure ? internalCall(() => onFailure(error50)) : new UnknownException(error50, "An unknown error occurred in Effect.try"));
        }
      });
    }, "try_");
    _catch = /* @__PURE__ */ dual(3, (self2, tag2, options) => catchAll(self2, (e) => {
      if (hasProperty(e, tag2) && e[tag2] === options.failure) {
        return options.onFailure(e);
      }
      return fail2(e);
    }));
    catchAllDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause3) => {
      const option5 = find(cause3, (_) => isDieType(_) ? some2(_) : none2());
      switch (option5._tag) {
        case "None": {
          return failCause(cause3);
        }
        case "Some": {
          return f(option5.value.defect);
        }
      }
    }));
    catchSomeCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
      onFailure: /* @__PURE__ */ __name((cause3) => {
        const option5 = f(cause3);
        switch (option5._tag) {
          case "None": {
            return failCause(cause3);
          }
          case "Some": {
            return option5.value;
          }
        }
      }, "onFailure"),
      onSuccess: succeed
    }));
    catchSomeDefect = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause3) => {
      const option5 = find(cause3, (_) => isDieType(_) ? some2(_) : none2());
      switch (option5._tag) {
        case "None": {
          return failCause(cause3);
        }
        case "Some": {
          const optionEffect = pf(option5.value.defect);
          return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause3);
        }
      }
    }));
    catchTag = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, ...args2) => {
      const f = args2[args2.length - 1];
      let predicate;
      if (args2.length === 2) {
        predicate = isTagged(args2[0]);
      } else {
        predicate = /* @__PURE__ */ __name((e) => {
          const tag2 = hasProperty(e, "_tag") ? e["_tag"] : void 0;
          if (!tag2) return false;
          for (let i = 0; i < args2.length - 1; i++) {
            if (args2[i] === tag2) return true;
          }
          return false;
        }, "predicate");
      }
      return catchIf(self2, predicate, f);
    });
    catchTags = /* @__PURE__ */ dual(2, (self2, cases) => {
      let keys5;
      return catchIf(self2, (e) => {
        keys5 ??= Object.keys(cases);
        return hasProperty(e, "_tag") && isString(e["_tag"]) && keys5.includes(e["_tag"]);
      }, (e) => cases[e["_tag"]](e));
    });
    cause = /* @__PURE__ */ __name((self2) => matchCause(self2, {
      onFailure: identity,
      onSuccess: /* @__PURE__ */ __name(() => empty17, "onSuccess")
    }), "cause");
    clockWith3 = clockWith2;
    clock = /* @__PURE__ */ clockWith3(succeed);
    delay = /* @__PURE__ */ dual(2, (self2, duration6) => zipRight2(sleep2(duration6), self2));
    descriptorWith = /* @__PURE__ */ __name((f) => withFiberRuntime((state, status2) => f({
      id: state.id(),
      status: status2,
      interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
    })), "descriptorWith");
    allowInterrupt = /* @__PURE__ */ descriptorWith((descriptor3) => size3(descriptor3.interruptors) > 0 ? interrupt2 : void_2);
    descriptor = /* @__PURE__ */ descriptorWith(succeed);
    diffFiberRefs = /* @__PURE__ */ __name((self2) => summarized(self2, fiberRefs2, diff5), "diffFiberRefs");
    diffFiberRefsAndRuntimeFlags = /* @__PURE__ */ __name((self2) => summarized(self2, zip2(fiberRefs2, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff5(refs, refsNew), diff4(flags, flagsNew)]), "diffFiberRefsAndRuntimeFlags");
    Do2 = /* @__PURE__ */ succeed({});
    bind3 = /* @__PURE__ */ bind(map11, flatMap8);
    bindTo3 = /* @__PURE__ */ bindTo(map11);
    let_3 = /* @__PURE__ */ let_(map11);
    dropUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
      const iterator2 = elements[Symbol.iterator]();
      const builder = [];
      let next4;
      let dropping7 = succeed(false);
      let i = 0;
      while ((next4 = iterator2.next()) && !next4.done) {
        const a = next4.value;
        const index2 = i++;
        dropping7 = flatMap8(dropping7, (bool) => {
          if (bool) {
            builder.push(a);
            return succeed(true);
          }
          return predicate(a, index2);
        });
      }
      return map11(dropping7, () => builder);
    }));
    dropWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
      const iterator2 = elements[Symbol.iterator]();
      const builder = [];
      let next4;
      let dropping7 = succeed(true);
      let i = 0;
      while ((next4 = iterator2.next()) && !next4.done) {
        const a = next4.value;
        const index2 = i++;
        dropping7 = flatMap8(dropping7, (d) => map11(d ? predicate(a, index2) : succeed(false), (b) => {
          if (!b) {
            builder.push(a);
          }
          return b;
        }));
      }
      return map11(dropping7, () => builder);
    }));
    contextWith = /* @__PURE__ */ __name((f) => map11(context3(), f), "contextWith");
    eventually = /* @__PURE__ */ __name((self2) => orElse2(self2, () => flatMap8(yieldNow(), () => eventually(self2))), "eventually");
    filterMap5 = /* @__PURE__ */ dual(2, (elements, pf) => map11(forEachSequential(elements, identity), filterMap2(pf)));
    filterOrDie = /* @__PURE__ */ dual(3, (self2, predicate, orDieWith6) => filterOrElse(self2, predicate, (a) => dieSync(() => orDieWith6(a))));
    filterOrDieMessage = /* @__PURE__ */ dual(3, (self2, predicate, message) => filterOrElse(self2, predicate, () => dieMessage(message)));
    filterOrElse = /* @__PURE__ */ dual(3, (self2, predicate, orElse12) => flatMap8(self2, (a) => predicate(a) ? succeed(a) : orElse12(a)));
    liftPredicate2 = /* @__PURE__ */ dual(3, (self2, predicate, orFailWith) => suspend(() => predicate(self2) ? succeed(self2) : fail2(orFailWith(self2))));
    filterOrFail = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, predicate, orFailWith) => filterOrElse(self2, predicate, (a) => orFailWith === void 0 ? fail2(new NoSuchElementException()) : failSync(() => orFailWith(a))));
    findFirst5 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
      const iterator2 = elements[Symbol.iterator]();
      const next4 = iterator2.next();
      if (!next4.done) {
        return findLoop(iterator2, 0, predicate, next4.value);
      }
      return succeed(none2());
    }));
    findLoop = /* @__PURE__ */ __name((iterator2, index2, f, value3) => flatMap8(f(value3, index2), (result) => {
      if (result) {
        return succeed(some2(value3));
      }
      const next4 = iterator2.next();
      if (!next4.done) {
        return findLoop(iterator2, index2 + 1, f, next4.value);
      }
      return succeed(none2());
    }), "findLoop");
    firstSuccessOf = /* @__PURE__ */ __name((effects) => suspend(() => {
      const list = fromIterable3(effects);
      if (!isNonEmpty2(list)) {
        return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
      }
      return pipe(tailNonEmpty2(list), reduce(headNonEmpty2(list), (left3, right3) => orElse2(left3, () => right3)));
    }), "firstSuccessOf");
    flipWith = /* @__PURE__ */ dual(2, (self2, f) => flip(f(flip(self2))));
    match7 = /* @__PURE__ */ dual(2, (self2, options) => matchEffect(self2, {
      onFailure: /* @__PURE__ */ __name((e) => succeed(options.onFailure(e)), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((a) => succeed(options.onSuccess(a)), "onSuccess")
    }));
    every5 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
    forAllLoop = /* @__PURE__ */ __name((iterator2, index2, f) => {
      const next4 = iterator2.next();
      return next4.done ? succeed(true) : flatMap8(f(next4.value, index2), (b) => b ? forAllLoop(iterator2, index2 + 1, f) : succeed(b));
    }, "forAllLoop");
    forever = /* @__PURE__ */ __name((self2) => {
      const loop3 = flatMap8(flatMap8(self2, () => yieldNow()), () => loop3);
      return loop3;
    }, "forever");
    fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.getFiberRefs()));
    head3 = /* @__PURE__ */ __name((self2) => flatMap8(self2, (as12) => {
      const iterator2 = as12[Symbol.iterator]();
      const next4 = iterator2.next();
      if (next4.done) {
        return fail2(new NoSuchElementException());
      }
      return succeed(next4.value);
    }), "head");
    ignore = /* @__PURE__ */ __name((self2) => match7(self2, {
      onFailure: constVoid,
      onSuccess: constVoid
    }), "ignore");
    ignoreLogged = /* @__PURE__ */ __name((self2) => matchCauseEffect(self2, {
      onFailure: /* @__PURE__ */ __name((cause3) => logDebug(cause3, "An error was silently ignored because it is not anticipated to be useful"), "onFailure"),
      onSuccess: /* @__PURE__ */ __name(() => void_2, "onSuccess")
    }), "ignoreLogged");
    inheritFiberRefs = /* @__PURE__ */ __name((childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs)), "inheritFiberRefs");
    isFailure2 = /* @__PURE__ */ __name((self2) => match7(self2, {
      onFailure: constTrue,
      onSuccess: constFalse
    }), "isFailure");
    isSuccess2 = /* @__PURE__ */ __name((self2) => match7(self2, {
      onFailure: constFalse,
      onSuccess: constTrue
    }), "isSuccess");
    iterate = /* @__PURE__ */ __name((initial, options) => suspend(() => {
      if (options.while(initial)) {
        return flatMap8(options.body(initial), (z2) => iterate(z2, options));
      }
      return succeed(initial);
    }), "iterate");
    logWithLevel = /* @__PURE__ */ __name((level) => (...message) => {
      const levelOption = fromNullable(level);
      let cause3 = void 0;
      for (let i = 0, len = message.length; i < len; i++) {
        const msg = message[i];
        if (isCause(msg)) {
          if (cause3 !== void 0) {
            cause3 = sequential(cause3, msg);
          } else {
            cause3 = msg;
          }
          message = [...message.slice(0, i), ...message.slice(i + 1)];
          i--;
        }
      }
      if (cause3 === void 0) {
        cause3 = empty17;
      }
      return withFiberRuntime((fiberState) => {
        fiberState.log(message, cause3, levelOption);
        return void_2;
      });
    }, "logWithLevel");
    log3 = /* @__PURE__ */ logWithLevel();
    logTrace = /* @__PURE__ */ logWithLevel(Trace);
    logDebug = /* @__PURE__ */ logWithLevel(Debug);
    logInfo = /* @__PURE__ */ logWithLevel(Info);
    logWarning = /* @__PURE__ */ logWithLevel(Warning);
    logError = /* @__PURE__ */ logWithLevel(Error2);
    logFatal = /* @__PURE__ */ logWithLevel(Fatal);
    withLogSpan = /* @__PURE__ */ dual(2, (effect4, label) => flatMap8(currentTimeMillis2, (now2) => fiberRefLocallyWith(effect4, currentLogSpan, prepend3(make27(label, now2)))));
    logAnnotations = /* @__PURE__ */ fiberRefGet(currentLogAnnotations);
    loop = /* @__PURE__ */ __name((initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map11(loopInternal(initial, options.while, options.step, options.body), fromIterable2), "loop");
    loopInternal = /* @__PURE__ */ __name((initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap8(body(initial), (a) => map11(loopInternal(inc(initial), cont, inc, body), prepend3(a))) : sync(() => empty10())), "loopInternal");
    loopDiscard = /* @__PURE__ */ __name((initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap8(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_2), "loopDiscard");
    mapAccum3 = /* @__PURE__ */ dual(3, (elements, initial, f) => suspend(() => {
      const iterator2 = elements[Symbol.iterator]();
      const builder = [];
      let result = succeed(initial);
      let next4;
      let i = 0;
      while (!(next4 = iterator2.next()).done) {
        const index2 = i++;
        const value3 = next4.value;
        result = flatMap8(result, (state) => map11(f(state, value3, index2), ([z2, b]) => {
          builder.push(b);
          return z2;
        }));
      }
      return map11(result, (z2) => [z2, builder]);
    }));
    mapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
      onFailure: /* @__PURE__ */ __name((c) => failCauseSync(() => f(c)), "onFailure"),
      onSuccess: succeed
    }));
    memoize = /* @__PURE__ */ __name((self2) => pipe(deferredMake(), flatMap8((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self2), intoDeferred(deferred), once2, map11((complete3) => zipRight2(complete3, pipe(deferredAwait(deferred), flatMap8(([patch9, a]) => as2(zip2(patchFiberRefs(patch9[0]), updateRuntimeFlags(patch9[1])), a)))))))), "memoize");
    merge5 = /* @__PURE__ */ __name((self2) => matchEffect(self2, {
      onFailure: /* @__PURE__ */ __name((e) => succeed(e), "onFailure"),
      onSuccess: succeed
    }), "merge");
    negate = /* @__PURE__ */ __name((self2) => map11(self2, (b) => !b), "negate");
    none6 = /* @__PURE__ */ __name((self2) => flatMap8(self2, (option5) => {
      switch (option5._tag) {
        case "None":
          return void_2;
        case "Some":
          return fail2(new NoSuchElementException());
      }
    }), "none");
    once2 = /* @__PURE__ */ __name((self2) => map11(make29(true), (ref2) => asVoid2(whenEffect(self2, getAndSet2(ref2, false)))), "once");
    option2 = /* @__PURE__ */ __name((self2) => matchEffect(self2, {
      onFailure: /* @__PURE__ */ __name(() => succeed(none2()), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((a) => succeed(some2(a)), "onSuccess")
    }), "option");
    orElseFail = /* @__PURE__ */ dual(2, (self2, evaluate3) => orElse2(self2, () => failSync(evaluate3)));
    orElseSucceed = /* @__PURE__ */ dual(2, (self2, evaluate3) => orElse2(self2, () => sync(evaluate3)));
    parallelErrors = /* @__PURE__ */ __name((self2) => matchCauseEffect(self2, {
      onFailure: /* @__PURE__ */ __name((cause3) => {
        const errors = fromIterable2(failures(cause3));
        return errors.length === 0 ? failCause(cause3) : fail2(errors);
      }, "onFailure"),
      onSuccess: succeed
    }), "parallelErrors");
    patchFiberRefs = /* @__PURE__ */ __name((patch9) => updateFiberRefs((fiberId3, fiberRefs3) => pipe(patch9, patch6(fiberId3, fiberRefs3))), "patchFiberRefs");
    promise = /* @__PURE__ */ __name((evaluate3) => evaluate3.length >= 1 ? async_((resolve, signal) => {
      try {
        evaluate3(signal).then((a) => resolve(succeed(a)), (e) => resolve(die2(e)));
      } catch (e) {
        resolve(die2(e));
      }
    }) : async_((resolve) => {
      try {
        ;
        evaluate3().then((a) => resolve(succeed(a)), (e) => resolve(die2(e)));
      } catch (e) {
        resolve(die2(e));
      }
    }), "promise");
    provideService = /* @__PURE__ */ dual(3, (self2, tag2, service3) => contextWithEffect((env2) => provideContext(self2, add2(env2, tag2, service3))));
    provideServiceEffect = /* @__PURE__ */ dual(3, (self2, tag2, effect4) => contextWithEffect((env2) => flatMap8(effect4, (service3) => provideContext(self2, pipe(env2, add2(tag2, service3))))));
    random2 = /* @__PURE__ */ randomWith(succeed);
    reduce9 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable2(elements).reduce((acc, el, i) => flatMap8(acc, (a) => f(a, el, i)), succeed(zero3)));
    reduceRight3 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable2(elements).reduceRight((acc, el, i) => flatMap8(acc, (a) => f(el, a, i)), succeed(zero3)));
    reduceWhile = /* @__PURE__ */ dual(3, (elements, zero3, options) => flatMap8(sync(() => elements[Symbol.iterator]()), (iterator2) => reduceWhileLoop(iterator2, 0, zero3, options.while, options.body)));
    reduceWhileLoop = /* @__PURE__ */ __name((iterator2, index2, state, predicate, f) => {
      const next4 = iterator2.next();
      if (!next4.done && predicate(state)) {
        return flatMap8(f(state, next4.value, index2), (nextState) => reduceWhileLoop(iterator2, index2 + 1, nextState, predicate, f));
      }
      return succeed(state);
    }, "reduceWhileLoop");
    repeatN = /* @__PURE__ */ dual(2, (self2, n) => suspend(() => repeatNLoop(self2, n)));
    repeatNLoop = /* @__PURE__ */ __name((self2, n) => flatMap8(self2, (a) => n <= 0 ? succeed(a) : zipRight2(yieldNow(), repeatNLoop(self2, n - 1))), "repeatNLoop");
    sandbox = /* @__PURE__ */ __name((self2) => matchCauseEffect(self2, {
      onFailure: fail2,
      onSuccess: succeed
    }), "sandbox");
    setFiberRefs = /* @__PURE__ */ __name((fiberRefs3) => suspend(() => setAll2(fiberRefs3)), "setFiberRefs");
    sleep3 = sleep2;
    succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
    succeedSome = /* @__PURE__ */ __name((value3) => succeed(some2(value3)), "succeedSome");
    summarized = /* @__PURE__ */ dual(3, (self2, summary5, f) => flatMap8(summary5, (start5) => flatMap8(self2, (value3) => map11(summary5, (end6) => [f(start5, end6), value3]))));
    tagMetrics = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
      return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make30(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make30(k, v)));
    });
    labelMetrics = /* @__PURE__ */ dual(2, (self2, labels) => fiberRefLocallyWith(self2, currentMetricLabels, (old) => union(old, labels)));
    takeUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
      const iterator2 = elements[Symbol.iterator]();
      const builder = [];
      let next4;
      let effect4 = succeed(false);
      let i = 0;
      while ((next4 = iterator2.next()) && !next4.done) {
        const a = next4.value;
        const index2 = i++;
        effect4 = flatMap8(effect4, (bool) => {
          if (bool) {
            return succeed(true);
          }
          builder.push(a);
          return predicate(a, index2);
        });
      }
      return map11(effect4, () => builder);
    }));
    takeWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
      const iterator2 = elements[Symbol.iterator]();
      const builder = [];
      let next4;
      let taking = succeed(true);
      let i = 0;
      while ((next4 = iterator2.next()) && !next4.done) {
        const a = next4.value;
        const index2 = i++;
        taking = flatMap8(taking, (taking2) => pipe(taking2 ? predicate(a, index2) : succeed(false), map11((bool) => {
          if (bool) {
            builder.push(a);
          }
          return bool;
        })));
      }
      return map11(taking, () => builder);
    }));
    tapBoth = /* @__PURE__ */ dual(2, (self2, {
      onFailure,
      onSuccess
    }) => matchCauseEffect(self2, {
      onFailure: /* @__PURE__ */ __name((cause3) => {
        const either8 = failureOrCause(cause3);
        switch (either8._tag) {
          case "Left": {
            return zipRight2(onFailure(either8.left), failCause(cause3));
          }
          case "Right": {
            return failCause(cause3);
          }
        }
      }, "onFailure"),
      onSuccess: /* @__PURE__ */ __name((a) => as2(onSuccess(a), a), "onSuccess")
    }));
    tapDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause3) => match2(keepDefects(cause3), {
      onNone: /* @__PURE__ */ __name(() => failCause(cause3), "onNone"),
      onSome: /* @__PURE__ */ __name((a) => zipRight2(f(a), failCause(cause3)), "onSome")
    })));
    tapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
      onFailure: /* @__PURE__ */ __name((cause3) => {
        const either8 = failureOrCause(cause3);
        switch (either8._tag) {
          case "Left":
            return zipRight2(f(either8.left), failCause(cause3));
          case "Right":
            return failCause(cause3);
        }
      }, "onFailure"),
      onSuccess: succeed
    }));
    tapErrorTag = /* @__PURE__ */ dual(3, (self2, k, f) => tapError(self2, (e) => {
      if (isTagged(e, k)) {
        return f(e);
      }
      return void_2;
    }));
    tapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
      onFailure: /* @__PURE__ */ __name((cause3) => zipRight2(f(cause3), failCause(cause3)), "onFailure"),
      onSuccess: succeed
    }));
    timed = /* @__PURE__ */ __name((self2) => timedWith(self2, currentTimeNanos2), "timed");
    timedWith = /* @__PURE__ */ dual(2, (self2, nanos2) => summarized(self2, nanos2, (start5, end6) => nanos(end6 - start5)));
    tracerWith3 = tracerWith2;
    tracer = /* @__PURE__ */ tracerWith3(succeed);
    tryPromise = /* @__PURE__ */ __name((arg) => {
      let evaluate3;
      let catcher = void 0;
      if (typeof arg === "function") {
        evaluate3 = arg;
      } else {
        evaluate3 = arg.try;
        catcher = arg.catch;
      }
      const fail19 = /* @__PURE__ */ __name((e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise")), "fail");
      if (evaluate3.length >= 1) {
        return async_((resolve, signal) => {
          try {
            evaluate3(signal).then((a) => resolve(succeed(a)), (e) => resolve(fail19(e)));
          } catch (e) {
            resolve(fail19(e));
          }
        });
      }
      return async_((resolve) => {
        try {
          evaluate3().then((a) => resolve(succeed(a)), (e) => resolve(fail19(e)));
        } catch (e) {
          resolve(fail19(e));
        }
      });
    }, "tryPromise");
    tryMap = /* @__PURE__ */ dual(2, (self2, options) => flatMap8(self2, (a) => try_2({
      try: /* @__PURE__ */ __name(() => options.try(a), "try"),
      catch: options.catch
    })));
    tryMapPromise = /* @__PURE__ */ dual(2, (self2, options) => flatMap8(self2, (a) => tryPromise({
      try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
      catch: options.catch
    })));
    unless = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? succeedNone : asSome(self2)));
    unlessEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap8(condition, (b) => b ? succeedNone : asSome(self2)));
    unsandbox = /* @__PURE__ */ __name((self2) => mapErrorCause(self2, flatten6), "unsandbox");
    updateFiberRefs = /* @__PURE__ */ __name((f) => withFiberRuntime((state) => {
      state.setFiberRefs(f(state.id(), state.getFiberRefs()));
      return void_2;
    }), "updateFiberRefs");
    updateService = /* @__PURE__ */ dual(3, (self2, tag2, f) => mapInputContext(self2, (context10) => add2(context10, tag2, f(unsafeGet3(context10, tag2)))));
    when = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? map11(self2, some2) : succeed(none2())));
    whenFiberRef = /* @__PURE__ */ dual(3, (self2, fiberRef, predicate) => flatMap8(fiberRefGet(fiberRef), (s) => predicate(s) ? map11(self2, (a) => [s, some2(a)]) : succeed([s, none2()])));
    whenRef = /* @__PURE__ */ dual(3, (self2, ref2, predicate) => flatMap8(get12(ref2), (s) => predicate(s) ? map11(self2, (a) => [s, some2(a)]) : succeed([s, none2()])));
    withMetric = /* @__PURE__ */ dual(2, (self2, metric) => metric(self2));
    serviceFunctionEffect = /* @__PURE__ */ __name((getService, f) => (...args2) => flatMap8(getService, (a) => f(a)(...args2)), "serviceFunctionEffect");
    serviceFunction = /* @__PURE__ */ __name((getService, f) => (...args2) => map11(getService, (a) => f(a)(...args2)), "serviceFunction");
    serviceFunctions = /* @__PURE__ */ __name((getService) => new Proxy({}, {
      get(_target, prop, _receiver) {
        return (...args2) => flatMap8(getService, (s) => s[prop](...args2));
      }
    }), "serviceFunctions");
    serviceConstants = /* @__PURE__ */ __name((getService) => new Proxy({}, {
      get(_target, prop, _receiver) {
        return flatMap8(getService, (s) => isEffect(s[prop]) ? s[prop] : succeed(s[prop]));
      }
    }), "serviceConstants");
    serviceMembers = /* @__PURE__ */ __name((getService) => ({
      functions: serviceFunctions(getService),
      constants: serviceConstants(getService)
    }), "serviceMembers");
    serviceOption = /* @__PURE__ */ __name((tag2) => map11(context3(), getOption2(tag2)), "serviceOption");
    serviceOptional = /* @__PURE__ */ __name((tag2) => flatMap8(context3(), getOption2(tag2)), "serviceOptional");
    annotateCurrentSpan = /* @__PURE__ */ __name(function() {
      const args2 = arguments;
      return ignore(flatMap8(currentSpan, (span4) => sync(() => {
        if (typeof args2[0] === "string") {
          span4.attribute(args2[0], args2[1]);
        } else {
          for (const key in args2[0]) {
            span4.attribute(key, args2[0][key]);
          }
        }
      })));
    }, "annotateCurrentSpan");
    linkSpanCurrent = /* @__PURE__ */ __name(function() {
      const args2 = arguments;
      const links = Array.isArray(args2[0]) ? args2[0] : [{
        _tag: "SpanLink",
        span: args2[0],
        attributes: args2[1] ?? {}
      }];
      return ignore(flatMap8(currentSpan, (span4) => sync(() => span4.addLinks(links))));
    }, "linkSpanCurrent");
    annotateSpans = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
      const args2 = arguments;
      return fiberRefLocallyWith(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value3]) => set3(acc, key, value3), annotations3));
    });
    currentParentSpan = /* @__PURE__ */ serviceOptional(spanTag);
    currentSpan = /* @__PURE__ */ flatMap8(/* @__PURE__ */ context3(), (context10) => {
      const span4 = context10.unsafeMap.get(spanTag.key);
      return span4 !== void 0 && span4._tag === "Span" ? succeed(span4) : fail2(new NoSuchElementException());
    });
    linkSpans = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, span4, attributes) => fiberRefLocallyWith(self2, currentTracerSpanLinks, append2({
      _tag: "SpanLink",
      span: span4,
      attributes: attributes ?? {}
    })));
    bigint03 = /* @__PURE__ */ BigInt(0);
    filterDisablePropagation = /* @__PURE__ */ flatMap((span4) => get3(span4.context, DisablePropagation) ? span4._tag === "Span" ? filterDisablePropagation(span4.parent) : none2() : some2(span4));
    unsafeMakeSpan = /* @__PURE__ */ __name((fiber, name, options) => {
      const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get3(options.context, DisablePropagation);
      const context10 = fiber.getFiberRef(currentContext);
      const parent = options.parent ? some2(options.parent) : options.root ? none2() : filterDisablePropagation(getOption2(context10, spanTag));
      let span4;
      if (disablePropagation) {
        span4 = noopSpan({
          name,
          parent,
          context: add2(options.context ?? empty4(), DisablePropagation, true)
        });
      } else {
        const services = fiber.getFiberRef(currentServices);
        const tracer4 = get3(services, tracerTag);
        const clock3 = get3(services, Clock);
        const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
        const fiberRefs3 = fiber.getFiberRefs();
        const annotationsFromEnv = get10(fiberRefs3, currentTracerSpanAnnotations);
        const linksFromEnv = get10(fiberRefs3, currentTracerSpanLinks);
        const links = linksFromEnv._tag === "Some" ? options.links !== void 0 ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty2();
        span4 = tracer4.span(name, parent, options.context ?? empty4(), links, timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint03, options.kind ?? "internal", options);
        if (annotationsFromEnv._tag === "Some") {
          forEach4(annotationsFromEnv.value, (value3, key) => span4.attribute(key, value3));
        }
        if (options.attributes !== void 0) {
          Object.entries(options.attributes).forEach(([k, v]) => span4.attribute(k, v));
        }
      }
      if (typeof options.captureStackTrace === "function") {
        spanToTrace.set(span4, options.captureStackTrace);
      }
      return span4;
    }, "unsafeMakeSpan");
    makeSpan = /* @__PURE__ */ __name((name, options) => {
      options = addSpanStackTrace(options);
      return withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name, options)));
    }, "makeSpan");
    spanAnnotations = /* @__PURE__ */ fiberRefGet(currentTracerSpanAnnotations);
    spanLinks = /* @__PURE__ */ fiberRefGet(currentTracerSpanLinks);
    endSpan = /* @__PURE__ */ __name((span4, exit5, clock3, timingEnabled) => sync(() => {
      if (span4.status._tag === "Ended") {
        return;
      }
      if (exitIsFailure(exit5) && spanToTrace.has(span4)) {
        span4.attribute("code.stacktrace", spanToTrace.get(span4)());
      }
      span4.end(timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint03, exit5);
    }), "endSpan");
    useSpan = /* @__PURE__ */ __name((name, ...args2) => {
      const options = addSpanStackTrace(args2.length === 1 ? void 0 : args2[0]);
      const evaluate3 = args2[args2.length - 1];
      return withFiberRuntime((fiber) => {
        const span4 = unsafeMakeSpan(fiber, name, options);
        const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
        const clock3 = get3(fiber.getFiberRef(currentServices), clockTag);
        return onExit(evaluate3(span4), (exit5) => endSpan(span4, exit5, clock3, timingEnabled));
      });
    }, "useSpan");
    withParentSpan = /* @__PURE__ */ dual(2, (self2, span4) => provideService(self2, spanTag, span4));
    withSpan = /* @__PURE__ */ __name(function() {
      const dataFirst = typeof arguments[0] !== "string";
      const name = dataFirst ? arguments[1] : arguments[0];
      const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
      if (dataFirst) {
        const self2 = arguments[0];
        return useSpan(name, options, (span4) => withParentSpan(self2, span4));
      }
      return (self2) => useSpan(name, options, (span4) => withParentSpan(self2, span4));
    }, "withSpan");
    functionWithSpan = /* @__PURE__ */ __name((options) => function() {
      let captureStackTrace2 = options.captureStackTrace ?? false;
      if (options.captureStackTrace !== false) {
        const limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        const error50 = new Error();
        Error.stackTraceLimit = limit;
        let cache = false;
        captureStackTrace2 = /* @__PURE__ */ __name(() => {
          if (cache !== false) {
            return cache;
          }
          if (error50.stack) {
            const stack = error50.stack.trim().split("\n");
            cache = stack.slice(2).join("\n").trim();
            return cache;
          }
        }, "captureStackTrace");
      }
      return suspend(() => {
        const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
        return withSpan(suspend(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {
          ...opts,
          captureStackTrace: captureStackTrace2
        });
      });
    }, "functionWithSpan");
    fromNullable2 = /* @__PURE__ */ __name((value3) => value3 == null ? fail2(new NoSuchElementException()) : succeed(value3), "fromNullable");
    optionFromOptional = /* @__PURE__ */ __name((self2) => catchAll(map11(self2, some2), (error50) => isNoSuchElementException(error50) ? succeedNone : fail2(error50)), "optionFromOptional");
  }
});

// node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2, OP_PARALLEL2, OP_PARALLEL_N, sequential2, parallel2, parallelN, isSequential, isParallel;
var init_executionStrategy = __esm({
  "node_modules/effect/dist/esm/internal/executionStrategy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_SEQUENTIAL2 = "Sequential";
    OP_PARALLEL2 = "Parallel";
    OP_PARALLEL_N = "ParallelN";
    sequential2 = {
      _tag: OP_SEQUENTIAL2
    };
    parallel2 = {
      _tag: OP_PARALLEL2
    };
    parallelN = /* @__PURE__ */ __name((parallelism) => ({
      _tag: OP_PARALLEL_N,
      parallelism
    }), "parallelN");
    isSequential = /* @__PURE__ */ __name((self2) => self2._tag === OP_SEQUENTIAL2, "isSequential");
    isParallel = /* @__PURE__ */ __name((self2) => self2._tag === OP_PARALLEL2, "isParallel");
  }
});

// node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3, parallel3, parallelN2;
var init_ExecutionStrategy = __esm({
  "node_modules/effect/dist/esm/ExecutionStrategy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_executionStrategy();
    sequential3 = sequential2;
    parallel3 = parallel2;
    parallelN2 = parallelN;
  }
});

// node_modules/effect/dist/esm/FiberRefsPatch.js
var diff6, patch7;
var init_FiberRefsPatch = __esm({
  "node_modules/effect/dist/esm/FiberRefsPatch.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_patch();
    diff6 = diff5;
    patch7 = patch6;
  }
});

// node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey, FiberStatusTypeId, OP_DONE, OP_RUNNING, OP_SUSPENDED, DoneHash, Done, Running, Suspended, done3, running, suspended, isFiberStatus, isDone2, isSuspended;
var init_fiberStatus = __esm({
  "node_modules/effect/dist/esm/internal/fiberStatus.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_Hash();
    init_Predicate();
    FiberStatusSymbolKey = "effect/FiberStatus";
    FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
    OP_DONE = "Done";
    OP_RUNNING = "Running";
    OP_SUSPENDED = "Suspended";
    DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE}`);
    Done = class {
      static {
        __name(this, "Done");
      }
      [FiberStatusTypeId] = FiberStatusTypeId;
      _tag = OP_DONE;
      [symbol]() {
        return DoneHash;
      }
      [symbol2](that) {
        return isFiberStatus(that) && that._tag === OP_DONE;
      }
    };
    Running = class {
      static {
        __name(this, "Running");
      }
      runtimeFlags;
      [FiberStatusTypeId] = FiberStatusTypeId;
      _tag = OP_RUNNING;
      constructor(runtimeFlags2) {
        this.runtimeFlags = runtimeFlags2;
      }
      [symbol]() {
        return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
      }
      [symbol2](that) {
        return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
      }
    };
    Suspended = class {
      static {
        __name(this, "Suspended");
      }
      runtimeFlags;
      blockingOn;
      [FiberStatusTypeId] = FiberStatusTypeId;
      _tag = OP_SUSPENDED;
      constructor(runtimeFlags2, blockingOn) {
        this.runtimeFlags = runtimeFlags2;
        this.blockingOn = blockingOn;
      }
      [symbol]() {
        return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
      }
      [symbol2](that) {
        return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
      }
    };
    done3 = /* @__PURE__ */ new Done();
    running = /* @__PURE__ */ __name((runtimeFlags2) => new Running(runtimeFlags2), "running");
    suspended = /* @__PURE__ */ __name((runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn), "suspended");
    isFiberStatus = /* @__PURE__ */ __name((u) => hasProperty(u, FiberStatusTypeId), "isFiberStatus");
    isDone2 = /* @__PURE__ */ __name((self2) => self2._tag === OP_DONE, "isDone");
    isSuspended = /* @__PURE__ */ __name((self2) => self2._tag === OP_SUSPENDED, "isSuspended");
  }
});

// node_modules/effect/dist/esm/FiberStatus.js
var done4, running2, suspended2, isDone3, isSuspended2;
var init_FiberStatus = __esm({
  "node_modules/effect/dist/esm/FiberStatus.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_fiberStatus();
    done4 = done3;
    running2 = running;
    suspended2 = suspended;
    isDone3 = isDone2;
    isSuspended2 = isSuspended;
  }
});

// node_modules/effect/dist/esm/Micro.js
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
var TypeId15, MicroExitTypeId, MicroCauseTypeId, microCauseVariance, MicroCauseImpl, Die, causeDie, Interrupt, causeInterrupt, causeIsInterrupt, MicroFiberTypeId, fiberVariance, MicroFiberImpl, fiberMiddleware, fiberInterruptAll, identifier, args, evaluate, successCont, failureCont, ensureCont, Yield, microVariance, MicroProto, makePrimitiveProto, makePrimitive, makeExit, succeed4, failCause4, sync2, suspend2, yieldNowWith, yieldNow2, void_4, withMicroFiber, asyncOptions, asyncFinalizer, async, as3, exit3, flatMap9, OnSuccessProto, map13, isMicroExit, exitSucceed2, exitFailCause2, exitInterrupt2, exitDie2, exitVoid2, exitVoidAll, setImmediate, MicroSchedulerDefault, updateContext, provideContext2, MaxOpsBeforeYield, CurrentConcurrency, CurrentScheduler, matchCauseEffect2, OnSuccessAndFailureProto, matchCause2, MicroScopeTypeId, MicroScopeImpl, onExit2, setInterruptible, interruptible3, uninterruptibleMask2, whileLoop2, forEach5, unsafeFork, runFork;
var init_Micro = __esm({
  "node_modules/effect/dist/esm/Micro.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Context();
    init_Effectable();
    init_Equal();
    init_Function();
    init_GlobalValue();
    init_Hash();
    init_Inspectable();
    init_context2();
    init_Pipeable();
    init_Predicate();
    init_Utils();
    TypeId15 = /* @__PURE__ */ Symbol.for("effect/Micro");
    MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
    MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
    microCauseVariance = {
      _E: identity
    };
    MicroCauseImpl = class extends globalThis.Error {
      static {
        __name(this, "MicroCauseImpl");
      }
      _tag;
      traces;
      [MicroCauseTypeId];
      constructor(_tag, originalError, traces) {
        const causeName = `MicroCause.${_tag}`;
        let name;
        let message;
        let stack;
        if (originalError instanceof globalThis.Error) {
          name = `(${causeName}) ${originalError.name}`;
          message = originalError.message;
          const messageLines = message.split("\n").length;
          stack = originalError.stack ? `(${causeName}) ${originalError.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
        } else {
          name = causeName;
          message = toStringUnknown(originalError, 0);
          stack = `${name}: ${message}`;
        }
        if (traces.length > 0) {
          stack += `
    ${traces.join("\n    ")}`;
        }
        super(message);
        this._tag = _tag;
        this.traces = traces;
        this[MicroCauseTypeId] = microCauseVariance;
        this.name = name;
        this.stack = stack;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
      toString() {
        return this.stack;
      }
      [NodeInspectSymbol]() {
        return this.stack;
      }
    };
    Die = class extends MicroCauseImpl {
      static {
        __name(this, "Die");
      }
      defect;
      constructor(defect, traces = []) {
        super("Die", defect, traces);
        this.defect = defect;
      }
    };
    causeDie = /* @__PURE__ */ __name((defect, traces = []) => new Die(defect, traces), "causeDie");
    Interrupt = class extends MicroCauseImpl {
      static {
        __name(this, "Interrupt");
      }
      constructor(traces = []) {
        super("Interrupt", "interrupted", traces);
      }
    };
    causeInterrupt = /* @__PURE__ */ __name((traces = []) => new Interrupt(traces), "causeInterrupt");
    causeIsInterrupt = /* @__PURE__ */ __name((self2) => self2._tag === "Interrupt", "causeIsInterrupt");
    MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
    fiberVariance = {
      _A: identity,
      _E: identity
    };
    MicroFiberImpl = class {
      static {
        __name(this, "MicroFiberImpl");
      }
      context;
      interruptible;
      [MicroFiberTypeId];
      _stack = [];
      _observers = [];
      _exit;
      _children;
      currentOpCount = 0;
      constructor(context10, interruptible5 = true) {
        this.context = context10;
        this.interruptible = interruptible5;
        this[MicroFiberTypeId] = fiberVariance;
      }
      getRef(ref2) {
        return unsafeGetReference(this.context, ref2);
      }
      addObserver(cb) {
        if (this._exit) {
          cb(this._exit);
          return constVoid;
        }
        this._observers.push(cb);
        return () => {
          const index2 = this._observers.indexOf(cb);
          if (index2 >= 0) {
            this._observers.splice(index2, 1);
          }
        };
      }
      _interrupted = false;
      unsafeInterrupt() {
        if (this._exit) {
          return;
        }
        this._interrupted = true;
        if (this.interruptible) {
          this.evaluate(exitInterrupt2);
        }
      }
      unsafePoll() {
        return this._exit;
      }
      evaluate(effect4) {
        if (this._exit) {
          return;
        } else if (this._yielded !== void 0) {
          const yielded = this._yielded;
          this._yielded = void 0;
          yielded();
        }
        const exit5 = this.runLoop(effect4);
        if (exit5 === Yield) {
          return;
        }
        const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
        if (interruptChildren !== void 0) {
          return this.evaluate(flatMap9(interruptChildren, () => exit5));
        }
        this._exit = exit5;
        for (let i = 0; i < this._observers.length; i++) {
          this._observers[i](exit5);
        }
        this._observers.length = 0;
      }
      runLoop(effect4) {
        let yielding = false;
        let current2 = effect4;
        this.currentOpCount = 0;
        try {
          while (true) {
            this.currentOpCount++;
            if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
              yielding = true;
              const prev = current2;
              current2 = flatMap9(yieldNow2, () => prev);
            }
            current2 = current2[evaluate](this);
            if (current2 === Yield) {
              const yielded = this._yielded;
              if (MicroExitTypeId in yielded) {
                this._yielded = void 0;
                return yielded;
              }
              return Yield;
            }
          }
        } catch (error50) {
          if (!hasProperty(current2, evaluate)) {
            return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current2)}`);
          }
          return exitDie2(error50);
        }
      }
      getCont(symbol4) {
        while (true) {
          const op = this._stack.pop();
          if (!op) return void 0;
          const cont = op[ensureCont] && op[ensureCont](this);
          if (cont) return {
            [symbol4]: cont
          };
          if (op[symbol4]) return op;
        }
      }
      // cancel the yielded operation, or for the yielded exit value
      _yielded = void 0;
      yieldWith(value3) {
        this._yielded = value3;
        return Yield;
      }
      children() {
        return this._children ??= /* @__PURE__ */ new Set();
      }
    };
    fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
      interruptChildren: void 0
    }));
    fiberInterruptAll = /* @__PURE__ */ __name((fibers2) => suspend2(() => {
      for (const fiber of fibers2) fiber.unsafeInterrupt();
      const iter = fibers2[Symbol.iterator]();
      const wait = suspend2(() => {
        let result = iter.next();
        while (!result.done) {
          if (result.value.unsafePoll()) {
            result = iter.next();
            continue;
          }
          const fiber = result.value;
          return async((resume2) => {
            fiber.addObserver((_) => {
              resume2(wait);
            });
          });
        }
        return exitVoid2;
      });
      return wait;
    }), "fiberInterruptAll");
    identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
    args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
    evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
    successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
    failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
    ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
    Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
    microVariance = {
      _A: identity,
      _E: identity,
      _R: identity
    };
    MicroProto = {
      ...EffectPrototype2,
      _op: "Micro",
      [TypeId15]: microVariance,
      pipe() {
        return pipeArguments(this, arguments);
      },
      [Symbol.iterator]() {
        return new SingleShotGen(new YieldWrap(this));
      },
      toJSON() {
        return {
          _id: "Micro",
          op: this[identifier],
          ...args in this ? {
            args: this[args]
          } : void 0
        };
      },
      toString() {
        return format(this);
      },
      [NodeInspectSymbol]() {
        return format(this);
      }
    };
    __name(defaultEvaluate, "defaultEvaluate");
    makePrimitiveProto = /* @__PURE__ */ __name((options) => ({
      ...MicroProto,
      [identifier]: options.op,
      [evaluate]: options.eval ?? defaultEvaluate,
      [successCont]: options.contA,
      [failureCont]: options.contE,
      [ensureCont]: options.ensure
    }), "makePrimitiveProto");
    makePrimitive = /* @__PURE__ */ __name((options) => {
      const Proto9 = makePrimitiveProto(options);
      return function() {
        const self2 = Object.create(Proto9);
        self2[args] = options.single === false ? arguments : arguments[0];
        return self2;
      };
    }, "makePrimitive");
    makeExit = /* @__PURE__ */ __name((options) => {
      const Proto9 = {
        ...makePrimitiveProto(options),
        [MicroExitTypeId]: MicroExitTypeId,
        _tag: options.op,
        get [options.prop]() {
          return this[args];
        },
        toJSON() {
          return {
            _id: "MicroExit",
            _tag: options.op,
            [options.prop]: this[args]
          };
        },
        [symbol2](that) {
          return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
        },
        [symbol]() {
          return cached(this, combine(string(options.op))(hash(this[args])));
        }
      };
      return function(value3) {
        const self2 = Object.create(Proto9);
        self2[args] = value3;
        self2[successCont] = void 0;
        self2[failureCont] = void 0;
        self2[ensureCont] = void 0;
        return self2;
      };
    }, "makeExit");
    succeed4 = /* @__PURE__ */ makeExit({
      op: "Success",
      prop: "value",
      eval(fiber) {
        const cont = fiber.getCont(successCont);
        return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
      }
    });
    failCause4 = /* @__PURE__ */ makeExit({
      op: "Failure",
      prop: "cause",
      eval(fiber) {
        let cont = fiber.getCont(failureCont);
        while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
          cont = fiber.getCont(failureCont);
        }
        return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
      }
    });
    sync2 = /* @__PURE__ */ makePrimitive({
      op: "Sync",
      eval(fiber) {
        const value3 = this[args]();
        const cont = fiber.getCont(successCont);
        return cont ? cont[successCont](value3, fiber) : fiber.yieldWith(exitSucceed2(value3));
      }
    });
    suspend2 = /* @__PURE__ */ makePrimitive({
      op: "Suspend",
      eval(_fiber) {
        return this[args]();
      }
    });
    yieldNowWith = /* @__PURE__ */ makePrimitive({
      op: "Yield",
      eval(fiber) {
        let resumed = false;
        fiber.getRef(CurrentScheduler).scheduleTask(() => {
          if (resumed) return;
          fiber.evaluate(exitVoid2);
        }, this[args] ?? 0);
        return fiber.yieldWith(() => {
          resumed = true;
        });
      }
    });
    yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
    void_4 = /* @__PURE__ */ succeed4(void 0);
    withMicroFiber = /* @__PURE__ */ makePrimitive({
      op: "WithMicroFiber",
      eval(fiber) {
        return this[args](fiber);
      }
    });
    asyncOptions = /* @__PURE__ */ makePrimitive({
      op: "Async",
      single: false,
      eval(fiber) {
        const register = this[args][0];
        let resumed = false;
        let yielded = false;
        const controller = this[args][1] ? new AbortController() : void 0;
        const onCancel = register((effect4) => {
          if (resumed) return;
          resumed = true;
          if (yielded) {
            fiber.evaluate(effect4);
          } else {
            yielded = effect4;
          }
        }, controller?.signal);
        if (yielded !== false) return yielded;
        yielded = true;
        fiber._yielded = () => {
          resumed = true;
        };
        if (controller === void 0 && onCancel === void 0) {
          return Yield;
        }
        fiber._stack.push(asyncFinalizer(() => {
          resumed = true;
          controller?.abort();
          return onCancel ?? exitVoid2;
        }));
        return Yield;
      }
    });
    asyncFinalizer = /* @__PURE__ */ makePrimitive({
      op: "AsyncFinalizer",
      ensure(fiber) {
        if (fiber.interruptible) {
          fiber.interruptible = false;
          fiber._stack.push(setInterruptible(true));
        }
      },
      contE(cause3, _fiber) {
        return causeIsInterrupt(cause3) ? flatMap9(this[args](), () => failCause4(cause3)) : failCause4(cause3);
      }
    });
    async = /* @__PURE__ */ __name((register) => asyncOptions(register, register.length >= 2), "async");
    as3 = /* @__PURE__ */ dual(2, (self2, value3) => map13(self2, (_) => value3));
    exit3 = /* @__PURE__ */ __name((self2) => matchCause2(self2, {
      onFailure: exitFailCause2,
      onSuccess: exitSucceed2
    }), "exit");
    flatMap9 = /* @__PURE__ */ dual(2, (self2, f) => {
      const onSuccess = Object.create(OnSuccessProto);
      onSuccess[args] = self2;
      onSuccess[successCont] = f;
      return onSuccess;
    });
    OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
      op: "OnSuccess",
      eval(fiber) {
        fiber._stack.push(this);
        return this[args];
      }
    });
    map13 = /* @__PURE__ */ dual(2, (self2, f) => flatMap9(self2, (a) => succeed4(f(a))));
    isMicroExit = /* @__PURE__ */ __name((u) => hasProperty(u, MicroExitTypeId), "isMicroExit");
    exitSucceed2 = succeed4;
    exitFailCause2 = failCause4;
    exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
    exitDie2 = /* @__PURE__ */ __name((defect) => exitFailCause2(causeDie(defect)), "exitDie");
    exitVoid2 = /* @__PURE__ */ exitSucceed2(void 0);
    exitVoidAll = /* @__PURE__ */ __name((exits) => {
      for (const exit5 of exits) {
        if (exit5._tag === "Failure") {
          return exit5;
        }
      }
      return exitVoid2;
    }, "exitVoidAll");
    setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);
    MicroSchedulerDefault = class {
      static {
        __name(this, "MicroSchedulerDefault");
      }
      tasks = [];
      running = false;
      /**
       * @since 3.5.9
       */
      scheduleTask(task, _priority) {
        this.tasks.push(task);
        if (!this.running) {
          this.running = true;
          setImmediate(this.afterScheduled);
        }
      }
      /**
       * @since 3.5.9
       */
      afterScheduled = /* @__PURE__ */ __name(() => {
        this.running = false;
        this.runTasks();
      }, "afterScheduled");
      /**
       * @since 3.5.9
       */
      runTasks() {
        const tasks = this.tasks;
        this.tasks = [];
        for (let i = 0, len = tasks.length; i < len; i++) {
          tasks[i]();
        }
      }
      /**
       * @since 3.5.9
       */
      shouldYield(fiber) {
        return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
      }
      /**
       * @since 3.5.9
       */
      flush() {
        while (this.tasks.length > 0) {
          this.runTasks();
        }
      }
    };
    updateContext = /* @__PURE__ */ dual(2, (self2, f) => withMicroFiber((fiber) => {
      const prev = fiber.context;
      fiber.context = f(prev);
      return onExit2(self2, () => {
        fiber.context = prev;
        return void_4;
      });
    }));
    provideContext2 = /* @__PURE__ */ dual(2, (self2, provided) => updateContext(self2, merge3(provided)));
    MaxOpsBeforeYield = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
      defaultValue: /* @__PURE__ */ __name(() => 2048, "defaultValue")
    })) {
      static {
        __name(this, "MaxOpsBeforeYield");
      }
    };
    CurrentConcurrency = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentConcurrency", {
      defaultValue: /* @__PURE__ */ __name(() => "unbounded", "defaultValue")
    })) {
      static {
        __name(this, "CurrentConcurrency");
      }
    };
    CurrentScheduler = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
      defaultValue: /* @__PURE__ */ __name(() => new MicroSchedulerDefault(), "defaultValue")
    })) {
      static {
        __name(this, "CurrentScheduler");
      }
    };
    matchCauseEffect2 = /* @__PURE__ */ dual(2, (self2, options) => {
      const primitive2 = Object.create(OnSuccessAndFailureProto);
      primitive2[args] = self2;
      primitive2[successCont] = options.onSuccess;
      primitive2[failureCont] = options.onFailure;
      return primitive2;
    });
    OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
      op: "OnSuccessAndFailure",
      eval(fiber) {
        fiber._stack.push(this);
        return this[args];
      }
    });
    matchCause2 = /* @__PURE__ */ dual(2, (self2, options) => matchCauseEffect2(self2, {
      onFailure: /* @__PURE__ */ __name((cause3) => sync2(() => options.onFailure(cause3)), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((value3) => sync2(() => options.onSuccess(value3)), "onSuccess")
    }));
    MicroScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroScope");
    MicroScopeImpl = class _MicroScopeImpl {
      static {
        __name(this, "MicroScopeImpl");
      }
      [MicroScopeTypeId];
      state = {
        _tag: "Open",
        finalizers: /* @__PURE__ */ new Set()
      };
      constructor() {
        this[MicroScopeTypeId] = MicroScopeTypeId;
      }
      unsafeAddFinalizer(finalizer3) {
        if (this.state._tag === "Open") {
          this.state.finalizers.add(finalizer3);
        }
      }
      addFinalizer(finalizer3) {
        return suspend2(() => {
          if (this.state._tag === "Open") {
            this.state.finalizers.add(finalizer3);
            return void_4;
          }
          return finalizer3(this.state.exit);
        });
      }
      unsafeRemoveFinalizer(finalizer3) {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(finalizer3);
        }
      }
      close(microExit) {
        return suspend2(() => {
          if (this.state._tag === "Open") {
            const finalizers = Array.from(this.state.finalizers).reverse();
            this.state = {
              _tag: "Closed",
              exit: microExit
            };
            return flatMap9(forEach5(finalizers, (finalizer3) => exit3(finalizer3(microExit))), exitVoidAll);
          }
          return void_4;
        });
      }
      get fork() {
        return sync2(() => {
          const newScope = new _MicroScopeImpl();
          if (this.state._tag === "Closed") {
            newScope.state = this.state;
            return newScope;
          }
          function fin(exit5) {
            return newScope.close(exit5);
          }
          __name(fin, "fin");
          this.state.finalizers.add(fin);
          newScope.unsafeAddFinalizer((_) => sync2(() => this.unsafeRemoveFinalizer(fin)));
          return newScope;
        });
      }
    };
    onExit2 = /* @__PURE__ */ dual(2, (self2, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self2), {
      onFailure: /* @__PURE__ */ __name((cause3) => flatMap9(f(exitFailCause2(cause3)), () => failCause4(cause3)), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((a) => flatMap9(f(exitSucceed2(a)), () => succeed4(a)), "onSuccess")
    })));
    setInterruptible = /* @__PURE__ */ makePrimitive({
      op: "SetInterruptible",
      ensure(fiber) {
        fiber.interruptible = this[args];
        if (fiber._interrupted && fiber.interruptible) {
          return () => exitInterrupt2;
        }
      }
    });
    interruptible3 = /* @__PURE__ */ __name((self2) => withMicroFiber((fiber) => {
      if (fiber.interruptible) return self2;
      fiber.interruptible = true;
      fiber._stack.push(setInterruptible(false));
      if (fiber._interrupted) return exitInterrupt2;
      return self2;
    }), "interruptible");
    uninterruptibleMask2 = /* @__PURE__ */ __name((f) => withMicroFiber((fiber) => {
      if (!fiber.interruptible) return f(identity);
      fiber.interruptible = false;
      fiber._stack.push(setInterruptible(true));
      return f(interruptible3);
    }), "uninterruptibleMask");
    whileLoop2 = /* @__PURE__ */ makePrimitive({
      op: "While",
      contA(value3, fiber) {
        this[args].step(value3);
        if (this[args].while()) {
          fiber._stack.push(this);
          return this[args].body();
        }
        return exitVoid2;
      },
      eval(fiber) {
        if (this[args].while()) {
          fiber._stack.push(this);
          return this[args].body();
        }
        return exitVoid2;
      }
    });
    forEach5 = /* @__PURE__ */ __name((iterable, f, options) => withMicroFiber((parent) => {
      const concurrencyOption = options?.concurrency === "inherit" ? parent.getRef(CurrentConcurrency) : options?.concurrency ?? 1;
      const concurrency = concurrencyOption === "unbounded" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);
      const items = fromIterable2(iterable);
      let length4 = items.length;
      if (length4 === 0) {
        return options?.discard ? void_4 : succeed4([]);
      }
      const out = options?.discard ? void 0 : new Array(length4);
      let index2 = 0;
      if (concurrency === 1) {
        return as3(whileLoop2({
          while: /* @__PURE__ */ __name(() => index2 < items.length, "while"),
          body: /* @__PURE__ */ __name(() => f(items[index2], index2), "body"),
          step: out ? (b) => out[index2++] = b : (_) => index2++
        }), out);
      }
      return async((resume2) => {
        const fibers2 = /* @__PURE__ */ new Set();
        let result = void 0;
        let inProgress = 0;
        let doneCount = 0;
        let pumping = false;
        let interrupted3 = false;
        function pump() {
          pumping = true;
          while (inProgress < concurrency && index2 < length4) {
            const currentIndex = index2;
            const item = items[currentIndex];
            index2++;
            inProgress++;
            try {
              const child = unsafeFork(parent, f(item, currentIndex), true, true);
              fibers2.add(child);
              child.addObserver((exit5) => {
                fibers2.delete(child);
                if (interrupted3) {
                  return;
                } else if (exit5._tag === "Failure") {
                  if (result === void 0) {
                    result = exit5;
                    length4 = index2;
                    fibers2.forEach((fiber) => fiber.unsafeInterrupt());
                  }
                } else if (out !== void 0) {
                  out[currentIndex] = exit5.value;
                }
                doneCount++;
                inProgress--;
                if (doneCount === length4) {
                  resume2(result ?? succeed4(out));
                } else if (!pumping && inProgress < concurrency) {
                  pump();
                }
              });
            } catch (err) {
              result = exitDie2(err);
              length4 = index2;
              fibers2.forEach((fiber) => fiber.unsafeInterrupt());
            }
          }
          pumping = false;
        }
        __name(pump, "pump");
        pump();
        return suspend2(() => {
          interrupted3 = true;
          index2 = length4;
          return fiberInterruptAll(fibers2);
        });
      });
    }), "forEach");
    unsafeFork = /* @__PURE__ */ __name((parent, effect4, immediate = false, daemon = false) => {
      const child = new MicroFiberImpl(parent.context, parent.interruptible);
      if (!daemon) {
        parent.children().add(child);
        child.addObserver(() => parent.children().delete(child));
      }
      if (immediate) {
        child.evaluate(effect4);
      } else {
        parent.getRef(CurrentScheduler).scheduleTask(() => child.evaluate(effect4), 0);
      }
      return child;
    }, "unsafeFork");
    runFork = /* @__PURE__ */ __name((effect4, options) => {
      const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault()));
      fiber.evaluate(effect4);
      if (options?.signal) {
        if (options.signal.aborted) {
          fiber.unsafeInterrupt();
        } else {
          const abort2 = /* @__PURE__ */ __name(() => fiber.unsafeInterrupt(), "abort");
          options.signal.addEventListener("abort", abort2, {
            once: true
          });
          fiber.addObserver(() => options.signal.removeEventListener("abort", abort2));
        }
      }
      return fiber;
    }, "runFork");
  }
});

// node_modules/effect/dist/esm/Scheduler.js
var PriorityBuckets, MixedScheduler, defaultScheduler, SyncScheduler, currentScheduler, withScheduler;
var init_Scheduler = __esm({
  "node_modules/effect/dist/esm/Scheduler.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_GlobalValue();
    init_core();
    PriorityBuckets = class {
      static {
        __name(this, "PriorityBuckets");
      }
      /**
       * @since 2.0.0
       */
      buckets = [];
      /**
       * @since 2.0.0
       */
      scheduleTask(task, priority) {
        const length4 = this.buckets.length;
        let bucket = void 0;
        let index2 = 0;
        for (; index2 < length4; index2++) {
          if (this.buckets[index2][0] <= priority) {
            bucket = this.buckets[index2];
          } else {
            break;
          }
        }
        if (bucket && bucket[0] === priority) {
          bucket[1].push(task);
        } else if (index2 === length4) {
          this.buckets.push([priority, [task]]);
        } else {
          this.buckets.splice(index2, 0, [priority, [task]]);
        }
      }
    };
    MixedScheduler = class {
      static {
        __name(this, "MixedScheduler");
      }
      maxNextTickBeforeTimer;
      /**
       * @since 2.0.0
       */
      running = false;
      /**
       * @since 2.0.0
       */
      tasks = /* @__PURE__ */ new PriorityBuckets();
      constructor(maxNextTickBeforeTimer) {
        this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
      }
      /**
       * @since 2.0.0
       */
      starveInternal(depth) {
        const tasks = this.tasks.buckets;
        this.tasks.buckets = [];
        for (const [_, toRun] of tasks) {
          for (let i = 0; i < toRun.length; i++) {
            toRun[i]();
          }
        }
        if (this.tasks.buckets.length === 0) {
          this.running = false;
        } else {
          this.starve(depth);
        }
      }
      /**
       * @since 2.0.0
       */
      starve(depth = 0) {
        if (depth >= this.maxNextTickBeforeTimer) {
          setTimeout(() => this.starveInternal(0), 0);
        } else {
          Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
        }
      }
      /**
       * @since 2.0.0
       */
      shouldYield(fiber) {
        return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
      }
      /**
       * @since 2.0.0
       */
      scheduleTask(task, priority) {
        this.tasks.scheduleTask(task, priority);
        if (!this.running) {
          this.running = true;
          this.starve();
        }
      }
    };
    defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
    SyncScheduler = class {
      static {
        __name(this, "SyncScheduler");
      }
      /**
       * @since 2.0.0
       */
      tasks = /* @__PURE__ */ new PriorityBuckets();
      /**
       * @since 2.0.0
       */
      deferred = false;
      /**
       * @since 2.0.0
       */
      scheduleTask(task, priority) {
        if (this.deferred) {
          defaultScheduler.scheduleTask(task, priority);
        } else {
          this.tasks.scheduleTask(task, priority);
        }
      }
      /**
       * @since 2.0.0
       */
      shouldYield(fiber) {
        return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
      }
      /**
       * @since 2.0.0
       */
      flush() {
        while (this.tasks.buckets.length > 0) {
          const tasks = this.tasks.buckets;
          this.tasks.buckets = [];
          for (const [_, toRun] of tasks) {
            for (let i = 0; i < toRun.length; i++) {
              toRun[i]();
            }
          }
        }
        this.deferred = true;
      }
    };
    currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
    withScheduler = /* @__PURE__ */ dual(2, (self2, scheduler2) => fiberRefLocally(self2, currentScheduler, scheduler2));
  }
});

// node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap;
var init_completedRequestMap = __esm({
  "node_modules/effect/dist/esm/internal/completedRequestMap.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_GlobalValue();
    init_core();
    currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));
  }
});

// node_modules/effect/dist/esm/internal/concurrency.js
var match9, matchSimple;
var init_concurrency = __esm({
  "node_modules/effect/dist/esm/internal/concurrency.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_core();
    match9 = /* @__PURE__ */ __name((concurrency, sequential5, unbounded8, bounded8) => {
      switch (concurrency) {
        case void 0:
          return sequential5();
        case "unbounded":
          return unbounded8();
        case "inherit":
          return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded8() : concurrency2 > 1 ? bounded8(concurrency2) : sequential5());
        default:
          return concurrency > 1 ? bounded8(concurrency) : sequential5();
      }
    }, "match");
    matchSimple = /* @__PURE__ */ __name((concurrency, sequential5, concurrent) => {
      switch (concurrency) {
        case void 0:
          return sequential5();
        case "unbounded":
          return concurrent();
        case "inherit":
          return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential5());
        default:
          return concurrency > 1 ? concurrent() : sequential5();
      }
    }, "matchSimple");
  }
});

// node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL, OP_STATEFUL, OP_RESUME, OP_YIELD_NOW, interruptSignal, stateful, resume, yieldNow3;
var init_fiberMessage = __esm({
  "node_modules/effect/dist/esm/internal/fiberMessage.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_INTERRUPT_SIGNAL = "InterruptSignal";
    OP_STATEFUL = "Stateful";
    OP_RESUME = "Resume";
    OP_YIELD_NOW = "YieldNow";
    interruptSignal = /* @__PURE__ */ __name((cause3) => ({
      _tag: OP_INTERRUPT_SIGNAL,
      cause: cause3
    }), "interruptSignal");
    stateful = /* @__PURE__ */ __name((onFiber) => ({
      _tag: OP_STATEFUL,
      onFiber
    }), "stateful");
    resume = /* @__PURE__ */ __name((effect4) => ({
      _tag: OP_RESUME,
      effect: effect4
    }), "resume");
    yieldNow3 = /* @__PURE__ */ __name(() => ({
      _tag: OP_YIELD_NOW
    }), "yieldNow");
  }
});

// node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey, FiberScopeTypeId, Global, Local, unsafeMake8, globalScope;
var init_fiberScope = __esm({
  "node_modules/effect/dist/esm/internal/fiberScope.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_FiberId();
    init_GlobalValue();
    init_fiberMessage();
    FiberScopeSymbolKey = "effect/FiberScope";
    FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);
    Global = class {
      static {
        __name(this, "Global");
      }
      [FiberScopeTypeId] = FiberScopeTypeId;
      fiberId = none4;
      roots = /* @__PURE__ */ new Set();
      add(_runtimeFlags, child) {
        this.roots.add(child);
        child.addObserver(() => {
          this.roots.delete(child);
        });
      }
    };
    Local = class {
      static {
        __name(this, "Local");
      }
      fiberId;
      parent;
      [FiberScopeTypeId] = FiberScopeTypeId;
      constructor(fiberId3, parent) {
        this.fiberId = fiberId3;
        this.parent = parent;
      }
      add(_runtimeFlags, child) {
        this.parent.tell(stateful((parentFiber) => {
          parentFiber.addChild(child);
          child.addObserver(() => {
            parentFiber.removeChild(child);
          });
        }));
      }
    };
    unsafeMake8 = /* @__PURE__ */ __name((fiber) => {
      return new Local(fiber.id(), fiber);
    }, "unsafeMake");
    globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global());
  }
});

// node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey, FiberTypeId, fiberVariance2, fiberProto, RuntimeFiberSymbolKey, RuntimeFiberTypeId, Order6, isRuntimeFiber, _await2, inheritAll, interruptAllAs, interruptAsFork, join2, _never, poll3, currentFiberURI;
var init_fiber = __esm({
  "node_modules/effect/dist/esm/internal/fiber.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_FiberId();
    init_Function();
    init_Number();
    init_Option();
    init_Order();
    init_Pipeable();
    init_core();
    init_effectable();
    FiberSymbolKey = "effect/Fiber";
    FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
    fiberVariance2 = {
      /* c8 ignore next */
      _E: /* @__PURE__ */ __name((_) => _, "_E"),
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    fiberProto = {
      [FiberTypeId]: fiberVariance2,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    RuntimeFiberSymbolKey = "effect/Fiber";
    RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
    Order6 = /* @__PURE__ */ pipe(/* @__PURE__ */ tuple(Order, Order), /* @__PURE__ */ mapInput2((fiber) => [fiber.id().startTimeMillis, fiber.id().id]));
    isRuntimeFiber = /* @__PURE__ */ __name((self2) => RuntimeFiberTypeId in self2, "isRuntimeFiber");
    _await2 = /* @__PURE__ */ __name((self2) => self2.await, "_await");
    inheritAll = /* @__PURE__ */ __name((self2) => self2.inheritAll, "inheritAll");
    interruptAllAs = /* @__PURE__ */ dual(2, /* @__PURE__ */ fnUntraced(function* (fibers2, fiberId3) {
      for (const fiber of fibers2) {
        if (isRuntimeFiber(fiber)) {
          fiber.unsafeInterruptAsFork(fiberId3);
          continue;
        }
        yield* fiber.interruptAsFork(fiberId3);
      }
      for (const fiber of fibers2) {
        if (isRuntimeFiber(fiber) && fiber.unsafePoll()) {
          continue;
        }
        yield* fiber.await;
      }
    }));
    interruptAsFork = /* @__PURE__ */ dual(2, (self2, fiberId3) => self2.interruptAsFork(fiberId3));
    join2 = /* @__PURE__ */ __name((self2) => zipLeft2(flatten7(self2.await), self2.inheritAll), "join");
    _never = {
      ...CommitPrototype,
      commit() {
        return join2(this);
      },
      ...fiberProto,
      id: /* @__PURE__ */ __name(() => none4, "id"),
      await: never,
      children: /* @__PURE__ */ succeed([]),
      inheritAll: never,
      poll: /* @__PURE__ */ succeed(/* @__PURE__ */ none2()),
      interruptAsFork: /* @__PURE__ */ __name(() => never, "interruptAsFork")
    };
    poll3 = /* @__PURE__ */ __name((self2) => self2.poll, "poll");
    currentFiberURI = "effect/FiberCurrent";
  }
});

// node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey, LoggerTypeId, loggerVariance, makeLogger, none7, textOnly, format4, escapeDoubleQuotes, stringLogger, colors, logLevelColors, hasProcessStdout, processStdoutIsTTY, hasProcessStdoutOrDeno;
var init_logger = __esm({
  "node_modules/effect/dist/esm/internal/logger.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Function();
    init_Inspectable();
    init_Pipeable();
    init_cause2();
    init_fiberId();
    init_logSpan();
    LoggerSymbolKey = "effect/Logger";
    LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
    loggerVariance = {
      /* c8 ignore next */
      _Message: /* @__PURE__ */ __name((_) => _, "_Message"),
      /* c8 ignore next */
      _Output: /* @__PURE__ */ __name((_) => _, "_Output")
    };
    makeLogger = /* @__PURE__ */ __name((log5) => ({
      [LoggerTypeId]: loggerVariance,
      log: log5,
      pipe() {
        return pipeArguments(this, arguments);
      }
    }), "makeLogger");
    none7 = {
      [LoggerTypeId]: loggerVariance,
      log: constVoid,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    textOnly = /^[^\s"=]*$/;
    format4 = /* @__PURE__ */ __name((quoteValue, whitespace) => ({
      annotations: annotations3,
      cause: cause3,
      date: date7,
      fiberId: fiberId3,
      logLevel: logLevel2,
      message,
      spans
    }) => {
      const formatValue = /* @__PURE__ */ __name((value3) => value3.match(textOnly) ? value3 : quoteValue(value3), "formatValue");
      const format7 = /* @__PURE__ */ __name((label, value3) => `${formatLabel(label)}=${formatValue(value3)}`, "format");
      const append4 = /* @__PURE__ */ __name((label, value3) => " " + format7(label, value3), "append");
      let out = format7("timestamp", date7.toISOString());
      out += append4("level", logLevel2.label);
      out += append4("fiber", threadName(fiberId3));
      const messages = ensure(message);
      for (let i = 0; i < messages.length; i++) {
        out += append4("message", toStringUnknown(messages[i], whitespace));
      }
      if (!isEmptyType(cause3)) {
        out += append4("cause", pretty(cause3, {
          renderErrorCause: true
        }));
      }
      for (const span4 of spans) {
        out += " " + render(date7.getTime())(span4);
      }
      for (const [label, value3] of annotations3) {
        out += append4(label, toStringUnknown(value3, whitespace));
      }
      return out;
    }, "format");
    escapeDoubleQuotes = /* @__PURE__ */ __name((s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`, "escapeDoubleQuotes");
    stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format4(escapeDoubleQuotes));
    colors = {
      bold: "1",
      red: "31",
      green: "32",
      yellow: "33",
      blue: "34",
      cyan: "36",
      white: "37",
      gray: "90",
      black: "30",
      bgBrightRed: "101"
    };
    logLevelColors = {
      None: [],
      All: [],
      Trace: [colors.gray],
      Debug: [colors.blue],
      Info: [colors.green],
      Warning: [colors.yellow],
      Error: [colors.red],
      Fatal: [colors.bgBrightRed, colors.black]
    };
    hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
    processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
    hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;
  }
});

// node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey, MetricBoundariesTypeId, MetricBoundariesImpl, isMetricBoundaries, fromIterable9, exponential;
var init_boundaries = __esm({
  "node_modules/effect/dist/esm/internal/metric/boundaries.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Chunk();
    init_Equal();
    init_Function();
    init_Hash();
    init_Pipeable();
    init_Predicate();
    MetricBoundariesSymbolKey = "effect/MetricBoundaries";
    MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);
    MetricBoundariesImpl = class {
      static {
        __name(this, "MetricBoundariesImpl");
      }
      values;
      [MetricBoundariesTypeId] = MetricBoundariesTypeId;
      constructor(values4) {
        this.values = values4;
        this._hash = pipe(string(MetricBoundariesSymbolKey), combine(array2(this.values)));
      }
      _hash;
      [symbol]() {
        return this._hash;
      }
      [symbol2](u) {
        return isMetricBoundaries(u) && equals(this.values, u.values);
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    isMetricBoundaries = /* @__PURE__ */ __name((u) => hasProperty(u, MetricBoundariesTypeId), "isMetricBoundaries");
    fromIterable9 = /* @__PURE__ */ __name((iterable) => {
      const values4 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
      return new MetricBoundariesImpl(values4);
    }, "fromIterable");
    exponential = /* @__PURE__ */ __name((options) => pipe(makeBy(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable9), "exponential");
  }
});

// node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey, MetricKeyTypeTypeId, CounterKeyTypeSymbolKey, CounterKeyTypeTypeId, FrequencyKeyTypeSymbolKey, FrequencyKeyTypeTypeId, GaugeKeyTypeSymbolKey, GaugeKeyTypeTypeId, HistogramKeyTypeSymbolKey, HistogramKeyTypeTypeId, SummaryKeyTypeSymbolKey, SummaryKeyTypeTypeId, metricKeyTypeVariance, CounterKeyType, FrequencyKeyTypeHash, FrequencyKeyType, GaugeKeyTypeHash, GaugeKeyType, HistogramKeyType, SummaryKeyType, counter, histogram, isCounterKey, isFrequencyKey, isGaugeKey, isHistogramKey, isSummaryKey;
var init_keyType = __esm({
  "node_modules/effect/dist/esm/internal/metric/keyType.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_Hash();
    init_Pipeable();
    init_Predicate();
    MetricKeyTypeSymbolKey = "effect/MetricKeyType";
    MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
    CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
    CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
    FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
    FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
    GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
    GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
    HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
    HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
    SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
    SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
    metricKeyTypeVariance = {
      /* c8 ignore next */
      _In: /* @__PURE__ */ __name((_) => _, "_In"),
      /* c8 ignore next */
      _Out: /* @__PURE__ */ __name((_) => _, "_Out")
    };
    CounterKeyType = class {
      static {
        __name(this, "CounterKeyType");
      }
      incremental;
      bigint;
      [MetricKeyTypeTypeId] = metricKeyTypeVariance;
      [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
      constructor(incremental, bigint6) {
        this.incremental = incremental;
        this.bigint = bigint6;
        this._hash = string(CounterKeyTypeSymbolKey);
      }
      _hash;
      [symbol]() {
        return this._hash;
      }
      [symbol2](that) {
        return isCounterKey(that);
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    FrequencyKeyTypeHash = /* @__PURE__ */ string(FrequencyKeyTypeSymbolKey);
    FrequencyKeyType = class {
      static {
        __name(this, "FrequencyKeyType");
      }
      preregisteredWords;
      [MetricKeyTypeTypeId] = metricKeyTypeVariance;
      [FrequencyKeyTypeTypeId] = FrequencyKeyTypeTypeId;
      constructor(preregisteredWords) {
        this.preregisteredWords = preregisteredWords;
      }
      [symbol]() {
        return FrequencyKeyTypeHash;
      }
      [symbol2](that) {
        return isFrequencyKey(that);
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    GaugeKeyTypeHash = /* @__PURE__ */ string(GaugeKeyTypeSymbolKey);
    GaugeKeyType = class {
      static {
        __name(this, "GaugeKeyType");
      }
      bigint;
      [MetricKeyTypeTypeId] = metricKeyTypeVariance;
      [GaugeKeyTypeTypeId] = GaugeKeyTypeTypeId;
      constructor(bigint6) {
        this.bigint = bigint6;
      }
      [symbol]() {
        return GaugeKeyTypeHash;
      }
      [symbol2](that) {
        return isGaugeKey(that);
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    HistogramKeyType = class {
      static {
        __name(this, "HistogramKeyType");
      }
      boundaries;
      [MetricKeyTypeTypeId] = metricKeyTypeVariance;
      [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
      constructor(boundaries) {
        this.boundaries = boundaries;
        this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
      }
      _hash;
      [symbol]() {
        return this._hash;
      }
      [symbol2](that) {
        return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    SummaryKeyType = class {
      static {
        __name(this, "SummaryKeyType");
      }
      maxAge;
      maxSize;
      error;
      quantiles;
      [MetricKeyTypeTypeId] = metricKeyTypeVariance;
      [SummaryKeyTypeTypeId] = SummaryKeyTypeTypeId;
      constructor(maxAge, maxSize, error50, quantiles) {
        this.maxAge = maxAge;
        this.maxSize = maxSize;
        this.error = error50;
        this.quantiles = quantiles;
        this._hash = pipe(string(SummaryKeyTypeSymbolKey), combine(hash(this.maxAge)), combine(hash(this.maxSize)), combine(hash(this.error)), combine(array2(this.quantiles)));
      }
      _hash;
      [symbol]() {
        return this._hash;
      }
      [symbol2](that) {
        return isSummaryKey(that) && equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && equals(this.quantiles, that.quantiles);
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    counter = /* @__PURE__ */ __name((options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false), "counter");
    histogram = /* @__PURE__ */ __name((boundaries) => {
      return new HistogramKeyType(boundaries);
    }, "histogram");
    isCounterKey = /* @__PURE__ */ __name((u) => hasProperty(u, CounterKeyTypeTypeId), "isCounterKey");
    isFrequencyKey = /* @__PURE__ */ __name((u) => hasProperty(u, FrequencyKeyTypeTypeId), "isFrequencyKey");
    isGaugeKey = /* @__PURE__ */ __name((u) => hasProperty(u, GaugeKeyTypeTypeId), "isGaugeKey");
    isHistogramKey = /* @__PURE__ */ __name((u) => hasProperty(u, HistogramKeyTypeTypeId), "isHistogramKey");
    isSummaryKey = /* @__PURE__ */ __name((u) => hasProperty(u, SummaryKeyTypeTypeId), "isSummaryKey");
  }
});

// node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey, MetricKeyTypeId, metricKeyVariance, arrayEquivilence, MetricKeyImpl, isMetricKey, counter2, histogram2, taggedWithLabels;
var init_key = __esm({
  "node_modules/effect/dist/esm/internal/metric/key.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Equal();
    init_Function();
    init_Hash();
    init_Option();
    init_Pipeable();
    init_Predicate();
    init_keyType();
    MetricKeySymbolKey = "effect/MetricKey";
    MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
    metricKeyVariance = {
      /* c8 ignore next */
      _Type: /* @__PURE__ */ __name((_) => _, "_Type")
    };
    arrayEquivilence = /* @__PURE__ */ getEquivalence3(equals);
    MetricKeyImpl = class {
      static {
        __name(this, "MetricKeyImpl");
      }
      name;
      keyType;
      description;
      tags;
      [MetricKeyTypeId] = metricKeyVariance;
      constructor(name, keyType, description, tags = []) {
        this.name = name;
        this.keyType = keyType;
        this.description = description;
        this.tags = tags;
        this._hash = pipe(string(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
      }
      _hash;
      [symbol]() {
        return this._hash;
      }
      [symbol2](u) {
        return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    isMetricKey = /* @__PURE__ */ __name((u) => hasProperty(u, MetricKeyTypeId), "isMetricKey");
    counter2 = /* @__PURE__ */ __name((name, options) => new MetricKeyImpl(name, counter(options), fromNullable(options?.description)), "counter");
    histogram2 = /* @__PURE__ */ __name((name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable(description)), "histogram");
    taggedWithLabels = /* @__PURE__ */ dual(2, (self2, extraTags) => extraTags.length === 0 ? self2 : new MetricKeyImpl(self2.name, self2.keyType, self2.description, union(self2.tags, extraTags)));
  }
});

// node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey, MetricStateTypeId, CounterStateSymbolKey, CounterStateTypeId, FrequencyStateSymbolKey, FrequencyStateTypeId, GaugeStateSymbolKey, GaugeStateTypeId, HistogramStateSymbolKey, HistogramStateTypeId, SummaryStateSymbolKey, SummaryStateTypeId, metricStateVariance, CounterState, arrayEquals, FrequencyState, GaugeState, HistogramState, SummaryState, counter3, frequency2, gauge2, histogram3, summary2, isCounterState, isFrequencyState, isGaugeState, isHistogramState, isSummaryState;
var init_state = __esm({
  "node_modules/effect/dist/esm/internal/metric/state.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Equal();
    init_Function();
    init_Hash();
    init_Pipeable();
    init_Predicate();
    MetricStateSymbolKey = "effect/MetricState";
    MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
    CounterStateSymbolKey = "effect/MetricState/Counter";
    CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
    FrequencyStateSymbolKey = "effect/MetricState/Frequency";
    FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
    GaugeStateSymbolKey = "effect/MetricState/Gauge";
    GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
    HistogramStateSymbolKey = "effect/MetricState/Histogram";
    HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
    SummaryStateSymbolKey = "effect/MetricState/Summary";
    SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
    metricStateVariance = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    CounterState = class {
      static {
        __name(this, "CounterState");
      }
      count;
      [MetricStateTypeId] = metricStateVariance;
      [CounterStateTypeId] = CounterStateTypeId;
      constructor(count6) {
        this.count = count6;
      }
      [symbol]() {
        return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
      }
      [symbol2](that) {
        return isCounterState(that) && this.count === that.count;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    arrayEquals = /* @__PURE__ */ getEquivalence3(equals);
    FrequencyState = class {
      static {
        __name(this, "FrequencyState");
      }
      occurrences;
      [MetricStateTypeId] = metricStateVariance;
      [FrequencyStateTypeId] = FrequencyStateTypeId;
      constructor(occurrences) {
        this.occurrences = occurrences;
      }
      _hash;
      [symbol]() {
        return pipe(string(FrequencyStateSymbolKey), combine(array2(fromIterable2(this.occurrences.entries()))), cached(this));
      }
      [symbol2](that) {
        return isFrequencyState(that) && arrayEquals(fromIterable2(this.occurrences.entries()), fromIterable2(that.occurrences.entries()));
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    GaugeState = class {
      static {
        __name(this, "GaugeState");
      }
      value;
      [MetricStateTypeId] = metricStateVariance;
      [GaugeStateTypeId] = GaugeStateTypeId;
      constructor(value3) {
        this.value = value3;
      }
      [symbol]() {
        return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
      }
      [symbol2](u) {
        return isGaugeState(u) && this.value === u.value;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    HistogramState = class {
      static {
        __name(this, "HistogramState");
      }
      buckets;
      count;
      min;
      max;
      sum;
      [MetricStateTypeId] = metricStateVariance;
      [HistogramStateTypeId] = HistogramStateTypeId;
      constructor(buckets, count6, min4, max6, sum3) {
        this.buckets = buckets;
        this.count = count6;
        this.min = min4;
        this.max = max6;
        this.sum = sum3;
      }
      [symbol]() {
        return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
      }
      [symbol2](that) {
        return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    SummaryState = class {
      static {
        __name(this, "SummaryState");
      }
      error;
      quantiles;
      count;
      min;
      max;
      sum;
      [MetricStateTypeId] = metricStateVariance;
      [SummaryStateTypeId] = SummaryStateTypeId;
      constructor(error50, quantiles, count6, min4, max6, sum3) {
        this.error = error50;
        this.quantiles = quantiles;
        this.count = count6;
        this.min = min4;
        this.max = max6;
        this.sum = sum3;
      }
      [symbol]() {
        return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
      }
      [symbol2](that) {
        return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    counter3 = /* @__PURE__ */ __name((count6) => new CounterState(count6), "counter");
    frequency2 = /* @__PURE__ */ __name((occurrences) => {
      return new FrequencyState(occurrences);
    }, "frequency");
    gauge2 = /* @__PURE__ */ __name((count6) => new GaugeState(count6), "gauge");
    histogram3 = /* @__PURE__ */ __name((options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum), "histogram");
    summary2 = /* @__PURE__ */ __name((options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum), "summary");
    isCounterState = /* @__PURE__ */ __name((u) => hasProperty(u, CounterStateTypeId), "isCounterState");
    isFrequencyState = /* @__PURE__ */ __name((u) => hasProperty(u, FrequencyStateTypeId), "isFrequencyState");
    isGaugeState = /* @__PURE__ */ __name((u) => hasProperty(u, GaugeStateTypeId), "isGaugeState");
    isHistogramState = /* @__PURE__ */ __name((u) => hasProperty(u, HistogramStateTypeId), "isHistogramState");
    isSummaryState = /* @__PURE__ */ __name((u) => hasProperty(u, SummaryStateTypeId), "isSummaryState");
  }
});

// node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey, MetricHookTypeId, metricHookVariance, make31, bigint04, counter4, frequency3, gauge3, histogram4, summary3, calculateQuantiles, resolveQuantile;
var init_hook = __esm({
  "node_modules/effect/dist/esm/internal/metric/hook.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Duration();
    init_Function();
    init_Number();
    init_Option();
    init_Pipeable();
    init_state();
    MetricHookSymbolKey = "effect/MetricHook";
    MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
    metricHookVariance = {
      /* c8 ignore next */
      _In: /* @__PURE__ */ __name((_) => _, "_In"),
      /* c8 ignore next */
      _Out: /* @__PURE__ */ __name((_) => _, "_Out")
    };
    make31 = /* @__PURE__ */ __name((options) => ({
      [MetricHookTypeId]: metricHookVariance,
      pipe() {
        return pipeArguments(this, arguments);
      },
      ...options
    }), "make");
    bigint04 = /* @__PURE__ */ BigInt(0);
    counter4 = /* @__PURE__ */ __name((key) => {
      let sum3 = key.keyType.bigint ? bigint04 : 0;
      const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value3) => value3 >= bigint04 : (value3) => value3 >= 0 : (_value) => true;
      const update6 = /* @__PURE__ */ __name((value3) => {
        if (canUpdate(value3)) {
          sum3 = sum3 + value3;
        }
      }, "update");
      return make31({
        get: /* @__PURE__ */ __name(() => counter3(sum3), "get"),
        update: update6,
        modify: update6
      });
    }, "counter");
    frequency3 = /* @__PURE__ */ __name((key) => {
      const values4 = /* @__PURE__ */ new Map();
      for (const word of key.keyType.preregisteredWords) {
        values4.set(word, 0);
      }
      const update6 = /* @__PURE__ */ __name((word) => {
        const slotCount = values4.get(word) ?? 0;
        values4.set(word, slotCount + 1);
      }, "update");
      return make31({
        get: /* @__PURE__ */ __name(() => frequency2(values4), "get"),
        update: update6,
        modify: update6
      });
    }, "frequency");
    gauge3 = /* @__PURE__ */ __name((_key, startAt) => {
      let value3 = startAt;
      return make31({
        get: /* @__PURE__ */ __name(() => gauge2(value3), "get"),
        update: /* @__PURE__ */ __name((v) => {
          value3 = v;
        }, "update"),
        modify: /* @__PURE__ */ __name((v) => {
          value3 = value3 + v;
        }, "modify")
      });
    }, "gauge");
    histogram4 = /* @__PURE__ */ __name((key) => {
      const bounds = key.keyType.boundaries.values;
      const size15 = bounds.length;
      const values4 = new Uint32Array(size15 + 1);
      const boundaries = new Float64Array(size15);
      let count6 = 0;
      let sum3 = 0;
      let min4 = Number.MAX_VALUE;
      let max6 = Number.MIN_VALUE;
      pipe(bounds, sort(Order), map4((n, i) => {
        boundaries[i] = n;
      }));
      const update6 = /* @__PURE__ */ __name((value3) => {
        let from2 = 0;
        let to = size15;
        while (from2 !== to) {
          const mid = Math.floor(from2 + (to - from2) / 2);
          const boundary = boundaries[mid];
          if (value3 <= boundary) {
            to = mid;
          } else {
            from2 = mid;
          }
          if (to === from2 + 1) {
            if (value3 <= boundaries[from2]) {
              to = from2;
            } else {
              from2 = to;
            }
          }
        }
        values4[from2] = values4[from2] + 1;
        count6 = count6 + 1;
        sum3 = sum3 + value3;
        if (value3 < min4) {
          min4 = value3;
        }
        if (value3 > max6) {
          max6 = value3;
        }
      }, "update");
      const getBuckets = /* @__PURE__ */ __name(() => {
        const builder = allocate(size15);
        let cumulated = 0;
        for (let i = 0; i < size15; i++) {
          const boundary = boundaries[i];
          const value3 = values4[i];
          cumulated = cumulated + value3;
          builder[i] = [boundary, cumulated];
        }
        return builder;
      }, "getBuckets");
      return make31({
        get: /* @__PURE__ */ __name(() => histogram3({
          buckets: getBuckets(),
          count: count6,
          min: min4,
          max: max6,
          sum: sum3
        }), "get"),
        update: update6,
        modify: update6
      });
    }, "histogram");
    summary3 = /* @__PURE__ */ __name((key) => {
      const {
        error: error50,
        maxAge,
        maxSize,
        quantiles
      } = key.keyType;
      const sortedQuantiles = pipe(quantiles, sort(Order));
      const values4 = allocate(maxSize);
      let head7 = 0;
      let count6 = 0;
      let sum3 = 0;
      let min4 = 0;
      let max6 = 0;
      const snapshot = /* @__PURE__ */ __name((now2) => {
        const builder = [];
        let i = 0;
        while (i !== maxSize - 1) {
          const item = values4[i];
          if (item != null) {
            const [t, v] = item;
            const age = millis(now2 - t);
            if (greaterThanOrEqualTo3(age, zero2) && lessThanOrEqualTo3(age, maxAge)) {
              builder.push(v);
            }
          }
          i = i + 1;
        }
        return calculateQuantiles(error50, sortedQuantiles, sort(builder, Order));
      }, "snapshot");
      const observe = /* @__PURE__ */ __name((value3, timestamp) => {
        if (maxSize > 0) {
          head7 = head7 + 1;
          const target = head7 % maxSize;
          values4[target] = [timestamp, value3];
        }
        min4 = count6 === 0 ? value3 : Math.min(min4, value3);
        max6 = count6 === 0 ? value3 : Math.max(max6, value3);
        count6 = count6 + 1;
        sum3 = sum3 + value3;
      }, "observe");
      return make31({
        get: /* @__PURE__ */ __name(() => summary2({
          error: error50,
          quantiles: snapshot(Date.now()),
          count: count6,
          min: min4,
          max: max6,
          sum: sum3
        }), "get"),
        update: /* @__PURE__ */ __name(([value3, timestamp]) => observe(value3, timestamp), "update"),
        modify: /* @__PURE__ */ __name(([value3, timestamp]) => observe(value3, timestamp), "modify")
      });
    }, "summary");
    calculateQuantiles = /* @__PURE__ */ __name((error50, sortedQuantiles, sortedSamples) => {
      const sampleCount = sortedSamples.length;
      if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
        return empty2();
      }
      const head7 = sortedQuantiles[0];
      const tail = sortedQuantiles.slice(1);
      const resolvedHead = resolveQuantile(error50, sampleCount, none2(), 0, head7, sortedSamples);
      const resolved = of(resolvedHead);
      tail.forEach((quantile) => {
        resolved.push(resolveQuantile(error50, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
      });
      return map4(resolved, (rq) => [rq.quantile, rq.value]);
    }, "calculateQuantiles");
    resolveQuantile = /* @__PURE__ */ __name((error50, sampleCount, current2, consumed, quantile, rest) => {
      let error_1 = error50;
      let sampleCount_1 = sampleCount;
      let current_1 = current2;
      let consumed_1 = consumed;
      let quantile_1 = quantile;
      let rest_1 = rest;
      let error_2 = error50;
      let sampleCount_2 = sampleCount;
      let current_2 = current2;
      let consumed_2 = consumed;
      let quantile_2 = quantile;
      let rest_2 = rest;
      while (1) {
        if (!isNonEmptyReadonlyArray(rest_1)) {
          return {
            quantile: quantile_1,
            value: none2(),
            consumed: consumed_1,
            rest: []
          };
        }
        if (quantile_1 === 1) {
          return {
            quantile: quantile_1,
            value: some2(lastNonEmpty(rest_1)),
            consumed: consumed_1 + rest_1.length,
            rest: []
          };
        }
        const headValue = headNonEmpty(rest_1);
        const sameHead = span(rest_1, (n) => n === headValue);
        const desired = quantile_1 * sampleCount_1;
        const allowedError = error_1 / 2 * desired;
        const candConsumed = consumed_1 + sameHead[0].length;
        const candError = Math.abs(candConsumed - desired);
        if (candConsumed < desired - allowedError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        if (candConsumed > desired + allowedError) {
          const valueToReturn = isNone2(current_1) ? some2(headValue) : current_1;
          return {
            quantile: quantile_1,
            value: valueToReturn,
            consumed: consumed_1,
            rest: rest_1
          };
        }
        switch (current_1._tag) {
          case "None": {
            error_2 = error_1;
            sampleCount_2 = sampleCount_1;
            current_2 = head(rest_1);
            consumed_2 = candConsumed;
            quantile_2 = quantile_1;
            rest_2 = sameHead[1];
            error_1 = error_2;
            sampleCount_1 = sampleCount_2;
            current_1 = current_2;
            consumed_1 = consumed_2;
            quantile_1 = quantile_2;
            rest_1 = rest_2;
            continue;
          }
          case "Some": {
            const prevError = Math.abs(desired - current_1.value);
            if (candError < prevError) {
              error_2 = error_1;
              sampleCount_2 = sampleCount_1;
              current_2 = head(rest_1);
              consumed_2 = candConsumed;
              quantile_2 = quantile_1;
              rest_2 = sameHead[1];
              error_1 = error_2;
              sampleCount_1 = sampleCount_2;
              current_1 = current_2;
              consumed_1 = consumed_2;
              quantile_1 = quantile_2;
              rest_1 = rest_2;
              continue;
            }
            return {
              quantile: quantile_1,
              value: some2(current_1.value),
              consumed: consumed_1,
              rest: rest_1
            };
          }
        }
      }
      throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
    }, "resolveQuantile");
  }
});

// node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey, MetricPairTypeId, metricPairVariance, unsafeMake9;
var init_pair = __esm({
  "node_modules/effect/dist/esm/internal/metric/pair.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Pipeable();
    MetricPairSymbolKey = "effect/MetricPair";
    MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
    metricPairVariance = {
      /* c8 ignore next */
      _Type: /* @__PURE__ */ __name((_) => _, "_Type")
    };
    unsafeMake9 = /* @__PURE__ */ __name((metricKey, metricState) => {
      return {
        [MetricPairTypeId]: metricPairVariance,
        metricKey,
        metricState,
        pipe() {
          return pipeArguments(this, arguments);
        }
      };
    }, "unsafeMake");
  }
});

// node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey, MetricRegistryTypeId, MetricRegistryImpl, make32;
var init_registry = __esm({
  "node_modules/effect/dist/esm/internal/metric/registry.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_MutableHashMap();
    init_Option();
    init_hook();
    init_keyType();
    init_pair();
    MetricRegistrySymbolKey = "effect/MetricRegistry";
    MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);
    MetricRegistryImpl = class {
      static {
        __name(this, "MetricRegistryImpl");
      }
      [MetricRegistryTypeId] = MetricRegistryTypeId;
      map = /* @__PURE__ */ empty18();
      snapshot() {
        const result = [];
        for (const [key, hook] of this.map) {
          result.push(unsafeMake9(key, hook.get()));
        }
        return result;
      }
      get(key) {
        const hook = pipe(this.map, get8(key), getOrUndefined);
        if (hook == null) {
          if (isCounterKey(key.keyType)) {
            return this.getCounter(key);
          }
          if (isGaugeKey(key.keyType)) {
            return this.getGauge(key);
          }
          if (isFrequencyKey(key.keyType)) {
            return this.getFrequency(key);
          }
          if (isHistogramKey(key.keyType)) {
            return this.getHistogram(key);
          }
          if (isSummaryKey(key.keyType)) {
            return this.getSummary(key);
          }
          throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
        } else {
          return hook;
        }
      }
      getCounter(key) {
        let value3 = pipe(this.map, get8(key), getOrUndefined);
        if (value3 == null) {
          const counter6 = counter4(key);
          if (!pipe(this.map, has5(key))) {
            pipe(this.map, set4(key, counter6));
          }
          value3 = counter6;
        }
        return value3;
      }
      getFrequency(key) {
        let value3 = pipe(this.map, get8(key), getOrUndefined);
        if (value3 == null) {
          const frequency5 = frequency3(key);
          if (!pipe(this.map, has5(key))) {
            pipe(this.map, set4(key, frequency5));
          }
          value3 = frequency5;
        }
        return value3;
      }
      getGauge(key) {
        let value3 = pipe(this.map, get8(key), getOrUndefined);
        if (value3 == null) {
          const gauge5 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
          if (!pipe(this.map, has5(key))) {
            pipe(this.map, set4(key, gauge5));
          }
          value3 = gauge5;
        }
        return value3;
      }
      getHistogram(key) {
        let value3 = pipe(this.map, get8(key), getOrUndefined);
        if (value3 == null) {
          const histogram6 = histogram4(key);
          if (!pipe(this.map, has5(key))) {
            pipe(this.map, set4(key, histogram6));
          }
          value3 = histogram6;
        }
        return value3;
      }
      getSummary(key) {
        let value3 = pipe(this.map, get8(key), getOrUndefined);
        if (value3 == null) {
          const summary5 = summary3(key);
          if (!pipe(this.map, has5(key))) {
            pipe(this.map, set4(key, summary5));
          }
          value3 = summary5;
        }
        return value3;
      }
    };
    make32 = /* @__PURE__ */ __name(() => {
      return new MetricRegistryImpl();
    }, "make");
  }
});

// node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey, MetricTypeId, metricVariance, globalMetricRegistry, make33, counter5, fromMetricKey, histogram5, tagged, taggedWithLabels2, update4;
var init_metric = __esm({
  "node_modules/effect/dist/esm/internal/metric.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Function();
    init_GlobalValue();
    init_Pipeable();
    init_core();
    init_key();
    init_label();
    init_registry();
    MetricSymbolKey = "effect/Metric";
    MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
    metricVariance = {
      /* c8 ignore next */
      _Type: /* @__PURE__ */ __name((_) => _, "_Type"),
      /* c8 ignore next */
      _In: /* @__PURE__ */ __name((_) => _, "_In"),
      /* c8 ignore next */
      _Out: /* @__PURE__ */ __name((_) => _, "_Out")
    };
    globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make32());
    make33 = /* @__PURE__ */ __name(function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
      const metric = Object.assign((effect4) => tap2(effect4, (a) => update4(metric, a)), {
        [MetricTypeId]: metricVariance,
        keyType,
        unsafeUpdate,
        unsafeValue,
        unsafeModify,
        register() {
          this.unsafeValue([]);
          return this;
        },
        pipe() {
          return pipeArguments(this, arguments);
        }
      });
      return metric;
    }, "make");
    counter5 = /* @__PURE__ */ __name((name, options) => fromMetricKey(counter2(name, options)), "counter");
    fromMetricKey = /* @__PURE__ */ __name((key) => {
      let untaggedHook;
      const hookCache = /* @__PURE__ */ new WeakMap();
      const hook = /* @__PURE__ */ __name((extraTags) => {
        if (extraTags.length === 0) {
          if (untaggedHook !== void 0) {
            return untaggedHook;
          }
          untaggedHook = globalMetricRegistry.get(key);
          return untaggedHook;
        }
        let hook2 = hookCache.get(extraTags);
        if (hook2 !== void 0) {
          return hook2;
        }
        hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
        hookCache.set(extraTags, hook2);
        return hook2;
      }, "hook");
      return make33(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
    }, "fromMetricKey");
    histogram5 = /* @__PURE__ */ __name((name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description)), "histogram");
    tagged = /* @__PURE__ */ dual(3, (self2, key, value3) => taggedWithLabels2(self2, [make30(key, value3)]));
    taggedWithLabels2 = /* @__PURE__ */ dual(2, (self2, extraTags) => {
      return make33(self2.keyType, (input, extraTags1) => self2.unsafeUpdate(input, union(extraTags, extraTags1)), (extraTags1) => self2.unsafeValue(union(extraTags, extraTags1)), (input, extraTags1) => self2.unsafeModify(input, union(extraTags, extraTags1)));
    });
    update4 = /* @__PURE__ */ dual(2, (self2, input) => fiberRefGetWith(currentMetricLabels, (tags) => sync(() => self2.unsafeUpdate(input, tags))));
  }
});

// node_modules/effect/dist/esm/internal/request.js
var RequestSymbolKey, RequestTypeId, requestVariance, RequestPrototype, isRequest, Class3, complete, Listeners;
var init_request = __esm({
  "node_modules/effect/dist/esm/internal/request.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_Predicate();
    init_completedRequestMap();
    init_core();
    init_effectable();
    RequestSymbolKey = "effect/Request";
    RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
    requestVariance = {
      /* c8 ignore next */
      _E: /* @__PURE__ */ __name((_) => _, "_E"),
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    RequestPrototype = {
      ...StructuralPrototype,
      [RequestTypeId]: requestVariance
    };
    isRequest = /* @__PURE__ */ __name((u) => hasProperty(u, RequestTypeId), "isRequest");
    Class3 = /* @__PURE__ */ (function() {
      function Class9(args2) {
        if (args2) {
          Object.assign(this, args2);
        }
      }
      __name(Class9, "Class");
      Class9.prototype = RequestPrototype;
      return Class9;
    })();
    complete = /* @__PURE__ */ dual(2, (self2, result) => fiberRefGetWith(currentRequestMap, (map31) => sync(() => {
      if (map31.has(self2)) {
        const entry = map31.get(self2);
        if (!entry.state.completed) {
          entry.state.completed = true;
          deferredUnsafeDone(entry.result, result);
        }
      }
    })));
    Listeners = class {
      static {
        __name(this, "Listeners");
      }
      count = 0;
      observers = /* @__PURE__ */ new Set();
      interrupted = false;
      addObserver(f) {
        this.observers.add(f);
      }
      removeObserver(f) {
        this.observers.delete(f);
      }
      increment() {
        this.count++;
        this.observers.forEach((f) => f(this.count));
      }
      decrement() {
        this.count--;
        this.observers.forEach((f) => f(this.count));
      }
    };
  }
});

// node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
var Direction, RedBlackTreeIterator;
var init_iterator = __esm({
  "node_modules/effect/dist/esm/internal/redBlackTree/iterator.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Option();
    Direction = {
      Forward: 0,
      Backward: 1 << 0
    };
    RedBlackTreeIterator = class _RedBlackTreeIterator {
      static {
        __name(this, "RedBlackTreeIterator");
      }
      self;
      stack;
      direction;
      count = 0;
      constructor(self2, stack, direction) {
        this.self = self2;
        this.stack = stack;
        this.direction = direction;
      }
      /**
       * Clones the iterator
       */
      clone() {
        return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
      }
      /**
       * Reverse the traversal direction
       */
      reversed() {
        return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
      }
      /**
       * Iterator next
       */
      next() {
        const entry = this.entry;
        this.count++;
        if (this.direction === Direction.Forward) {
          this.moveNext();
        } else {
          this.movePrev();
        }
        switch (entry._tag) {
          case "None": {
            return {
              done: true,
              value: this.count
            };
          }
          case "Some": {
            return {
              done: false,
              value: entry.value
            };
          }
        }
      }
      /**
       * Returns the key
       */
      get key() {
        if (this.stack.length > 0) {
          return some2(this.stack[this.stack.length - 1].key);
        }
        return none2();
      }
      /**
       * Returns the value
       */
      get value() {
        if (this.stack.length > 0) {
          return some2(this.stack[this.stack.length - 1].value);
        }
        return none2();
      }
      /**
       * Returns the key
       */
      get entry() {
        return map2(last(this.stack), (node) => [node.key, node.value]);
      }
      /**
       * Returns the position of this iterator in the sorted list
       */
      get index() {
        let idx = 0;
        const stack = this.stack;
        if (stack.length === 0) {
          const r = this.self._root;
          if (r != null) {
            return r.count;
          }
          return 0;
        } else if (stack[stack.length - 1].left != null) {
          idx = stack[stack.length - 1].left.count;
        }
        for (let s = stack.length - 2; s >= 0; --s) {
          if (stack[s + 1] === stack[s].right) {
            ++idx;
            if (stack[s].left != null) {
              idx += stack[s].left.count;
            }
          }
        }
        return idx;
      }
      /**
       * Advances iterator to next element in list
       */
      moveNext() {
        const stack = this.stack;
        if (stack.length === 0) {
          return;
        }
        let n = stack[stack.length - 1];
        if (n.right != null) {
          n = n.right;
          while (n != null) {
            stack.push(n);
            n = n.left;
          }
        } else {
          stack.pop();
          while (stack.length > 0 && stack[stack.length - 1].right === n) {
            n = stack[stack.length - 1];
            stack.pop();
          }
        }
      }
      /**
       * Checks if there is a next element
       */
      get hasNext() {
        const stack = this.stack;
        if (stack.length === 0) {
          return false;
        }
        if (stack[stack.length - 1].right != null) {
          return true;
        }
        for (let s = stack.length - 1; s > 0; --s) {
          if (stack[s - 1].left === stack[s]) {
            return true;
          }
        }
        return false;
      }
      /**
       * Advances iterator to previous element in list
       */
      movePrev() {
        const stack = this.stack;
        if (stack.length === 0) {
          return;
        }
        let n = stack[stack.length - 1];
        if (n != null && n.left != null) {
          n = n.left;
          while (n != null) {
            stack.push(n);
            n = n.right;
          }
        } else {
          stack.pop();
          while (stack.length > 0 && stack[stack.length - 1].left === n) {
            n = stack[stack.length - 1];
            stack.pop();
          }
        }
      }
      /**
       * Checks if there is a previous element
       */
      get hasPrev() {
        const stack = this.stack;
        if (stack.length === 0) {
          return false;
        }
        if (stack[stack.length - 1].left != null) {
          return true;
        }
        for (let s = stack.length - 1; s > 0; --s) {
          if (stack[s - 1].right === stack[s]) {
            return true;
          }
        }
        return false;
      }
    };
  }
});

// node_modules/effect/dist/esm/internal/redBlackTree/node.js
function swap2(n, v) {
  n.key = v.key;
  n.value = v.value;
  n.left = v.left;
  n.right = v.right;
  n.color = v.color;
  n.count = v.count;
}
var Color, clone2, repaint, recount;
var init_node2 = __esm({
  "node_modules/effect/dist/esm/internal/redBlackTree/node.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Color = {
      Red: 0,
      Black: 1 << 0
    };
    clone2 = /* @__PURE__ */ __name(({
      color,
      count: count6,
      key,
      left: left3,
      right: right3,
      value: value3
    }) => ({
      color,
      key,
      value: value3,
      left: left3,
      right: right3,
      count: count6
    }), "clone");
    __name(swap2, "swap");
    repaint = /* @__PURE__ */ __name(({
      count: count6,
      key,
      left: left3,
      right: right3,
      value: value3
    }, color) => ({
      color,
      key,
      value: value3,
      left: left3,
      right: right3,
      count: count6
    }), "repaint");
    recount = /* @__PURE__ */ __name((node) => {
      node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);
    }, "recount");
  }
});

// node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey, RedBlackTreeTypeId, redBlackTreeVariance, RedBlackTreeProto, makeImpl3, isRedBlackTree, empty24, fromIterable10, findFirst6, getOrder2, has6, insert, keysForward, keys3, removeFirst, fixDoubleBlack;
var init_redBlackTree = __esm({
  "node_modules/effect/dist/esm/internal/redBlackTree.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_Hash();
    init_Inspectable();
    init_Option();
    init_Pipeable();
    init_Predicate();
    init_iterator();
    init_node2();
    RedBlackTreeSymbolKey = "effect/RedBlackTree";
    RedBlackTreeTypeId = /* @__PURE__ */ Symbol.for(RedBlackTreeSymbolKey);
    redBlackTreeVariance = {
      /* c8 ignore next */
      _Key: /* @__PURE__ */ __name((_) => _, "_Key"),
      /* c8 ignore next */
      _Value: /* @__PURE__ */ __name((_) => _, "_Value")
    };
    RedBlackTreeProto = {
      [RedBlackTreeTypeId]: redBlackTreeVariance,
      [symbol]() {
        let hash4 = hash(RedBlackTreeSymbolKey);
        for (const item of this) {
          hash4 ^= pipe(hash(item[0]), combine(hash(item[1])));
        }
        return cached(this, hash4);
      },
      [symbol2](that) {
        if (isRedBlackTree(that)) {
          if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {
            return false;
          }
          const entries2 = Array.from(that);
          return Array.from(this).every((itemSelf, i) => {
            const itemThat = entries2[i];
            return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
          });
        }
        return false;
      },
      [Symbol.iterator]() {
        const stack = [];
        let n = this._root;
        while (n != null) {
          stack.push(n);
          n = n.left;
        }
        return new RedBlackTreeIterator(this, stack, Direction.Forward);
      },
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "RedBlackTree",
          values: Array.from(this).map(toJSON)
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    makeImpl3 = /* @__PURE__ */ __name((ord, root) => {
      const tree = Object.create(RedBlackTreeProto);
      tree._ord = ord;
      tree._root = root;
      return tree;
    }, "makeImpl");
    isRedBlackTree = /* @__PURE__ */ __name((u) => hasProperty(u, RedBlackTreeTypeId), "isRedBlackTree");
    empty24 = /* @__PURE__ */ __name((ord) => makeImpl3(ord, void 0), "empty");
    fromIterable10 = /* @__PURE__ */ dual(2, (entries2, ord) => {
      let tree = empty24(ord);
      for (const [key, value3] of entries2) {
        tree = insert(tree, key, value3);
      }
      return tree;
    });
    findFirst6 = /* @__PURE__ */ dual(2, (self2, key) => {
      const cmp = self2._ord;
      let node = self2._root;
      while (node !== void 0) {
        const d = cmp(key, node.key);
        if (equals(key, node.key)) {
          return some2(node.value);
        }
        if (d <= 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      return none2();
    });
    getOrder2 = /* @__PURE__ */ __name((tree) => tree._ord, "getOrder");
    has6 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(findFirst6(self2, key)));
    insert = /* @__PURE__ */ dual(3, (self2, key, value3) => {
      const cmp = self2._ord;
      let n = self2._root;
      const n_stack = [];
      const d_stack = [];
      while (n != null) {
        const d = cmp(key, n.key);
        n_stack.push(n);
        d_stack.push(d);
        if (d <= 0) {
          n = n.left;
        } else {
          n = n.right;
        }
      }
      n_stack.push({
        color: Color.Red,
        key,
        value: value3,
        left: void 0,
        right: void 0,
        count: 1
      });
      for (let s = n_stack.length - 2; s >= 0; --s) {
        const n2 = n_stack[s];
        if (d_stack[s] <= 0) {
          n_stack[s] = {
            color: n2.color,
            key: n2.key,
            value: n2.value,
            left: n_stack[s + 1],
            right: n2.right,
            count: n2.count + 1
          };
        } else {
          n_stack[s] = {
            color: n2.color,
            key: n2.key,
            value: n2.value,
            left: n2.left,
            right: n_stack[s + 1],
            count: n2.count + 1
          };
        }
      }
      for (let s = n_stack.length - 1; s > 1; --s) {
        const p = n_stack[s - 1];
        const n3 = n_stack[s];
        if (p.color === Color.Black || n3.color === Color.Black) {
          break;
        }
        const pp = n_stack[s - 2];
        if (pp.left === p) {
          if (p.left === n3) {
            const y = pp.right;
            if (y && y.color === Color.Red) {
              p.color = Color.Black;
              pp.right = repaint(y, Color.Black);
              pp.color = Color.Red;
              s -= 1;
            } else {
              pp.color = Color.Red;
              pp.left = p.right;
              p.color = Color.Black;
              p.right = pp;
              n_stack[s - 2] = p;
              n_stack[s - 1] = n3;
              recount(pp);
              recount(p);
              if (s >= 3) {
                const ppp = n_stack[s - 3];
                if (ppp.left === pp) {
                  ppp.left = p;
                } else {
                  ppp.right = p;
                }
              }
              break;
            }
          } else {
            const y = pp.right;
            if (y && y.color === Color.Red) {
              p.color = Color.Black;
              pp.right = repaint(y, Color.Black);
              pp.color = Color.Red;
              s -= 1;
            } else {
              p.right = n3.left;
              pp.color = Color.Red;
              pp.left = n3.right;
              n3.color = Color.Black;
              n3.left = p;
              n3.right = pp;
              n_stack[s - 2] = n3;
              n_stack[s - 1] = p;
              recount(pp);
              recount(p);
              recount(n3);
              if (s >= 3) {
                const ppp = n_stack[s - 3];
                if (ppp.left === pp) {
                  ppp.left = n3;
                } else {
                  ppp.right = n3;
                }
              }
              break;
            }
          }
        } else {
          if (p.right === n3) {
            const y = pp.left;
            if (y && y.color === Color.Red) {
              p.color = Color.Black;
              pp.left = repaint(y, Color.Black);
              pp.color = Color.Red;
              s -= 1;
            } else {
              pp.color = Color.Red;
              pp.right = p.left;
              p.color = Color.Black;
              p.left = pp;
              n_stack[s - 2] = p;
              n_stack[s - 1] = n3;
              recount(pp);
              recount(p);
              if (s >= 3) {
                const ppp = n_stack[s - 3];
                if (ppp.right === pp) {
                  ppp.right = p;
                } else {
                  ppp.left = p;
                }
              }
              break;
            }
          } else {
            const y = pp.left;
            if (y && y.color === Color.Red) {
              p.color = Color.Black;
              pp.left = repaint(y, Color.Black);
              pp.color = Color.Red;
              s -= 1;
            } else {
              p.left = n3.right;
              pp.color = Color.Red;
              pp.right = n3.left;
              n3.color = Color.Black;
              n3.right = p;
              n3.left = pp;
              n_stack[s - 2] = n3;
              n_stack[s - 1] = p;
              recount(pp);
              recount(p);
              recount(n3);
              if (s >= 3) {
                const ppp = n_stack[s - 3];
                if (ppp.right === pp) {
                  ppp.right = n3;
                } else {
                  ppp.left = n3;
                }
              }
              break;
            }
          }
        }
      }
      n_stack[0].color = Color.Black;
      return makeImpl3(self2._ord, n_stack[0]);
    });
    keysForward = /* @__PURE__ */ __name((self2) => keys3(self2, Direction.Forward), "keysForward");
    keys3 = /* @__PURE__ */ __name((self2, direction) => {
      const begin = self2[Symbol.iterator]();
      let count6 = 0;
      return {
        [Symbol.iterator]: () => keys3(self2, direction),
        next: /* @__PURE__ */ __name(() => {
          count6++;
          const entry = begin.key;
          if (direction === Direction.Forward) {
            begin.moveNext();
          } else {
            begin.movePrev();
          }
          switch (entry._tag) {
            case "None": {
              return {
                done: true,
                value: count6
              };
            }
            case "Some": {
              return {
                done: false,
                value: entry.value
              };
            }
          }
        }, "next")
      };
    }, "keys");
    removeFirst = /* @__PURE__ */ dual(2, (self2, key) => {
      if (!has6(self2, key)) {
        return self2;
      }
      const ord = self2._ord;
      const cmp = ord;
      let node = self2._root;
      const stack = [];
      while (node !== void 0) {
        const d = cmp(key, node.key);
        stack.push(node);
        if (equals(key, node.key)) {
          node = void 0;
        } else if (d <= 0) {
          node = node.left;
        } else {
          node = node.right;
        }
      }
      if (stack.length === 0) {
        return self2;
      }
      const cstack = new Array(stack.length);
      let n = stack[stack.length - 1];
      cstack[cstack.length - 1] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: n.right,
        count: n.count
      };
      for (let i = stack.length - 2; i >= 0; --i) {
        n = stack[i];
        if (n.left === stack[i + 1]) {
          cstack[i] = {
            color: n.color,
            key: n.key,
            value: n.value,
            left: cstack[i + 1],
            right: n.right,
            count: n.count
          };
        } else {
          cstack[i] = {
            color: n.color,
            key: n.key,
            value: n.value,
            left: n.left,
            right: cstack[i + 1],
            count: n.count
          };
        }
      }
      n = cstack[cstack.length - 1];
      if (n.left !== void 0 && n.right !== void 0) {
        const split4 = cstack.length;
        n = n.left;
        while (n.right != null) {
          cstack.push(n);
          n = n.right;
        }
        const v = cstack[split4 - 1];
        cstack.push({
          color: n.color,
          key: v.key,
          value: v.value,
          left: n.left,
          right: n.right,
          count: n.count
        });
        cstack[split4 - 1].key = n.key;
        cstack[split4 - 1].value = n.value;
        for (let i = cstack.length - 2; i >= split4; --i) {
          n = cstack[i];
          cstack[i] = {
            color: n.color,
            key: n.key,
            value: n.value,
            left: n.left,
            right: cstack[i + 1],
            count: n.count
          };
        }
        cstack[split4 - 1].left = cstack[split4];
      }
      n = cstack[cstack.length - 1];
      if (n.color === Color.Red) {
        const p = cstack[cstack.length - 2];
        if (p.left === n) {
          p.left = void 0;
        } else if (p.right === n) {
          p.right = void 0;
        }
        cstack.pop();
        for (let i = 0; i < cstack.length; ++i) {
          cstack[i].count--;
        }
        return makeImpl3(ord, cstack[0]);
      } else {
        if (n.left !== void 0 || n.right !== void 0) {
          if (n.left !== void 0) {
            swap2(n, n.left);
          } else if (n.right !== void 0) {
            swap2(n, n.right);
          }
          n.color = Color.Black;
          for (let i = 0; i < cstack.length - 1; ++i) {
            cstack[i].count--;
          }
          return makeImpl3(ord, cstack[0]);
        } else if (cstack.length === 1) {
          return makeImpl3(ord, void 0);
        } else {
          for (let i = 0; i < cstack.length; ++i) {
            cstack[i].count--;
          }
          const parent = cstack[cstack.length - 2];
          fixDoubleBlack(cstack);
          if (parent.left === n) {
            parent.left = void 0;
          } else {
            parent.right = void 0;
          }
        }
      }
      return makeImpl3(ord, cstack[0]);
    });
    fixDoubleBlack = /* @__PURE__ */ __name((stack) => {
      let n, p, s, z2;
      for (let i = stack.length - 1; i >= 0; --i) {
        n = stack[i];
        if (i === 0) {
          n.color = Color.Black;
          return;
        }
        p = stack[i - 1];
        if (p.left === n) {
          s = p.right;
          if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
            s = p.right = clone2(s);
            z2 = s.right = clone2(s.right);
            p.right = s.left;
            s.left = p;
            s.right = z2;
            s.color = p.color;
            n.color = Color.Black;
            p.color = Color.Black;
            z2.color = Color.Black;
            recount(p);
            recount(s);
            if (i > 1) {
              const pp = stack[i - 2];
              if (pp.left === p) {
                pp.left = s;
              } else {
                pp.right = s;
              }
            }
            stack[i - 1] = s;
            return;
          } else if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
            s = p.right = clone2(s);
            z2 = s.left = clone2(s.left);
            p.right = z2.left;
            s.left = z2.right;
            z2.left = p;
            z2.right = s;
            z2.color = p.color;
            p.color = Color.Black;
            s.color = Color.Black;
            n.color = Color.Black;
            recount(p);
            recount(s);
            recount(z2);
            if (i > 1) {
              const pp = stack[i - 2];
              if (pp.left === p) {
                pp.left = z2;
              } else {
                pp.right = z2;
              }
            }
            stack[i - 1] = z2;
            return;
          }
          if (s !== void 0 && s.color === Color.Black) {
            if (p.color === Color.Red) {
              p.color = Color.Black;
              p.right = repaint(s, Color.Red);
              return;
            } else {
              p.right = repaint(s, Color.Red);
              continue;
            }
          } else if (s !== void 0) {
            s = clone2(s);
            p.right = s.left;
            s.left = p;
            s.color = p.color;
            p.color = Color.Red;
            recount(p);
            recount(s);
            if (i > 1) {
              const pp = stack[i - 2];
              if (pp.left === p) {
                pp.left = s;
              } else {
                pp.right = s;
              }
            }
            stack[i - 1] = s;
            stack[i] = p;
            if (i + 1 < stack.length) {
              stack[i + 1] = n;
            } else {
              stack.push(n);
            }
            i = i + 2;
          }
        } else {
          s = p.left;
          if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
            s = p.left = clone2(s);
            z2 = s.left = clone2(s.left);
            p.left = s.right;
            s.right = p;
            s.left = z2;
            s.color = p.color;
            n.color = Color.Black;
            p.color = Color.Black;
            z2.color = Color.Black;
            recount(p);
            recount(s);
            if (i > 1) {
              const pp = stack[i - 2];
              if (pp.right === p) {
                pp.right = s;
              } else {
                pp.left = s;
              }
            }
            stack[i - 1] = s;
            return;
          } else if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
            s = p.left = clone2(s);
            z2 = s.right = clone2(s.right);
            p.left = z2.right;
            s.right = z2.left;
            z2.right = p;
            z2.left = s;
            z2.color = p.color;
            p.color = Color.Black;
            s.color = Color.Black;
            n.color = Color.Black;
            recount(p);
            recount(s);
            recount(z2);
            if (i > 1) {
              const pp = stack[i - 2];
              if (pp.right === p) {
                pp.right = z2;
              } else {
                pp.left = z2;
              }
            }
            stack[i - 1] = z2;
            return;
          }
          if (s !== void 0 && s.color === Color.Black) {
            if (p.color === Color.Red) {
              p.color = Color.Black;
              p.left = repaint(s, Color.Red);
              return;
            } else {
              p.left = repaint(s, Color.Red);
              continue;
            }
          } else if (s !== void 0) {
            s = clone2(s);
            p.left = s.right;
            s.right = p;
            s.color = p.color;
            p.color = Color.Red;
            recount(p);
            recount(s);
            if (i > 1) {
              const pp = stack[i - 2];
              if (pp.right === p) {
                pp.right = s;
              } else {
                pp.left = s;
              }
            }
            stack[i - 1] = s;
            stack[i] = p;
            if (i + 1 < stack.length) {
              stack[i + 1] = n;
            } else {
              stack.push(n);
            }
            i = i + 2;
          }
        }
      }
    }, "fixDoubleBlack");
  }
});

// node_modules/effect/dist/esm/RedBlackTree.js
var empty25, fromIterable11, getOrder3, has7, insert2, keys4, removeFirst2;
var init_RedBlackTree = __esm({
  "node_modules/effect/dist/esm/RedBlackTree.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_redBlackTree();
    empty25 = empty24;
    fromIterable11 = fromIterable10;
    getOrder3 = getOrder2;
    has7 = has6;
    insert2 = insert;
    keys4 = keysForward;
    removeFirst2 = removeFirst;
  }
});

// node_modules/effect/dist/esm/SortedSet.js
var TypeId16, SortedSetProto, fromTree, isSortedSet, empty26, fromIterable12, add5, every6, filter6, has8, isSubset2, remove7, union5, values3, getEquivalence6;
var init_SortedSet = __esm({
  "node_modules/effect/dist/esm/SortedSet.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_Function();
    init_Hash();
    init_Inspectable();
    init_Pipeable();
    init_Predicate();
    init_RedBlackTree();
    TypeId16 = /* @__PURE__ */ Symbol.for("effect/SortedSet");
    SortedSetProto = {
      [TypeId16]: {
        _A: /* @__PURE__ */ __name((_) => _, "_A")
      },
      [symbol]() {
        return pipe(hash(this.keyTree), combine(hash(TypeId16)), cached(this));
      },
      [symbol2](that) {
        return isSortedSet(that) && equals(this.keyTree, that.keyTree);
      },
      [Symbol.iterator]() {
        return keys4(this.keyTree);
      },
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "SortedSet",
          values: Array.from(this).map(toJSON)
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    fromTree = /* @__PURE__ */ __name((keyTree) => {
      const a = Object.create(SortedSetProto);
      a.keyTree = keyTree;
      return a;
    }, "fromTree");
    isSortedSet = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId16), "isSortedSet");
    empty26 = /* @__PURE__ */ __name((O) => fromTree(empty25(O)), "empty");
    fromIterable12 = /* @__PURE__ */ dual(2, (iterable, ord) => fromTree(fromIterable11(Array.from(iterable).map((k) => [k, true]), ord)));
    add5 = /* @__PURE__ */ dual(2, (self2, value3) => has7(self2.keyTree, value3) ? self2 : fromTree(insert2(self2.keyTree, value3, true)));
    every6 = /* @__PURE__ */ dual(2, (self2, predicate) => {
      for (const value3 of self2) {
        if (!predicate(value3)) {
          return false;
        }
      }
      return true;
    });
    filter6 = /* @__PURE__ */ dual(2, (self2, predicate) => {
      const ord = getOrder3(self2.keyTree);
      let out = empty26(ord);
      for (const value3 of self2) {
        if (predicate(value3)) {
          out = add5(out, value3);
        }
      }
      return out;
    });
    has8 = /* @__PURE__ */ dual(2, (self2, value3) => has7(self2.keyTree, value3));
    isSubset2 = /* @__PURE__ */ dual(2, (self2, that) => every6(self2, (a) => has8(that, a)));
    remove7 = /* @__PURE__ */ dual(2, (self2, value3) => fromTree(removeFirst2(self2.keyTree, value3)));
    union5 = /* @__PURE__ */ dual(2, (self2, that) => {
      const ord = getOrder3(self2.keyTree);
      let out = empty26(ord);
      for (const value3 of self2) {
        out = add5(value3)(out);
      }
      for (const value3 of that) {
        out = add5(value3)(out);
      }
      return out;
    });
    values3 = /* @__PURE__ */ __name((self2) => keys4(self2.keyTree), "values");
    getEquivalence6 = /* @__PURE__ */ __name(() => (a, b) => isSubset2(a, b) && isSubset2(b, a), "getEquivalence");
  }
});

// node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey, SupervisorTypeId, supervisorVariance, ProxySupervisor, Zip, isZip, Track, Const, FibersIn, unsafeTrack, track, fromEffect, none8;
var init_supervisor = __esm({
  "node_modules/effect/dist/esm/internal/supervisor.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_GlobalValue();
    init_MutableRef();
    init_Predicate();
    init_SortedSet();
    init_core();
    SupervisorSymbolKey = "effect/Supervisor";
    SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
    supervisorVariance = {
      /* c8 ignore next */
      _T: /* @__PURE__ */ __name((_) => _, "_T")
    };
    ProxySupervisor = class _ProxySupervisor {
      static {
        __name(this, "ProxySupervisor");
      }
      underlying;
      value0;
      [SupervisorTypeId] = supervisorVariance;
      constructor(underlying, value0) {
        this.underlying = underlying;
        this.value0 = value0;
      }
      get value() {
        return this.value0;
      }
      onStart(context10, effect4, parent, fiber) {
        this.underlying.onStart(context10, effect4, parent, fiber);
      }
      onEnd(value3, fiber) {
        this.underlying.onEnd(value3, fiber);
      }
      onEffect(fiber, effect4) {
        this.underlying.onEffect(fiber, effect4);
      }
      onSuspend(fiber) {
        this.underlying.onSuspend(fiber);
      }
      onResume(fiber) {
        this.underlying.onResume(fiber);
      }
      map(f) {
        return new _ProxySupervisor(this, pipe(this.value, map11(f)));
      }
      zip(right3) {
        return new Zip(this, right3);
      }
    };
    Zip = class _Zip {
      static {
        __name(this, "Zip");
      }
      left;
      right;
      _tag = "Zip";
      [SupervisorTypeId] = supervisorVariance;
      constructor(left3, right3) {
        this.left = left3;
        this.right = right3;
      }
      get value() {
        return zip2(this.left.value, this.right.value);
      }
      onStart(context10, effect4, parent, fiber) {
        this.left.onStart(context10, effect4, parent, fiber);
        this.right.onStart(context10, effect4, parent, fiber);
      }
      onEnd(value3, fiber) {
        this.left.onEnd(value3, fiber);
        this.right.onEnd(value3, fiber);
      }
      onEffect(fiber, effect4) {
        this.left.onEffect(fiber, effect4);
        this.right.onEffect(fiber, effect4);
      }
      onSuspend(fiber) {
        this.left.onSuspend(fiber);
        this.right.onSuspend(fiber);
      }
      onResume(fiber) {
        this.left.onResume(fiber);
        this.right.onResume(fiber);
      }
      map(f) {
        return new ProxySupervisor(this, pipe(this.value, map11(f)));
      }
      zip(right3) {
        return new _Zip(this, right3);
      }
    };
    isZip = /* @__PURE__ */ __name((self2) => hasProperty(self2, SupervisorTypeId) && isTagged(self2, "Zip"), "isZip");
    Track = class {
      static {
        __name(this, "Track");
      }
      [SupervisorTypeId] = supervisorVariance;
      fibers = /* @__PURE__ */ new Set();
      get value() {
        return sync(() => Array.from(this.fibers));
      }
      onStart(_context, _effect, _parent, fiber) {
        this.fibers.add(fiber);
      }
      onEnd(_value, fiber) {
        this.fibers.delete(fiber);
      }
      onEffect(_fiber, _effect) {
      }
      onSuspend(_fiber) {
      }
      onResume(_fiber) {
      }
      map(f) {
        return new ProxySupervisor(this, pipe(this.value, map11(f)));
      }
      zip(right3) {
        return new Zip(this, right3);
      }
      onRun(execution, _fiber) {
        return execution();
      }
    };
    Const = class {
      static {
        __name(this, "Const");
      }
      effect;
      [SupervisorTypeId] = supervisorVariance;
      constructor(effect4) {
        this.effect = effect4;
      }
      get value() {
        return this.effect;
      }
      onStart(_context, _effect, _parent, _fiber) {
      }
      onEnd(_value, _fiber) {
      }
      onEffect(_fiber, _effect) {
      }
      onSuspend(_fiber) {
      }
      onResume(_fiber) {
      }
      map(f) {
        return new ProxySupervisor(this, pipe(this.value, map11(f)));
      }
      zip(right3) {
        return new Zip(this, right3);
      }
      onRun(execution, _fiber) {
        return execution();
      }
    };
    FibersIn = class {
      static {
        __name(this, "FibersIn");
      }
      ref;
      [SupervisorTypeId] = supervisorVariance;
      constructor(ref2) {
        this.ref = ref2;
      }
      get value() {
        return sync(() => get6(this.ref));
      }
      onStart(_context, _effect, _parent, fiber) {
        pipe(this.ref, set2(pipe(get6(this.ref), add5(fiber))));
      }
      onEnd(_value, fiber) {
        pipe(this.ref, set2(pipe(get6(this.ref), remove7(fiber))));
      }
      onEffect(_fiber, _effect) {
      }
      onSuspend(_fiber) {
      }
      onResume(_fiber) {
      }
      map(f) {
        return new ProxySupervisor(this, pipe(this.value, map11(f)));
      }
      zip(right3) {
        return new Zip(this, right3);
      }
      onRun(execution, _fiber) {
        return execution();
      }
    };
    unsafeTrack = /* @__PURE__ */ __name(() => {
      return new Track();
    }, "unsafeTrack");
    track = /* @__PURE__ */ sync(unsafeTrack);
    fromEffect = /* @__PURE__ */ __name((effect4) => {
      return new Const(effect4);
    }, "fromEffect");
    none8 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect(void_2));
  }
});

// node_modules/effect/dist/esm/Differ.js
var make35;
var init_Differ = __esm({
  "node_modules/effect/dist/esm/Differ.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_differ();
    make35 = make15;
  }
});

// node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3, OP_ADD_SUPERVISOR, OP_REMOVE_SUPERVISOR, OP_AND_THEN2, empty27, combine8, patch8, patchLoop, removeSupervisor, toSet2, diff7, differ2;
var init_patch2 = __esm({
  "node_modules/effect/dist/esm/internal/supervisor/patch.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Chunk();
    init_Differ();
    init_Equal();
    init_Function();
    init_HashSet();
    init_supervisor();
    OP_EMPTY3 = "Empty";
    OP_ADD_SUPERVISOR = "AddSupervisor";
    OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
    OP_AND_THEN2 = "AndThen";
    empty27 = {
      _tag: OP_EMPTY3
    };
    combine8 = /* @__PURE__ */ __name((self2, that) => {
      return {
        _tag: OP_AND_THEN2,
        first: self2,
        second: that
      };
    }, "combine");
    patch8 = /* @__PURE__ */ __name((self2, supervisor) => {
      return patchLoop(supervisor, of2(self2));
    }, "patch");
    patchLoop = /* @__PURE__ */ __name((_supervisor, _patches) => {
      let supervisor = _supervisor;
      let patches = _patches;
      while (isNonEmpty2(patches)) {
        const head7 = headNonEmpty2(patches);
        switch (head7._tag) {
          case OP_EMPTY3: {
            patches = tailNonEmpty2(patches);
            break;
          }
          case OP_ADD_SUPERVISOR: {
            supervisor = supervisor.zip(head7.supervisor);
            patches = tailNonEmpty2(patches);
            break;
          }
          case OP_REMOVE_SUPERVISOR: {
            supervisor = removeSupervisor(supervisor, head7.supervisor);
            patches = tailNonEmpty2(patches);
            break;
          }
          case OP_AND_THEN2: {
            patches = prepend2(head7.first)(prepend2(head7.second)(tailNonEmpty2(patches)));
            break;
          }
        }
      }
      return supervisor;
    }, "patchLoop");
    removeSupervisor = /* @__PURE__ */ __name((self2, that) => {
      if (equals(self2, that)) {
        return none8;
      } else {
        if (isZip(self2)) {
          return removeSupervisor(self2.left, that).zip(removeSupervisor(self2.right, that));
        } else {
          return self2;
        }
      }
    }, "removeSupervisor");
    toSet2 = /* @__PURE__ */ __name((self2) => {
      if (equals(self2, none8)) {
        return empty8();
      } else {
        if (isZip(self2)) {
          return pipe(toSet2(self2.left), union3(toSet2(self2.right)));
        } else {
          return make11(self2);
        }
      }
    }, "toSet");
    diff7 = /* @__PURE__ */ __name((oldValue, newValue) => {
      if (equals(oldValue, newValue)) {
        return empty27;
      }
      const oldSupervisors = toSet2(oldValue);
      const newSupervisors = toSet2(newValue);
      const added = pipe(newSupervisors, difference3(oldSupervisors), reduce5(empty27, (patch9, supervisor) => combine8(patch9, {
        _tag: OP_ADD_SUPERVISOR,
        supervisor
      })));
      const removed = pipe(oldSupervisors, difference3(newSupervisors), reduce5(empty27, (patch9, supervisor) => combine8(patch9, {
        _tag: OP_REMOVE_SUPERVISOR,
        supervisor
      })));
      return combine8(added, removed);
    }, "diff");
    differ2 = /* @__PURE__ */ make35({
      empty: empty27,
      patch: patch8,
      combine: combine8,
      diff: diff7
    });
  }
});

// node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted, fiberActive, fiberSuccesses, fiberFailures, fiberLifetimes, EvaluationSignalContinue, EvaluationSignalDone, EvaluationSignalYieldNow, runtimeFiberVariance, absurd, YieldedOp, yieldedOpChannel, contOpSuccess, drainQueueWhileRunningTable, runBlockedRequests, _version, FiberRuntime, currentMinimumLogLevel, loggerWithConsoleLog, defaultLogger, tracerLogger, currentLoggers, annotateLogsScoped, whenLogLevel, acquireRelease, acquireReleaseInterruptible, addFinalizer, daemonChildren, _existsParFound, exists2, existsLoop, filter7, allResolveInput, allValidate, allEither, all5, allWith, allSuccesses, replicate, replicateEffect, forEach8, forEachParUnbounded, forEachConcurrentDiscard, forEachParN, fork, forkDaemon, forkWithErrorHandler, unsafeFork2, unsafeForkUnstarted, unsafeMakeChildFiber, forkWithScopeOverride, mergeAll3, partition3, validateAll, raceAll, reduceEffect, parallelFinalizers, parallelNFinalizers, finalizersMask, finalizersMaskInternal, scopeWith, scopedWith, scopedEffect, sequentialFinalizers, tagMetricsScoped, labelMetricsScoped, using, validate, validateWith, validateFirst, withClockScoped, withRandomScoped, withConfigProviderScoped, withEarlyRelease, zipOptions, zipLeftOptions, zipRightOptions, zipWithOptions, withRuntimeFlagsScoped, scopeTag, scope, scopeUnsafeAddFinalizer, ScopeImplProto, scopeUnsafeMake, scopeMake, scopeExtend, scopeUse, fiberRefUnsafeMakeSupervisor, fiberRefLocallyScoped, fiberRefLocallyScopedWith, currentRuntimeFlags, currentSupervisor, fiberAwaitAll, fiberAll, raceWith, disconnect2, race, raceFibersWith, completeRace, ensuring, invokeWithInterrupt, makeSpanScoped, withTracerScoped, withSpanScoped;
var init_fiberRuntime = __esm({
  "node_modules/effect/dist/esm/internal/fiberRuntime.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Boolean();
    init_Chunk();
    init_Context();
    init_Effectable();
    init_ExecutionStrategy();
    init_FiberId();
    init_FiberRefs();
    init_FiberRefsPatch();
    init_FiberStatus();
    init_Function();
    init_GlobalValue();
    init_HashMap();
    init_HashSet();
    init_Inspectable();
    init_LogLevel();
    init_Micro();
    init_MutableRef();
    init_Option();
    init_Pipeable();
    init_Predicate();
    init_Ref();
    init_RuntimeFlagsPatch();
    init_Scheduler();
    init_Utils();
    init_blockedRequests();
    init_cause2();
    init_clock();
    init_completedRequestMap();
    init_concurrency();
    init_configProvider();
    init_core_effect();
    init_core();
    init_defaultServices();
    init_console3();
    init_executionStrategy();
    init_fiber();
    init_fiberMessage();
    init_fiberRefs();
    init_fiberScope();
    init_logger();
    init_metric();
    init_boundaries();
    init_label();
    init_effect();
    init_random();
    init_request();
    init_runtimeFlags();
    init_runtimeFlags();
    init_supervisor();
    init_patch2();
    init_tracer();
    init_version();
    fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
      incremental: true
    });
    fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
    fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
      incremental: true
    });
    fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
      incremental: true
    });
    fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
      start: 0.5,
      factor: 2,
      count: 35
    })), "time_unit", "milliseconds");
    EvaluationSignalContinue = "Continue";
    EvaluationSignalDone = "Done";
    EvaluationSignalYieldNow = "Yield";
    runtimeFiberVariance = {
      /* c8 ignore next */
      _E: /* @__PURE__ */ __name((_) => _, "_E"),
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    absurd = /* @__PURE__ */ __name((_) => {
      throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
    }, "absurd");
    YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
    yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
      currentOp: null
    }));
    contOpSuccess = {
      [OP_ON_SUCCESS]: (_, cont, value3) => {
        return internalCall(() => cont.effect_instruction_i1(value3));
      },
      ["OnStep"]: /* @__PURE__ */ __name((_, _cont, value3) => {
        return exitSucceed(exitSucceed(value3));
      }, "OnStep"),
      [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value3) => {
        return internalCall(() => cont.effect_instruction_i2(value3));
      },
      [OP_REVERT_FLAGS]: (self2, cont, value3) => {
        self2.patchRuntimeFlags(self2.currentRuntimeFlags, cont.patch);
        if (interruptible(self2.currentRuntimeFlags) && self2.isInterrupted()) {
          return exitFailCause(self2.getInterruptedCause());
        } else {
          return exitSucceed(value3);
        }
      },
      [OP_WHILE]: (self2, cont, value3) => {
        internalCall(() => cont.effect_instruction_i2(value3));
        if (internalCall(() => cont.effect_instruction_i0())) {
          self2.pushStack(cont);
          return internalCall(() => cont.effect_instruction_i1());
        } else {
          return void_2;
        }
      },
      [OP_ITERATOR]: (self2, cont, value3) => {
        while (true) {
          const state = internalCall(() => cont.effect_instruction_i0.next(value3));
          if (state.done) {
            return exitSucceed(state.value);
          }
          const primitive2 = yieldWrapGet(state.value);
          if (!exitIsExit(primitive2)) {
            self2.pushStack(cont);
            return primitive2;
          } else if (primitive2._tag === "Failure") {
            return primitive2;
          }
          value3 = primitive2.value;
        }
      }
    };
    drainQueueWhileRunningTable = {
      [OP_INTERRUPT_SIGNAL]: (self2, runtimeFlags2, cur, message) => {
        self2.processNewInterruptSignal(message.cause);
        return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
      },
      [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
        throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
      },
      [OP_STATEFUL]: (self2, runtimeFlags2, cur, message) => {
        message.onFiber(self2, running2(runtimeFlags2));
        return cur;
      },
      [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
        return flatMap8(yieldNow(), () => cur);
      }
    };
    runBlockedRequests = /* @__PURE__ */ __name((self2) => forEachSequentialDiscard(flatten5(self2), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential5]) => {
      const map31 = /* @__PURE__ */ new Map();
      const arr = [];
      for (const block of sequential5) {
        arr.push(toReadonlyArray(block));
        for (const entry of block) {
          map31.set(entry.request, entry);
        }
      }
      const flat = arr.flat();
      return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
        entry.listeners.interrupted = true;
      })), currentRequestMap, map31);
    }, false, false)), "runBlockedRequests");
    _version = /* @__PURE__ */ getCurrentVersion();
    FiberRuntime = class extends Class2 {
      static {
        __name(this, "FiberRuntime");
      }
      [FiberTypeId] = fiberVariance2;
      [RuntimeFiberTypeId] = runtimeFiberVariance;
      _fiberRefs;
      _fiberId;
      _queue = /* @__PURE__ */ new Array();
      _children = null;
      _observers = /* @__PURE__ */ new Array();
      _running = false;
      _stack = [];
      _asyncInterruptor = null;
      _asyncBlockingOn = null;
      _exitValue = null;
      _steps = [];
      _isYielding = false;
      currentRuntimeFlags;
      currentOpCount = 0;
      currentSupervisor;
      currentScheduler;
      currentTracer;
      currentSpan;
      currentContext;
      currentDefaultServices;
      constructor(fiberId3, fiberRefs0, runtimeFlags0) {
        super();
        this.currentRuntimeFlags = runtimeFlags0;
        this._fiberId = fiberId3;
        this._fiberRefs = fiberRefs0;
        if (runtimeMetrics(runtimeFlags0)) {
          const tags = this.getFiberRef(currentMetricLabels);
          fiberStarted.unsafeUpdate(1, tags);
          fiberActive.unsafeUpdate(1, tags);
        }
        this.refreshRefCache();
      }
      commit() {
        return join2(this);
      }
      /**
       * The identity of the fiber.
       */
      id() {
        return this._fiberId;
      }
      /**
       * Begins execution of the effect associated with this fiber on in the
       * background. This can be called to "kick off" execution of a fiber after
       * it has been created.
       */
      resume(effect4) {
        this.tell(resume(effect4));
      }
      /**
       * The status of the fiber.
       */
      get status() {
        return this.ask((_, status2) => status2);
      }
      /**
       * Gets the fiber runtime flags.
       */
      get runtimeFlags() {
        return this.ask((state, status2) => {
          if (isDone3(status2)) {
            return state.currentRuntimeFlags;
          }
          return status2.runtimeFlags;
        });
      }
      /**
       * Returns the current `FiberScope` for the fiber.
       */
      scope() {
        return unsafeMake8(this);
      }
      /**
       * Retrieves the immediate children of the fiber.
       */
      get children() {
        return this.ask((fiber) => Array.from(fiber.getChildren()));
      }
      /**
       * Gets the fiber's set of children.
       */
      getChildren() {
        if (this._children === null) {
          this._children = /* @__PURE__ */ new Set();
        }
        return this._children;
      }
      /**
       * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
       * if the fiber has not been interrupted.
       *
       * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
       * on this fiber, then values derived from the fiber's state (including the
       * log annotations and log level) may not be up-to-date.
       */
      getInterruptedCause() {
        return this.getFiberRef(currentInterruptedCause);
      }
      /**
       * Retrieves the whole set of fiber refs.
       */
      fiberRefs() {
        return this.ask((fiber) => fiber.getFiberRefs());
      }
      /**
       * Returns an effect that will contain information computed from the fiber
       * state and status while running on the fiber.
       *
       * This allows the outside world to interact safely with mutable fiber state
       * without locks or immutable data.
       */
      ask(f) {
        return suspend(() => {
          const deferred = deferredUnsafeMake(this._fiberId);
          this.tell(stateful((fiber, status2) => {
            deferredUnsafeDone(deferred, sync(() => f(fiber, status2)));
          }));
          return deferredAwait(deferred);
        });
      }
      /**
       * Adds a message to be processed by the fiber on the fiber.
       */
      tell(message) {
        this._queue.push(message);
        if (!this._running) {
          this._running = true;
          this.drainQueueLaterOnExecutor();
        }
      }
      get await() {
        return async_((resume2) => {
          const cb = /* @__PURE__ */ __name((exit5) => resume2(succeed(exit5)), "cb");
          this.tell(stateful((fiber, _) => {
            if (fiber._exitValue !== null) {
              cb(this._exitValue);
            } else {
              fiber.addObserver(cb);
            }
          }));
          return sync(() => this.tell(stateful((fiber, _) => {
            fiber.removeObserver(cb);
          })));
        }, this.id());
      }
      get inheritAll() {
        return withFiberRuntime((parentFiber, parentStatus) => {
          const parentFiberId = parentFiber.id();
          const parentFiberRefs = parentFiber.getFiberRefs();
          const parentRuntimeFlags = parentStatus.runtimeFlags;
          const childFiberRefs = this.getFiberRefs();
          const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
          parentFiber.setFiberRefs(updatedFiberRefs);
          const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
          const patch9 = pipe(
            diff4(parentRuntimeFlags, updatedRuntimeFlags),
            // Do not inherit WindDown or Interruption!
            exclude2(Interruption),
            exclude2(WindDown)
          );
          return updateRuntimeFlags(patch9);
        });
      }
      /**
       * Tentatively observes the fiber, but returns immediately if it is not
       * already done.
       */
      get poll() {
        return sync(() => fromNullable(this._exitValue));
      }
      /**
       * Unsafely observes the fiber, but returns immediately if it is not
       * already done.
       */
      unsafePoll() {
        return this._exitValue;
      }
      /**
       * In the background, interrupts the fiber as if interrupted from the specified fiber.
       */
      interruptAsFork(fiberId3) {
        return sync(() => this.tell(interruptSignal(interrupt(fiberId3))));
      }
      /**
       * In the background, interrupts the fiber as if interrupted from the specified fiber.
       */
      unsafeInterruptAsFork(fiberId3) {
        this.tell(interruptSignal(interrupt(fiberId3)));
      }
      /**
       * Adds an observer to the list of observers.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      addObserver(observer) {
        if (this._exitValue !== null) {
          observer(this._exitValue);
        } else {
          this._observers.push(observer);
        }
      }
      /**
       * Removes the specified observer from the list of observers that will be
       * notified when the fiber exits.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      removeObserver(observer) {
        this._observers = this._observers.filter((o) => o !== observer);
      }
      /**
       * Retrieves all fiber refs of the fiber.
       *
       * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
       * on this fiber, then values derived from the fiber's state (including the
       * log annotations and log level) may not be up-to-date.
       */
      getFiberRefs() {
        this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
        return this._fiberRefs;
      }
      /**
       * Deletes the specified fiber ref.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      unsafeDeleteFiberRef(fiberRef) {
        this._fiberRefs = delete_(this._fiberRefs, fiberRef);
      }
      /**
       * Retrieves the state of the fiber ref, or else its initial value.
       *
       * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
       * on this fiber, then values derived from the fiber's state (including the
       * log annotations and log level) may not be up-to-date.
       */
      getFiberRef(fiberRef) {
        if (this._fiberRefs.locals.has(fiberRef)) {
          return this._fiberRefs.locals.get(fiberRef)[0][1];
        }
        return fiberRef.initial;
      }
      /**
       * Sets the fiber ref to the specified value.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      setFiberRef(fiberRef, value3) {
        this._fiberRefs = updateAs(this._fiberRefs, {
          fiberId: this._fiberId,
          fiberRef,
          value: value3
        });
        this.refreshRefCache();
      }
      refreshRefCache() {
        this.currentDefaultServices = this.getFiberRef(currentServices);
        this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
        this.currentSupervisor = this.getFiberRef(currentSupervisor);
        this.currentScheduler = this.getFiberRef(currentScheduler);
        this.currentContext = this.getFiberRef(currentContext);
        this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
      }
      /**
       * Wholesale replaces all fiber refs of this fiber.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      setFiberRefs(fiberRefs3) {
        this._fiberRefs = fiberRefs3;
        this.refreshRefCache();
      }
      /**
       * Adds a reference to the specified fiber inside the children set.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      addChild(child) {
        this.getChildren().add(child);
      }
      /**
       * Removes a reference to the specified fiber inside the children set.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      removeChild(child) {
        this.getChildren().delete(child);
      }
      /**
       * Transfers all children of this fiber that are currently running to the
       * specified fiber scope.
       *
       * **NOTE**: This method must be invoked by the fiber itself after it has
       * evaluated the effects but prior to exiting.
       */
      transferChildren(scope5) {
        const children2 = this._children;
        this._children = null;
        if (children2 !== null && children2.size > 0) {
          for (const child of children2) {
            if (child._exitValue === null) {
              scope5.add(this.currentRuntimeFlags, child);
            }
          }
        }
      }
      /**
       * On the current thread, executes all messages in the fiber's inbox. This
       * method may return before all work is done, in the event the fiber executes
       * an asynchronous operation.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      drainQueueOnCurrentThread() {
        let recurse = true;
        while (recurse) {
          let evaluationSignal = EvaluationSignalContinue;
          const prev = globalThis[currentFiberURI];
          globalThis[currentFiberURI] = this;
          try {
            while (evaluationSignal === EvaluationSignalContinue) {
              evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
            }
          } finally {
            this._running = false;
            globalThis[currentFiberURI] = prev;
          }
          if (this._queue.length > 0 && !this._running) {
            this._running = true;
            if (evaluationSignal === EvaluationSignalYieldNow) {
              this.drainQueueLaterOnExecutor();
              recurse = false;
            } else {
              recurse = true;
            }
          } else {
            recurse = false;
          }
        }
      }
      /**
       * Schedules the execution of all messages in the fiber's inbox.
       *
       * This method will return immediately after the scheduling
       * operation is completed, but potentially before such messages have been
       * executed.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      drainQueueLaterOnExecutor() {
        this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
      }
      /**
       * Drains the fiber's message queue while the fiber is actively running,
       * returning the next effect to execute, which may be the input effect if no
       * additional effect needs to be executed.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      drainQueueWhileRunning(runtimeFlags2, cur0) {
        let cur = cur0;
        while (this._queue.length > 0) {
          const message = this._queue.splice(0, 1)[0];
          cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
        }
        return cur;
      }
      /**
       * Determines if the fiber is interrupted.
       *
       * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
       * on this fiber, then values derived from the fiber's state (including the
       * log annotations and log level) may not be up-to-date.
       */
      isInterrupted() {
        return !isEmpty5(this.getFiberRef(currentInterruptedCause));
      }
      /**
       * Adds an interruptor to the set of interruptors that are interrupting this
       * fiber.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      addInterruptedCause(cause3) {
        const oldSC = this.getFiberRef(currentInterruptedCause);
        this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause3));
      }
      /**
       * Processes a new incoming interrupt signal.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      processNewInterruptSignal(cause3) {
        this.addInterruptedCause(cause3);
        this.sendInterruptSignalToAllChildren();
      }
      /**
       * Interrupts all children of the current fiber, returning an effect that will
       * await the exit of the children. This method will return null if the fiber
       * has no children.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      sendInterruptSignalToAllChildren() {
        if (this._children === null || this._children.size === 0) {
          return false;
        }
        let told = false;
        for (const child of this._children) {
          child.tell(interruptSignal(interrupt(this.id())));
          told = true;
        }
        return told;
      }
      /**
       * Interrupts all children of the current fiber, returning an effect that will
       * await the exit of the children. This method will return null if the fiber
       * has no children.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      interruptAllChildren() {
        if (this.sendInterruptSignalToAllChildren()) {
          const it = this._children.values();
          this._children = null;
          let isDone7 = false;
          const body = /* @__PURE__ */ __name(() => {
            const next4 = it.next();
            if (!next4.done) {
              return asVoid2(next4.value.await);
            } else {
              return sync(() => {
                isDone7 = true;
              });
            }
          }, "body");
          return whileLoop({
            while: /* @__PURE__ */ __name(() => !isDone7, "while"),
            body,
            step: /* @__PURE__ */ __name(() => {
            }, "step")
          });
        }
        return null;
      }
      reportExitValue(exit5) {
        if (runtimeMetrics(this.currentRuntimeFlags)) {
          const tags = this.getFiberRef(currentMetricLabels);
          const startTimeMillis = this.id().startTimeMillis;
          const endTimeMillis = Date.now();
          fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
          fiberActive.unsafeUpdate(-1, tags);
          switch (exit5._tag) {
            case OP_SUCCESS: {
              fiberSuccesses.unsafeUpdate(1, tags);
              break;
            }
            case OP_FAILURE: {
              fiberFailures.unsafeUpdate(1, tags);
              break;
            }
          }
        }
        if (exit5._tag === "Failure") {
          const level = this.getFiberRef(currentUnhandledErrorLogLevel);
          if (!isInterruptedOnly(exit5.cause) && level._tag === "Some") {
            this.log("Fiber terminated with an unhandled error", exit5.cause, level);
          }
        }
      }
      setExitValue(exit5) {
        this._exitValue = exit5;
        this.reportExitValue(exit5);
        for (let i = this._observers.length - 1; i >= 0; i--) {
          this._observers[i](exit5);
        }
        this._observers = [];
      }
      getLoggers() {
        return this.getFiberRef(currentLoggers);
      }
      log(message, cause3, overrideLogLevel) {
        const logLevel2 = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
        const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
        if (greaterThan4(minimumLogLevel, logLevel2)) {
          return;
        }
        const spans = this.getFiberRef(currentLogSpan);
        const annotations3 = this.getFiberRef(currentLogAnnotations);
        const loggers = this.getLoggers();
        const contextMap = this.getFiberRefs();
        if (size3(loggers) > 0) {
          const clockService = get3(this.getFiberRef(currentServices), clockTag);
          const date7 = new Date(clockService.unsafeCurrentTimeMillis());
          withRedactableContext(contextMap, () => {
            for (const logger of loggers) {
              logger.log({
                fiberId: this.id(),
                logLevel: logLevel2,
                message,
                cause: cause3,
                context: contextMap,
                spans,
                annotations: annotations3,
                date: date7
              });
            }
          });
        }
      }
      /**
       * Evaluates a single message on the current thread, while the fiber is
       * suspended. This method should only be called while evaluation of the
       * fiber's effect is suspended due to an asynchronous operation.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      evaluateMessageWhileSuspended(message) {
        switch (message._tag) {
          case OP_YIELD_NOW: {
            return EvaluationSignalYieldNow;
          }
          case OP_INTERRUPT_SIGNAL: {
            this.processNewInterruptSignal(message.cause);
            if (this._asyncInterruptor !== null) {
              this._asyncInterruptor(exitFailCause(message.cause));
              this._asyncInterruptor = null;
            }
            return EvaluationSignalContinue;
          }
          case OP_RESUME: {
            this._asyncInterruptor = null;
            this._asyncBlockingOn = null;
            this.evaluateEffect(message.effect);
            return EvaluationSignalContinue;
          }
          case OP_STATEFUL: {
            message.onFiber(this, this._exitValue !== null ? done4 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
            return EvaluationSignalContinue;
          }
          default: {
            return absurd(message);
          }
        }
      }
      /**
       * Evaluates an effect until completion, potentially asynchronously.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      evaluateEffect(effect0) {
        this.currentSupervisor.onResume(this);
        try {
          let effect4 = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
          while (effect4 !== null) {
            const eff = effect4;
            const exit5 = this.runLoop(eff);
            if (exit5 === YieldedOp) {
              const op = yieldedOpChannel.currentOp;
              yieldedOpChannel.currentOp = null;
              if (op._op === OP_YIELD) {
                if (cooperativeYielding(this.currentRuntimeFlags)) {
                  this.tell(yieldNow3());
                  this.tell(resume(exitVoid));
                  effect4 = null;
                } else {
                  effect4 = exitVoid;
                }
              } else if (op._op === OP_ASYNC) {
                effect4 = null;
              }
            } else {
              this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
              const interruption2 = this.interruptAllChildren();
              if (interruption2 !== null) {
                effect4 = flatMap8(interruption2, () => exit5);
              } else {
                if (this._queue.length === 0) {
                  this.setExitValue(exit5);
                } else {
                  this.tell(resume(exit5));
                }
                effect4 = null;
              }
            }
          }
        } finally {
          this.currentSupervisor.onSuspend(this);
        }
      }
      /**
       * Begins execution of the effect associated with this fiber on the current
       * thread. This can be called to "kick off" execution of a fiber after it has
       * been created, in hopes that the effect can be executed synchronously.
       *
       * This is not the normal way of starting a fiber, but it is useful when the
       * express goal of executing the fiber is to synchronously produce its exit.
       */
      start(effect4) {
        if (!this._running) {
          this._running = true;
          const prev = globalThis[currentFiberURI];
          globalThis[currentFiberURI] = this;
          try {
            this.evaluateEffect(effect4);
          } finally {
            this._running = false;
            globalThis[currentFiberURI] = prev;
            if (this._queue.length > 0) {
              this.drainQueueLaterOnExecutor();
            }
          }
        } else {
          this.tell(resume(effect4));
        }
      }
      /**
       * Begins execution of the effect associated with this fiber on in the
       * background, and on the correct thread pool. This can be called to "kick
       * off" execution of a fiber after it has been created, in hopes that the
       * effect can be executed synchronously.
       */
      startFork(effect4) {
        this.tell(resume(effect4));
      }
      /**
       * Takes the current runtime flags, patches them to return the new runtime
       * flags, and then makes any changes necessary to fiber state based on the
       * specified patch.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      patchRuntimeFlags(oldRuntimeFlags, patch9) {
        const newRuntimeFlags = patch4(oldRuntimeFlags, patch9);
        globalThis[currentFiberURI] = this;
        this.currentRuntimeFlags = newRuntimeFlags;
        return newRuntimeFlags;
      }
      /**
       * Initiates an asynchronous operation, by building a callback that will
       * resume execution, and then feeding that callback to the registration
       * function, handling error cases and repeated resumptions appropriately.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      initiateAsync(runtimeFlags2, asyncRegister) {
        let alreadyCalled = false;
        const callback = /* @__PURE__ */ __name((effect4) => {
          if (!alreadyCalled) {
            alreadyCalled = true;
            this.tell(resume(effect4));
          }
        }, "callback");
        if (interruptible(runtimeFlags2)) {
          this._asyncInterruptor = callback;
        }
        try {
          asyncRegister(callback);
        } catch (e) {
          callback(failCause(die(e)));
        }
      }
      pushStack(cont) {
        this._stack.push(cont);
        if (cont._op === "OnStep") {
          this._steps.push({
            refs: this.getFiberRefs(),
            flags: this.currentRuntimeFlags
          });
        }
      }
      popStack() {
        const item = this._stack.pop();
        if (item) {
          if (item._op === "OnStep") {
            this._steps.pop();
          }
          return item;
        }
        return;
      }
      getNextSuccessCont() {
        let frame = this.popStack();
        while (frame) {
          if (frame._op !== OP_ON_FAILURE) {
            return frame;
          }
          frame = this.popStack();
        }
      }
      getNextFailCont() {
        let frame = this.popStack();
        while (frame) {
          if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
            return frame;
          }
          frame = this.popStack();
        }
      }
      [OP_TAG](op) {
        return sync(() => unsafeGet3(this.currentContext, op));
      }
      ["Left"](op) {
        return fail2(op.left);
      }
      ["None"](_) {
        return fail2(new NoSuchElementException());
      }
      ["Right"](op) {
        return exitSucceed(op.right);
      }
      ["Some"](op) {
        return exitSucceed(op.value);
      }
      ["Micro"](op) {
        return unsafeAsync((microResume) => {
          let resume2 = microResume;
          const fiber = runFork(provideContext2(op, this.currentContext));
          fiber.addObserver((exit5) => {
            if (exit5._tag === "Success") {
              return resume2(exitSucceed(exit5.value));
            }
            switch (exit5.cause._tag) {
              case "Interrupt": {
                return resume2(exitFailCause(interrupt(none4)));
              }
              case "Fail": {
                return resume2(fail2(exit5.cause.error));
              }
              case "Die": {
                return resume2(die2(exit5.cause.defect));
              }
            }
          });
          return unsafeAsync((abortResume) => {
            resume2 = /* @__PURE__ */ __name((_) => {
              abortResume(void_2);
            }, "resume");
            fiber.unsafeInterrupt();
          });
        });
      }
      [OP_SYNC](op) {
        const value3 = internalCall(() => op.effect_instruction_i0());
        const cont = this.getNextSuccessCont();
        if (cont !== void 0) {
          if (!(cont._op in contOpSuccess)) {
            absurd(cont);
          }
          return contOpSuccess[cont._op](this, cont, value3);
        } else {
          yieldedOpChannel.currentOp = exitSucceed(value3);
          return YieldedOp;
        }
      }
      [OP_SUCCESS](op) {
        const oldCur = op;
        const cont = this.getNextSuccessCont();
        if (cont !== void 0) {
          if (!(cont._op in contOpSuccess)) {
            absurd(cont);
          }
          return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
        } else {
          yieldedOpChannel.currentOp = oldCur;
          return YieldedOp;
        }
      }
      [OP_FAILURE](op) {
        const cause3 = op.effect_instruction_i0;
        const cont = this.getNextFailCont();
        if (cont !== void 0) {
          switch (cont._op) {
            case OP_ON_FAILURE:
            case OP_ON_SUCCESS_AND_FAILURE: {
              if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
                return internalCall(() => cont.effect_instruction_i1(cause3));
              } else {
                return exitFailCause(stripFailures(cause3));
              }
            }
            case "OnStep": {
              if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
                return exitSucceed(exitFailCause(cause3));
              } else {
                return exitFailCause(stripFailures(cause3));
              }
            }
            case OP_REVERT_FLAGS: {
              this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
              if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
                return exitFailCause(sequential(cause3, this.getInterruptedCause()));
              } else {
                return exitFailCause(cause3);
              }
            }
            default: {
              absurd(cont);
            }
          }
        } else {
          yieldedOpChannel.currentOp = exitFailCause(cause3);
          return YieldedOp;
        }
      }
      [OP_WITH_RUNTIME](op) {
        return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
      }
      ["Blocked"](op) {
        const refs = this.getFiberRefs();
        const flags = this.currentRuntimeFlags;
        if (this._steps.length > 0) {
          const frames = [];
          const snap = this._steps[this._steps.length - 1];
          let frame = this.popStack();
          while (frame && frame._op !== "OnStep") {
            frames.push(frame);
            frame = this.popStack();
          }
          this.setFiberRefs(snap.refs);
          this.currentRuntimeFlags = snap.flags;
          const patchRefs = diff6(snap.refs, refs);
          const patchFlags = diff4(snap.flags, flags);
          return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
            while (frames.length > 0) {
              newFiber.pushStack(frames.pop());
            }
            newFiber.setFiberRefs(patch7(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
            newFiber.currentRuntimeFlags = patch4(patchFlags)(newFiber.currentRuntimeFlags);
            return op.effect_instruction_i1;
          })));
        }
        return uninterruptibleMask((restore) => flatMap8(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
      }
      ["RunBlocked"](op) {
        return runBlockedRequests(op.effect_instruction_i0);
      }
      [OP_UPDATE_RUNTIME_FLAGS](op) {
        const updateFlags = op.effect_instruction_i0;
        const oldRuntimeFlags = this.currentRuntimeFlags;
        const newRuntimeFlags = patch4(oldRuntimeFlags, updateFlags);
        if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
          return exitFailCause(this.getInterruptedCause());
        } else {
          this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
          if (op.effect_instruction_i1) {
            const revertFlags = diff4(newRuntimeFlags, oldRuntimeFlags);
            this.pushStack(new RevertFlags(revertFlags, op));
            return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
          } else {
            return exitVoid;
          }
        }
      }
      [OP_ON_SUCCESS](op) {
        this.pushStack(op);
        return op.effect_instruction_i0;
      }
      ["OnStep"](op) {
        this.pushStack(op);
        return op.effect_instruction_i0;
      }
      [OP_ON_FAILURE](op) {
        this.pushStack(op);
        return op.effect_instruction_i0;
      }
      [OP_ON_SUCCESS_AND_FAILURE](op) {
        this.pushStack(op);
        return op.effect_instruction_i0;
      }
      [OP_ASYNC](op) {
        this._asyncBlockingOn = op.effect_instruction_i1;
        this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
        yieldedOpChannel.currentOp = op;
        return YieldedOp;
      }
      [OP_YIELD](op) {
        this._isYielding = false;
        yieldedOpChannel.currentOp = op;
        return YieldedOp;
      }
      [OP_WHILE](op) {
        const check5 = op.effect_instruction_i0;
        const body = op.effect_instruction_i1;
        if (check5()) {
          this.pushStack(op);
          return body();
        } else {
          return exitVoid;
        }
      }
      [OP_ITERATOR](op) {
        return contOpSuccess[OP_ITERATOR](this, op, void 0);
      }
      [OP_COMMIT](op) {
        return internalCall(() => op.commit());
      }
      /**
       * The main run-loop for evaluating effects.
       *
       * **NOTE**: This method must be invoked by the fiber itself.
       */
      runLoop(effect0) {
        let cur = effect0;
        this.currentOpCount = 0;
        while (true) {
          if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
            this.currentSupervisor.onEffect(this, cur);
          }
          if (this._queue.length > 0) {
            cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
          }
          if (!this._isYielding) {
            this.currentOpCount += 1;
            const shouldYield = this.currentScheduler.shouldYield(this);
            if (shouldYield !== false) {
              this._isYielding = true;
              this.currentOpCount = 0;
              const oldCur = cur;
              cur = flatMap8(yieldNow({
                priority: shouldYield
              }), () => oldCur);
            }
          }
          try {
            cur = this.currentTracer.context(() => {
              if (_version !== cur[EffectTypeId2]._V) {
                const level = this.getFiberRef(currentVersionMismatchErrorLogLevel);
                if (level._tag === "Some") {
                  const effectVersion = cur[EffectTypeId2]._V;
                  this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty17, level);
                }
              }
              return this[cur._op](cur);
            }, this);
            if (cur === YieldedOp) {
              const op = yieldedOpChannel.currentOp;
              if (op._op === OP_YIELD || op._op === OP_ASYNC) {
                return YieldedOp;
              }
              yieldedOpChannel.currentOp = null;
              return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
            }
          } catch (e) {
            if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
              cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
            } else if (isInterruptedException(e)) {
              cur = exitFailCause(sequential(die(e), interrupt(none4)));
            } else {
              cur = die2(e);
            }
          }
        }
      }
      run = /* @__PURE__ */ __name(() => {
        this.drainQueueOnCurrentThread();
      }, "run");
    };
    currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
    loggerWithConsoleLog = /* @__PURE__ */ __name((self2) => makeLogger((opts) => {
      const services = getOrDefault2(opts.context, currentServices);
      get3(services, consoleTag).unsafe.log(self2.log(opts));
    }), "loggerWithConsoleLog");
    defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
    tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
      annotations: annotations3,
      cause: cause3,
      context: context10,
      fiberId: fiberId3,
      logLevel: logLevel2,
      message
    }) => {
      const span4 = getOption2(getOrDefault(context10, currentContext), spanTag);
      if (span4._tag === "None" || span4.value._tag === "ExternalSpan") {
        return;
      }
      const clockService = unsafeGet3(getOrDefault(context10, currentServices), clockTag);
      const attributes = {};
      for (const [key, value3] of annotations3) {
        attributes[key] = value3;
      }
      attributes["effect.fiberId"] = threadName2(fiberId3);
      attributes["effect.logLevel"] = logLevel2.label;
      if (cause3 !== null && cause3._tag !== "Empty") {
        attributes["effect.cause"] = pretty(cause3, {
          renderErrorCause: true
        });
      }
      span4.value.event(toStringUnknown(Array.isArray(message) && message.length === 1 ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
    }));
    currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make11(defaultLogger, tracerLogger)));
    annotateLogsScoped = /* @__PURE__ */ __name(function() {
      if (typeof arguments[0] === "string") {
        return fiberRefLocallyScopedWith(currentLogAnnotations, set3(arguments[0], arguments[1]));
      }
      const entries2 = Object.entries(arguments[0]);
      return fiberRefLocallyScopedWith(currentLogAnnotations, mutate3((annotations3) => {
        for (let i = 0; i < entries2.length; i++) {
          const [key, value3] = entries2[i];
          set3(annotations3, key, value3);
        }
        return annotations3;
      }));
    }, "annotateLogsScoped");
    whenLogLevel = /* @__PURE__ */ dual(2, (effect4, level) => {
      const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
      return withFiberRuntime((fiberState) => {
        const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel);
        if (greaterThan4(minimumLogLevel, requiredLogLevel)) {
          return succeed(none2());
        }
        return map11(effect4, some2);
      });
    });
    acquireRelease = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire2, release2) => uninterruptible(tap2(acquire2, (a) => addFinalizer((exit5) => release2(a, exit5)))));
    acquireReleaseInterruptible = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire2, release2) => ensuring(acquire2, addFinalizer((exit5) => release2(exit5))));
    addFinalizer = /* @__PURE__ */ __name((finalizer3) => withFiberRuntime((runtime5) => {
      const acquireRefs = runtime5.getFiberRefs();
      const acquireFlags = disable2(runtime5.currentRuntimeFlags, Interruption);
      return flatMap8(scope, (scope5) => scopeAddFinalizerExit(scope5, (exit5) => withFiberRuntime((runtimeFinalizer) => {
        const preRefs = runtimeFinalizer.getFiberRefs();
        const preFlags = runtimeFinalizer.currentRuntimeFlags;
        const patchRefs = diff6(preRefs, acquireRefs);
        const patchFlags = diff4(preFlags, acquireFlags);
        const inverseRefs = diff6(acquireRefs, preRefs);
        runtimeFinalizer.setFiberRefs(patch7(patchRefs, runtimeFinalizer.id(), acquireRefs));
        return ensuring(withRuntimeFlags(finalizer3(exit5), patchFlags), sync(() => {
          runtimeFinalizer.setFiberRefs(patch7(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
        }));
      })));
    }), "addFinalizer");
    daemonChildren = /* @__PURE__ */ __name((self2) => {
      const forkScope = fiberRefLocally(currentForkScopeOverride, some2(globalScope));
      return forkScope(self2);
    }, "daemonChildren");
    _existsParFound = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
    exists2 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => matchSimple(options?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach8(elements, (a, i) => if_(predicate(a, i), {
      onTrue: /* @__PURE__ */ __name(() => fail2(_existsParFound), "onTrue"),
      onFalse: /* @__PURE__ */ __name(() => void_2, "onFalse")
    }), options), {
      onFailure: /* @__PURE__ */ __name((e) => e === _existsParFound ? succeed(true) : fail2(e), "onFailure"),
      onSuccess: /* @__PURE__ */ __name(() => succeed(false), "onSuccess")
    })));
    existsLoop = /* @__PURE__ */ __name((iterator2, index2, f) => {
      const next4 = iterator2.next();
      if (next4.done) {
        return succeed(false);
      }
      return flatMap8(f(next4.value, index2), (b) => b ? succeed(b) : existsLoop(iterator2, index2 + 1, f));
    }, "existsLoop");
    filter7 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => {
      const predicate_ = options?.negate ? (a, i) => map11(predicate(a, i), not) : predicate;
      return matchSimple(options?.concurrency, () => suspend(() => fromIterable2(elements).reduceRight((effect4, a, i) => zipWith4(effect4, suspend(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array()))), () => map11(forEach8(elements, (a, i) => map11(predicate_(a, i), (b) => b ? some2(a) : none2()), options), getSomes));
    });
    allResolveInput = /* @__PURE__ */ __name((input) => {
      if (Array.isArray(input) || isIterable(input)) {
        return [input, none2()];
      }
      const keys5 = Object.keys(input);
      const size15 = keys5.length;
      return [keys5.map((k) => input[k]), some2((values4) => {
        const res = {};
        for (let i = 0; i < size15; i++) {
          ;
          res[keys5[i]] = values4[i];
        }
        return res;
      })];
    }, "allResolveInput");
    allValidate = /* @__PURE__ */ __name((effects, reconcile, options) => {
      const eitherEffects = [];
      for (const effect4 of effects) {
        eitherEffects.push(either2(effect4));
      }
      return flatMap8(forEach8(eitherEffects, identity, {
        concurrency: options?.concurrency,
        batching: options?.batching,
        concurrentFinalizers: options?.concurrentFinalizers
      }), (eithers) => {
        const none10 = none2();
        const size15 = eithers.length;
        const errors = new Array(size15);
        const successes = new Array(size15);
        let errored = false;
        for (let i = 0; i < size15; i++) {
          const either8 = eithers[i];
          if (either8._tag === "Left") {
            errors[i] = some2(either8.left);
            errored = true;
          } else {
            successes[i] = either8.right;
            errors[i] = none10;
          }
        }
        if (errored) {
          return reconcile._tag === "Some" ? fail2(reconcile.value(errors)) : fail2(errors);
        } else if (options?.discard) {
          return void_2;
        }
        return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
      });
    }, "allValidate");
    allEither = /* @__PURE__ */ __name((effects, reconcile, options) => {
      const eitherEffects = [];
      for (const effect4 of effects) {
        eitherEffects.push(either2(effect4));
      }
      if (options?.discard) {
        return forEach8(eitherEffects, identity, {
          concurrency: options?.concurrency,
          batching: options?.batching,
          discard: true,
          concurrentFinalizers: options?.concurrentFinalizers
        });
      }
      return map11(forEach8(eitherEffects, identity, {
        concurrency: options?.concurrency,
        batching: options?.batching,
        concurrentFinalizers: options?.concurrentFinalizers
      }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
    }, "allEither");
    all5 = /* @__PURE__ */ __name((arg, options) => {
      const [effects, reconcile] = allResolveInput(arg);
      if (options?.mode === "validate") {
        return allValidate(effects, reconcile, options);
      } else if (options?.mode === "either") {
        return allEither(effects, reconcile, options);
      }
      return options?.discard !== true && reconcile._tag === "Some" ? map11(forEach8(effects, identity, options), reconcile.value) : forEach8(effects, identity, options);
    }, "all");
    allWith = /* @__PURE__ */ __name((options) => (arg) => all5(arg, options), "allWith");
    allSuccesses = /* @__PURE__ */ __name((elements, options) => map11(all5(fromIterable2(elements).map(exit2), options), filterMap2((exit5) => exitIsSuccess(exit5) ? some2(exit5.effect_instruction_i0) : none2())), "allSuccesses");
    replicate = /* @__PURE__ */ dual(2, (self2, n) => Array.from({
      length: n
    }, () => self2));
    replicateEffect = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, n, options) => all5(replicate(self2, n), options));
    forEach8 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (self2, f, options) => withFiberRuntime((r) => {
      const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
      if (options?.discard) {
        return match9(options.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
      }
      return match9(options?.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self2, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachParN(self2, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
    }));
    forEachParUnbounded = /* @__PURE__ */ __name((self2, f, batching) => suspend(() => {
      const as12 = fromIterable2(self2);
      const array7 = new Array(as12.length);
      const fn2 = /* @__PURE__ */ __name((a, i) => flatMap8(f(a, i), (b) => sync(() => array7[i] = b)), "fn");
      return zipRight2(forEachConcurrentDiscard(as12, fn2, batching, false), succeed(array7));
    }), "forEachParUnbounded");
    forEachConcurrentDiscard = /* @__PURE__ */ __name((self2, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
      let todos = Array.from(self2).reverse();
      let target = todos.length;
      if (target === 0) {
        return void_2;
      }
      let counter6 = 0;
      let interrupted3 = false;
      const fibersCount = n ? Math.min(todos.length, n) : todos.length;
      const fibers2 = /* @__PURE__ */ new Set();
      const results = new Array();
      const interruptAll2 = /* @__PURE__ */ __name(() => fibers2.forEach((fiber) => {
        fiber.currentScheduler.scheduleTask(() => {
          fiber.unsafeInterruptAsFork(parent.id());
        }, 0);
      }), "interruptAll");
      const startOrder = new Array();
      const joinOrder = new Array();
      const residual = new Array();
      const collectExits = /* @__PURE__ */ __name(() => {
        const exits = results.filter(({
          exit: exit5
        }) => exit5._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
          exit: exit5
        }) => exit5);
        if (exits.length === 0) {
          exits.push(exitVoid);
        }
        return exits;
      }, "collectExits");
      const runFiber = /* @__PURE__ */ __name((eff, interruptImmediately = false) => {
        const runnable = uninterruptible(graft(eff));
        const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
        parent.currentScheduler.scheduleTask(() => {
          if (interruptImmediately) {
            fiber.unsafeInterruptAsFork(parent.id());
          }
          fiber.resume(runnable);
        }, 0);
        return fiber;
      }, "runFiber");
      const onInterruptSignal = /* @__PURE__ */ __name(() => {
        if (!processAll) {
          target -= todos.length;
          todos = [];
        }
        interrupted3 = true;
        interruptAll2();
      }, "onInterruptSignal");
      const stepOrExit = batching ? step2 : exit2;
      const processingFiber = runFiber(async_((resume2) => {
        const pushResult = /* @__PURE__ */ __name((res, index2) => {
          if (res._op === "Blocked") {
            residual.push(res);
          } else {
            results.push({
              index: index2,
              exit: res
            });
            if (res._op === "Failure" && !interrupted3) {
              onInterruptSignal();
            }
          }
        }, "pushResult");
        const next4 = /* @__PURE__ */ __name(() => {
          if (todos.length > 0) {
            const a = todos.pop();
            let index2 = counter6++;
            const returnNextElement = /* @__PURE__ */ __name(() => {
              const a2 = todos.pop();
              index2 = counter6++;
              return flatMap8(yieldNow(), () => flatMap8(stepOrExit(restore(f(a2, index2))), onRes));
            }, "returnNextElement");
            const onRes = /* @__PURE__ */ __name((res) => {
              if (todos.length > 0) {
                pushResult(res, index2);
                if (todos.length > 0) {
                  return returnNextElement();
                }
              }
              return succeed(res);
            }, "onRes");
            const todo = flatMap8(stepOrExit(restore(f(a, index2))), onRes);
            const fiber = runFiber(todo);
            startOrder.push(fiber);
            fibers2.add(fiber);
            if (interrupted3) {
              fiber.currentScheduler.scheduleTask(() => {
                fiber.unsafeInterruptAsFork(parent.id());
              }, 0);
            }
            fiber.addObserver((wrapped) => {
              let exit5;
              if (wrapped._op === "Failure") {
                exit5 = wrapped;
              } else {
                exit5 = wrapped.effect_instruction_i0;
              }
              joinOrder.push(fiber);
              fibers2.delete(fiber);
              pushResult(exit5, index2);
              if (results.length === target) {
                resume2(succeed(getOrElse(exitCollectAll(collectExits(), {
                  parallel: true
                }), () => exitVoid)));
              } else if (residual.length + results.length === target) {
                const exits = collectExits();
                const requests = residual.map((blocked3) => blocked3.effect_instruction_i0).reduce(par);
                resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(exits, {
                  parallel: true
                }), () => exitVoid), ...residual.map((blocked3) => blocked3.effect_instruction_i1)], (i) => i, batching, true, n))));
              } else {
                next4();
              }
            });
          }
        }, "next");
        for (let i = 0; i < fibersCount; i++) {
          next4();
        }
      }));
      return asVoid2(onExit(flatten7(restore(join2(processingFiber))), exitMatch({
        onFailure: /* @__PURE__ */ __name((cause3) => {
          onInterruptSignal();
          const target2 = residual.length + 1;
          const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
          const toPop = Array.from(residual);
          return async_((cb) => {
            const exits = [];
            let count6 = 0;
            let index2 = 0;
            const check5 = /* @__PURE__ */ __name((index3, hitNext) => (exit5) => {
              exits[index3] = exit5;
              count6++;
              if (count6 === target2) {
                cb(exitSucceed(exitFailCause(cause3)));
              }
              if (toPop.length > 0 && hitNext) {
                next4();
              }
            }, "check");
            const next4 = /* @__PURE__ */ __name(() => {
              runFiber(toPop.pop(), true).addObserver(check5(index2, true));
              index2++;
            }, "next");
            processingFiber.addObserver(check5(index2, false));
            index2++;
            for (let i = 0; i < concurrency; i++) {
              next4();
            }
          });
        }, "onFailure"),
        onSuccess: /* @__PURE__ */ __name(() => forEachSequential(joinOrder, (f2) => f2.inheritAll), "onSuccess")
      })));
    }))), "forEachConcurrentDiscard");
    forEachParN = /* @__PURE__ */ __name((self2, n, f, batching) => suspend(() => {
      const as12 = fromIterable2(self2);
      const array7 = new Array(as12.length);
      const fn2 = /* @__PURE__ */ __name((a, i) => map11(f(a, i), (b) => array7[i] = b), "fn");
      return zipRight2(forEachConcurrentDiscard(as12, fn2, batching, false, n), succeed(array7));
    }), "forEachParN");
    fork = /* @__PURE__ */ __name((self2) => withFiberRuntime((state, status2) => succeed(unsafeFork2(self2, state, status2.runtimeFlags))), "fork");
    forkDaemon = /* @__PURE__ */ __name((self2) => forkWithScopeOverride(self2, globalScope), "forkDaemon");
    forkWithErrorHandler = /* @__PURE__ */ dual(2, (self2, handler) => fork(onError(self2, (cause3) => {
      const either8 = failureOrCause(cause3);
      switch (either8._tag) {
        case "Left":
          return handler(either8.left);
        case "Right":
          return failCause(either8.right);
      }
    })));
    unsafeFork2 = /* @__PURE__ */ __name((effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
      const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
      childFiber.resume(effect4);
      return childFiber;
    }, "unsafeFork");
    unsafeForkUnstarted = /* @__PURE__ */ __name((effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
      const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
      return childFiber;
    }, "unsafeForkUnstarted");
    unsafeMakeChildFiber = /* @__PURE__ */ __name((effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
      const childId = unsafeMake3();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const childFiberRefs = forkAs(parentFiberRefs, childId);
      const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
      const childContext = getOrDefault(childFiberRefs, currentContext);
      const supervisor = childFiber.currentSupervisor;
      supervisor.onStart(childContext, effect4, some2(parentFiber), childFiber);
      childFiber.addObserver((exit5) => supervisor.onEnd(exit5, childFiber));
      const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
      parentScope.add(parentRuntimeFlags, childFiber);
      return childFiber;
    }, "unsafeMakeChildFiber");
    forkWithScopeOverride = /* @__PURE__ */ __name((self2, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork2(self2, parentFiber, parentStatus.runtimeFlags, scopeOverride))), "forkWithScopeOverride");
    mergeAll3 = /* @__PURE__ */ dual((args2) => isFunction2(args2[2]), (elements, zero3, f, options) => matchSimple(options?.concurrency, () => fromIterable2(elements).reduce((acc, a, i) => zipWith4(acc, a, (acc2, a2) => f(acc2, a2, i)), succeed(zero3)), () => flatMap8(make29(zero3), (acc) => flatMap8(forEach8(elements, (effect4, i) => flatMap8(effect4, (a) => update3(acc, (b) => f(b, a, i))), options), () => get12(acc)))));
    partition3 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => pipe(forEach8(elements, (a, i) => either2(f(a, i)), options), map11((chunk4) => partitionMap3(chunk4, identity))));
    validateAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flatMap8(partition3(elements, f, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      concurrentFinalizers: options?.concurrentFinalizers
    }), ([es, bs]) => isNonEmptyArray2(es) ? fail2(es) : options?.discard ? void_2 : succeed(bs)));
    raceAll = /* @__PURE__ */ __name((all9) => withFiberRuntime((state, status2) => async_((resume2) => {
      const fibers2 = /* @__PURE__ */ new Set();
      let winner;
      let failures2 = empty17;
      const interruptAll2 = /* @__PURE__ */ __name(() => {
        for (const fiber of fibers2) {
          fiber.unsafeInterruptAsFork(state.id());
        }
      }, "interruptAll");
      let latch = false;
      let empty36 = true;
      for (const self2 of all9) {
        empty36 = false;
        const fiber = unsafeFork2(interruptible2(self2), state, status2.runtimeFlags);
        fibers2.add(fiber);
        fiber.addObserver((exit5) => {
          fibers2.delete(fiber);
          if (!winner) {
            if (exit5._tag === "Success") {
              latch = true;
              winner = fiber;
              failures2 = empty17;
              interruptAll2();
            } else {
              failures2 = parallel(exit5.cause, failures2);
            }
          }
          if (latch && fibers2.size === 0) {
            resume2(winner ? zipRight2(inheritAll(winner), winner.unsafePoll()) : failCause(failures2));
          }
        });
        if (winner) break;
      }
      if (empty36) {
        return resume2(dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`)));
      }
      latch = true;
      return interruptAllAs(fibers2, state.id());
    })), "raceAll");
    reduceEffect = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, zero3, f, options) => matchSimple(options?.concurrency, () => fromIterable2(elements).reduce((acc, a, i) => zipWith4(acc, a, (acc2, a2) => f(acc2, a2, i)), zero3), () => suspend(() => pipe(mergeAll3([zero3, ...elements], none2(), (acc, elem, i) => {
      switch (acc._tag) {
        case "None": {
          return some2(elem);
        }
        case "Some": {
          return some2(f(acc.value, elem, i));
        }
      }
    }, options), map11((option5) => {
      switch (option5._tag) {
        case "None": {
          throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
        }
        case "Some": {
          return option5.value;
        }
      }
    })))));
    parallelFinalizers = /* @__PURE__ */ __name((self2) => contextWithEffect((context10) => match2(getOption2(context10, scopeTag), {
      onNone: /* @__PURE__ */ __name(() => self2, "onNone"),
      onSome: /* @__PURE__ */ __name((scope5) => {
        switch (scope5.strategy._tag) {
          case "Parallel":
            return self2;
          case "Sequential":
          case "ParallelN":
            return flatMap8(scopeFork(scope5, parallel3), (inner) => scopeExtend(self2, inner));
        }
      }, "onSome")
    })), "parallelFinalizers");
    parallelNFinalizers = /* @__PURE__ */ __name((parallelism) => (self2) => contextWithEffect((context10) => match2(getOption2(context10, scopeTag), {
      onNone: /* @__PURE__ */ __name(() => self2, "onNone"),
      onSome: /* @__PURE__ */ __name((scope5) => {
        if (scope5.strategy._tag === "ParallelN" && scope5.strategy.parallelism === parallelism) {
          return self2;
        }
        return flatMap8(scopeFork(scope5, parallelN2(parallelism)), (inner) => scopeExtend(self2, inner));
      }, "onSome")
    })), "parallelNFinalizers");
    finalizersMask = /* @__PURE__ */ __name((strategy) => (self2) => finalizersMaskInternal(strategy, true)(self2), "finalizersMask");
    finalizersMaskInternal = /* @__PURE__ */ __name((strategy, concurrentFinalizers) => (self2) => contextWithEffect((context10) => match2(getOption2(context10, scopeTag), {
      onNone: /* @__PURE__ */ __name(() => self2(identity), "onNone"),
      onSome: /* @__PURE__ */ __name((scope5) => {
        if (concurrentFinalizers === true) {
          const patch9 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
          switch (scope5.strategy._tag) {
            case "Parallel":
              return patch9(self2(parallelFinalizers));
            case "Sequential":
              return patch9(self2(sequentialFinalizers));
            case "ParallelN":
              return patch9(self2(parallelNFinalizers(scope5.strategy.parallelism)));
          }
        } else {
          return self2(identity);
        }
      }, "onSome")
    })), "finalizersMaskInternal");
    scopeWith = /* @__PURE__ */ __name((f) => flatMap8(scopeTag, f), "scopeWith");
    scopedWith = /* @__PURE__ */ __name((f) => flatMap8(scopeMake(), (scope5) => onExit(f(scope5), (exit5) => scope5.close(exit5))), "scopedWith");
    scopedEffect = /* @__PURE__ */ __name((effect4) => flatMap8(scopeMake(), (scope5) => scopeUse(effect4, scope5)), "scopedEffect");
    sequentialFinalizers = /* @__PURE__ */ __name((self2) => contextWithEffect((context10) => match2(getOption2(context10, scopeTag), {
      onNone: /* @__PURE__ */ __name(() => self2, "onNone"),
      onSome: /* @__PURE__ */ __name((scope5) => {
        switch (scope5.strategy._tag) {
          case "Sequential":
            return self2;
          case "Parallel":
          case "ParallelN":
            return flatMap8(scopeFork(scope5, sequential3), (inner) => scopeExtend(self2, inner));
        }
      }, "onSome")
    })), "sequentialFinalizers");
    tagMetricsScoped = /* @__PURE__ */ __name((key, value3) => labelMetricsScoped([make30(key, value3)]), "tagMetricsScoped");
    labelMetricsScoped = /* @__PURE__ */ __name((labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union(old, labels)), "labelMetricsScoped");
    using = /* @__PURE__ */ dual(2, (self2, use) => scopedWith((scope5) => flatMap8(scopeExtend(self2, scope5), use)));
    validate = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => validateWith(self2, that, (a, b) => [a, b], options));
    validateWith = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f, options) => flatten7(zipWithOptions(exit2(self2), exit2(that), (ea, eb) => exitZipWith(ea, eb, {
      onSuccess: f,
      onFailure: /* @__PURE__ */ __name((ca, cb) => options?.concurrent ? parallel(ca, cb) : sequential(ca, cb), "onFailure")
    }), options)));
    validateFirst = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flip(forEach8(elements, (a, i) => flip(f(a, i)), options)));
    withClockScoped = /* @__PURE__ */ __name((c) => fiberRefLocallyScopedWith(currentServices, add2(clockTag, c)), "withClockScoped");
    withRandomScoped = /* @__PURE__ */ __name((value3) => fiberRefLocallyScopedWith(currentServices, add2(randomTag, value3)), "withRandomScoped");
    withConfigProviderScoped = /* @__PURE__ */ __name((provider) => fiberRefLocallyScopedWith(currentServices, add2(configProviderTag, provider)), "withConfigProviderScoped");
    withEarlyRelease = /* @__PURE__ */ __name((self2) => scopeWith((parent) => flatMap8(scopeFork(parent, sequential2), (child) => pipe(self2, scopeExtend(child), map11((value3) => [fiberIdWith((fiberId3) => scopeClose(child, exitInterrupt(fiberId3))), value3])))), "withEarlyRelease");
    zipOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => zipWithOptions(self2, that, (a, b) => [a, b], options));
    zipLeftOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => {
      if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) {
        return zipLeft2(self2, that);
      }
      return zipWithOptions(self2, that, (a, _) => a, options);
    });
    zipRightOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => {
      if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) {
        return zipRight2(self2, that);
      }
      return zipWithOptions(self2, that, (_, b) => b, options);
    });
    zipWithOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f, options) => map11(all5([self2, that], {
      concurrency: options?.concurrent ? 2 : 1,
      batching: options?.batching,
      concurrentFinalizers: options?.concurrentFinalizers
    }), ([a, a2]) => f(a, a2)));
    withRuntimeFlagsScoped = /* @__PURE__ */ __name((update6) => {
      if (update6 === empty15) {
        return void_2;
      }
      return pipe(runtimeFlags, flatMap8((runtimeFlags2) => {
        const updatedRuntimeFlags = patch4(runtimeFlags2, update6);
        const revertRuntimeFlags = diff4(updatedRuntimeFlags, runtimeFlags2);
        return pipe(updateRuntimeFlags(update6), zipRight2(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid2);
      }), uninterruptible);
    }, "withRuntimeFlagsScoped");
    scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
    scope = scopeTag;
    scopeUnsafeAddFinalizer = /* @__PURE__ */ __name((scope5, fin) => {
      if (scope5.state._tag === "Open") {
        scope5.state.finalizers.set({}, fin);
      }
    }, "scopeUnsafeAddFinalizer");
    ScopeImplProto = {
      [ScopeTypeId]: ScopeTypeId,
      [CloseableScopeTypeId]: CloseableScopeTypeId,
      pipe() {
        return pipeArguments(this, arguments);
      },
      fork(strategy) {
        return sync(() => {
          const newScope = scopeUnsafeMake(strategy);
          if (this.state._tag === "Closed") {
            newScope.state = this.state;
            return newScope;
          }
          const key = {};
          const fin = /* @__PURE__ */ __name((exit5) => newScope.close(exit5), "fin");
          this.state.finalizers.set(key, fin);
          scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
            if (this.state._tag === "Open") {
              this.state.finalizers.delete(key);
            }
          }));
          return newScope;
        });
      },
      close(exit5) {
        return suspend(() => {
          if (this.state._tag === "Closed") {
            return void_2;
          }
          const finalizers = Array.from(this.state.finalizers.values()).reverse();
          this.state = {
            _tag: "Closed",
            exit: exit5
          };
          if (finalizers.length === 0) {
            return void_2;
          }
          return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit2(fin(exit5))), flatMap8((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit2(fin(exit5)), false), flatMap8((results) => pipe(exitCollectAll(results, {
            parallel: true
          }), map2(exitAsVoid), getOrElse(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit2(fin(exit5)), false), flatMap8((results) => pipe(exitCollectAll(results, {
            parallel: true
          }), map2(exitAsVoid), getOrElse(() => exitVoid))));
        });
      },
      addFinalizer(fin) {
        return suspend(() => {
          if (this.state._tag === "Closed") {
            return fin(this.state.exit);
          }
          this.state.finalizers.set({}, fin);
          return void_2;
        });
      }
    };
    scopeUnsafeMake = /* @__PURE__ */ __name((strategy = sequential2) => {
      const scope5 = Object.create(ScopeImplProto);
      scope5.strategy = strategy;
      scope5.state = {
        _tag: "Open",
        finalizers: /* @__PURE__ */ new Map()
      };
      return scope5;
    }, "scopeUnsafeMake");
    scopeMake = /* @__PURE__ */ __name((strategy = sequential2) => sync(() => scopeUnsafeMake(strategy)), "scopeMake");
    scopeExtend = /* @__PURE__ */ dual(2, (effect4, scope5) => mapInputContext(
      effect4,
      // @ts-expect-error
      merge3(make6(scopeTag, scope5))
    ));
    scopeUse = /* @__PURE__ */ dual(2, (effect4, scope5) => pipe(effect4, scopeExtend(scope5), onExit((exit5) => scope5.close(exit5))));
    fiberRefUnsafeMakeSupervisor = /* @__PURE__ */ __name((initial) => fiberRefUnsafeMakePatch(initial, {
      differ: differ2,
      fork: empty27
    }), "fiberRefUnsafeMakeSupervisor");
    fiberRefLocallyScoped = /* @__PURE__ */ dual(2, (self2, value3) => asVoid2(acquireRelease(flatMap8(fiberRefGet(self2), (oldValue) => as2(fiberRefSet(self2, value3), oldValue)), (oldValue) => fiberRefSet(self2, oldValue))));
    fiberRefLocallyScopedWith = /* @__PURE__ */ dual(2, (self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocallyScoped(self2, f(a))));
    currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
    currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none8);
    fiberAwaitAll = /* @__PURE__ */ __name((fibers2) => forEach8(fibers2, _await2), "fiberAwaitAll");
    fiberAll = /* @__PURE__ */ __name((fibers2) => {
      const _fiberAll = {
        ...CommitPrototype2,
        commit() {
          return join2(this);
        },
        [FiberTypeId]: fiberVariance2,
        id: /* @__PURE__ */ __name(() => fromIterable2(fibers2).reduce((id2, fiber) => combine3(id2, fiber.id()), none4), "id"),
        await: exit2(forEachParUnbounded(fibers2, (fiber) => flatten7(fiber.await), false)),
        children: map11(forEachParUnbounded(fibers2, (fiber) => fiber.children, false), flatten2),
        inheritAll: forEachSequentialDiscard(fibers2, (fiber) => fiber.inheritAll),
        poll: map11(forEachSequential(fibers2, (fiber) => fiber.poll), reduceRight(some2(exitSucceed(new Array())), (optionB, optionA) => {
          switch (optionA._tag) {
            case "None": {
              return none2();
            }
            case "Some": {
              switch (optionB._tag) {
                case "None": {
                  return none2();
                }
                case "Some": {
                  return some2(exitZipWith(optionA.value, optionB.value, {
                    onSuccess: /* @__PURE__ */ __name((a, chunk4) => [a, ...chunk4], "onSuccess"),
                    onFailure: parallel
                  }));
                }
              }
            }
          }
        })),
        interruptAsFork: /* @__PURE__ */ __name((fiberId3) => forEachSequentialDiscard(fibers2, (fiber) => fiber.interruptAsFork(fiberId3)), "interruptAsFork")
      };
      return _fiberAll;
    }, "fiberAll");
    raceWith = /* @__PURE__ */ dual(3, (self2, other, options) => raceFibersWith(self2, other, {
      onSelfWin: /* @__PURE__ */ __name((winner, loser) => flatMap8(winner.await, (exit5) => {
        switch (exit5._tag) {
          case OP_SUCCESS: {
            return flatMap8(winner.inheritAll, () => options.onSelfDone(exit5, loser));
          }
          case OP_FAILURE: {
            return options.onSelfDone(exit5, loser);
          }
        }
      }), "onSelfWin"),
      onOtherWin: /* @__PURE__ */ __name((winner, loser) => flatMap8(winner.await, (exit5) => {
        switch (exit5._tag) {
          case OP_SUCCESS: {
            return flatMap8(winner.inheritAll, () => options.onOtherDone(exit5, loser));
          }
          case OP_FAILURE: {
            return options.onOtherDone(exit5, loser);
          }
        }
      }), "onOtherWin")
    }));
    disconnect2 = /* @__PURE__ */ __name((self2) => uninterruptibleMask((restore) => fiberIdWith((fiberId3) => flatMap8(forkDaemon(restore(self2)), (fiber) => pipe(restore(join2(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId3))))))), "disconnect");
    race = /* @__PURE__ */ dual(2, (self2, that) => fiberIdWith((parentFiberId) => raceWith(self2, that, {
      onSelfDone: /* @__PURE__ */ __name((exit5, right3) => exitMatchEffect(exit5, {
        onFailure: /* @__PURE__ */ __name((cause3) => pipe(join2(right3), mapErrorCause((cause22) => parallel(cause3, cause22))), "onFailure"),
        onSuccess: /* @__PURE__ */ __name((value3) => pipe(right3, interruptAsFiber(parentFiberId), as2(value3)), "onSuccess")
      }), "onSelfDone"),
      onOtherDone: /* @__PURE__ */ __name((exit5, left3) => exitMatchEffect(exit5, {
        onFailure: /* @__PURE__ */ __name((cause3) => pipe(join2(left3), mapErrorCause((cause22) => parallel(cause22, cause3))), "onFailure"),
        onSuccess: /* @__PURE__ */ __name((value3) => pipe(left3, interruptAsFiber(parentFiberId), as2(value3)), "onSuccess")
      }), "onOtherDone")
    })));
    raceFibersWith = /* @__PURE__ */ dual(3, (self2, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const raceIndicator = make12(true);
      const leftFiber = unsafeMakeChildFiber(self2, parentFiber, parentRuntimeFlags, options.selfScope);
      const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
      return async_((cb) => {
        leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
        rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
        leftFiber.startFork(self2);
        rightFiber.startFork(other);
      }, combine3(leftFiber.id(), rightFiber.id()));
    }));
    completeRace = /* @__PURE__ */ __name((winner, loser, cont, ab, cb) => {
      if (compareAndSet(true, false)(ab)) {
        cb(cont(winner, loser));
      }
    }, "completeRace");
    ensuring = /* @__PURE__ */ dual(2, (self2, finalizer3) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
      onFailure: /* @__PURE__ */ __name((cause1) => matchCauseEffect(finalizer3, {
        onFailure: /* @__PURE__ */ __name((cause22) => failCause(sequential(cause1, cause22)), "onFailure"),
        onSuccess: /* @__PURE__ */ __name(() => failCause(cause1), "onSuccess")
      }), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((a) => as2(finalizer3, a), "onSuccess")
    })));
    invokeWithInterrupt = /* @__PURE__ */ __name((self2, entries2, onInterrupt3) => fiberIdWith((id2) => flatMap8(flatMap8(forkDaemon(interruptible2(self2)), (processing) => async_((cb) => {
      const counts = entries2.map((_) => _.listeners.count);
      const checkDone = /* @__PURE__ */ __name(() => {
        if (counts.every((count6) => count6 === 0)) {
          if (entries2.every((_) => {
            if (_.result.state.current._tag === "Pending") {
              return true;
            } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
              return true;
            } else {
              return false;
            }
          })) {
            cleanup.forEach((f) => f());
            onInterrupt3?.();
            cb(interruptFiber(processing));
          }
        }
      }, "checkDone");
      processing.addObserver((exit5) => {
        cleanup.forEach((f) => f());
        cb(exit5);
      });
      const cleanup = entries2.map((r, i) => {
        const observer = /* @__PURE__ */ __name((count6) => {
          counts[i] = count6;
          checkDone();
        }, "observer");
        r.listeners.addObserver(observer);
        return () => r.listeners.removeObserver(observer);
      });
      checkDone();
      return sync(() => {
        cleanup.forEach((f) => f());
      });
    })), () => suspend(() => {
      const residual = entries2.flatMap((entry) => {
        if (!entry.state.completed) {
          return [entry];
        }
        return [];
      });
      return forEachSequentialDiscard(residual, (entry) => complete(entry.request, exitInterrupt(id2)));
    }))), "invokeWithInterrupt");
    makeSpanScoped = /* @__PURE__ */ __name((name, options) => {
      options = addSpanStackTrace(options);
      return uninterruptible(withFiberRuntime((fiber) => {
        const scope5 = unsafeGet3(fiber.getFiberRef(currentContext), scopeTag);
        const span4 = unsafeMakeSpan(fiber, name, options);
        const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
        const clock_ = get3(fiber.getFiberRef(currentServices), clockTag);
        return as2(scopeAddFinalizerExit(scope5, (exit5) => endSpan(span4, exit5, clock_, timingEnabled)), span4);
      }));
    }, "makeSpanScoped");
    withTracerScoped = /* @__PURE__ */ __name((value3) => fiberRefLocallyScopedWith(currentServices, add2(tracerTag, value3)), "withTracerScoped");
    withSpanScoped = /* @__PURE__ */ __name(function() {
      const dataFirst = typeof arguments[0] !== "string";
      const name = dataFirst ? arguments[1] : arguments[0];
      const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
      if (dataFirst) {
        const self2 = arguments[0];
        return flatMap8(makeSpanScoped(name, addSpanStackTrace(options)), (span4) => provideService(self2, spanTag, span4));
      }
      return (self2) => flatMap8(makeSpanScoped(name, addSpanStackTrace(options)), (span4) => provideService(self2, spanTag, span4));
    }, "withSpanScoped");
  }
});

// node_modules/effect/dist/esm/internal/cache.js
var complete2, pending2, refreshing, MapKeyTypeId, MapKeyImpl, makeMapKey, isMapKey, KeySetImpl, makeKeySet, makeCacheState, initialCacheState, CacheSymbolKey, CacheTypeId, cacheVariance, ConsumerCacheSymbolKey, ConsumerCacheTypeId, consumerCacheVariance, makeCacheStats, makeEntryStats, CacheImpl, unsafeMakeWith;
var init_cache = __esm({
  "node_modules/effect/dist/esm/internal/cache.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Context();
    init_Deferred();
    init_Duration();
    init_Either();
    init_Equal();
    init_Exit();
    init_Function();
    init_Hash();
    init_MutableHashMap();
    init_MutableQueue();
    init_MutableRef();
    init_Option();
    init_Predicate();
    init_core_effect();
    init_core();
    init_data();
    init_fiberId();
    complete2 = /* @__PURE__ */ __name((key, exit5, entryStats, timeToLiveMillis) => struct({
      _tag: "Complete",
      key,
      exit: exit5,
      entryStats,
      timeToLiveMillis
    }), "complete");
    pending2 = /* @__PURE__ */ __name((key, deferred) => struct({
      _tag: "Pending",
      key,
      deferred
    }), "pending");
    refreshing = /* @__PURE__ */ __name((deferred, complete3) => struct({
      _tag: "Refreshing",
      deferred,
      complete: complete3
    }), "refreshing");
    MapKeyTypeId = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");
    MapKeyImpl = class {
      static {
        __name(this, "MapKeyImpl");
      }
      current;
      [MapKeyTypeId] = MapKeyTypeId;
      previous = void 0;
      next = void 0;
      constructor(current2) {
        this.current = current2;
      }
      [symbol]() {
        return pipe(hash(this.current), combine(hash(this.previous)), combine(hash(this.next)), cached(this));
      }
      [symbol2](that) {
        if (this === that) {
          return true;
        }
        return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
      }
    };
    makeMapKey = /* @__PURE__ */ __name((current2) => new MapKeyImpl(current2), "makeMapKey");
    isMapKey = /* @__PURE__ */ __name((u) => hasProperty(u, MapKeyTypeId), "isMapKey");
    KeySetImpl = class {
      static {
        __name(this, "KeySetImpl");
      }
      head = void 0;
      tail = void 0;
      add(key) {
        if (key !== this.tail) {
          if (this.tail === void 0) {
            this.head = key;
            this.tail = key;
          } else {
            const previous2 = key.previous;
            const next4 = key.next;
            if (next4 !== void 0) {
              key.next = void 0;
              if (previous2 !== void 0) {
                previous2.next = next4;
                next4.previous = previous2;
              } else {
                this.head = next4;
                this.head.previous = void 0;
              }
            }
            this.tail.next = key;
            key.previous = this.tail;
            this.tail = key;
          }
        }
      }
      remove() {
        const key = this.head;
        if (key !== void 0) {
          const next4 = key.next;
          if (next4 !== void 0) {
            key.next = void 0;
            this.head = next4;
            this.head.previous = void 0;
          } else {
            this.head = void 0;
            this.tail = void 0;
          }
        }
        return key;
      }
    };
    makeKeySet = /* @__PURE__ */ __name(() => new KeySetImpl(), "makeKeySet");
    makeCacheState = /* @__PURE__ */ __name((map31, keys5, accesses, updating, hits, misses) => ({
      map: map31,
      keys: keys5,
      accesses,
      updating,
      hits,
      misses
    }), "makeCacheState");
    initialCacheState = /* @__PURE__ */ __name(() => makeCacheState(empty18(), makeKeySet(), unbounded(), make12(false), 0, 0), "initialCacheState");
    CacheSymbolKey = "effect/Cache";
    CacheTypeId = /* @__PURE__ */ Symbol.for(CacheSymbolKey);
    cacheVariance = {
      /* c8 ignore next */
      _Key: /* @__PURE__ */ __name((_) => _, "_Key"),
      /* c8 ignore next */
      _Error: /* @__PURE__ */ __name((_) => _, "_Error"),
      /* c8 ignore next */
      _Value: /* @__PURE__ */ __name((_) => _, "_Value")
    };
    ConsumerCacheSymbolKey = "effect/ConsumerCache";
    ConsumerCacheTypeId = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey);
    consumerCacheVariance = {
      /* c8 ignore next */
      _Key: /* @__PURE__ */ __name((_) => _, "_Key"),
      /* c8 ignore next */
      _Error: /* @__PURE__ */ __name((_) => _, "_Error"),
      /* c8 ignore next */
      _Value: /* @__PURE__ */ __name((_) => _, "_Value")
    };
    makeCacheStats = /* @__PURE__ */ __name((options) => options, "makeCacheStats");
    makeEntryStats = /* @__PURE__ */ __name((loadedMillis) => ({
      loadedMillis
    }), "makeEntryStats");
    CacheImpl = class {
      static {
        __name(this, "CacheImpl");
      }
      capacity;
      context;
      fiberId;
      lookup;
      timeToLive;
      [CacheTypeId] = cacheVariance;
      [ConsumerCacheTypeId] = consumerCacheVariance;
      cacheState;
      constructor(capacity7, context10, fiberId3, lookup, timeToLive) {
        this.capacity = capacity7;
        this.context = context10;
        this.fiberId = fiberId3;
        this.lookup = lookup;
        this.timeToLive = timeToLive;
        this.cacheState = initialCacheState();
      }
      get(key) {
        return map11(this.getEither(key), merge);
      }
      get cacheStats() {
        return sync(() => makeCacheStats({
          hits: this.cacheState.hits,
          misses: this.cacheState.misses,
          size: size4(this.cacheState.map)
        }));
      }
      getOption(key) {
        return suspend(() => match2(get8(this.cacheState.map, key), {
          onNone: /* @__PURE__ */ __name(() => {
            const mapKey = makeMapKey(key);
            this.trackAccess(mapKey);
            this.trackMiss();
            return succeed(none2());
          }, "onNone"),
          onSome: /* @__PURE__ */ __name((value3) => this.resolveMapValue(value3), "onSome")
        }));
      }
      getOptionComplete(key) {
        return suspend(() => match2(get8(this.cacheState.map, key), {
          onNone: /* @__PURE__ */ __name(() => {
            const mapKey = makeMapKey(key);
            this.trackAccess(mapKey);
            this.trackMiss();
            return succeed(none2());
          }, "onNone"),
          onSome: /* @__PURE__ */ __name((value3) => this.resolveMapValue(value3, true), "onSome")
        }));
      }
      contains(key) {
        return sync(() => has5(this.cacheState.map, key));
      }
      entryStats(key) {
        return sync(() => {
          const option5 = get8(this.cacheState.map, key);
          if (isSome2(option5)) {
            switch (option5.value._tag) {
              case "Complete": {
                const loaded = option5.value.entryStats.loadedMillis;
                return some2(makeEntryStats(loaded));
              }
              case "Pending": {
                return none2();
              }
              case "Refreshing": {
                const loaded = option5.value.complete.entryStats.loadedMillis;
                return some2(makeEntryStats(loaded));
              }
            }
          }
          return none2();
        });
      }
      getEither(key) {
        return suspend(() => {
          const k = key;
          let mapKey = void 0;
          let deferred = void 0;
          let value3 = getOrUndefined(get8(this.cacheState.map, k));
          if (value3 === void 0) {
            deferred = unsafeMake4(this.fiberId);
            mapKey = makeMapKey(k);
            if (has5(this.cacheState.map, k)) {
              value3 = getOrUndefined(get8(this.cacheState.map, k));
            } else {
              set4(this.cacheState.map, k, pending2(mapKey, deferred));
            }
          }
          if (value3 === void 0) {
            this.trackAccess(mapKey);
            this.trackMiss();
            return map11(this.lookupValueOf(key, deferred), right2);
          } else {
            return flatMap8(this.resolveMapValue(value3), match2({
              onNone: /* @__PURE__ */ __name(() => this.getEither(key), "onNone"),
              onSome: /* @__PURE__ */ __name((value4) => succeed(left2(value4)), "onSome")
            }));
          }
        });
      }
      invalidate(key) {
        return sync(() => {
          remove5(this.cacheState.map, key);
        });
      }
      invalidateWhen(key, when5) {
        return sync(() => {
          const value3 = get8(this.cacheState.map, key);
          if (isSome2(value3) && value3.value._tag === "Complete") {
            if (value3.value.exit._tag === "Success") {
              if (when5(value3.value.exit.value)) {
                remove5(this.cacheState.map, key);
              }
            }
          }
        });
      }
      get invalidateAll() {
        return sync(() => {
          this.cacheState.map = empty18();
        });
      }
      refresh(key) {
        return clockWith3((clock3) => suspend(() => {
          const k = key;
          const deferred = unsafeMake4(this.fiberId);
          let value3 = getOrUndefined(get8(this.cacheState.map, k));
          if (value3 === void 0) {
            if (has5(this.cacheState.map, k)) {
              value3 = getOrUndefined(get8(this.cacheState.map, k));
            } else {
              set4(this.cacheState.map, k, pending2(makeMapKey(k), deferred));
            }
          }
          if (value3 === void 0) {
            return asVoid2(this.lookupValueOf(key, deferred));
          } else {
            switch (value3._tag) {
              case "Complete": {
                if (this.hasExpired(clock3, value3.timeToLiveMillis)) {
                  const found = getOrUndefined(get8(this.cacheState.map, k));
                  if (equals(found, value3)) {
                    remove5(this.cacheState.map, k);
                  }
                  return asVoid2(this.get(key));
                }
                return pipe(this.lookupValueOf(key, deferred), when(() => {
                  const current2 = getOrUndefined(get8(this.cacheState.map, k));
                  if (equals(current2, value3)) {
                    const mapValue = refreshing(deferred, value3);
                    set4(this.cacheState.map, k, mapValue);
                    return true;
                  }
                  return false;
                }), asVoid2);
              }
              case "Pending": {
                return _await(value3.deferred);
              }
              case "Refreshing": {
                return _await(value3.deferred);
              }
            }
          }
        }));
      }
      set(key, value3) {
        return clockWith3((clock3) => sync(() => {
          const now2 = clock3.unsafeCurrentTimeMillis();
          const k = key;
          const lookupResult = succeed3(value3);
          const mapValue = complete2(makeMapKey(k), lookupResult, makeEntryStats(now2), now2 + toMillis(decode(this.timeToLive(lookupResult))));
          set4(this.cacheState.map, k, mapValue);
        }));
      }
      get size() {
        return sync(() => {
          return size4(this.cacheState.map);
        });
      }
      get values() {
        return sync(() => {
          const values4 = [];
          for (const entry of this.cacheState.map) {
            if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
              values4.push(entry[1].exit.value);
            }
          }
          return values4;
        });
      }
      get entries() {
        return sync(() => {
          const values4 = [];
          for (const entry of this.cacheState.map) {
            if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
              values4.push([entry[0], entry[1].exit.value]);
            }
          }
          return values4;
        });
      }
      get keys() {
        return sync(() => {
          const keys5 = [];
          for (const entry of this.cacheState.map) {
            if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
              keys5.push(entry[0]);
            }
          }
          return keys5;
        });
      }
      resolveMapValue(value3, ignorePending = false) {
        return clockWith3((clock3) => {
          switch (value3._tag) {
            case "Complete": {
              this.trackAccess(value3.key);
              if (this.hasExpired(clock3, value3.timeToLiveMillis)) {
                remove5(this.cacheState.map, value3.key.current);
                return succeed(none2());
              }
              this.trackHit();
              return map11(value3.exit, some2);
            }
            case "Pending": {
              this.trackAccess(value3.key);
              this.trackHit();
              if (ignorePending) {
                return succeed(none2());
              }
              return map11(_await(value3.deferred), some2);
            }
            case "Refreshing": {
              this.trackAccess(value3.complete.key);
              this.trackHit();
              if (this.hasExpired(clock3, value3.complete.timeToLiveMillis)) {
                if (ignorePending) {
                  return succeed(none2());
                }
                return map11(_await(value3.deferred), some2);
              }
              return map11(value3.complete.exit, some2);
            }
          }
        });
      }
      trackHit() {
        this.cacheState.hits = this.cacheState.hits + 1;
      }
      trackMiss() {
        this.cacheState.misses = this.cacheState.misses + 1;
      }
      trackAccess(key) {
        offer(this.cacheState.accesses, key);
        if (compareAndSet(this.cacheState.updating, false, true)) {
          let loop3 = true;
          while (loop3) {
            const key2 = poll2(this.cacheState.accesses, EmptyMutableQueue);
            if (key2 === EmptyMutableQueue) {
              loop3 = false;
            } else {
              this.cacheState.keys.add(key2);
            }
          }
          let size15 = size4(this.cacheState.map);
          loop3 = size15 > this.capacity;
          while (loop3) {
            const key2 = this.cacheState.keys.remove();
            if (key2 !== void 0) {
              if (has5(this.cacheState.map, key2.current)) {
                remove5(this.cacheState.map, key2.current);
                size15 = size15 - 1;
                loop3 = size15 > this.capacity;
              }
            } else {
              loop3 = false;
            }
          }
          set2(this.cacheState.updating, false);
        }
      }
      hasExpired(clock3, timeToLiveMillis) {
        return clock3.unsafeCurrentTimeMillis() > timeToLiveMillis;
      }
      lookupValueOf(input, deferred) {
        return clockWith3((clock3) => suspend(() => {
          const key = input;
          return pipe(this.lookup(input), provideContext(this.context), exit2, flatMap8((exit5) => {
            const now2 = clock3.unsafeCurrentTimeMillis();
            const stats = makeEntryStats(now2);
            const value3 = complete2(makeMapKey(key), exit5, stats, now2 + toMillis(decode(this.timeToLive(exit5))));
            set4(this.cacheState.map, key, value3);
            return zipRight2(done2(deferred, exit5), exit5);
          }), onInterrupt(() => zipRight2(interrupt3(deferred), sync(() => {
            remove5(this.cacheState.map, key);
          }))));
        }));
      }
    };
    unsafeMakeWith = /* @__PURE__ */ __name((capacity7, lookup, timeToLive) => new CacheImpl(capacity7, empty4(), none3, lookup, (exit5) => decode(timeToLive(exit5))), "unsafeMakeWith");
  }
});

// node_modules/effect/dist/esm/Cache.js
var init_Cache = __esm({
  "node_modules/effect/dist/esm/Cache.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Cause.js
var empty28, fail5, die4, interrupt5, parallel4, sequential4, isCause2, isFailType2, isDieType2, isInterrupted2, isInterruptedOnly2, interruptors2, failureOrCause2, flipCauseOption2, map14, squash, IllegalArgumentException2, NoSuchElementException2, RuntimeException2, isRuntimeException2, pretty2;
var init_Cause = __esm({
  "node_modules/effect/dist/esm/Cause.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_cause2();
    init_core();
    empty28 = empty17;
    fail5 = fail;
    die4 = die;
    interrupt5 = interrupt;
    parallel4 = parallel;
    sequential4 = sequential;
    isCause2 = isCause;
    isFailType2 = isFailType;
    isDieType2 = isDieType;
    isInterrupted2 = isInterrupted;
    isInterruptedOnly2 = isInterruptedOnly;
    interruptors2 = interruptors;
    failureOrCause2 = failureOrCause;
    flipCauseOption2 = flipCauseOption;
    map14 = map10;
    squash = causeSquash;
    IllegalArgumentException2 = IllegalArgumentException;
    NoSuchElementException2 = NoSuchElementException;
    RuntimeException2 = RuntimeException;
    isRuntimeException2 = isRuntimeException;
    pretty2 = pretty;
  }
});

// node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey, IntervalTypeId, empty29, make36, lessThan4, min2, isEmpty8, intersect, size8, after;
var init_interval = __esm({
  "node_modules/effect/dist/esm/internal/schedule/interval.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Duration();
    init_Function();
    IntervalSymbolKey = "effect/ScheduleInterval";
    IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
    empty29 = {
      [IntervalTypeId]: IntervalTypeId,
      startMillis: 0,
      endMillis: 0
    };
    make36 = /* @__PURE__ */ __name((startMillis, endMillis) => {
      if (startMillis > endMillis) {
        return empty29;
      }
      return {
        [IntervalTypeId]: IntervalTypeId,
        startMillis,
        endMillis
      };
    }, "make");
    lessThan4 = /* @__PURE__ */ dual(2, (self2, that) => min2(self2, that) === self2);
    min2 = /* @__PURE__ */ dual(2, (self2, that) => {
      if (self2.endMillis <= that.startMillis) return self2;
      if (that.endMillis <= self2.startMillis) return that;
      if (self2.startMillis < that.startMillis) return self2;
      if (that.startMillis < self2.startMillis) return that;
      if (self2.endMillis <= that.endMillis) return self2;
      return that;
    });
    isEmpty8 = /* @__PURE__ */ __name((self2) => {
      return self2.startMillis >= self2.endMillis;
    }, "isEmpty");
    intersect = /* @__PURE__ */ dual(2, (self2, that) => {
      const start5 = Math.max(self2.startMillis, that.startMillis);
      const end6 = Math.min(self2.endMillis, that.endMillis);
      return make36(start5, end6);
    });
    size8 = /* @__PURE__ */ __name((self2) => {
      return millis(self2.endMillis - self2.startMillis);
    }, "size");
    after = /* @__PURE__ */ __name((startMilliseconds) => {
      return make36(startMilliseconds, Number.POSITIVE_INFINITY);
    }, "after");
  }
});

// node_modules/effect/dist/esm/ScheduleInterval.js
var make37, empty30, lessThan5, isEmpty9, intersect2, size9, after2;
var init_ScheduleInterval = __esm({
  "node_modules/effect/dist/esm/ScheduleInterval.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_interval();
    make37 = make36;
    empty30 = empty29;
    lessThan5 = lessThan4;
    isEmpty9 = isEmpty8;
    intersect2 = intersect;
    size9 = size8;
    after2 = after;
  }
});

// node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey, IntervalsTypeId, make38, union7, unionLoop, intersect3, intersectLoop, start, end, lessThan6, isNonEmpty4, max3;
var init_intervals = __esm({
  "node_modules/effect/dist/esm/internal/schedule/intervals.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Chunk();
    init_Function();
    init_Option();
    init_ScheduleInterval();
    init_errors();
    IntervalsSymbolKey = "effect/ScheduleIntervals";
    IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
    make38 = /* @__PURE__ */ __name((intervals) => {
      return {
        [IntervalsTypeId]: IntervalsTypeId,
        intervals
      };
    }, "make");
    union7 = /* @__PURE__ */ dual(2, (self2, that) => {
      if (!isNonEmpty2(that.intervals)) {
        return self2;
      }
      if (!isNonEmpty2(self2.intervals)) {
        return that;
      }
      if (headNonEmpty2(self2.intervals).startMillis < headNonEmpty2(that.intervals).startMillis) {
        return unionLoop(tailNonEmpty2(self2.intervals), that.intervals, headNonEmpty2(self2.intervals), empty5());
      }
      return unionLoop(self2.intervals, tailNonEmpty2(that.intervals), headNonEmpty2(that.intervals), empty5());
    });
    unionLoop = /* @__PURE__ */ __name((_self, _that, _interval, _acc) => {
      let self2 = _self;
      let that = _that;
      let interval = _interval;
      let acc = _acc;
      while (isNonEmpty2(self2) || isNonEmpty2(that)) {
        if (!isNonEmpty2(self2) && isNonEmpty2(that)) {
          if (interval.endMillis < headNonEmpty2(that).startMillis) {
            acc = pipe(acc, prepend2(interval));
            interval = headNonEmpty2(that);
            that = tailNonEmpty2(that);
            self2 = empty5();
          } else {
            interval = make37(interval.startMillis, headNonEmpty2(that).endMillis);
            that = tailNonEmpty2(that);
            self2 = empty5();
          }
        } else if (isNonEmpty2(self2) && isEmpty(that)) {
          if (interval.endMillis < headNonEmpty2(self2).startMillis) {
            acc = pipe(acc, prepend2(interval));
            interval = headNonEmpty2(self2);
            that = empty5();
            self2 = tailNonEmpty2(self2);
          } else {
            interval = make37(interval.startMillis, headNonEmpty2(self2).endMillis);
            that = empty5();
            self2 = tailNonEmpty2(self2);
          }
        } else if (isNonEmpty2(self2) && isNonEmpty2(that)) {
          if (headNonEmpty2(self2).startMillis < headNonEmpty2(that).startMillis) {
            if (interval.endMillis < headNonEmpty2(self2).startMillis) {
              acc = pipe(acc, prepend2(interval));
              interval = headNonEmpty2(self2);
              self2 = tailNonEmpty2(self2);
            } else {
              interval = make37(interval.startMillis, headNonEmpty2(self2).endMillis);
              self2 = tailNonEmpty2(self2);
            }
          } else if (interval.endMillis < headNonEmpty2(that).startMillis) {
            acc = pipe(acc, prepend2(interval));
            interval = headNonEmpty2(that);
            that = tailNonEmpty2(that);
          } else {
            interval = make37(interval.startMillis, headNonEmpty2(that).endMillis);
            that = tailNonEmpty2(that);
          }
        } else {
          throw new Error(getBugErrorMessage("Intervals.unionLoop"));
        }
      }
      return make38(pipe(acc, prepend2(interval), reverse2));
    }, "unionLoop");
    intersect3 = /* @__PURE__ */ dual(2, (self2, that) => intersectLoop(self2.intervals, that.intervals, empty5()));
    intersectLoop = /* @__PURE__ */ __name((_left, _right, _acc) => {
      let left3 = _left;
      let right3 = _right;
      let acc = _acc;
      while (isNonEmpty2(left3) && isNonEmpty2(right3)) {
        const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
        const intervals = isEmpty9(interval) ? acc : pipe(acc, prepend2(interval));
        if (pipe(headNonEmpty2(left3), lessThan5(headNonEmpty2(right3)))) {
          left3 = tailNonEmpty2(left3);
        } else {
          right3 = tailNonEmpty2(right3);
        }
        acc = intervals;
      }
      return make38(reverse2(acc));
    }, "intersectLoop");
    start = /* @__PURE__ */ __name((self2) => {
      return pipe(self2.intervals, head2, getOrElse(() => empty30)).startMillis;
    }, "start");
    end = /* @__PURE__ */ __name((self2) => {
      return pipe(self2.intervals, head2, getOrElse(() => empty30)).endMillis;
    }, "end");
    lessThan6 = /* @__PURE__ */ dual(2, (self2, that) => start(self2) < start(that));
    isNonEmpty4 = /* @__PURE__ */ __name((self2) => {
      return isNonEmpty2(self2.intervals);
    }, "isNonEmpty");
    max3 = /* @__PURE__ */ dual(2, (self2, that) => lessThan6(self2, that) ? that : self2);
  }
});

// node_modules/effect/dist/esm/ScheduleIntervals.js
var make39, union8, intersect4, start2, end2, lessThan7, isNonEmpty5, max4;
var init_ScheduleIntervals = __esm({
  "node_modules/effect/dist/esm/ScheduleIntervals.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_intervals();
    make39 = make38;
    union8 = union7;
    intersect4 = intersect3;
    start2 = start;
    end2 = end;
    lessThan7 = lessThan6;
    isNonEmpty5 = isNonEmpty4;
    max4 = max3;
  }
});

// node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE, OP_DONE2, _continue, continueWith, done5, isContinue, isDone4;
var init_decision = __esm({
  "node_modules/effect/dist/esm/internal/schedule/decision.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Chunk();
    init_ScheduleIntervals();
    OP_CONTINUE = "Continue";
    OP_DONE2 = "Done";
    _continue = /* @__PURE__ */ __name((intervals) => {
      return {
        _tag: OP_CONTINUE,
        intervals
      };
    }, "_continue");
    continueWith = /* @__PURE__ */ __name((interval) => {
      return {
        _tag: OP_CONTINUE,
        intervals: make39(of2(interval))
      };
    }, "continueWith");
    done5 = {
      _tag: OP_DONE2
    };
    isContinue = /* @__PURE__ */ __name((self2) => {
      return self2._tag === OP_CONTINUE;
    }, "isContinue");
    isDone4 = /* @__PURE__ */ __name((self2) => {
      return self2._tag === OP_DONE2;
    }, "isDone");
  }
});

// node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2, continueWith2, done6, isContinue2, isDone5;
var init_ScheduleDecision = __esm({
  "node_modules/effect/dist/esm/ScheduleDecision.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_decision();
    _continue2 = _continue;
    continueWith2 = continueWith;
    done6 = done5;
    isContinue2 = isContinue;
    isDone5 = isDone4;
  }
});

// node_modules/effect/dist/esm/Scope.js
var Scope, addFinalizer2, addFinalizerExit, close, extend2, fork2, make40;
var init_Scope = __esm({
  "node_modules/effect/dist/esm/Scope.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_core();
    init_fiberRuntime();
    Scope = scopeTag;
    addFinalizer2 = scopeAddFinalizer;
    addFinalizerExit = scopeAddFinalizerExit;
    close = scopeClose;
    extend2 = scopeExtend;
    fork2 = scopeFork;
    make40 = scopeMake;
  }
});

// node_modules/effect/dist/esm/internal/effect/circular.js
var Semaphore, unsafeMakeSemaphore, makeSemaphore, Latch, unsafeMakeLatch, makeLatch, awaitAllChildren, cached2, cachedInvalidateWithTTL, computeCachedValue, getCachedValue, invalidateCache, ensuringChild, ensuringChildren, forkAll, forkIn, forkScoped, fromFiber, fromFiberEffect, memoKeySymbol, Key, cachedFunction, raceFirst, supervised, timeout, timeoutFail, timeoutFailCause, timeoutOption, timeoutTo, SynchronizedSymbolKey, SynchronizedTypeId, synchronizedVariance, SynchronizedImpl, makeSynchronized, unsafeMakeSynchronized, updateSomeAndGetEffectSynchronized, bindAll;
var init_circular = __esm({
  "node_modules/effect/dist/esm/internal/effect/circular.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Duration();
    init_Effectable();
    init_Equal();
    init_Function();
    init_Hash();
    init_MutableHashMap();
    init_Option();
    init_Predicate();
    init_Readable();
    init_Scheduler();
    init_core_effect();
    init_core();
    init_fiber();
    init_fiberRuntime();
    init_fiberScope();
    init_ref();
    init_supervisor();
    Semaphore = class {
      static {
        __name(this, "Semaphore");
      }
      permits;
      waiters = /* @__PURE__ */ new Set();
      taken = 0;
      constructor(permits) {
        this.permits = permits;
      }
      get free() {
        return this.permits - this.taken;
      }
      take = /* @__PURE__ */ __name((n) => asyncInterrupt((resume2) => {
        if (this.free < n) {
          const observer = /* @__PURE__ */ __name(() => {
            if (this.free < n) {
              return;
            }
            this.waiters.delete(observer);
            this.taken += n;
            resume2(succeed(n));
          }, "observer");
          this.waiters.add(observer);
          return sync(() => {
            this.waiters.delete(observer);
          });
        }
        this.taken += n;
        return resume2(succeed(n));
      }), "take");
      updateTakenUnsafe(fiber, f) {
        this.taken = f(this.taken);
        if (this.waiters.size > 0) {
          fiber.getFiberRef(currentScheduler).scheduleTask(() => {
            const iter = this.waiters.values();
            let item = iter.next();
            while (item.done === false && this.free > 0) {
              item.value();
              item = iter.next();
            }
          }, fiber.getFiberRef(currentSchedulingPriority));
        }
        return succeed(this.free);
      }
      updateTaken(f) {
        return withFiberRuntime((fiber) => this.updateTakenUnsafe(fiber, f));
      }
      resize = /* @__PURE__ */ __name((permits) => asVoid2(withFiberRuntime((fiber) => {
        this.permits = permits;
        if (this.free < 0) {
          return void_2;
        }
        return this.updateTakenUnsafe(fiber, (taken) => taken);
      })), "resize");
      release = /* @__PURE__ */ __name((n) => this.updateTaken((taken) => taken - n), "release");
      releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
      withPermits = /* @__PURE__ */ __name((n) => (self2) => uninterruptibleMask((restore) => flatMap8(restore(this.take(n)), (permits) => ensuring(restore(self2), this.release(permits)))), "withPermits");
      withPermitsIfAvailable = /* @__PURE__ */ __name((n) => (self2) => uninterruptibleMask((restore) => suspend(() => {
        if (this.free < n) {
          return succeedNone;
        }
        this.taken += n;
        return ensuring(restore(asSome(self2)), this.release(n));
      })), "withPermitsIfAvailable");
    };
    unsafeMakeSemaphore = /* @__PURE__ */ __name((permits) => new Semaphore(permits), "unsafeMakeSemaphore");
    makeSemaphore = /* @__PURE__ */ __name((permits) => sync(() => unsafeMakeSemaphore(permits)), "makeSemaphore");
    Latch = class extends Class2 {
      static {
        __name(this, "Latch");
      }
      isOpen;
      waiters = [];
      scheduled = false;
      constructor(isOpen) {
        super();
        this.isOpen = isOpen;
      }
      commit() {
        return this.await;
      }
      unsafeSchedule(fiber) {
        if (this.scheduled || this.waiters.length === 0) {
          return void_2;
        }
        this.scheduled = true;
        fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
        return void_2;
      }
      flushWaiters = /* @__PURE__ */ __name(() => {
        this.scheduled = false;
        const waiters = this.waiters;
        this.waiters = [];
        for (let i = 0; i < waiters.length; i++) {
          waiters[i](exitVoid);
        }
      }, "flushWaiters");
      open = /* @__PURE__ */ withFiberRuntime((fiber) => {
        if (this.isOpen) {
          return void_2;
        }
        this.isOpen = true;
        return this.unsafeSchedule(fiber);
      });
      unsafeOpen() {
        if (this.isOpen) return;
        this.isOpen = true;
        this.flushWaiters();
      }
      release = /* @__PURE__ */ withFiberRuntime((fiber) => {
        if (this.isOpen) {
          return void_2;
        }
        return this.unsafeSchedule(fiber);
      });
      await = /* @__PURE__ */ asyncInterrupt((resume2) => {
        if (this.isOpen) {
          return resume2(void_2);
        }
        this.waiters.push(resume2);
        return sync(() => {
          const index2 = this.waiters.indexOf(resume2);
          if (index2 !== -1) {
            this.waiters.splice(index2, 1);
          }
        });
      });
      unsafeClose() {
        this.isOpen = false;
      }
      close = /* @__PURE__ */ sync(() => {
        this.isOpen = false;
      });
      whenOpen = /* @__PURE__ */ __name((self2) => {
        return zipRight2(this.await, self2);
      }, "whenOpen");
    };
    unsafeMakeLatch = /* @__PURE__ */ __name((open) => new Latch(open ?? false), "unsafeMakeLatch");
    makeLatch = /* @__PURE__ */ __name((open) => sync(() => unsafeMakeLatch(open)), "makeLatch");
    awaitAllChildren = /* @__PURE__ */ __name((self2) => ensuringChildren(self2, fiberAwaitAll), "awaitAllChildren");
    cached2 = /* @__PURE__ */ dual(2, (self2, timeToLive) => map11(cachedInvalidateWithTTL(self2, timeToLive), (tuple4) => tuple4[0]));
    cachedInvalidateWithTTL = /* @__PURE__ */ dual(2, (self2, timeToLive) => {
      const duration6 = decode(timeToLive);
      return flatMap8(context3(), (env2) => map11(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self2, duration6, cache), env2), invalidateCache(cache)]));
    });
    computeCachedValue = /* @__PURE__ */ __name((self2, timeToLive, start5) => {
      const timeToLiveMillis = toMillis(decode(timeToLive));
      return pipe(deferredMake(), tap2((deferred) => intoDeferred(self2, deferred)), map11((deferred) => some2([start5 + timeToLiveMillis, deferred])));
    }, "computeCachedValue");
    getCachedValue = /* @__PURE__ */ __name((self2, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock3) => clock3.currentTimeMillis), flatMap8((time5) => updateSomeAndGetEffectSynchronized(cache, (option5) => {
      switch (option5._tag) {
        case "None": {
          return some2(computeCachedValue(self2, timeToLive, time5));
        }
        case "Some": {
          const [end6] = option5.value;
          return end6 - time5 <= 0 ? some2(computeCachedValue(self2, timeToLive, time5)) : none2();
        }
      }
    })), flatMap8((option5) => isNone2(option5) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option5.value[1]))))), "getCachedValue");
    invalidateCache = /* @__PURE__ */ __name((cache) => set5(cache, none2()), "invalidateCache");
    ensuringChild = /* @__PURE__ */ dual(2, (self2, f) => ensuringChildren(self2, (children2) => f(fiberAll(children2))));
    ensuringChildren = /* @__PURE__ */ dual(2, (self2, children2) => flatMap8(track, (supervisor) => pipe(supervised(self2, supervisor), ensuring(flatMap8(supervisor.value, children2)))));
    forkAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork) : map11(forEachSequential(effects, fork), fiberAll));
    forkIn = /* @__PURE__ */ dual(2, (self2, scope5) => withFiberRuntime((parent, parentStatus) => {
      const scopeImpl = scope5;
      const fiber = unsafeFork2(self2, parent, parentStatus.runtimeFlags, globalScope);
      if (scopeImpl.state._tag === "Open") {
        const finalizer3 = /* @__PURE__ */ __name(() => fiberIdWith((fiberId3) => equals(fiberId3, fiber.id()) ? void_2 : asVoid2(interruptFiber(fiber))), "finalizer");
        const key = {};
        scopeImpl.state.finalizers.set(key, finalizer3);
        fiber.addObserver(() => {
          if (scopeImpl.state._tag === "Closed") return;
          scopeImpl.state.finalizers.delete(key);
        });
      } else {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      return succeed(fiber);
    }));
    forkScoped = /* @__PURE__ */ __name((self2) => scopeWith((scope5) => forkIn(self2, scope5)), "forkScoped");
    fromFiber = /* @__PURE__ */ __name((fiber) => join2(fiber), "fromFiber");
    fromFiberEffect = /* @__PURE__ */ __name((fiber) => suspend(() => flatMap8(fiber, join2)), "fromFiberEffect");
    memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");
    Key = class {
      static {
        __name(this, "Key");
      }
      a;
      eq;
      [memoKeySymbol] = memoKeySymbol;
      constructor(a, eq2) {
        this.a = a;
        this.eq = eq2;
      }
      [symbol2](that) {
        if (hasProperty(that, memoKeySymbol)) {
          if (this.eq) {
            return this.eq(this.a, that.a);
          } else {
            return equals(this.a, that.a);
          }
        }
        return false;
      }
      [symbol]() {
        return this.eq ? 0 : cached(this, hash(this.a));
      }
    };
    cachedFunction = /* @__PURE__ */ __name((f, eq2) => {
      return pipe(sync(() => empty18()), flatMap8(makeSynchronized), map11((ref2) => (a) => pipe(ref2.modifyEffect((map31) => {
        const result = pipe(map31, get8(new Key(a, eq2)));
        if (isNone2(result)) {
          return pipe(deferredMake(), tap2((deferred) => pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork)), map11((deferred) => [deferred, pipe(map31, set4(new Key(a, eq2), deferred))]));
        }
        return succeed([result.value, map31]);
      }), flatMap8(deferredAwait), flatMap8(([patch9, b]) => pipe(patchFiberRefs(patch9), as2(b))))));
    }, "cachedFunction");
    raceFirst = /* @__PURE__ */ dual(2, (self2, that) => pipe(exit2(self2), race(exit2(that)), (effect4) => flatten7(effect4)));
    supervised = /* @__PURE__ */ dual(2, (self2, supervisor) => {
      const supervise = fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor));
      return supervise(self2);
    });
    timeout = /* @__PURE__ */ dual(2, (self2, duration6) => timeoutFail(self2, {
      onTimeout: /* @__PURE__ */ __name(() => timeoutExceptionFromDuration(duration6), "onTimeout"),
      duration: duration6
    }));
    timeoutFail = /* @__PURE__ */ dual(2, (self2, {
      duration: duration6,
      onTimeout
    }) => flatten7(timeoutTo(self2, {
      onTimeout: /* @__PURE__ */ __name(() => failSync(onTimeout), "onTimeout"),
      onSuccess: succeed,
      duration: duration6
    })));
    timeoutFailCause = /* @__PURE__ */ dual(2, (self2, {
      duration: duration6,
      onTimeout
    }) => flatten7(timeoutTo(self2, {
      onTimeout: /* @__PURE__ */ __name(() => failCauseSync(onTimeout), "onTimeout"),
      onSuccess: succeed,
      duration: duration6
    })));
    timeoutOption = /* @__PURE__ */ dual(2, (self2, duration6) => timeoutTo(self2, {
      duration: duration6,
      onSuccess: some2,
      onTimeout: none2
    }));
    timeoutTo = /* @__PURE__ */ dual(2, (self2, {
      duration: duration6,
      onSuccess,
      onTimeout
    }) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self2), interruptible2(sleep3(duration6)), {
      onSelfWin: /* @__PURE__ */ __name((winner, loser) => flatMap8(winner.await, (exit5) => {
        if (exit5._tag === "Success") {
          return flatMap8(winner.inheritAll, () => as2(interruptAsFiber(loser, parentFiberId), onSuccess(exit5.value)));
        } else {
          return flatMap8(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit5.cause));
        }
      }), "onSelfWin"),
      onOtherWin: /* @__PURE__ */ __name((winner, loser) => flatMap8(winner.await, (exit5) => {
        if (exit5._tag === "Success") {
          return flatMap8(winner.inheritAll, () => as2(interruptAsFiber(loser, parentFiberId), onTimeout()));
        } else {
          return flatMap8(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit5.cause));
        }
      }), "onOtherWin"),
      otherScope: globalScope
    }))));
    SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
    SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
    synchronizedVariance = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    SynchronizedImpl = class extends Class2 {
      static {
        __name(this, "SynchronizedImpl");
      }
      ref;
      withLock;
      [SynchronizedTypeId] = synchronizedVariance;
      [RefTypeId] = refVariance;
      [TypeId14] = TypeId14;
      constructor(ref2, withLock) {
        super();
        this.ref = ref2;
        this.withLock = withLock;
        this.get = get11(this.ref);
      }
      get;
      commit() {
        return this.get;
      }
      modify(f) {
        return this.modifyEffect((a) => succeed(f(a)));
      }
      modifyEffect(f) {
        return this.withLock(pipe(flatMap8(get11(this.ref), f), flatMap8(([b, a]) => as2(set5(this.ref, a), b))));
      }
    };
    makeSynchronized = /* @__PURE__ */ __name((value3) => sync(() => unsafeMakeSynchronized(value3)), "makeSynchronized");
    unsafeMakeSynchronized = /* @__PURE__ */ __name((value3) => {
      const ref2 = unsafeMake6(value3);
      const sem = unsafeMakeSemaphore(1);
      return new SynchronizedImpl(ref2, sem.withPermits(1));
    }, "unsafeMakeSynchronized");
    updateSomeAndGetEffectSynchronized = /* @__PURE__ */ dual(2, (self2, pf) => self2.modifyEffect((value3) => {
      const result = pf(value3);
      switch (result._tag) {
        case "None": {
          return succeed([value3, value3]);
        }
        case "Some": {
          return map11(result.value, (a) => [a, a]);
        }
      }
    }));
    bindAll = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, f, options) => flatMap8(self2, (a) => all5(f(a), options).pipe(map11((record4) => Object.assign({}, a, record4)))));
  }
});

// node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId17;
var init_circular2 = __esm({
  "node_modules/effect/dist/esm/internal/managedRuntime/circular.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    TypeId17 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");
  }
});

// node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_EXTEND_SCOPE, OP_FOLD, OP_FRESH, OP_FROM_EFFECT, OP_SCOPED, OP_SUSPEND, OP_PROVIDE, OP_PROVIDE_MERGE, OP_MERGE_ALL, OP_ZIP_WITH2;
var init_layer = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/layer.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_EXTEND_SCOPE = "ExtendScope";
    OP_FOLD = "Fold";
    OP_FRESH = "Fresh";
    OP_FROM_EFFECT = "FromEffect";
    OP_SCOPED = "Scoped";
    OP_SUSPEND = "Suspend";
    OP_PROVIDE = "Provide";
    OP_PROVIDE_MERGE = "ProvideMerge";
    OP_MERGE_ALL = "MergeAll";
    OP_ZIP_WITH2 = "ZipWith";
  }
});

// node_modules/effect/dist/esm/Fiber.js
var _await3, inheritAll2, interrupt6, interruptAs, join3, poll4;
var init_Fiber = __esm({
  "node_modules/effect/dist/esm/Fiber.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_core();
    init_fiber();
    _await3 = _await2;
    inheritAll2 = inheritAll;
    interrupt6 = interruptFiber;
    interruptAs = interruptAsFiber;
    join3 = join2;
    poll4 = poll3;
  }
});

// node_modules/effect/dist/esm/internal/runtime.js
var makeDual, unsafeFork3, unsafeRunCallback, unsafeRunSync, AsyncFiberExceptionImpl, asyncFiberException, FiberFailureId, FiberFailureCauseId, FiberFailureImpl, fiberFailure, fastPath, unsafeRunSyncExit, unsafeRunPromise, unsafeRunPromiseExit, RuntimeImpl, make41, runtime3, defaultRuntimeFlags, defaultRuntime, unsafeRunEffect, unsafeForkEffect, unsafeRunPromiseEffect, unsafeRunPromiseExitEffect, unsafeRunSyncEffect, unsafeRunSyncExitEffect, asyncEffect;
var init_runtime = __esm({
  "node_modules/effect/dist/esm/internal/runtime.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Context();
    init_Equal();
    init_Exit();
    init_Fiber();
    init_FiberId();
    init_FiberRefs();
    init_Function();
    init_Inspectable();
    init_Option();
    init_Pipeable();
    init_Scheduler();
    init_Scope();
    init_cause2();
    init_core();
    init_executionStrategy();
    init_fiberRuntime();
    init_fiberScope();
    init_effect();
    init_runtimeFlags();
    init_supervisor();
    makeDual = /* @__PURE__ */ __name((f) => function() {
      if (arguments.length === 1) {
        const runtime5 = arguments[0];
        return (effect4, ...args2) => f(runtime5, effect4, ...args2);
      }
      return f.apply(this, arguments);
    }, "makeDual");
    unsafeFork3 = /* @__PURE__ */ makeDual((runtime5, self2, options) => {
      const fiberId3 = unsafeMake3();
      const fiberRefUpdates = [[currentContext, [[fiberId3, runtime5.context]]]];
      if (options?.scheduler) {
        fiberRefUpdates.push([currentScheduler, [[fiberId3, options.scheduler]]]);
      }
      let fiberRefs3 = updateManyAs2(runtime5.fiberRefs, {
        entries: fiberRefUpdates,
        forkAs: fiberId3
      });
      if (options?.updateRefs) {
        fiberRefs3 = options.updateRefs(fiberRefs3, fiberId3);
      }
      const fiberRuntime = new FiberRuntime(fiberId3, fiberRefs3, runtime5.runtimeFlags);
      let effect4 = self2;
      if (options?.scope) {
        effect4 = flatMap8(fork2(options.scope, sequential2), (closeableScope) => zipRight2(scopeAddFinalizer(closeableScope, fiberIdWith((id2) => equals(id2, fiberRuntime.id()) ? void_2 : interruptAsFiber(fiberRuntime, id2))), onExit(self2, (exit5) => close(closeableScope, exit5))));
      }
      const supervisor = fiberRuntime.currentSupervisor;
      if (supervisor !== none8) {
        supervisor.onStart(runtime5.context, effect4, none2(), fiberRuntime);
        fiberRuntime.addObserver((exit5) => supervisor.onEnd(exit5, fiberRuntime));
      }
      globalScope.add(runtime5.runtimeFlags, fiberRuntime);
      if (options?.immediate === false) {
        fiberRuntime.resume(effect4);
      } else {
        fiberRuntime.start(effect4);
      }
      return fiberRuntime;
    });
    unsafeRunCallback = /* @__PURE__ */ makeDual((runtime5, effect4, options = {}) => {
      const fiberRuntime = unsafeFork3(runtime5, effect4, options);
      if (options.onExit) {
        fiberRuntime.addObserver((exit5) => {
          options.onExit(exit5);
        });
      }
      return (id2, cancelOptions) => unsafeRunCallback(runtime5)(pipe(fiberRuntime, interruptAs(id2 ?? none4)), {
        ...cancelOptions,
        onExit: cancelOptions?.onExit ? (exit5) => cancelOptions.onExit(flatten8(exit5)) : void 0
      });
    });
    unsafeRunSync = /* @__PURE__ */ makeDual((runtime5, effect4) => {
      const result = unsafeRunSyncExit(runtime5)(effect4);
      if (result._tag === "Failure") {
        throw fiberFailure(result.effect_instruction_i0);
      }
      return result.effect_instruction_i0;
    });
    AsyncFiberExceptionImpl = class extends Error {
      static {
        __name(this, "AsyncFiberExceptionImpl");
      }
      fiber;
      _tag = "AsyncFiberException";
      constructor(fiber) {
        super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
        this.fiber = fiber;
        this.name = this._tag;
        this.stack = this.message;
      }
    };
    asyncFiberException = /* @__PURE__ */ __name((fiber) => {
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      const error50 = new AsyncFiberExceptionImpl(fiber);
      Error.stackTraceLimit = limit;
      return error50;
    }, "asyncFiberException");
    FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
    FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");
    FiberFailureImpl = class extends Error {
      static {
        __name(this, "FiberFailureImpl");
      }
      [FiberFailureId];
      [FiberFailureCauseId];
      constructor(cause3) {
        const head7 = prettyErrors(cause3)[0];
        super(head7?.message || "An error has occurred");
        this[FiberFailureId] = FiberFailureId;
        this[FiberFailureCauseId] = cause3;
        this.name = head7 ? `(FiberFailure) ${head7.name}` : "FiberFailure";
        if (head7?.stack) {
          this.stack = head7.stack;
        }
      }
      toJSON() {
        return {
          _id: "FiberFailure",
          cause: this[FiberFailureCauseId].toJSON()
        };
      }
      toString() {
        return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
          renderErrorCause: true
        });
      }
      [NodeInspectSymbol]() {
        return this.toString();
      }
    };
    fiberFailure = /* @__PURE__ */ __name((cause3) => {
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      const error50 = new FiberFailureImpl(cause3);
      Error.stackTraceLimit = limit;
      return error50;
    }, "fiberFailure");
    fastPath = /* @__PURE__ */ __name((effect4) => {
      const op = effect4;
      switch (op._op) {
        case "Failure":
        case "Success": {
          return op;
        }
        case "Left": {
          return exitFail(op.left);
        }
        case "Right": {
          return exitSucceed(op.right);
        }
        case "Some": {
          return exitSucceed(op.value);
        }
        case "None": {
          return exitFail(new NoSuchElementException());
        }
      }
    }, "fastPath");
    unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime5, effect4) => {
      const op = fastPath(effect4);
      if (op) {
        return op;
      }
      const scheduler2 = new SyncScheduler();
      const fiberRuntime = unsafeFork3(runtime5)(effect4, {
        scheduler: scheduler2
      });
      scheduler2.flush();
      const result = fiberRuntime.unsafePoll();
      if (result) {
        return result;
      }
      return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
    });
    unsafeRunPromise = /* @__PURE__ */ makeDual((runtime5, effect4, options) => unsafeRunPromiseExit(runtime5, effect4, options).then((result) => {
      switch (result._tag) {
        case OP_SUCCESS: {
          return result.effect_instruction_i0;
        }
        case OP_FAILURE: {
          throw fiberFailure(result.effect_instruction_i0);
        }
      }
    }));
    unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime5, effect4, options) => new Promise((resolve) => {
      const op = fastPath(effect4);
      if (op) {
        resolve(op);
      }
      const fiber = unsafeFork3(runtime5)(effect4);
      fiber.addObserver((exit5) => {
        resolve(exit5);
      });
      if (options?.signal !== void 0) {
        if (options.signal.aborted) {
          fiber.unsafeInterruptAsFork(fiber.id());
        } else {
          options.signal.addEventListener("abort", () => {
            fiber.unsafeInterruptAsFork(fiber.id());
          }, {
            once: true
          });
        }
      }
    }));
    RuntimeImpl = class {
      static {
        __name(this, "RuntimeImpl");
      }
      context;
      runtimeFlags;
      fiberRefs;
      constructor(context10, runtimeFlags2, fiberRefs3) {
        this.context = context10;
        this.runtimeFlags = runtimeFlags2;
        this.fiberRefs = fiberRefs3;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    make41 = /* @__PURE__ */ __name((options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs), "make");
    runtime3 = /* @__PURE__ */ __name(() => withFiberRuntime((state, status2) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status2.runtimeFlags, state.getFiberRefs()))), "runtime");
    defaultRuntimeFlags = /* @__PURE__ */ make17(Interruption, CooperativeYielding, RuntimeMetrics);
    defaultRuntime = /* @__PURE__ */ make41({
      context: /* @__PURE__ */ empty4(),
      runtimeFlags: defaultRuntimeFlags,
      fiberRefs: /* @__PURE__ */ empty22()
    });
    unsafeRunEffect = /* @__PURE__ */ unsafeRunCallback(defaultRuntime);
    unsafeForkEffect = /* @__PURE__ */ unsafeFork3(defaultRuntime);
    unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
    unsafeRunPromiseExitEffect = /* @__PURE__ */ unsafeRunPromiseExit(defaultRuntime);
    unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
    unsafeRunSyncExitEffect = /* @__PURE__ */ unsafeRunSyncExit(defaultRuntime);
    asyncEffect = /* @__PURE__ */ __name((register) => suspend(() => {
      let cleanup = void 0;
      return flatMap8(deferredMake(), (deferred) => flatMap8(runtime3(), (runtime5) => uninterruptibleMask((restore) => zipRight2(fork(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime5)(intoDeferred(cb, deferred))), {
        onFailure: /* @__PURE__ */ __name((cause3) => deferredFailCause(deferred, cause3), "onFailure"),
        onSuccess: /* @__PURE__ */ __name((cleanup_) => {
          cleanup = cleanup_;
          return void_2;
        }, "onSuccess")
      }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? void_2))))));
    }), "asyncEffect");
  }
});

// node_modules/effect/dist/esm/internal/synchronizedRef.js
var modifyEffect, updateSomeEffect;
var init_synchronizedRef = __esm({
  "node_modules/effect/dist/esm/internal/synchronizedRef.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_core();
    modifyEffect = /* @__PURE__ */ dual(2, (self2, f) => self2.modifyEffect(f));
    updateSomeEffect = /* @__PURE__ */ dual(2, (self2, pf) => self2.modifyEffect((value3) => {
      const result = pf(value3);
      switch (result._tag) {
        case "None": {
          return succeed([void 0, value3]);
        }
        case "Some": {
          return map11(result.value, (a) => [void 0, a]);
        }
      }
    }));
  }
});

// node_modules/effect/dist/esm/internal/layer.js
function fromEffectContext(effect4) {
  const fromEffect9 = Object.create(proto3);
  fromEffect9._op_layer = OP_FROM_EFFECT;
  fromEffect9.effect = effect4;
  return fromEffect9;
}
var LayerSymbolKey, LayerTypeId, layerVariance, proto3, MemoMapTypeIdKey, MemoMapTypeId, CurrentMemoMap, isLayer, isFresh, MemoMapImpl, makeMemoMap, unsafeMakeMemoMap, build, buildWithScope, buildWithMemoMap, makeBuilder, catchAll2, catchAllCause2, die5, dieSync2, discard, context4, extendScope, fail7, failSync2, failCause6, failCauseSync2, flatMap10, flatten9, fresh, fromEffect3, fromEffectDiscard, fiberRefLocally2, locallyEffect, fiberRefLocallyWith2, fiberRefLocallyScoped2, fiberRefLocallyScopedWith2, fromFunction, launch, mock, mockImpl, makeUnimplemented, map16, mapError2, matchCause3, match11, memoize2, merge6, mergeAll4, orDie2, orElse4, passthrough, project, retry, retryLoop, retryUpdate, scoped, scopedDiscard, scopedContext, scope2, service, succeed6, succeedContext, empty32, suspend3, sync3, syncContext, tap3, tapError2, tapErrorCause2, toRuntime, toRuntimeWithMemoMap, provide, provideMerge, zipWith5, unwrapEffect, unwrapScoped, annotateLogs2, annotateSpans2, withSpan2, withParentSpan2, provideSomeLayer, provideSomeRuntime, effect_provide;
var init_layer2 = __esm({
  "node_modules/effect/dist/esm/internal/layer.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Cause();
    init_Clock();
    init_Context();
    init_Duration();
    init_FiberRefsPatch();
    init_Function();
    init_HashMap();
    init_Pipeable();
    init_Predicate();
    init_ScheduleDecision();
    init_ScheduleIntervals();
    init_Scope();
    init_core_effect();
    init_core();
    init_circular();
    init_executionStrategy();
    init_fiberRuntime();
    init_circular2();
    init_effect();
    init_layer();
    init_ref();
    init_runtime();
    init_runtimeFlags();
    init_synchronizedRef();
    init_tracer();
    LayerSymbolKey = "effect/Layer";
    LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
    layerVariance = {
      /* c8 ignore next */
      _RIn: /* @__PURE__ */ __name((_) => _, "_RIn"),
      /* c8 ignore next */
      _E: /* @__PURE__ */ __name((_) => _, "_E"),
      /* c8 ignore next */
      _ROut: /* @__PURE__ */ __name((_) => _, "_ROut")
    };
    proto3 = {
      [LayerTypeId]: layerVariance,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    MemoMapTypeIdKey = "effect/Layer/MemoMap";
    MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
    CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
      defaultValue: /* @__PURE__ */ __name(() => unsafeMakeMemoMap(), "defaultValue")
    });
    isLayer = /* @__PURE__ */ __name((u) => hasProperty(u, LayerTypeId), "isLayer");
    isFresh = /* @__PURE__ */ __name((self2) => {
      return self2._op_layer === OP_FRESH;
    }, "isFresh");
    MemoMapImpl = class {
      static {
        __name(this, "MemoMapImpl");
      }
      ref;
      [MemoMapTypeId];
      constructor(ref2) {
        this.ref = ref2;
        this[MemoMapTypeId] = MemoMapTypeId;
      }
      /**
       * Checks the memo map to see if a layer exists. If it is, immediately
       * returns it. Otherwise, obtains the layer, stores it in the memo map,
       * and adds a finalizer to the `Scope`.
       */
      getOrElseMemoize(layer, scope5) {
        return pipe(modifyEffect(this.ref, (map31) => {
          const inMap = map31.get(layer);
          if (inMap !== void 0) {
            const [acquire2, release2] = inMap;
            const cached5 = pipe(acquire2, flatMap8(([patch9, b]) => pipe(patchFiberRefs(patch9), as2(b))), onExit(exitMatch({
              onFailure: /* @__PURE__ */ __name(() => void_2, "onFailure"),
              onSuccess: /* @__PURE__ */ __name(() => scopeAddFinalizerExit(scope5, release2), "onSuccess")
            })));
            return succeed([cached5, map31]);
          }
          return pipe(make28(0), flatMap8((observers) => pipe(deferredMake(), flatMap8((deferred) => pipe(make28(() => void_2), map11((finalizerRef) => {
            const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap8((innerScope) => pipe(restore(flatMap8(makeBuilder(layer, innerScope, true), (f) => diffFiberRefs(f(this)))), exit2, flatMap8((exit5) => {
              switch (exit5._tag) {
                case OP_FAILURE: {
                  return pipe(deferredFailCause(deferred, exit5.effect_instruction_i0), zipRight2(scopeClose(innerScope, exit5)), zipRight2(failCause(exit5.effect_instruction_i0)));
                }
                case OP_SUCCESS: {
                  return pipe(set5(finalizerRef, (exit6) => pipe(scopeClose(innerScope, exit6), whenEffect(modify3(observers, (n) => [n === 1, n - 1])), asVoid2)), zipRight2(update2(observers, (n) => n + 1)), zipRight2(scopeAddFinalizerExit(scope5, (exit6) => pipe(sync(() => map31.delete(layer)), zipRight2(get11(finalizerRef)), flatMap8((finalizer3) => finalizer3(exit6))))), zipRight2(deferredSucceed(deferred, exit5.effect_instruction_i0)), as2(exit5.effect_instruction_i0[1]));
                }
              }
            })))));
            const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
              onFailure: /* @__PURE__ */ __name(() => void_2, "onFailure"),
              onSuccess: /* @__PURE__ */ __name(() => update2(observers, (n) => n + 1), "onSuccess")
            }))), (exit5) => pipe(get11(finalizerRef), flatMap8((finalizer3) => finalizer3(exit5)))];
            return [resource, isFresh(layer) ? map31 : map31.set(layer, memoized)];
          }))))));
        }), flatten7);
      }
    };
    makeMemoMap = /* @__PURE__ */ suspend(() => map11(makeSynchronized(/* @__PURE__ */ new Map()), (ref2) => new MemoMapImpl(ref2)));
    unsafeMakeMemoMap = /* @__PURE__ */ __name(() => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map())), "unsafeMakeMemoMap");
    build = /* @__PURE__ */ __name((self2) => scopeWith((scope5) => buildWithScope(self2, scope5)), "build");
    buildWithScope = /* @__PURE__ */ dual(2, (self2, scope5) => flatMap8(makeMemoMap, (memoMap) => buildWithMemoMap(self2, memoMap, scope5)));
    buildWithMemoMap = /* @__PURE__ */ dual(3, (self2, memoMap, scope5) => flatMap8(makeBuilder(self2, scope5), (run6) => provideService(run6(memoMap), CurrentMemoMap, memoMap)));
    makeBuilder = /* @__PURE__ */ __name((self2, scope5, inMemoMap = false) => {
      const op = self2;
      switch (op._op_layer) {
        case "Locally": {
          return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope5)));
        }
        case "ExtendScope": {
          return sync(() => (memoMap) => scopeWith((scope6) => memoMap.getOrElseMemoize(op.layer, scope6)));
        }
        case "Fold": {
          return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope5), matchCauseEffect({
            onFailure: /* @__PURE__ */ __name((cause3) => memoMap.getOrElseMemoize(op.failureK(cause3), scope5), "onFailure"),
            onSuccess: /* @__PURE__ */ __name((value3) => memoMap.getOrElseMemoize(op.successK(value3), scope5), "onSuccess")
          })));
        }
        case "Fresh": {
          return sync(() => (_) => pipe(op.layer, buildWithScope(scope5)));
        }
        case "FromEffect": {
          return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope5));
        }
        case "Provide": {
          return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), flatMap8((env2) => pipe(memoMap.getOrElseMemoize(op.second, scope5), provideContext(env2)))));
        }
        case "Scoped": {
          return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope5)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope5));
        }
        case "Suspend": {
          return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope5));
        }
        case "ProvideMerge": {
          return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), zipWith4(memoMap.getOrElseMemoize(op.second, scope5), op.zipK)));
        }
        case "ZipWith": {
          return gen3(function* () {
            const parallelScope = yield* scopeFork(scope5, parallel2);
            const firstScope = yield* scopeFork(parallelScope, sequential2);
            const secondScope = yield* scopeFork(parallelScope, sequential2);
            return (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, firstScope), zipWithOptions(memoMap.getOrElseMemoize(op.second, secondScope), op.zipK, {
              concurrent: true
            }));
          });
        }
        case "MergeAll": {
          const layers = op.layers;
          return map11(scopeFork(scope5, parallel2), (parallelScope) => (memoMap) => {
            const contexts = new Array(layers.length);
            return map11(forEachConcurrentDiscard(layers, fnUntraced(function* (layer, i) {
              const scope6 = yield* scopeFork(parallelScope, sequential2);
              const context10 = yield* memoMap.getOrElseMemoize(layer, scope6);
              contexts[i] = context10;
            }), false, false), () => mergeAll2(...contexts));
          });
        }
      }
    }, "makeBuilder");
    catchAll2 = /* @__PURE__ */ dual(2, (self2, onFailure) => match11(self2, {
      onFailure,
      onSuccess: succeedContext
    }));
    catchAllCause2 = /* @__PURE__ */ dual(2, (self2, onFailure) => matchCause3(self2, {
      onFailure,
      onSuccess: succeedContext
    }));
    die5 = /* @__PURE__ */ __name((defect) => failCause6(die4(defect)), "die");
    dieSync2 = /* @__PURE__ */ __name((evaluate3) => failCauseSync2(() => die4(evaluate3())), "dieSync");
    discard = /* @__PURE__ */ __name((self2) => map16(self2, () => empty4()), "discard");
    context4 = /* @__PURE__ */ __name(() => fromEffectContext(context3()), "context");
    extendScope = /* @__PURE__ */ __name((self2) => {
      const extendScope3 = Object.create(proto3);
      extendScope3._op_layer = OP_EXTEND_SCOPE;
      extendScope3.layer = self2;
      return extendScope3;
    }, "extendScope");
    fail7 = /* @__PURE__ */ __name((error50) => failCause6(fail5(error50)), "fail");
    failSync2 = /* @__PURE__ */ __name((evaluate3) => failCauseSync2(() => fail5(evaluate3())), "failSync");
    failCause6 = /* @__PURE__ */ __name((cause3) => fromEffectContext(failCause(cause3)), "failCause");
    failCauseSync2 = /* @__PURE__ */ __name((evaluate3) => fromEffectContext(failCauseSync(evaluate3)), "failCauseSync");
    flatMap10 = /* @__PURE__ */ dual(2, (self2, f) => match11(self2, {
      onFailure: fail7,
      onSuccess: f
    }));
    flatten9 = /* @__PURE__ */ dual(2, (self2, tag2) => flatMap10(self2, get3(tag2)));
    fresh = /* @__PURE__ */ __name((self2) => {
      const fresh3 = Object.create(proto3);
      fresh3._op_layer = OP_FRESH;
      fresh3.layer = self2;
      return fresh3;
    }, "fresh");
    fromEffect3 = /* @__PURE__ */ dual(2, (a, b) => {
      const tagFirst = isTag2(a);
      const tag2 = tagFirst ? a : b;
      const effect4 = tagFirst ? b : a;
      return fromEffectContext(map11(effect4, (service3) => make6(tag2, service3)));
    });
    fromEffectDiscard = /* @__PURE__ */ __name((effect4) => fromEffectContext(map11(effect4, () => empty4())), "fromEffectDiscard");
    __name(fromEffectContext, "fromEffectContext");
    fiberRefLocally2 = /* @__PURE__ */ dual(3, (self2, ref2, value3) => locallyEffect(self2, fiberRefLocally(ref2, value3)));
    locallyEffect = /* @__PURE__ */ dual(2, (self2, f) => {
      const locally3 = Object.create(proto3);
      locally3._op_layer = "Locally";
      locally3.self = self2;
      locally3.f = f;
      return locally3;
    });
    fiberRefLocallyWith2 = /* @__PURE__ */ dual(3, (self2, ref2, value3) => locallyEffect(self2, fiberRefLocallyWith(ref2, value3)));
    fiberRefLocallyScoped2 = /* @__PURE__ */ __name((self2, value3) => scopedDiscard(fiberRefLocallyScoped(self2, value3)), "fiberRefLocallyScoped");
    fiberRefLocallyScopedWith2 = /* @__PURE__ */ __name((self2, value3) => scopedDiscard(fiberRefLocallyScopedWith(self2, value3)), "fiberRefLocallyScopedWith");
    fromFunction = /* @__PURE__ */ __name((tagA, tagB, f) => fromEffectContext(map11(tagA, (a) => make6(tagB, f(a)))), "fromFunction");
    launch = /* @__PURE__ */ __name((self2) => scopedEffect(zipRight2(scopeWith((scope5) => pipe(self2, buildWithScope(scope5))), never)), "launch");
    mock = /* @__PURE__ */ __name(function() {
      if (arguments.length === 1) {
        return (service3) => mockImpl(arguments[0], service3);
      }
      return mockImpl(arguments[0], arguments[1]);
    }, "mock");
    mockImpl = /* @__PURE__ */ __name((tag2, service3) => succeed6(tag2, new Proxy({
      ...service3
    }, {
      get(target, prop, _receiver) {
        if (prop in target) {
          return target[prop];
        }
        const prevLimit = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        const error50 = new Error(`${tag2.key}: Unimplemented method "${prop.toString()}"`);
        Error.stackTraceLimit = prevLimit;
        error50.name = "UnimplementedError";
        return makeUnimplemented(error50);
      },
      has: constTrue
    })), "mockImpl");
    makeUnimplemented = /* @__PURE__ */ __name((error50) => {
      const dead = die2(error50);
      function unimplemented() {
        return dead;
      }
      __name(unimplemented, "unimplemented");
      Object.assign(unimplemented, dead);
      Object.setPrototypeOf(unimplemented, Object.getPrototypeOf(dead));
      return unimplemented;
    }, "makeUnimplemented");
    map16 = /* @__PURE__ */ dual(2, (self2, f) => flatMap10(self2, (context10) => succeedContext(f(context10))));
    mapError2 = /* @__PURE__ */ dual(2, (self2, f) => catchAll2(self2, (error50) => failSync2(() => f(error50))));
    matchCause3 = /* @__PURE__ */ dual(2, (self2, {
      onFailure,
      onSuccess
    }) => {
      const fold2 = Object.create(proto3);
      fold2._op_layer = OP_FOLD;
      fold2.layer = self2;
      fold2.failureK = onFailure;
      fold2.successK = onSuccess;
      return fold2;
    });
    match11 = /* @__PURE__ */ dual(2, (self2, {
      onFailure,
      onSuccess
    }) => matchCause3(self2, {
      onFailure: /* @__PURE__ */ __name((cause3) => {
        const failureOrCause3 = failureOrCause2(cause3);
        switch (failureOrCause3._tag) {
          case "Left": {
            return onFailure(failureOrCause3.left);
          }
          case "Right": {
            return failCause6(failureOrCause3.right);
          }
        }
      }, "onFailure"),
      onSuccess
    }));
    memoize2 = /* @__PURE__ */ __name((self2) => scopeWith((scope5) => map11(memoize(buildWithScope(self2, scope5)), fromEffectContext)), "memoize");
    merge6 = /* @__PURE__ */ dual(2, (self2, that) => zipWith5(self2, that, (a, b) => merge3(a, b)));
    mergeAll4 = /* @__PURE__ */ __name((...layers) => {
      const mergeAll11 = Object.create(proto3);
      mergeAll11._op_layer = OP_MERGE_ALL;
      mergeAll11.layers = layers;
      return mergeAll11;
    }, "mergeAll");
    orDie2 = /* @__PURE__ */ __name((self2) => catchAll2(self2, (defect) => die5(defect)), "orDie");
    orElse4 = /* @__PURE__ */ dual(2, (self2, that) => catchAll2(self2, that));
    passthrough = /* @__PURE__ */ __name((self2) => merge6(context4(), self2), "passthrough");
    project = /* @__PURE__ */ dual(4, (self2, tagA, tagB, f) => map16(self2, (context10) => make6(tagB, f(unsafeGet3(context10, tagA)))));
    retry = /* @__PURE__ */ dual(2, (self2, schedule4) => suspend3(() => {
      const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
      return pipe(succeed6(stateTag, {
        state: schedule4.initial
      }), flatMap10((env2) => retryLoop(self2, schedule4, stateTag, pipe(env2, get3(stateTag)).state)));
    }));
    retryLoop = /* @__PURE__ */ __name((self2, schedule4, stateTag, state) => {
      return pipe(self2, catchAll2((error50) => pipe(retryUpdate(schedule4, stateTag, error50, state), flatMap10((env2) => fresh(retryLoop(self2, schedule4, stateTag, pipe(env2, get3(stateTag)).state))))));
    }, "retryLoop");
    retryUpdate = /* @__PURE__ */ __name((schedule4, stateTag, error50, state) => {
      return fromEffect3(stateTag, pipe(currentTimeMillis2, flatMap8((now2) => pipe(schedule4.step(now2, error50, state), flatMap8(([state2, _, decision]) => isDone5(decision) ? fail2(error50) : pipe(sleep2(millis(start2(decision.intervals) - now2)), as2({
        state: state2
      })))))));
    }, "retryUpdate");
    scoped = /* @__PURE__ */ dual(2, (a, b) => {
      const tagFirst = isTag2(a);
      const tag2 = tagFirst ? a : b;
      const effect4 = tagFirst ? b : a;
      return scopedContext(map11(effect4, (service3) => make6(tag2, service3)));
    });
    scopedDiscard = /* @__PURE__ */ __name((effect4) => scopedContext(pipe(effect4, as2(empty4()))), "scopedDiscard");
    scopedContext = /* @__PURE__ */ __name((effect4) => {
      const scoped7 = Object.create(proto3);
      scoped7._op_layer = OP_SCOPED;
      scoped7.effect = effect4;
      return scoped7;
    }, "scopedContext");
    scope2 = /* @__PURE__ */ scopedContext(/* @__PURE__ */ map11(/* @__PURE__ */ acquireRelease(/* @__PURE__ */ scopeMake(), (scope5, exit5) => scope5.close(exit5)), (scope5) => make6(Scope, scope5)));
    service = /* @__PURE__ */ __name((tag2) => fromEffect3(tag2, tag2), "service");
    succeed6 = /* @__PURE__ */ dual(2, (a, b) => {
      const tagFirst = isTag2(a);
      const tag2 = tagFirst ? a : b;
      const resource = tagFirst ? b : a;
      return fromEffectContext(succeed(make6(tag2, resource)));
    });
    succeedContext = /* @__PURE__ */ __name((context10) => {
      return fromEffectContext(succeed(context10));
    }, "succeedContext");
    empty32 = /* @__PURE__ */ succeedContext(/* @__PURE__ */ empty4());
    suspend3 = /* @__PURE__ */ __name((evaluate3) => {
      const suspend14 = Object.create(proto3);
      suspend14._op_layer = OP_SUSPEND;
      suspend14.evaluate = evaluate3;
      return suspend14;
    }, "suspend");
    sync3 = /* @__PURE__ */ dual(2, (a, b) => {
      const tagFirst = isTag2(a);
      const tag2 = tagFirst ? a : b;
      const evaluate3 = tagFirst ? b : a;
      return fromEffectContext(sync(() => make6(tag2, evaluate3())));
    });
    syncContext = /* @__PURE__ */ __name((evaluate3) => {
      return fromEffectContext(sync(evaluate3));
    }, "syncContext");
    tap3 = /* @__PURE__ */ dual(2, (self2, f) => flatMap10(self2, (context10) => fromEffectContext(as2(f(context10), context10))));
    tapError2 = /* @__PURE__ */ dual(2, (self2, f) => catchAll2(self2, (e) => fromEffectContext(flatMap8(f(e), () => fail2(e)))));
    tapErrorCause2 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause2(self2, (cause3) => fromEffectContext(flatMap8(f(cause3), () => failCause(cause3)))));
    toRuntime = /* @__PURE__ */ __name((self2) => pipe(scopeWith((scope5) => buildWithScope(self2, scope5)), flatMap8((context10) => pipe(runtime3(), provideContext(context10)))), "toRuntime");
    toRuntimeWithMemoMap = /* @__PURE__ */ dual(2, (self2, memoMap) => flatMap8(scopeWith((scope5) => buildWithMemoMap(self2, memoMap, scope5)), (context10) => pipe(runtime3(), provideContext(context10))));
    provide = /* @__PURE__ */ dual(2, (self2, that) => suspend3(() => {
      const provideTo = Object.create(proto3);
      provideTo._op_layer = OP_PROVIDE;
      provideTo.first = Object.create(proto3, {
        _op_layer: {
          value: OP_PROVIDE_MERGE,
          enumerable: true
        },
        first: {
          value: context4(),
          enumerable: true
        },
        second: {
          value: Array.isArray(that) ? mergeAll4(...that) : that
        },
        zipK: {
          value: /* @__PURE__ */ __name((a, b) => pipe(a, merge3(b)), "value")
        }
      });
      provideTo.second = self2;
      return provideTo;
    }));
    provideMerge = /* @__PURE__ */ dual(2, (that, self2) => {
      const zipWith15 = Object.create(proto3);
      zipWith15._op_layer = OP_PROVIDE_MERGE;
      zipWith15.first = self2;
      zipWith15.second = provide(that, self2);
      zipWith15.zipK = (a, b) => {
        return pipe(a, merge3(b));
      };
      return zipWith15;
    });
    zipWith5 = /* @__PURE__ */ dual(3, (self2, that, f) => suspend3(() => {
      const zipWith15 = Object.create(proto3);
      zipWith15._op_layer = OP_ZIP_WITH2;
      zipWith15.first = self2;
      zipWith15.second = that;
      zipWith15.zipK = f;
      return zipWith15;
    }));
    unwrapEffect = /* @__PURE__ */ __name((self2) => {
      const tag2 = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
      return flatMap10(fromEffect3(tag2, self2), (context10) => get3(context10, tag2));
    }, "unwrapEffect");
    unwrapScoped = /* @__PURE__ */ __name((self2) => {
      const tag2 = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
      return flatMap10(scoped(tag2, self2), (context10) => get3(context10, tag2));
    }, "unwrapScoped");
    annotateLogs2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
      const args2 = arguments;
      return fiberRefLocallyWith2(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value3]) => set3(acc, key, value3), annotations3));
    });
    annotateSpans2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
      const args2 = arguments;
      return fiberRefLocallyWith2(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value3]) => set3(acc, key, value3), annotations3));
    });
    withSpan2 = /* @__PURE__ */ __name(function() {
      const dataFirst = typeof arguments[0] !== "string";
      const name = dataFirst ? arguments[1] : arguments[0];
      const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
      if (dataFirst) {
        const self2 = arguments[0];
        return unwrapScoped(map11(options?.onEnd ? tap2(makeSpanScoped(name, options), (span4) => addFinalizer((exit5) => options.onEnd(span4, exit5))) : makeSpanScoped(name, options), (span4) => withParentSpan2(self2, span4)));
      }
      return (self2) => unwrapScoped(map11(options?.onEnd ? tap2(makeSpanScoped(name, options), (span4) => addFinalizer((exit5) => options.onEnd(span4, exit5))) : makeSpanScoped(name, options), (span4) => withParentSpan2(self2, span4)));
    }, "withSpan");
    withParentSpan2 = /* @__PURE__ */ dual(2, (self2, span4) => provide(self2, succeedContext(make6(spanTag, span4))));
    provideSomeLayer = /* @__PURE__ */ dual(2, (self2, layer) => scopedWith((scope5) => flatMap8(buildWithScope(layer, scope5), (context10) => provideSomeContext(self2, context10))));
    provideSomeRuntime = /* @__PURE__ */ dual(2, (self2, rt) => {
      const patchRefs = diff6(defaultRuntime.fiberRefs, rt.fiberRefs);
      const patchFlags = diff4(defaultRuntime.runtimeFlags, rt.runtimeFlags);
      return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
        const oldContext = fiber.getFiberRef(currentContext);
        const oldRefs = fiber.getFiberRefs();
        const newRefs = patch7(fiber.id(), oldRefs)(patchRefs);
        const oldFlags = fiber.currentRuntimeFlags;
        const newFlags = patch4(patchFlags)(oldFlags);
        const rollbackRefs = diff6(newRefs, oldRefs);
        const rollbackFlags = diff4(newFlags, oldFlags);
        fiber.setFiberRefs(newRefs);
        fiber.currentRuntimeFlags = newFlags;
        return ensuring(provideSomeContext(restore(self2), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
          fiber2.setFiberRefs(patch7(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
          fiber2.currentRuntimeFlags = patch4(rollbackFlags)(fiber2.currentRuntimeFlags);
          return void_2;
        }));
      }));
    });
    effect_provide = /* @__PURE__ */ dual(2, (self2, source2) => {
      if (Array.isArray(source2)) {
        return provideSomeLayer(self2, mergeAll4(...source2));
      } else if (isLayer(source2)) {
        return provideSomeLayer(self2, source2);
      } else if (isContext2(source2)) {
        return provideSomeContext(self2, source2);
      } else if (TypeId17 in source2) {
        return flatMap8(source2.runtimeEffect, (rt) => provideSomeRuntime(self2, rt));
      } else {
        return provideSomeRuntime(self2, source2);
      }
    });
  }
});

// node_modules/effect/dist/esm/internal/console.js
var console2, consoleWith, withConsole, withConsoleScoped;
var init_console4 = __esm({
  "node_modules/effect/dist/esm/internal/console.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Context();
    init_Function();
    init_core();
    init_defaultServices();
    init_console3();
    init_fiberRuntime();
    console2 = /* @__PURE__ */ map11(/* @__PURE__ */ fiberRefGet(currentServices), /* @__PURE__ */ get3(consoleTag));
    consoleWith = /* @__PURE__ */ __name((f) => fiberRefGetWith(currentServices, (services) => f(get3(services, consoleTag))), "consoleWith");
    withConsole = /* @__PURE__ */ dual(2, (effect4, value3) => fiberRefLocallyWith(effect4, currentServices, add2(consoleTag, value3)));
    withConsoleScoped = /* @__PURE__ */ __name((console4) => fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console4)), "withConsoleScoped");
  }
});

// node_modules/effect/dist/esm/Data.js
var struct2, array4, unsafeArray, Class4, Error3, TaggedError;
var init_Data = __esm({
  "node_modules/effect/dist/esm/Data.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_core();
    init_data();
    struct2 = struct;
    array4 = /* @__PURE__ */ __name((as12) => unsafeArray(as12.slice(0)), "array");
    unsafeArray = /* @__PURE__ */ __name((as12) => Object.setPrototypeOf(as12, ArrayProto), "unsafeArray");
    Class4 = Structural;
    Error3 = /* @__PURE__ */ (function() {
      const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
      const O = {
        BaseEffectError: class extends YieldableError {
          static {
            __name(this, "BaseEffectError");
          }
          constructor(args2) {
            super(args2?.message, args2?.cause ? {
              cause: args2.cause
            } : void 0);
            if (args2) {
              Object.assign(this, args2);
              Object.defineProperty(this, plainArgsSymbol, {
                value: args2,
                enumerable: false
              });
            }
          }
          toJSON() {
            return {
              ...this[plainArgsSymbol],
              ...this
            };
          }
        }
      };
      return O.BaseEffectError;
    })();
    TaggedError = /* @__PURE__ */ __name((tag2) => {
      const O = {
        BaseEffectError: class extends Error3 {
          static {
            __name(this, "BaseEffectError");
          }
          _tag = tag2;
        }
      };
      O.BaseEffectError.prototype.name = tag2;
      return O.BaseEffectError;
    }, "TaggedError");
  }
});

// node_modules/effect/dist/esm/internal/dateTime.js
var TypeId18, TimeZoneTypeId, Proto2, ProtoUtc, ProtoZoned, ProtoTimeZone, ProtoTimeZoneNamed, ProtoTimeZoneOffset, makeZonedProto, isDateTime, isDateTimeArgs, isTimeZone, isTimeZoneOffset, isTimeZoneNamed, isUtc, isZoned, Equivalence3, makeUtc, unsafeFromDate, unsafeMake10, hasZone, minEpochMillis, maxEpochMillis, unsafeMakeZoned, makeZoned, zonedStringRegex, makeZonedFromString, validZoneCache, formatOptions, zoneMakeIntl, zoneUnsafeMakeNamed, zoneMakeOffset, zoneMakeNamed, offsetZoneRegex, zoneFromString, zoneToString, toDateUtc, toDate, zonedOffset, offsetToString, zonedOffsetIso, toEpochMillis, dateToParts, toParts, toPartsUtc, setPartsDate, constDayMillis, makeZonedFromAdjusted, offsetRegex, parseOffset, calculateNamedOffset, mutate4, withDate, withDateUtc, formatIso, formatIsoOffset, formatIsoZoned;
var init_dateTime = __esm({
  "node_modules/effect/dist/esm/internal/dateTime.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Cause();
    init_Equal();
    init_Equivalence();
    init_Function();
    init_GlobalValue();
    init_Hash();
    init_Inspectable();
    init_Option();
    init_Pipeable();
    init_Predicate();
    TypeId18 = /* @__PURE__ */ Symbol.for("effect/DateTime");
    TimeZoneTypeId = /* @__PURE__ */ Symbol.for("effect/DateTime/TimeZone");
    Proto2 = {
      [TypeId18]: TypeId18,
      pipe() {
        return pipeArguments(this, arguments);
      },
      [NodeInspectSymbol]() {
        return this.toString();
      },
      toJSON() {
        return toDateUtc(this).toJSON();
      }
    };
    ProtoUtc = {
      ...Proto2,
      _tag: "Utc",
      [symbol]() {
        return cached(this, number2(this.epochMillis));
      },
      [symbol2](that) {
        return isDateTime(that) && that._tag === "Utc" && this.epochMillis === that.epochMillis;
      },
      toString() {
        return `DateTime.Utc(${toDateUtc(this).toJSON()})`;
      }
    };
    ProtoZoned = {
      ...Proto2,
      _tag: "Zoned",
      [symbol]() {
        return pipe(number2(this.epochMillis), combine(hash(this.zone)), cached(this));
      },
      [symbol2](that) {
        return isDateTime(that) && that._tag === "Zoned" && this.epochMillis === that.epochMillis && equals(this.zone, that.zone);
      },
      toString() {
        return `DateTime.Zoned(${formatIsoZoned(this)})`;
      }
    };
    ProtoTimeZone = {
      [TimeZoneTypeId]: TimeZoneTypeId,
      [NodeInspectSymbol]() {
        return this.toString();
      }
    };
    ProtoTimeZoneNamed = {
      ...ProtoTimeZone,
      _tag: "Named",
      [symbol]() {
        return cached(this, string(`Named:${this.id}`));
      },
      [symbol2](that) {
        return isTimeZone(that) && that._tag === "Named" && this.id === that.id;
      },
      toString() {
        return `TimeZone.Named(${this.id})`;
      },
      toJSON() {
        return {
          _id: "TimeZone",
          _tag: "Named",
          id: this.id
        };
      }
    };
    ProtoTimeZoneOffset = {
      ...ProtoTimeZone,
      _tag: "Offset",
      [symbol]() {
        return cached(this, string(`Offset:${this.offset}`));
      },
      [symbol2](that) {
        return isTimeZone(that) && that._tag === "Offset" && this.offset === that.offset;
      },
      toString() {
        return `TimeZone.Offset(${offsetToString(this.offset)})`;
      },
      toJSON() {
        return {
          _id: "TimeZone",
          _tag: "Offset",
          offset: this.offset
        };
      }
    };
    makeZonedProto = /* @__PURE__ */ __name((epochMillis, zone, partsUtc) => {
      const self2 = Object.create(ProtoZoned);
      self2.epochMillis = epochMillis;
      self2.zone = zone;
      Object.defineProperty(self2, "partsUtc", {
        value: partsUtc,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(self2, "adjustedEpochMillis", {
        value: void 0,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(self2, "partsAdjusted", {
        value: void 0,
        enumerable: false,
        writable: true
      });
      return self2;
    }, "makeZonedProto");
    isDateTime = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId18), "isDateTime");
    isDateTimeArgs = /* @__PURE__ */ __name((args2) => isDateTime(args2[0]), "isDateTimeArgs");
    isTimeZone = /* @__PURE__ */ __name((u) => hasProperty(u, TimeZoneTypeId), "isTimeZone");
    isTimeZoneOffset = /* @__PURE__ */ __name((u) => isTimeZone(u) && u._tag === "Offset", "isTimeZoneOffset");
    isTimeZoneNamed = /* @__PURE__ */ __name((u) => isTimeZone(u) && u._tag === "Named", "isTimeZoneNamed");
    isUtc = /* @__PURE__ */ __name((self2) => self2._tag === "Utc", "isUtc");
    isZoned = /* @__PURE__ */ __name((self2) => self2._tag === "Zoned", "isZoned");
    Equivalence3 = /* @__PURE__ */ make((a, b) => a.epochMillis === b.epochMillis);
    makeUtc = /* @__PURE__ */ __name((epochMillis) => {
      const self2 = Object.create(ProtoUtc);
      self2.epochMillis = epochMillis;
      Object.defineProperty(self2, "partsUtc", {
        value: void 0,
        enumerable: false,
        writable: true
      });
      return self2;
    }, "makeUtc");
    unsafeFromDate = /* @__PURE__ */ __name((date7) => {
      const epochMillis = date7.getTime();
      if (Number.isNaN(epochMillis)) {
        throw new IllegalArgumentException2("Invalid date");
      }
      return makeUtc(epochMillis);
    }, "unsafeFromDate");
    unsafeMake10 = /* @__PURE__ */ __name((input) => {
      if (isDateTime(input)) {
        return input;
      } else if (input instanceof Date) {
        return unsafeFromDate(input);
      } else if (typeof input === "object") {
        const date7 = /* @__PURE__ */ new Date(0);
        setPartsDate(date7, input);
        return unsafeFromDate(date7);
      } else if (typeof input === "string" && !hasZone(input)) {
        return unsafeFromDate(/* @__PURE__ */ new Date(input + "Z"));
      }
      return unsafeFromDate(new Date(input));
    }, "unsafeMake");
    hasZone = /* @__PURE__ */ __name((input) => /Z|[+-]\d{2}$|[+-]\d{2}:?\d{2}$|\]$/.test(input), "hasZone");
    minEpochMillis = -864e13 + 12 * 60 * 60 * 1e3;
    maxEpochMillis = 864e13 - 14 * 60 * 60 * 1e3;
    unsafeMakeZoned = /* @__PURE__ */ __name((input, options) => {
      if (options?.timeZone === void 0 && isDateTime(input) && isZoned(input)) {
        return input;
      }
      const self2 = unsafeMake10(input);
      if (self2.epochMillis < minEpochMillis || self2.epochMillis > maxEpochMillis) {
        throw new RangeError(`Epoch millis out of range: ${self2.epochMillis}`);
      }
      let zone;
      if (options?.timeZone === void 0) {
        const offset = new Date(self2.epochMillis).getTimezoneOffset() * -60 * 1e3;
        zone = zoneMakeOffset(offset);
      } else if (isTimeZone(options?.timeZone)) {
        zone = options.timeZone;
      } else if (typeof options?.timeZone === "number") {
        zone = zoneMakeOffset(options.timeZone);
      } else {
        const parsedZone = zoneFromString(options.timeZone);
        if (isNone2(parsedZone)) {
          throw new IllegalArgumentException2(`Invalid time zone: ${options.timeZone}`);
        }
        zone = parsedZone.value;
      }
      if (options?.adjustForTimeZone !== true) {
        return makeZonedProto(self2.epochMillis, zone, self2.partsUtc);
      }
      return makeZonedFromAdjusted(self2.epochMillis, zone, options?.disambiguation ?? "compatible");
    }, "unsafeMakeZoned");
    makeZoned = /* @__PURE__ */ liftThrowable(unsafeMakeZoned);
    zonedStringRegex = /^(.{17,35})\[(.+)\]$/;
    makeZonedFromString = /* @__PURE__ */ __name((input) => {
      const match20 = zonedStringRegex.exec(input);
      if (match20 === null) {
        const offset = parseOffset(input);
        return offset !== null ? makeZoned(input, {
          timeZone: offset
        }) : none2();
      }
      const [, isoString, timeZone] = match20;
      return makeZoned(isoString, {
        timeZone
      });
    }, "makeZonedFromString");
    validZoneCache = /* @__PURE__ */ globalValue("effect/DateTime/validZoneCache", () => /* @__PURE__ */ new Map());
    formatOptions = {
      day: "numeric",
      month: "numeric",
      year: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      timeZoneName: "longOffset",
      fractionalSecondDigits: 3,
      hourCycle: "h23"
    };
    zoneMakeIntl = /* @__PURE__ */ __name((format7) => {
      const zoneId = format7.resolvedOptions().timeZone;
      if (validZoneCache.has(zoneId)) {
        return validZoneCache.get(zoneId);
      }
      const zone = Object.create(ProtoTimeZoneNamed);
      zone.id = zoneId;
      zone.format = format7;
      validZoneCache.set(zoneId, zone);
      return zone;
    }, "zoneMakeIntl");
    zoneUnsafeMakeNamed = /* @__PURE__ */ __name((zoneId) => {
      if (validZoneCache.has(zoneId)) {
        return validZoneCache.get(zoneId);
      }
      try {
        return zoneMakeIntl(new Intl.DateTimeFormat("en-US", {
          ...formatOptions,
          timeZone: zoneId
        }));
      } catch {
        throw new IllegalArgumentException2(`Invalid time zone: ${zoneId}`);
      }
    }, "zoneUnsafeMakeNamed");
    zoneMakeOffset = /* @__PURE__ */ __name((offset) => {
      const zone = Object.create(ProtoTimeZoneOffset);
      zone.offset = offset;
      return zone;
    }, "zoneMakeOffset");
    zoneMakeNamed = /* @__PURE__ */ liftThrowable(zoneUnsafeMakeNamed);
    offsetZoneRegex = /^(?:GMT|[+-])/;
    zoneFromString = /* @__PURE__ */ __name((zone) => {
      if (offsetZoneRegex.test(zone)) {
        const offset = parseOffset(zone);
        return offset === null ? none2() : some2(zoneMakeOffset(offset));
      }
      return zoneMakeNamed(zone);
    }, "zoneFromString");
    zoneToString = /* @__PURE__ */ __name((self2) => {
      if (self2._tag === "Offset") {
        return offsetToString(self2.offset);
      }
      return self2.id;
    }, "zoneToString");
    toDateUtc = /* @__PURE__ */ __name((self2) => new Date(self2.epochMillis), "toDateUtc");
    toDate = /* @__PURE__ */ __name((self2) => {
      if (self2._tag === "Utc") {
        return new Date(self2.epochMillis);
      } else if (self2.zone._tag === "Offset") {
        return new Date(self2.epochMillis + self2.zone.offset);
      } else if (self2.adjustedEpochMillis !== void 0) {
        return new Date(self2.adjustedEpochMillis);
      }
      const parts2 = self2.zone.format.formatToParts(self2.epochMillis).filter((_) => _.type !== "literal");
      const date7 = /* @__PURE__ */ new Date(0);
      date7.setUTCFullYear(Number(parts2[2].value), Number(parts2[0].value) - 1, Number(parts2[1].value));
      date7.setUTCHours(Number(parts2[3].value), Number(parts2[4].value), Number(parts2[5].value), Number(parts2[6].value));
      self2.adjustedEpochMillis = date7.getTime();
      return date7;
    }, "toDate");
    zonedOffset = /* @__PURE__ */ __name((self2) => {
      const date7 = toDate(self2);
      return date7.getTime() - toEpochMillis(self2);
    }, "zonedOffset");
    offsetToString = /* @__PURE__ */ __name((offset) => {
      const abs2 = Math.abs(offset);
      let hours2 = Math.floor(abs2 / (60 * 60 * 1e3));
      let minutes2 = Math.round(abs2 % (60 * 60 * 1e3) / (60 * 1e3));
      if (minutes2 === 60) {
        hours2 += 1;
        minutes2 = 0;
      }
      return `${offset < 0 ? "-" : "+"}${String(hours2).padStart(2, "0")}:${String(minutes2).padStart(2, "0")}`;
    }, "offsetToString");
    zonedOffsetIso = /* @__PURE__ */ __name((self2) => offsetToString(zonedOffset(self2)), "zonedOffsetIso");
    toEpochMillis = /* @__PURE__ */ __name((self2) => self2.epochMillis, "toEpochMillis");
    dateToParts = /* @__PURE__ */ __name((date7) => ({
      millis: date7.getUTCMilliseconds(),
      seconds: date7.getUTCSeconds(),
      minutes: date7.getUTCMinutes(),
      hours: date7.getUTCHours(),
      day: date7.getUTCDate(),
      weekDay: date7.getUTCDay(),
      month: date7.getUTCMonth() + 1,
      year: date7.getUTCFullYear()
    }), "dateToParts");
    toParts = /* @__PURE__ */ __name((self2) => {
      if (self2._tag === "Utc") {
        return toPartsUtc(self2);
      } else if (self2.partsAdjusted !== void 0) {
        return self2.partsAdjusted;
      }
      self2.partsAdjusted = withDate(self2, dateToParts);
      return self2.partsAdjusted;
    }, "toParts");
    toPartsUtc = /* @__PURE__ */ __name((self2) => {
      if (self2.partsUtc !== void 0) {
        return self2.partsUtc;
      }
      self2.partsUtc = withDateUtc(self2, dateToParts);
      return self2.partsUtc;
    }, "toPartsUtc");
    setPartsDate = /* @__PURE__ */ __name((date7, parts2) => {
      if (parts2.year !== void 0) {
        date7.setUTCFullYear(parts2.year);
      }
      if (parts2.month !== void 0) {
        date7.setUTCMonth(parts2.month - 1);
      }
      if (parts2.day !== void 0) {
        date7.setUTCDate(parts2.day);
      }
      if (parts2.weekDay !== void 0) {
        const diff8 = parts2.weekDay - date7.getUTCDay();
        date7.setUTCDate(date7.getUTCDate() + diff8);
      }
      if (parts2.hours !== void 0) {
        date7.setUTCHours(parts2.hours);
      }
      if (parts2.minutes !== void 0) {
        date7.setUTCMinutes(parts2.minutes);
      }
      if (parts2.seconds !== void 0) {
        date7.setUTCSeconds(parts2.seconds);
      }
      if (parts2.millis !== void 0) {
        date7.setUTCMilliseconds(parts2.millis);
      }
    }, "setPartsDate");
    constDayMillis = 24 * 60 * 60 * 1e3;
    makeZonedFromAdjusted = /* @__PURE__ */ __name((adjustedMillis, zone, disambiguation) => {
      if (zone._tag === "Offset") {
        return makeZonedProto(adjustedMillis - zone.offset, zone);
      }
      const beforeOffset = calculateNamedOffset(adjustedMillis - constDayMillis, adjustedMillis, zone);
      const afterOffset = calculateNamedOffset(adjustedMillis + constDayMillis, adjustedMillis, zone);
      if (beforeOffset === afterOffset) {
        return makeZonedProto(adjustedMillis - beforeOffset, zone);
      }
      const isForwards = beforeOffset < afterOffset;
      const transitionMillis = beforeOffset - afterOffset;
      if (isForwards) {
        const currentAfterOffset = calculateNamedOffset(adjustedMillis - afterOffset, adjustedMillis, zone);
        if (currentAfterOffset === afterOffset) {
          return makeZonedProto(adjustedMillis - afterOffset, zone);
        }
        const before2 = makeZonedProto(adjustedMillis - beforeOffset, zone);
        const beforeAdjustedMillis = toDate(before2).getTime();
        if (adjustedMillis !== beforeAdjustedMillis) {
          switch (disambiguation) {
            case "reject": {
              const formatted = new Date(adjustedMillis).toISOString();
              throw new RangeError(`Gap time: ${formatted} does not exist in time zone ${zone.id}`);
            }
            case "earlier":
              return makeZonedProto(adjustedMillis - afterOffset, zone);
            case "compatible":
            case "later":
              return before2;
          }
        }
        return before2;
      }
      const currentBeforeOffset = calculateNamedOffset(adjustedMillis - beforeOffset, adjustedMillis, zone);
      if (currentBeforeOffset === beforeOffset) {
        if (disambiguation === "earlier" || disambiguation === "compatible") {
          return makeZonedProto(adjustedMillis - beforeOffset, zone);
        }
        const laterOffset = calculateNamedOffset(adjustedMillis - beforeOffset + transitionMillis, adjustedMillis + transitionMillis, zone);
        if (laterOffset === beforeOffset) {
          return makeZonedProto(adjustedMillis - beforeOffset, zone);
        }
        if (disambiguation === "reject") {
          const formatted = new Date(adjustedMillis).toISOString();
          throw new RangeError(`Ambiguous time: ${formatted} occurs twice in time zone ${zone.id}`);
        }
      }
      return makeZonedProto(adjustedMillis - afterOffset, zone);
    }, "makeZonedFromAdjusted");
    offsetRegex = /([+-])(\d{2}):(\d{2})$/;
    parseOffset = /* @__PURE__ */ __name((offset) => {
      const match20 = offsetRegex.exec(offset);
      if (match20 === null) {
        return null;
      }
      const [, sign2, hours2, minutes2] = match20;
      return (sign2 === "+" ? 1 : -1) * (Number(hours2) * 60 + Number(minutes2)) * 60 * 1e3;
    }, "parseOffset");
    calculateNamedOffset = /* @__PURE__ */ __name((utcMillis, adjustedMillis, zone) => {
      const offset = zone.format.formatToParts(utcMillis).find((_) => _.type === "timeZoneName")?.value ?? "";
      if (offset === "GMT") {
        return 0;
      }
      const result = parseOffset(offset);
      if (result === null) {
        return zonedOffset(makeZonedProto(adjustedMillis, zone));
      }
      return result;
    }, "calculateNamedOffset");
    mutate4 = /* @__PURE__ */ dual(isDateTimeArgs, (self2, f, options) => {
      if (self2._tag === "Utc") {
        const date7 = toDateUtc(self2);
        f(date7);
        return makeUtc(date7.getTime());
      }
      const adjustedDate = toDate(self2);
      const newAdjustedDate = new Date(adjustedDate.getTime());
      f(newAdjustedDate);
      return makeZonedFromAdjusted(newAdjustedDate.getTime(), self2.zone, options?.disambiguation ?? "compatible");
    });
    withDate = /* @__PURE__ */ dual(2, (self2, f) => f(toDate(self2)));
    withDateUtc = /* @__PURE__ */ dual(2, (self2, f) => f(toDateUtc(self2)));
    formatIso = /* @__PURE__ */ __name((self2) => toDateUtc(self2).toISOString(), "formatIso");
    formatIsoOffset = /* @__PURE__ */ __name((self2) => {
      const date7 = toDate(self2);
      return self2._tag === "Utc" ? date7.toISOString() : `${date7.toISOString().slice(0, -1)}${zonedOffsetIso(self2)}`;
    }, "formatIsoOffset");
    formatIsoZoned = /* @__PURE__ */ __name((self2) => self2.zone._tag === "Offset" ? formatIsoOffset(self2) : `${formatIsoOffset(self2)}[${self2.zone.id}]`, "formatIsoZoned");
  }
});

// node_modules/effect/dist/esm/String.js
var toUpperCase, toLowerCase, capitalize, uncapitalize, isNonEmpty6;
var init_String = __esm({
  "node_modules/effect/dist/esm/String.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    toUpperCase = /* @__PURE__ */ __name((self2) => self2.toUpperCase(), "toUpperCase");
    toLowerCase = /* @__PURE__ */ __name((self2) => self2.toLowerCase(), "toLowerCase");
    capitalize = /* @__PURE__ */ __name((self2) => {
      if (self2.length === 0) return self2;
      return toUpperCase(self2[0]) + self2.slice(1);
    }, "capitalize");
    uncapitalize = /* @__PURE__ */ __name((self2) => {
      if (self2.length === 0) return self2;
      return toLowerCase(self2[0]) + self2.slice(1);
    }, "uncapitalize");
    isNonEmpty6 = /* @__PURE__ */ __name((self2) => self2.length > 0, "isNonEmpty");
  }
});

// node_modules/effect/dist/esm/Cron.js
function aliasOrValue(field, aliases) {
  return aliases?.[field.toLocaleLowerCase()] ?? Number(field);
}
var TypeId19, CronProto, isCron, make42, nextLookupTable, ParseErrorTypeId, ParseError, parse2, match12, daysInMonth, next2, Equivalence4, restrictionsArrayEquals, restrictionsEquals, equals5, secondOptions, minuteOptions, hourOptions, dayOptions, monthOptions, weekdayOptions, parseSegment, splitStep, splitRange;
var init_Cron = __esm({
  "node_modules/effect/dist/esm/Cron.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Data();
    init_Either();
    init_Equal();
    init_Equivalence();
    init_Function();
    init_Hash();
    init_Inspectable();
    init_dateTime();
    init_Number();
    init_Option();
    init_Pipeable();
    init_Predicate();
    init_String();
    TypeId19 = /* @__PURE__ */ Symbol.for("effect/Cron");
    CronProto = {
      [TypeId19]: TypeId19,
      [symbol2](that) {
        return isCron(that) && equals5(this, that);
      },
      [symbol]() {
        return pipe(hash(this.tz), combine(array2(fromIterable2(this.seconds))), combine(array2(fromIterable2(this.minutes))), combine(array2(fromIterable2(this.hours))), combine(array2(fromIterable2(this.days))), combine(array2(fromIterable2(this.months))), combine(array2(fromIterable2(this.weekdays))), cached(this));
      },
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "Cron",
          tz: this.tz,
          seconds: fromIterable2(this.seconds),
          minutes: fromIterable2(this.minutes),
          hours: fromIterable2(this.hours),
          days: fromIterable2(this.days),
          months: fromIterable2(this.months),
          weekdays: fromIterable2(this.weekdays)
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    isCron = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId19), "isCron");
    make42 = /* @__PURE__ */ __name((values4) => {
      const o = Object.create(CronProto);
      o.seconds = new Set(sort(values4.seconds ?? [0], Order));
      o.minutes = new Set(sort(values4.minutes, Order));
      o.hours = new Set(sort(values4.hours, Order));
      o.days = new Set(sort(values4.days, Order));
      o.months = new Set(sort(values4.months, Order));
      o.weekdays = new Set(sort(values4.weekdays, Order));
      o.tz = fromNullable(values4.tz);
      const seconds2 = Array.from(o.seconds);
      const minutes2 = Array.from(o.minutes);
      const hours2 = Array.from(o.hours);
      const days2 = Array.from(o.days);
      const months = Array.from(o.months);
      const weekdays = Array.from(o.weekdays);
      o.first = {
        second: seconds2[0] ?? 0,
        minute: minutes2[0] ?? 0,
        hour: hours2[0] ?? 0,
        day: days2[0] ?? 1,
        month: (months[0] ?? 1) - 1,
        weekday: weekdays[0] ?? 0
      };
      o.next = {
        second: nextLookupTable(seconds2, 60),
        minute: nextLookupTable(minutes2, 60),
        hour: nextLookupTable(hours2, 24),
        day: nextLookupTable(days2, 32),
        month: nextLookupTable(months, 13),
        weekday: nextLookupTable(weekdays, 7)
      };
      return o;
    }, "make");
    nextLookupTable = /* @__PURE__ */ __name((values4, size15) => {
      const result = new Array(size15).fill(void 0);
      if (values4.length === 0) {
        return result;
      }
      let current2 = void 0;
      let index2 = values4.length - 1;
      for (let i = size15 - 1; i >= 0; i--) {
        while (index2 >= 0 && values4[index2] >= i) {
          current2 = values4[index2--];
        }
        result[i] = current2;
      }
      return result;
    }, "nextLookupTable");
    ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Cron/errors/ParseError");
    ParseError = class extends (/* @__PURE__ */ TaggedError("CronParseError")) {
      static {
        __name(this, "ParseError");
      }
      /**
       * @since 2.0.0
       */
      [ParseErrorTypeId] = ParseErrorTypeId;
    };
    parse2 = /* @__PURE__ */ __name((cron3, tz) => {
      const segments = cron3.split(" ").filter(isNonEmpty6);
      if (segments.length !== 5 && segments.length !== 6) {
        return left2(new ParseError({
          message: `Invalid number of segments in cron expression`,
          input: cron3
        }));
      }
      if (segments.length === 5) {
        segments.unshift("0");
      }
      const [seconds2, minutes2, hours2, days2, months, weekdays] = segments;
      const zone = tz === void 0 || isTimeZone(tz) ? right2(tz) : fromOption2(zoneFromString(tz), () => new ParseError({
        message: `Invalid time zone in cron expression`,
        input: tz
      }));
      return all({
        tz: zone,
        seconds: parseSegment(seconds2, secondOptions),
        minutes: parseSegment(minutes2, minuteOptions),
        hours: parseSegment(hours2, hourOptions),
        days: parseSegment(days2, dayOptions),
        months: parseSegment(months, monthOptions),
        weekdays: parseSegment(weekdays, weekdayOptions)
      }).pipe(map(make42));
    }, "parse");
    match12 = /* @__PURE__ */ __name((cron3, date7) => {
      const parts2 = unsafeMakeZoned(date7, {
        timeZone: getOrUndefined(cron3.tz)
      }).pipe(toParts);
      if (cron3.seconds.size !== 0 && !cron3.seconds.has(parts2.seconds)) {
        return false;
      }
      if (cron3.minutes.size !== 0 && !cron3.minutes.has(parts2.minutes)) {
        return false;
      }
      if (cron3.hours.size !== 0 && !cron3.hours.has(parts2.hours)) {
        return false;
      }
      if (cron3.months.size !== 0 && !cron3.months.has(parts2.month)) {
        return false;
      }
      if (cron3.days.size === 0 && cron3.weekdays.size === 0) {
        return true;
      }
      if (cron3.weekdays.size === 0) {
        return cron3.days.has(parts2.day);
      }
      if (cron3.days.size === 0) {
        return cron3.weekdays.has(parts2.weekDay);
      }
      return cron3.days.has(parts2.day) || cron3.weekdays.has(parts2.weekDay);
    }, "match");
    daysInMonth = /* @__PURE__ */ __name((date7) => new Date(Date.UTC(date7.getUTCFullYear(), date7.getUTCMonth() + 1, 0)).getUTCDate(), "daysInMonth");
    next2 = /* @__PURE__ */ __name((cron3, startFrom) => {
      const tz = getOrUndefined(cron3.tz);
      const zoned = unsafeMakeZoned(startFrom ?? /* @__PURE__ */ new Date(), {
        timeZone: tz
      });
      const utc = tz !== void 0 && isTimeZoneNamed(tz) && tz.id === "UTC";
      const adjustDst = utc ? constVoid : (current2) => {
        const adjusted = unsafeMakeZoned(current2, {
          timeZone: zoned.zone,
          adjustForTimeZone: true
        }).pipe(toDate);
        const drift = current2.getTime() - adjusted.getTime();
        if (drift > 0) {
          current2.setTime(current2.getTime() + drift);
        }
      };
      const result = mutate4(zoned, (current2) => {
        current2.setUTCSeconds(current2.getUTCSeconds() + 1, 0);
        for (let i = 0; i < 1e4; i++) {
          if (cron3.seconds.size !== 0) {
            const currentSecond = current2.getUTCSeconds();
            const nextSecond2 = cron3.next.second[currentSecond];
            if (nextSecond2 === void 0) {
              current2.setUTCMinutes(current2.getUTCMinutes() + 1, cron3.first.second);
              adjustDst(current2);
              continue;
            }
            if (nextSecond2 > currentSecond) {
              current2.setUTCSeconds(nextSecond2);
              adjustDst(current2);
              continue;
            }
          }
          if (cron3.minutes.size !== 0) {
            const currentMinute = current2.getUTCMinutes();
            const nextMinute2 = cron3.next.minute[currentMinute];
            if (nextMinute2 === void 0) {
              current2.setUTCHours(current2.getUTCHours() + 1, cron3.first.minute, cron3.first.second);
              adjustDst(current2);
              continue;
            }
            if (nextMinute2 > currentMinute) {
              current2.setUTCMinutes(nextMinute2, cron3.first.second);
              adjustDst(current2);
              continue;
            }
          }
          if (cron3.hours.size !== 0) {
            const currentHour = current2.getUTCHours();
            const nextHour2 = cron3.next.hour[currentHour];
            if (nextHour2 === void 0) {
              current2.setUTCDate(current2.getUTCDate() + 1);
              current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
              adjustDst(current2);
              continue;
            }
            if (nextHour2 > currentHour) {
              current2.setUTCHours(nextHour2, cron3.first.minute, cron3.first.second);
              adjustDst(current2);
              continue;
            }
          }
          if (cron3.weekdays.size !== 0 || cron3.days.size !== 0) {
            let a = Infinity;
            let b = Infinity;
            if (cron3.weekdays.size !== 0) {
              const currentWeekday = current2.getUTCDay();
              const nextWeekday = cron3.next.weekday[currentWeekday];
              a = nextWeekday === void 0 ? 7 - currentWeekday + cron3.first.weekday : nextWeekday - currentWeekday;
            }
            if (cron3.days.size !== 0 && a !== 0) {
              const currentDay = current2.getUTCDate();
              const nextDay2 = cron3.next.day[currentDay];
              b = nextDay2 === void 0 ? daysInMonth(current2) - currentDay + cron3.first.day : nextDay2 - currentDay;
            }
            const addDays = Math.min(a, b);
            if (addDays !== 0) {
              current2.setUTCDate(current2.getUTCDate() + addDays);
              current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
              adjustDst(current2);
              continue;
            }
          }
          if (cron3.months.size !== 0) {
            const currentMonth = current2.getUTCMonth() + 1;
            const nextMonth = cron3.next.month[currentMonth];
            if (nextMonth === void 0) {
              current2.setUTCFullYear(current2.getUTCFullYear() + 1);
              current2.setUTCMonth(cron3.first.month, cron3.first.day);
              current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
              adjustDst(current2);
              continue;
            }
            if (nextMonth > currentMonth) {
              current2.setUTCMonth(nextMonth - 1, cron3.first.day);
              current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
              adjustDst(current2);
              continue;
            }
          }
          return;
        }
        throw new Error("Unable to find next cron date");
      });
      return toDateUtc(result);
    }, "next");
    Equivalence4 = /* @__PURE__ */ make((self2, that) => restrictionsEquals(self2.seconds, that.seconds) && restrictionsEquals(self2.minutes, that.minutes) && restrictionsEquals(self2.hours, that.hours) && restrictionsEquals(self2.days, that.days) && restrictionsEquals(self2.months, that.months) && restrictionsEquals(self2.weekdays, that.weekdays));
    restrictionsArrayEquals = /* @__PURE__ */ array(number);
    restrictionsEquals = /* @__PURE__ */ __name((self2, that) => restrictionsArrayEquals(fromIterable2(self2), fromIterable2(that)), "restrictionsEquals");
    equals5 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence4(self2, that));
    secondOptions = {
      min: 0,
      max: 59
    };
    minuteOptions = {
      min: 0,
      max: 59
    };
    hourOptions = {
      min: 0,
      max: 23
    };
    dayOptions = {
      min: 1,
      max: 31
    };
    monthOptions = {
      min: 1,
      max: 12,
      aliases: {
        jan: 1,
        feb: 2,
        mar: 3,
        apr: 4,
        may: 5,
        jun: 6,
        jul: 7,
        aug: 8,
        sep: 9,
        oct: 10,
        nov: 11,
        dec: 12
      }
    };
    weekdayOptions = {
      min: 0,
      max: 6,
      aliases: {
        sun: 0,
        mon: 1,
        tue: 2,
        wed: 3,
        thu: 4,
        fri: 5,
        sat: 6
      }
    };
    parseSegment = /* @__PURE__ */ __name((input, options) => {
      const capacity7 = options.max - options.min + 1;
      const values4 = /* @__PURE__ */ new Set();
      const fields = input.split(",");
      for (const field of fields) {
        const [raw, step4] = splitStep(field);
        if (raw === "*" && step4 === void 0) {
          return right2(/* @__PURE__ */ new Set());
        }
        if (step4 !== void 0) {
          if (!Number.isInteger(step4)) {
            return left2(new ParseError({
              message: `Expected step value to be a positive integer`,
              input
            }));
          }
          if (step4 < 1) {
            return left2(new ParseError({
              message: `Expected step value to be greater than 0`,
              input
            }));
          }
          if (step4 > options.max) {
            return left2(new ParseError({
              message: `Expected step value to be less than ${options.max}`,
              input
            }));
          }
        }
        if (raw === "*") {
          for (let i = options.min; i <= options.max; i += step4 ?? 1) {
            values4.add(i);
          }
        } else {
          const [left3, right3] = splitRange(raw, options.aliases);
          if (!Number.isInteger(left3)) {
            return left2(new ParseError({
              message: `Expected a positive integer`,
              input
            }));
          }
          if (left3 < options.min || left3 > options.max) {
            return left2(new ParseError({
              message: `Expected a value between ${options.min} and ${options.max}`,
              input
            }));
          }
          if (right3 === void 0) {
            values4.add(left3);
          } else {
            if (!Number.isInteger(right3)) {
              return left2(new ParseError({
                message: `Expected a positive integer`,
                input
              }));
            }
            if (right3 < options.min || right3 > options.max) {
              return left2(new ParseError({
                message: `Expected a value between ${options.min} and ${options.max}`,
                input
              }));
            }
            if (left3 > right3) {
              return left2(new ParseError({
                message: `Invalid value range`,
                input
              }));
            }
            for (let i = left3; i <= right3; i += step4 ?? 1) {
              values4.add(i);
            }
          }
        }
        if (values4.size >= capacity7) {
          return right2(/* @__PURE__ */ new Set());
        }
      }
      return right2(values4);
    }, "parseSegment");
    splitStep = /* @__PURE__ */ __name((input) => {
      const seperator = input.indexOf("/");
      if (seperator !== -1) {
        return [input.slice(0, seperator), Number(input.slice(seperator + 1))];
      }
      return [input, void 0];
    }, "splitStep");
    splitRange = /* @__PURE__ */ __name((input, aliases) => {
      const seperator = input.indexOf("-");
      if (seperator !== -1) {
        return [aliasOrValue(input.slice(0, seperator), aliases), aliasOrValue(input.slice(seperator + 1), aliases)];
      }
      return [aliasOrValue(input, aliases), void 0];
    }, "splitRange");
    __name(aliasOrValue, "aliasOrValue");
  }
});

// node_modules/effect/dist/esm/Random.js
var next3, fixed2;
var init_Random2 = __esm({
  "node_modules/effect/dist/esm/Random.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_defaultServices();
    init_random();
    next3 = next;
    fixed2 = fixed;
  }
});

// node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey, ScheduleTypeId, isSchedule, ScheduleDriverSymbolKey, ScheduleDriverTypeId, defaultIterationMetadata, CurrentIterationMetadata, scheduleVariance, scheduleDriverVariance, ScheduleImpl, updateInfo, ScheduleDriverImpl, makeWithState, addDelay, addDelayEffect, andThen5, andThenEither, as5, asVoid3, bothInOut, check2, checkEffect, collectAllInputs, collectAllOutputs, collectUntil, collectUntilEffect, collectWhile, collectWhileEffect, compose2, mapInput3, mapInputContext2, mapInputEffect, cron, dayOfMonth, dayOfWeek, delayed, delayedEffect, delayedSchedule, delays, mapBoth4, mapBothEffect, driver, duration, either3, eitherWith, ensuring2, exponential2, fibonacci, fixed3, fromDelay, fromDelays, fromFunction2, hourOfDay, identity3, intersect5, intersectWith, intersectWithLoop, jittered, jitteredWith, linear, map17, mapEffect2, minuteOfHour, modifyDelay, modifyDelayEffect, onDecision, passthrough2, provideContext3, provideService2, recurUntil, recurUntilEffect, recurUntilOption, recurUpTo, recurWhile, recurWhileEffect, recurs, reduce11, reduceEffect2, repetitions, resetAfter, resetWhen, run, runLoop, secondOfMinute, spaced, succeed7, sync4, tapInput, tapOutput, unfold2, union9, unionWith2, untilInput, untilInputEffect, untilOutput, untilOutputEffect, upTo, whileInput, whileInputEffect, whileOutput, whileOutputEffect, windowed, zipLeft3, zipRight4, zipWith6, beginningOfSecond, endOfSecond, nextSecond, beginningOfMinute, endOfMinute, nextMinute, beginningOfHour, endOfHour, nextHour, beginningOfDay, endOfDay, nextDay, nextDayOfMonth, findNextMonth, ScheduleDefectTypeId, ScheduleDefect, isScheduleDefect, scheduleDefectWrap, scheduleDefectRefailCause, scheduleDefectRefail, repeat_Effect, repeat_combined, repeatOrElse_Effect, repeatOrElseEffectLoop, retry_Effect, retry_combined, fromRetryOptions, retryOrElse_Effect, retryOrElse_EffectLoop, schedule_Effect, scheduleFrom_Effect, scheduleFrom_EffectLoop, count3, elapsed, forever2, once3, stop, scheduleForked;
var init_schedule = __esm({
  "node_modules/effect/dist/esm/internal/schedule.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Chunk();
    init_Clock();
    init_Context();
    init_Cron();
    init_Duration();
    init_Either();
    init_Equal();
    init_Function();
    init_Option();
    init_Pipeable();
    init_Predicate();
    init_Random2();
    init_ScheduleDecision();
    init_ScheduleInterval();
    init_ScheduleIntervals();
    init_cause2();
    init_core_effect();
    init_core();
    init_circular();
    init_ref();
    ScheduleSymbolKey = "effect/Schedule";
    ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
    isSchedule = /* @__PURE__ */ __name((u) => hasProperty(u, ScheduleTypeId), "isSchedule");
    ScheduleDriverSymbolKey = "effect/ScheduleDriver";
    ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
    defaultIterationMetadata = {
      start: 0,
      now: 0,
      input: void 0,
      output: void 0,
      elapsed: zero2,
      elapsedSincePrevious: zero2,
      recurrence: 0
    };
    CurrentIterationMetadata = /* @__PURE__ */ Reference2()("effect/Schedule/CurrentIterationMetadata", {
      defaultValue: /* @__PURE__ */ __name(() => defaultIterationMetadata, "defaultValue")
    });
    scheduleVariance = {
      /* c8 ignore next */
      _Out: /* @__PURE__ */ __name((_) => _, "_Out"),
      /* c8 ignore next */
      _In: /* @__PURE__ */ __name((_) => _, "_In"),
      /* c8 ignore next */
      _R: /* @__PURE__ */ __name((_) => _, "_R")
    };
    scheduleDriverVariance = {
      /* c8 ignore next */
      _Out: /* @__PURE__ */ __name((_) => _, "_Out"),
      /* c8 ignore next */
      _In: /* @__PURE__ */ __name((_) => _, "_In"),
      /* c8 ignore next */
      _R: /* @__PURE__ */ __name((_) => _, "_R")
    };
    ScheduleImpl = class {
      static {
        __name(this, "ScheduleImpl");
      }
      initial;
      step;
      [ScheduleTypeId] = scheduleVariance;
      constructor(initial, step4) {
        this.initial = initial;
        this.step = step4;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    updateInfo = /* @__PURE__ */ __name((iterationMetaRef, now2, input, output) => update2(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
      now: now2,
      input,
      output,
      recurrence: prev.recurrence + 1,
      elapsed: zero2,
      elapsedSincePrevious: zero2,
      start: now2
    } : {
      now: now2,
      input,
      output,
      recurrence: prev.recurrence + 1,
      elapsed: millis(now2 - prev.start),
      elapsedSincePrevious: millis(now2 - prev.now),
      start: prev.start
    }), "updateInfo");
    ScheduleDriverImpl = class {
      static {
        __name(this, "ScheduleDriverImpl");
      }
      schedule;
      ref;
      [ScheduleDriverTypeId] = scheduleDriverVariance;
      constructor(schedule4, ref2) {
        this.schedule = schedule4;
        this.ref = ref2;
      }
      get state() {
        return map11(get11(this.ref), (tuple4) => tuple4[1]);
      }
      get last() {
        return flatMap8(get11(this.ref), ([element2, _]) => {
          switch (element2._tag) {
            case "None": {
              return failSync(() => new NoSuchElementException());
            }
            case "Some": {
              return succeed(element2.value);
            }
          }
        });
      }
      iterationMeta = /* @__PURE__ */ unsafeMake6(defaultIterationMetadata);
      get reset() {
        return set5(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft2(set5(this.iterationMeta, defaultIterationMetadata)));
      }
      next(input) {
        return pipe(map11(get11(this.ref), (tuple4) => tuple4[1]), flatMap8((state) => pipe(currentTimeMillis2, flatMap8((now2) => pipe(suspend(() => this.schedule.step(now2, input, state)), flatMap8(([state2, out, decision]) => {
          const setState = set5(this.ref, [some2(out), state2]);
          if (isDone5(decision)) {
            return setState.pipe(zipRight2(fail2(none2())));
          }
          const millis2 = start2(decision.intervals) - now2;
          if (millis2 <= 0) {
            return setState.pipe(zipRight2(updateInfo(this.iterationMeta, now2, input, out)), as2(out));
          }
          const duration6 = millis(millis2);
          return pipe(setState, zipRight2(updateInfo(this.iterationMeta, now2, input, out)), zipRight2(sleep3(duration6)), as2(out));
        }))))));
      }
    };
    makeWithState = /* @__PURE__ */ __name((initial, step4) => new ScheduleImpl(initial, step4), "makeWithState");
    addDelay = /* @__PURE__ */ dual(2, (self2, f) => addDelayEffect(self2, (out) => sync(() => f(out))));
    addDelayEffect = /* @__PURE__ */ dual(2, (self2, f) => modifyDelayEffect(self2, (out, duration6) => map11(f(out), (delay3) => sum(duration6, decode(delay3)))));
    andThen5 = /* @__PURE__ */ dual(2, (self2, that) => map17(andThenEither(self2, that), merge));
    andThenEither = /* @__PURE__ */ dual(2, (self2, that) => makeWithState([self2.initial, that.initial, true], (now2, input, state) => state[2] ? flatMap8(self2.step(now2, input, state[0]), ([lState, out, decision]) => {
      if (isDone5(decision)) {
        return map11(that.step(now2, input, state[1]), ([rState, out2, decision2]) => [[lState, rState, false], right2(out2), decision2]);
      }
      return succeed([[lState, state[1], true], left2(out), decision]);
    }) : map11(that.step(now2, input, state[1]), ([rState, out, decision]) => [[state[0], rState, false], right2(out), decision])));
    as5 = /* @__PURE__ */ dual(2, (self2, out) => map17(self2, () => out));
    asVoid3 = /* @__PURE__ */ __name((self2) => map17(self2, constVoid), "asVoid");
    bothInOut = /* @__PURE__ */ dual(2, (self2, that) => makeWithState([self2.initial, that.initial], (now2, [in1, in2], state) => zipWith4(self2.step(now2, in1, state[0]), that.step(now2, in2, state[1]), ([lState, out, lDecision], [rState, out2, rDecision]) => {
      if (isContinue2(lDecision) && isContinue2(rDecision)) {
        const interval = pipe(lDecision.intervals, union8(rDecision.intervals));
        return [[lState, rState], [out, out2], _continue2(interval)];
      }
      return [[lState, rState], [out, out2], done6];
    })));
    check2 = /* @__PURE__ */ dual(2, (self2, test) => checkEffect(self2, (input, out) => sync(() => test(input, out))));
    checkEffect = /* @__PURE__ */ dual(2, (self2, test) => makeWithState(self2.initial, (now2, input, state) => flatMap8(self2.step(now2, input, state), ([state2, out, decision]) => {
      if (isDone5(decision)) {
        return succeed([state2, out, done6]);
      }
      return map11(test(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done6]);
    })));
    collectAllInputs = /* @__PURE__ */ __name(() => collectAllOutputs(identity3()), "collectAllInputs");
    collectAllOutputs = /* @__PURE__ */ __name((self2) => reduce11(self2, empty5(), (outs, out) => pipe(outs, append2(out))), "collectAllOutputs");
    collectUntil = /* @__PURE__ */ __name((f) => collectAllOutputs(recurUntil(f)), "collectUntil");
    collectUntilEffect = /* @__PURE__ */ __name((f) => collectAllOutputs(recurUntilEffect(f)), "collectUntilEffect");
    collectWhile = /* @__PURE__ */ __name((f) => collectAllOutputs(recurWhile(f)), "collectWhile");
    collectWhileEffect = /* @__PURE__ */ __name((f) => collectAllOutputs(recurWhileEffect(f)), "collectWhileEffect");
    compose2 = /* @__PURE__ */ dual(2, (self2, that) => makeWithState([self2.initial, that.initial], (now2, input, state) => flatMap8(self2.step(now2, input, state[0]), ([lState, out, lDecision]) => map11(that.step(now2, out, state[1]), ([rState, out2, rDecision]) => isDone5(lDecision) ? [[lState, rState], out2, done6] : isDone5(rDecision) ? [[lState, rState], out2, done6] : [[lState, rState], out2, _continue2(pipe(lDecision.intervals, max4(rDecision.intervals)))]))));
    mapInput3 = /* @__PURE__ */ dual(2, (self2, f) => mapInputEffect(self2, (input2) => sync(() => f(input2))));
    mapInputContext2 = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state) => mapInputContext(self2.step(now2, input, state), f)));
    mapInputEffect = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input2, state) => flatMap8(f(input2), (input) => self2.step(now2, input, state))));
    cron = /* @__PURE__ */ __name((expression, tz) => {
      const parsed = isCron(expression) ? right2(expression) : parse2(expression, tz);
      return makeWithState([true, [Number.MIN_SAFE_INTEGER, 0, 0]], (now2, _, [initial, previous2]) => {
        if (now2 < previous2[0]) {
          return succeed([[false, previous2], [previous2[1], previous2[2]], continueWith2(make37(previous2[1], previous2[2]))]);
        }
        if (isLeft2(parsed)) {
          return die2(parsed.left);
        }
        const cron3 = parsed.right;
        const date7 = new Date(now2);
        let next4;
        if (initial && match12(cron3, date7)) {
          next4 = now2;
        }
        next4 = next2(cron3, date7).getTime();
        const start5 = beginningOfSecond(next4);
        const end6 = endOfSecond(next4);
        return succeed([[false, [next4, start5, end6]], [start5, end6], continueWith2(make37(start5, end6))]);
      });
    }, "cron");
    dayOfMonth = /* @__PURE__ */ __name((day) => {
      return makeWithState([Number.NEGATIVE_INFINITY, 0], (now2, _, state) => {
        if (!Number.isInteger(day) || day < 1 || 31 < day) {
          return dieSync(() => new IllegalArgumentException(`Invalid argument in: dayOfMonth(${day}). Must be in range 1...31`));
        }
        const n = state[1];
        const initial = n === 0;
        const day0 = nextDayOfMonth(now2, day, initial);
        const start5 = beginningOfDay(day0);
        const end6 = endOfDay(day0);
        const interval = make37(start5, end6);
        return succeed([[end6, n + 1], n, continueWith2(interval)]);
      });
    }, "dayOfMonth");
    dayOfWeek = /* @__PURE__ */ __name((day) => {
      return makeWithState([Number.MIN_SAFE_INTEGER, 0], (now2, _, state) => {
        if (!Number.isInteger(day) || day < 1 || 7 < day) {
          return dieSync(() => new IllegalArgumentException(`Invalid argument in: dayOfWeek(${day}). Must be in range 1 (Monday)...7 (Sunday)`));
        }
        const n = state[1];
        const initial = n === 0;
        const day0 = nextDay(now2, day, initial);
        const start5 = beginningOfDay(day0);
        const end6 = endOfDay(day0);
        const interval = make37(start5, end6);
        return succeed([[end6, n + 1], n, continueWith2(interval)]);
      });
    }, "dayOfWeek");
    delayed = /* @__PURE__ */ dual(2, (self2, f) => delayedEffect(self2, (duration6) => sync(() => f(duration6))));
    delayedEffect = /* @__PURE__ */ dual(2, (self2, f) => modifyDelayEffect(self2, (_, delay3) => f(delay3)));
    delayedSchedule = /* @__PURE__ */ __name((schedule4) => addDelay(schedule4, (x) => x), "delayedSchedule");
    delays = /* @__PURE__ */ __name((self2) => makeWithState(self2.initial, (now2, input, state) => pipe(self2.step(now2, input, state), flatMap8(([state2, _, decision]) => {
      if (isDone5(decision)) {
        return succeed([state2, zero2, decision]);
      }
      return succeed([state2, millis(start2(decision.intervals) - now2), decision]);
    }))), "delays");
    mapBoth4 = /* @__PURE__ */ dual(2, (self2, {
      onInput,
      onOutput
    }) => map17(mapInput3(self2, onInput), onOutput));
    mapBothEffect = /* @__PURE__ */ dual(2, (self2, {
      onInput,
      onOutput
    }) => mapEffect2(mapInputEffect(self2, onInput), onOutput));
    driver = /* @__PURE__ */ __name((self2) => pipe(make28([none2(), self2.initial]), map11((ref2) => new ScheduleDriverImpl(self2, ref2))), "driver");
    duration = /* @__PURE__ */ __name((durationInput) => {
      const duration6 = decode(durationInput);
      const durationMillis = toMillis(duration6);
      return makeWithState(true, (now2, _, state) => succeed(state ? [false, duration6, continueWith2(after2(now2 + durationMillis))] : [false, zero2, done6]));
    }, "duration");
    either3 = /* @__PURE__ */ dual(2, (self2, that) => union9(self2, that));
    eitherWith = /* @__PURE__ */ dual(3, (self2, that, f) => unionWith2(self2, that, f));
    ensuring2 = /* @__PURE__ */ dual(2, (self2, finalizer3) => makeWithState(self2.initial, (now2, input, state) => flatMap8(self2.step(now2, input, state), ([state2, out, decision]) => isDone5(decision) ? as2(finalizer3, [state2, out, decision]) : succeed([state2, out, decision]))));
    exponential2 = /* @__PURE__ */ __name((baseInput, factor = 2) => {
      const base = decode(baseInput);
      return delayedSchedule(map17(forever2, (i) => times(base, Math.pow(factor, i))));
    }, "exponential");
    fibonacci = /* @__PURE__ */ __name((oneInput) => {
      const one = decode(oneInput);
      return delayedSchedule(pipe(unfold2([one, one], ([a, b]) => [b, sum(a, b)]), map17((out) => out[0])));
    }, "fibonacci");
    fixed3 = /* @__PURE__ */ __name((intervalInput) => {
      const interval = decode(intervalInput);
      const intervalMillis = toMillis(interval);
      return makeWithState([none2(), 0], (now2, _, [option5, n]) => sync(() => {
        switch (option5._tag) {
          case "None": {
            return [[some2([now2, now2 + intervalMillis]), n + 1], n, continueWith2(after2(now2 + intervalMillis))];
          }
          case "Some": {
            const [startMillis, lastRun] = option5.value;
            const runningBehind = now2 > lastRun + intervalMillis;
            const boundary = equals(interval, zero2) ? interval : millis(intervalMillis - (now2 - startMillis) % intervalMillis);
            const sleepTime = equals(boundary, zero2) ? interval : boundary;
            const nextRun = runningBehind ? now2 : now2 + toMillis(sleepTime);
            return [[some2([startMillis, nextRun]), n + 1], n, continueWith2(after2(nextRun))];
          }
        }
      }));
    }, "fixed");
    fromDelay = /* @__PURE__ */ __name((delay3) => duration(delay3), "fromDelay");
    fromDelays = /* @__PURE__ */ __name((delay3, ...delays3) => makeWithState([[delay3, ...delays3].map((_) => decode(_)), true], (now2, _, [durations, cont]) => sync(() => {
      if (cont) {
        const x = durations[0];
        const interval = after2(now2 + toMillis(x));
        if (durations.length >= 2) {
          return [[durations.slice(1), true], x, continueWith2(interval)];
        }
        const y = durations.slice(1);
        return [[[x, ...y], false], x, continueWith2(interval)];
      }
      return [[durations, false], zero2, done6];
    })), "fromDelays");
    fromFunction2 = /* @__PURE__ */ __name((f) => map17(identity3(), f), "fromFunction");
    hourOfDay = /* @__PURE__ */ __name((hour) => makeWithState([Number.NEGATIVE_INFINITY, 0], (now2, _, state) => {
      if (!Number.isInteger(hour) || hour < 0 || 23 < hour) {
        return dieSync(() => new IllegalArgumentException(`Invalid argument in: hourOfDay(${hour}). Must be in range 0...23`));
      }
      const n = state[1];
      const initial = n === 0;
      const hour0 = nextHour(now2, hour, initial);
      const start5 = beginningOfHour(hour0);
      const end6 = endOfHour(hour0);
      const interval = make37(start5, end6);
      return succeed([[end6, n + 1], n, continueWith2(interval)]);
    }), "hourOfDay");
    identity3 = /* @__PURE__ */ __name(() => makeWithState(void 0, (now2, input, state) => succeed([state, input, continueWith2(after2(now2))])), "identity");
    intersect5 = /* @__PURE__ */ dual(2, (self2, that) => intersectWith(self2, that, intersect4));
    intersectWith = /* @__PURE__ */ dual(3, (self2, that, f) => makeWithState([self2.initial, that.initial], (now2, input, state) => pipe(zipWith4(self2.step(now2, input, state[0]), that.step(now2, input, state[1]), (a, b) => [a, b]), flatMap8(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
      if (isContinue2(lDecision) && isContinue2(rDecision)) {
        return intersectWithLoop(self2, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
      }
      return succeed([[lState, rState], [out, out2], done6]);
    }))));
    intersectWithLoop = /* @__PURE__ */ __name((self2, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
      const combined = f(lInterval, rInterval);
      if (isNonEmpty5(combined)) {
        return succeed([[lState, rState], [out, out2], _continue2(combined)]);
      }
      if (pipe(lInterval, lessThan7(rInterval))) {
        return flatMap8(self2.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
          if (isDone5(decision)) {
            return succeed([[lState2, rState], [out3, out2], done6]);
          }
          return intersectWithLoop(self2, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
        });
      }
      return flatMap8(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
        if (isDone5(decision)) {
          return succeed([[lState, rState2], [out, out22], done6]);
        }
        return intersectWithLoop(self2, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
      });
    }, "intersectWithLoop");
    jittered = /* @__PURE__ */ __name((self2) => jitteredWith(self2, {
      min: 0.8,
      max: 1.2
    }), "jittered");
    jitteredWith = /* @__PURE__ */ dual(2, (self2, options) => {
      const {
        max: max6,
        min: min4
      } = Object.assign({
        min: 0.8,
        max: 1.2
      }, options);
      return delayedEffect(self2, (duration6) => map11(next3, (random4) => {
        const d = toMillis(duration6);
        const jittered3 = d * min4 * (1 - random4) + d * max6 * random4;
        return millis(jittered3);
      }));
    });
    linear = /* @__PURE__ */ __name((baseInput) => {
      const base = decode(baseInput);
      return delayedSchedule(map17(forever2, (i) => times(base, i + 1)));
    }, "linear");
    map17 = /* @__PURE__ */ dual(2, (self2, f) => mapEffect2(self2, (out) => sync(() => f(out))));
    mapEffect2 = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state) => flatMap8(self2.step(now2, input, state), ([state2, out, decision]) => map11(f(out), (out2) => [state2, out2, decision]))));
    minuteOfHour = /* @__PURE__ */ __name((minute) => makeWithState([Number.MIN_SAFE_INTEGER, 0], (now2, _, state) => {
      if (!Number.isInteger(minute) || minute < 0 || 59 < minute) {
        return dieSync(() => new IllegalArgumentException(`Invalid argument in: minuteOfHour(${minute}). Must be in range 0...59`));
      }
      const n = state[1];
      const initial = n === 0;
      const minute0 = nextMinute(now2, minute, initial);
      const start5 = beginningOfMinute(minute0);
      const end6 = endOfMinute(minute0);
      const interval = make37(start5, end6);
      return succeed([[end6, n + 1], n, continueWith2(interval)]);
    }), "minuteOfHour");
    modifyDelay = /* @__PURE__ */ dual(2, (self2, f) => modifyDelayEffect(self2, (out, duration6) => sync(() => f(out, duration6))));
    modifyDelayEffect = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state) => flatMap8(self2.step(now2, input, state), ([state2, out, decision]) => {
      if (isDone5(decision)) {
        return succeed([state2, out, decision]);
      }
      const intervals = decision.intervals;
      const delay3 = size9(make37(now2, start2(intervals)));
      return map11(f(out, delay3), (durationInput) => {
        const duration6 = decode(durationInput);
        const oldStart = start2(intervals);
        const newStart = now2 + toMillis(duration6);
        const delta = newStart - oldStart;
        const newEnd = Math.max(0, end2(intervals) + delta);
        const newInterval = make37(newStart, newEnd);
        return [state2, out, continueWith2(newInterval)];
      });
    })));
    onDecision = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state) => flatMap8(self2.step(now2, input, state), ([state2, out, decision]) => as2(f(out, decision), [state2, out, decision]))));
    passthrough2 = /* @__PURE__ */ __name((self2) => makeWithState(self2.initial, (now2, input, state) => pipe(self2.step(now2, input, state), map11(([state2, _, decision]) => [state2, input, decision]))), "passthrough");
    provideContext3 = /* @__PURE__ */ dual(2, (self2, context10) => makeWithState(self2.initial, (now2, input, state) => provideContext(self2.step(now2, input, state), context10)));
    provideService2 = /* @__PURE__ */ dual(3, (self2, tag2, service3) => makeWithState(self2.initial, (now2, input, state) => contextWithEffect((env2) => provideContext(
      // @ts-expect-error
      self2.step(now2, input, state),
      add2(env2, tag2, service3)
    ))));
    recurUntil = /* @__PURE__ */ __name((f) => untilInput(identity3(), f), "recurUntil");
    recurUntilEffect = /* @__PURE__ */ __name((f) => untilInputEffect(identity3(), f), "recurUntilEffect");
    recurUntilOption = /* @__PURE__ */ __name((pf) => untilOutput(map17(identity3(), pf), isSome2), "recurUntilOption");
    recurUpTo = /* @__PURE__ */ __name((durationInput) => {
      const duration6 = decode(durationInput);
      return whileOutput(elapsed, (elapsed3) => lessThan3(elapsed3, duration6));
    }, "recurUpTo");
    recurWhile = /* @__PURE__ */ __name((f) => whileInput(identity3(), f), "recurWhile");
    recurWhileEffect = /* @__PURE__ */ __name((f) => whileInputEffect(identity3(), f), "recurWhileEffect");
    recurs = /* @__PURE__ */ __name((n) => whileOutput(forever2, (out) => out < n), "recurs");
    reduce11 = /* @__PURE__ */ dual(3, (self2, zero3, f) => reduceEffect2(self2, zero3, (z2, out) => sync(() => f(z2, out))));
    reduceEffect2 = /* @__PURE__ */ dual(3, (self2, zero3, f) => makeWithState([self2.initial, zero3], (now2, input, [s, z2]) => flatMap8(self2.step(now2, input, s), ([s2, out, decision]) => isDone5(decision) ? succeed([[s2, z2], z2, decision]) : map11(f(z2, out), (z22) => [[s2, z22], z2, decision]))));
    repetitions = /* @__PURE__ */ __name((self2) => reduce11(self2, 0, (n, _) => n + 1), "repetitions");
    resetAfter = /* @__PURE__ */ dual(2, (self2, durationInput) => {
      const duration6 = decode(durationInput);
      return pipe(self2, intersect5(elapsed), resetWhen(([, time5]) => greaterThanOrEqualTo3(time5, duration6)), map17((out) => out[0]));
    });
    resetWhen = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state) => flatMap8(self2.step(now2, input, state), ([state2, out, decision]) => f(out) ? self2.step(now2, input, self2.initial) : succeed([state2, out, decision]))));
    run = /* @__PURE__ */ dual(3, (self2, now2, input) => pipe(runLoop(self2, now2, fromIterable3(input), self2.initial, empty5()), map11((list) => reverse2(list))));
    runLoop = /* @__PURE__ */ __name((self2, now2, inputs, state, acc) => {
      if (!isNonEmpty2(inputs)) {
        return succeed(acc);
      }
      const input = headNonEmpty2(inputs);
      const nextInputs = tailNonEmpty2(inputs);
      return flatMap8(self2.step(now2, input, state), ([state2, out, decision]) => {
        if (isDone5(decision)) {
          return sync(() => pipe(acc, prepend2(out)));
        }
        return runLoop(self2, start2(decision.intervals), nextInputs, state2, prepend2(acc, out));
      });
    }, "runLoop");
    secondOfMinute = /* @__PURE__ */ __name((second) => makeWithState([Number.NEGATIVE_INFINITY, 0], (now2, _, state) => {
      if (!Number.isInteger(second) || second < 0 || 59 < second) {
        return dieSync(() => new IllegalArgumentException(`Invalid argument in: secondOfMinute(${second}). Must be in range 0...59`));
      }
      const n = state[1];
      const initial = n === 0;
      const second0 = nextSecond(now2, second, initial);
      const start5 = beginningOfSecond(second0);
      const end6 = endOfSecond(second0);
      const interval = make37(start5, end6);
      return succeed([[end6, n + 1], n, continueWith2(interval)]);
    }), "secondOfMinute");
    spaced = /* @__PURE__ */ __name((duration6) => addDelay(forever2, () => duration6), "spaced");
    succeed7 = /* @__PURE__ */ __name((value3) => map17(forever2, () => value3), "succeed");
    sync4 = /* @__PURE__ */ __name((evaluate3) => map17(forever2, evaluate3), "sync");
    tapInput = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state) => zipRight2(f(input), self2.step(now2, input, state))));
    tapOutput = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state) => tap2(self2.step(now2, input, state), ([, out]) => f(out))));
    unfold2 = /* @__PURE__ */ __name((initial, f) => makeWithState(initial, (now2, _, state) => sync(() => [f(state), state, continueWith2(after2(now2))])), "unfold");
    union9 = /* @__PURE__ */ dual(2, (self2, that) => unionWith2(self2, that, union8));
    unionWith2 = /* @__PURE__ */ dual(3, (self2, that, f) => makeWithState([self2.initial, that.initial], (now2, input, state) => zipWith4(self2.step(now2, input, state[0]), that.step(now2, input, state[1]), ([lState, l, lDecision], [rState, r, rDecision]) => {
      if (isDone5(lDecision) && isDone5(rDecision)) {
        return [[lState, rState], [l, r], done6];
      }
      if (isDone5(lDecision) && isContinue2(rDecision)) {
        return [[lState, rState], [l, r], _continue2(rDecision.intervals)];
      }
      if (isContinue2(lDecision) && isDone5(rDecision)) {
        return [[lState, rState], [l, r], _continue2(lDecision.intervals)];
      }
      if (isContinue2(lDecision) && isContinue2(rDecision)) {
        const combined = f(lDecision.intervals, rDecision.intervals);
        return [[lState, rState], [l, r], _continue2(combined)];
      }
      throw new Error("BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/effect/issues");
    })));
    untilInput = /* @__PURE__ */ dual(2, (self2, f) => check2(self2, (input, _) => !f(input)));
    untilInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => negate(f(input))));
    untilOutput = /* @__PURE__ */ dual(2, (self2, f) => check2(self2, (_, out) => !f(out)));
    untilOutputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (_, out) => negate(f(out))));
    upTo = /* @__PURE__ */ dual(2, (self2, duration6) => zipLeft3(self2, recurUpTo(duration6)));
    whileInput = /* @__PURE__ */ dual(2, (self2, f) => check2(self2, (input, _) => f(input)));
    whileInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => f(input)));
    whileOutput = /* @__PURE__ */ dual(2, (self2, f) => check2(self2, (_, out) => f(out)));
    whileOutputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (_, out) => f(out)));
    windowed = /* @__PURE__ */ __name((intervalInput) => {
      const interval = decode(intervalInput);
      const millis2 = toMillis(interval);
      return makeWithState([none2(), 0], (now2, _, [option5, n]) => {
        switch (option5._tag) {
          case "None": {
            return succeed([[some2(now2), n + 1], n, continueWith2(after2(now2 + millis2))]);
          }
          case "Some": {
            return succeed([[some2(option5.value), n + 1], n, continueWith2(after2(now2 + (millis2 - (now2 - option5.value) % millis2)))]);
          }
        }
      });
    }, "windowed");
    zipLeft3 = /* @__PURE__ */ dual(2, (self2, that) => map17(intersect5(self2, that), (out) => out[0]));
    zipRight4 = /* @__PURE__ */ dual(2, (self2, that) => map17(intersect5(self2, that), (out) => out[1]));
    zipWith6 = /* @__PURE__ */ dual(3, (self2, that, f) => map17(intersect5(self2, that), ([out, out2]) => f(out, out2)));
    beginningOfSecond = /* @__PURE__ */ __name((now2) => {
      const date7 = new Date(now2);
      return new Date(date7.getFullYear(), date7.getMonth(), date7.getDate(), date7.getHours(), date7.getMinutes(), date7.getSeconds(), 0).getTime();
    }, "beginningOfSecond");
    endOfSecond = /* @__PURE__ */ __name((now2) => {
      const date7 = new Date(beginningOfSecond(now2));
      return date7.setSeconds(date7.getSeconds() + 1);
    }, "endOfSecond");
    nextSecond = /* @__PURE__ */ __name((now2, second, initial) => {
      const date7 = new Date(now2);
      if (date7.getSeconds() === second && initial) {
        return now2;
      }
      if (date7.getSeconds() < second) {
        return date7.setSeconds(second);
      }
      const newDate = new Date(date7.setSeconds(second));
      return newDate.setTime(newDate.getTime() + 1e3 * 60);
    }, "nextSecond");
    beginningOfMinute = /* @__PURE__ */ __name((now2) => {
      const date7 = new Date(now2);
      return new Date(date7.getFullYear(), date7.getMonth(), date7.getDate(), date7.getHours(), date7.getMinutes(), 0, 0).getTime();
    }, "beginningOfMinute");
    endOfMinute = /* @__PURE__ */ __name((now2) => {
      const date7 = new Date(beginningOfMinute(now2));
      return date7.setMinutes(date7.getMinutes() + 1);
    }, "endOfMinute");
    nextMinute = /* @__PURE__ */ __name((now2, minute, initial) => {
      const date7 = new Date(now2);
      if (date7.getMinutes() === minute && initial) {
        return now2;
      }
      if (date7.getMinutes() < minute) {
        return date7.setMinutes(minute);
      }
      const newDate = new Date(date7.setMinutes(minute));
      return newDate.setTime(newDate.getTime() + 1e3 * 60 * 60);
    }, "nextMinute");
    beginningOfHour = /* @__PURE__ */ __name((now2) => {
      const date7 = new Date(now2);
      return new Date(date7.getFullYear(), date7.getMonth(), date7.getDate(), date7.getHours(), 0, 0, 0).getTime();
    }, "beginningOfHour");
    endOfHour = /* @__PURE__ */ __name((now2) => {
      const date7 = new Date(beginningOfHour(now2));
      return date7.setHours(date7.getHours() + 1);
    }, "endOfHour");
    nextHour = /* @__PURE__ */ __name((now2, hour, initial) => {
      const date7 = new Date(now2);
      if (date7.getHours() === hour && initial) {
        return now2;
      }
      if (date7.getHours() < hour) {
        return date7.setHours(hour);
      }
      const newDate = new Date(date7.setHours(hour));
      return newDate.setTime(newDate.getTime() + 1e3 * 60 * 60 * 24);
    }, "nextHour");
    beginningOfDay = /* @__PURE__ */ __name((now2) => {
      const date7 = new Date(now2);
      return new Date(date7.getFullYear(), date7.getMonth(), date7.getDate(), 0, 0, 0, 0).getTime();
    }, "beginningOfDay");
    endOfDay = /* @__PURE__ */ __name((now2) => {
      const date7 = new Date(beginningOfDay(now2));
      return date7.setDate(date7.getDate() + 1);
    }, "endOfDay");
    nextDay = /* @__PURE__ */ __name((now2, dayOfWeek3, initial) => {
      const date7 = new Date(now2);
      if (date7.getDay() === dayOfWeek3 && initial) {
        return now2;
      }
      const nextDayOfWeek = (7 + dayOfWeek3 - date7.getDay()) % 7;
      return date7.setDate(date7.getDate() + (nextDayOfWeek === 0 ? 7 : nextDayOfWeek));
    }, "nextDay");
    nextDayOfMonth = /* @__PURE__ */ __name((now2, day, initial) => {
      const date7 = new Date(now2);
      if (date7.getDate() === day && initial) {
        return now2;
      }
      if (date7.getDate() < day) {
        return date7.setDate(day);
      }
      return findNextMonth(now2, day, 1);
    }, "nextDayOfMonth");
    findNextMonth = /* @__PURE__ */ __name((now2, day, months) => {
      const d = new Date(now2);
      const tmp1 = new Date(d.setDate(day));
      const tmp2 = new Date(tmp1.setMonth(tmp1.getMonth() + months));
      if (tmp2.getDate() === day) {
        const d2 = new Date(now2);
        const tmp3 = new Date(d2.setDate(day));
        return tmp3.setMonth(tmp3.getMonth() + months);
      }
      return findNextMonth(now2, day, months + 1);
    }, "findNextMonth");
    ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");
    ScheduleDefect = class {
      static {
        __name(this, "ScheduleDefect");
      }
      error;
      [ScheduleDefectTypeId];
      constructor(error50) {
        this.error = error50;
        this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
      }
    };
    isScheduleDefect = /* @__PURE__ */ __name((u) => hasProperty(u, ScheduleDefectTypeId), "isScheduleDefect");
    scheduleDefectWrap = /* @__PURE__ */ __name((self2) => catchAll(self2, (e) => die2(new ScheduleDefect(e))), "scheduleDefectWrap");
    scheduleDefectRefailCause = /* @__PURE__ */ __name((cause3) => match2(find(cause3, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some2(_.defect) : none2()), {
      onNone: /* @__PURE__ */ __name(() => cause3, "onNone"),
      onSome: /* @__PURE__ */ __name((error50) => fail(error50.error), "onSome")
    }), "scheduleDefectRefailCause");
    scheduleDefectRefail = /* @__PURE__ */ __name((effect4) => catchAllCause(effect4, (cause3) => failCause(scheduleDefectRefailCause(cause3))), "scheduleDefectRefail");
    repeat_Effect = /* @__PURE__ */ dual(2, (self2, schedule4) => repeatOrElse_Effect(self2, schedule4, (e, _) => fail2(e)));
    repeat_combined = /* @__PURE__ */ dual(2, (self2, options) => {
      if (isSchedule(options)) {
        return repeat_Effect(self2, options);
      }
      const base = options.schedule ?? passthrough2(forever2);
      const withWhile = options.while ? whileInputEffect(base, (a) => {
        const applied = options.while(a);
        if (typeof applied === "boolean") {
          return succeed(applied);
        }
        return scheduleDefectWrap(applied);
      }) : base;
      const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
        const applied = options.until(a);
        if (typeof applied === "boolean") {
          return succeed(applied);
        }
        return scheduleDefectWrap(applied);
      }) : withWhile;
      const withTimes = options.times ? intersect5(withUntil, recurs(options.times)).pipe(map17((intersectionPair) => intersectionPair[0])) : withUntil;
      return scheduleDefectRefail(repeat_Effect(self2, withTimes));
    });
    repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self2, schedule4, orElse12) => flatMap8(driver(schedule4), (driver3) => matchEffect(self2, {
      onFailure: /* @__PURE__ */ __name((error50) => orElse12(error50, none2()), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((value3) => repeatOrElseEffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver3.iterationMeta)), driver3, (error50, option5) => provideServiceEffect(orElse12(error50, option5), CurrentIterationMetadata, get11(driver3.iterationMeta)), value3), "onSuccess")
    })));
    repeatOrElseEffectLoop = /* @__PURE__ */ __name((self2, driver3, orElse12, value3) => matchEffect(driver3.next(value3), {
      onFailure: /* @__PURE__ */ __name(() => orDie(driver3.last), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((b) => matchEffect(self2, {
        onFailure: /* @__PURE__ */ __name((error50) => orElse12(error50, some2(b)), "onFailure"),
        onSuccess: /* @__PURE__ */ __name((value4) => repeatOrElseEffectLoop(self2, driver3, orElse12, value4), "onSuccess")
      }), "onSuccess")
    }), "repeatOrElseEffectLoop");
    retry_Effect = /* @__PURE__ */ dual(2, (self2, policy) => retryOrElse_Effect(self2, policy, (e, _) => fail2(e)));
    retry_combined = /* @__PURE__ */ dual(2, (self2, options) => {
      if (isSchedule(options)) {
        return retry_Effect(self2, options);
      }
      return scheduleDefectRefail(retry_Effect(self2, fromRetryOptions(options)));
    });
    fromRetryOptions = /* @__PURE__ */ __name((options) => {
      const base = options.schedule ?? forever2;
      const withWhile = options.while ? whileInputEffect(base, (e) => {
        const applied = options.while(e);
        if (typeof applied === "boolean") {
          return succeed(applied);
        }
        return scheduleDefectWrap(applied);
      }) : base;
      const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
        const applied = options.until(e);
        if (typeof applied === "boolean") {
          return succeed(applied);
        }
        return scheduleDefectWrap(applied);
      }) : withWhile;
      return options.times !== void 0 ? intersect5(withUntil, recurs(options.times)) : withUntil;
    }, "fromRetryOptions");
    retryOrElse_Effect = /* @__PURE__ */ dual(3, (self2, policy, orElse12) => flatMap8(driver(policy), (driver3) => retryOrElse_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver3.iterationMeta)), driver3, (e, out) => provideServiceEffect(orElse12(e, out), CurrentIterationMetadata, get11(driver3.iterationMeta)))));
    retryOrElse_EffectLoop = /* @__PURE__ */ __name((self2, driver3, orElse12) => {
      return catchAll(self2, (e) => matchEffect(driver3.next(e), {
        onFailure: /* @__PURE__ */ __name(() => pipe(driver3.last, orDie, flatMap8((out) => orElse12(e, out))), "onFailure"),
        onSuccess: /* @__PURE__ */ __name(() => retryOrElse_EffectLoop(self2, driver3, orElse12), "onSuccess")
      }));
    }, "retryOrElse_EffectLoop");
    schedule_Effect = /* @__PURE__ */ dual(2, (self2, schedule4) => scheduleFrom_Effect(self2, void 0, schedule4));
    scheduleFrom_Effect = /* @__PURE__ */ dual(3, (self2, initial, schedule4) => flatMap8(driver(schedule4), (driver3) => scheduleFrom_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver3.iterationMeta)), initial, driver3)));
    scheduleFrom_EffectLoop = /* @__PURE__ */ __name((self2, initial, driver3) => matchEffect(driver3.next(initial), {
      onFailure: /* @__PURE__ */ __name(() => orDie(driver3.last), "onFailure"),
      onSuccess: /* @__PURE__ */ __name(() => flatMap8(self2, (a) => scheduleFrom_EffectLoop(self2, a, driver3)), "onSuccess")
    }), "scheduleFrom_EffectLoop");
    count3 = /* @__PURE__ */ unfold2(0, (n) => n + 1);
    elapsed = /* @__PURE__ */ makeWithState(/* @__PURE__ */ none2(), (now2, _, state) => {
      switch (state._tag) {
        case "None": {
          return succeed([some2(now2), zero2, continueWith2(after2(now2))]);
        }
        case "Some": {
          return succeed([some2(state.value), millis(now2 - state.value), continueWith2(after2(now2))]);
        }
      }
    });
    forever2 = /* @__PURE__ */ unfold2(0, (n) => n + 1);
    once3 = /* @__PURE__ */ asVoid3(/* @__PURE__ */ recurs(1));
    stop = /* @__PURE__ */ asVoid3(/* @__PURE__ */ recurs(0));
    scheduleForked = /* @__PURE__ */ dual(2, (self2, schedule4) => forkScoped(schedule_Effect(self2, schedule4)));
  }
});

// node_modules/effect/dist/esm/internal/executionPlan.js
var TypeId20, withExecutionPlan, scheduleFromStep;
var init_executionPlan = __esm({
  "node_modules/effect/dist/esm/internal/executionPlan.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Either();
    init_Function();
    init_core();
    init_layer2();
    init_schedule();
    TypeId20 = /* @__PURE__ */ Symbol.for("effect/ExecutionPlan");
    withExecutionPlan = /* @__PURE__ */ dual(2, (effect4, plan) => suspend(() => {
      let i = 0;
      let result;
      return flatMap8(whileLoop({
        while: /* @__PURE__ */ __name(() => i < plan.steps.length && (result === void 0 || isLeft2(result)), "while"),
        body: /* @__PURE__ */ __name(() => {
          const step4 = plan.steps[i];
          let nextEffect = effect_provide(effect4, step4.provide);
          if (result) {
            let attempted = false;
            const wrapped = nextEffect;
            nextEffect = suspend(() => {
              if (attempted) return wrapped;
              attempted = true;
              return result;
            });
            nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step4, false)));
          } else {
            const schedule4 = scheduleFromStep(step4, true);
            nextEffect = schedule4 ? scheduleDefectRefail(retry_Effect(nextEffect, schedule4)) : nextEffect;
          }
          return either2(nextEffect);
        }, "body"),
        step: /* @__PURE__ */ __name((either8) => {
          result = either8;
          i++;
        }, "step")
      }), () => result);
    }));
    scheduleFromStep = /* @__PURE__ */ __name((step4, first3) => {
      if (!first3) {
        return fromRetryOptions({
          schedule: step4.schedule ? step4.schedule : step4.attempts ? void 0 : once3,
          times: step4.attempts,
          while: step4.while
        });
      } else if (step4.attempts === 1 || !(step4.schedule || step4.attempts)) {
        return void 0;
      }
      return fromRetryOptions({
        schedule: step4.schedule,
        while: step4.while,
        times: step4.attempts ? step4.attempts - 1 : void 0
      });
    }, "scheduleFromStep");
  }
});

// node_modules/effect/dist/esm/internal/query.js
var currentCache, currentCacheEnabled, fromRequest, cacheRequest, withRequestCaching, withRequestCache;
var init_query = __esm({
  "node_modules/effect/dist/esm/internal/query.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Duration();
    init_Function();
    init_GlobalValue();
    init_blockedRequests();
    init_cache();
    init_core();
    init_fiberRuntime();
    init_request();
    currentCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map11(deferredMake(), (handle) => ({
      listeners: new Listeners(),
      handle
    })), () => seconds(60))));
    currentCacheEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
    fromRequest = /* @__PURE__ */ __name((request2, dataSource) => flatMap8(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id2) => {
      const proxy = new Proxy(request2, {});
      return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
        if (cacheEnabled) {
          const cached5 = fiberRefGetWith(currentCache, (cache) => flatMap8(cache.getEither(proxy), (orNew) => {
            switch (orNew._tag) {
              case "Left": {
                if (orNew.left.listeners.interrupted) {
                  return flatMap8(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached5);
                }
                orNew.left.listeners.increment();
                return uninterruptibleMask((restore) => flatMap8(exit2(blocked(empty16, restore(deferredAwait(orNew.left.handle)))), (exit5) => {
                  orNew.left.listeners.decrement();
                  return exit5;
                }));
              }
              case "Right": {
                orNew.right.listeners.increment();
                return uninterruptibleMask((restore) => flatMap8(exit2(blocked(single(ds, makeEntry({
                  request: proxy,
                  result: orNew.right.handle,
                  listeners: orNew.right.listeners,
                  ownerId: id2,
                  state: {
                    completed: false
                  }
                })), restore(deferredAwait(orNew.right.handle)))), () => {
                  orNew.right.listeners.decrement();
                  return deferredAwait(orNew.right.handle);
                }));
              }
            }
          }));
          return cached5;
        }
        const listeners2 = new Listeners();
        listeners2.increment();
        return flatMap8(deferredMake(), (ref2) => ensuring(blocked(single(ds, makeEntry({
          request: proxy,
          result: ref2,
          listeners: listeners2,
          ownerId: id2,
          state: {
            completed: false
          }
        })), deferredAwait(ref2)), sync(() => listeners2.decrement())));
      });
    })), "fromRequest");
    cacheRequest = /* @__PURE__ */ __name((request2, result) => {
      return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
        if (cacheEnabled) {
          return fiberRefGetWith(currentCache, (cache) => flatMap8(cache.getEither(request2), (orNew) => {
            switch (orNew._tag) {
              case "Left": {
                return void_2;
              }
              case "Right": {
                return deferredComplete(orNew.right.handle, result);
              }
            }
          }));
        }
        return void_2;
      });
    }, "cacheRequest");
    withRequestCaching = /* @__PURE__ */ dual(2, (self2, strategy) => fiberRefLocally(self2, currentCacheEnabled, strategy));
    withRequestCache = /* @__PURE__ */ dual(
      2,
      // @ts-expect-error
      (self2, cache) => fiberRefLocally(self2, currentCache, cache)
    );
  }
});

// node_modules/effect/dist/esm/Request.js
var isRequest2, Class5;
var init_Request = __esm({
  "node_modules/effect/dist/esm/Request.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_request();
    isRequest2 = isRequest;
    Class5 = Class3;
  }
});

// node_modules/effect/dist/esm/Effect.js
var Effect_exports = {};
__export(Effect_exports, {
  Do: () => Do3,
  EffectTypeId: () => EffectTypeId3,
  Service: () => Service,
  Tag: () => Tag3,
  acquireRelease: () => acquireRelease2,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireUseRelease: () => acquireUseRelease2,
  addFinalizer: () => addFinalizer3,
  all: () => all6,
  allSuccesses: () => allSuccesses2,
  allWith: () => allWith2,
  allowInterrupt: () => allowInterrupt2,
  andThen: () => andThen6,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  annotateLogs: () => annotateLogs3,
  annotateLogsScoped: () => annotateLogsScoped2,
  annotateSpans: () => annotateSpans3,
  ap: () => ap2,
  as: () => as6,
  asSome: () => asSome2,
  asSomeError: () => asSomeError2,
  asVoid: () => asVoid4,
  async: () => async2,
  asyncEffect: () => asyncEffect2,
  awaitAllChildren: () => awaitAllChildren2,
  bind: () => bind4,
  bindAll: () => bindAll2,
  bindTo: () => bindTo4,
  blocked: () => blocked2,
  cacheRequestResult: () => cacheRequestResult,
  cached: () => cached3,
  cachedFunction: () => cachedFunction2,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedWithTTL: () => cachedWithTTL,
  catch: () => _catch2,
  catchAll: () => catchAll3,
  catchAllCause: () => catchAllCause3,
  catchAllDefect: () => catchAllDefect2,
  catchIf: () => catchIf2,
  catchSome: () => catchSome2,
  catchSomeCause: () => catchSomeCause2,
  catchSomeDefect: () => catchSomeDefect2,
  catchTag: () => catchTag2,
  catchTags: () => catchTags2,
  cause: () => cause2,
  checkInterruptible: () => checkInterruptible2,
  clock: () => clock2,
  clockWith: () => clockWith4,
  configProviderWith: () => configProviderWith2,
  console: () => console3,
  consoleWith: () => consoleWith2,
  context: () => context5,
  contextWith: () => contextWith2,
  contextWithEffect: () => contextWithEffect2,
  currentParentSpan: () => currentParentSpan2,
  currentSpan: () => currentSpan2,
  custom: () => custom2,
  daemonChildren: () => daemonChildren2,
  delay: () => delay2,
  descriptor: () => descriptor2,
  descriptorWith: () => descriptorWith2,
  die: () => die6,
  dieMessage: () => dieMessage2,
  dieSync: () => dieSync3,
  diffFiberRefs: () => diffFiberRefs2,
  disconnect: () => disconnect3,
  dropUntil: () => dropUntil2,
  dropWhile: () => dropWhile3,
  either: () => either4,
  ensureErrorType: () => ensureErrorType,
  ensureRequirementsType: () => ensureRequirementsType,
  ensureSuccessType: () => ensureSuccessType,
  ensuring: () => ensuring3,
  ensuringChild: () => ensuringChild2,
  ensuringChildren: () => ensuringChildren2,
  eventually: () => eventually2,
  every: () => every7,
  exists: () => exists3,
  exit: () => exit4,
  fail: () => fail9,
  failCause: () => failCause8,
  failCauseSync: () => failCauseSync3,
  failSync: () => failSync3,
  fiberId: () => fiberId2,
  fiberIdWith: () => fiberIdWith2,
  filter: () => filter9,
  filterEffectOrElse: () => filterEffectOrElse2,
  filterEffectOrFail: () => filterEffectOrFail2,
  filterMap: () => filterMap6,
  filterOrDie: () => filterOrDie2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrElse: () => filterOrElse2,
  filterOrFail: () => filterOrFail2,
  finalizersMask: () => finalizersMask2,
  findFirst: () => findFirst7,
  firstSuccessOf: () => firstSuccessOf2,
  flatMap: () => flatMap11,
  flatten: () => flatten10,
  flip: () => flip2,
  flipWith: () => flipWith2,
  fn: () => fn,
  fnUntraced: () => fnUntraced2,
  forEach: () => forEach9,
  forever: () => forever3,
  fork: () => fork3,
  forkAll: () => forkAll2,
  forkDaemon: () => forkDaemon2,
  forkIn: () => forkIn2,
  forkScoped: () => forkScoped2,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  fromFiber: () => fromFiber2,
  fromFiberEffect: () => fromFiberEffect2,
  fromNullable: () => fromNullable3,
  functionWithSpan: () => functionWithSpan2,
  gen: () => gen4,
  getFiberRefs: () => getFiberRefs,
  getRuntimeFlags: () => getRuntimeFlags,
  head: () => head4,
  if: () => if_2,
  ignore: () => ignore2,
  ignoreLogged: () => ignoreLogged2,
  inheritFiberRefs: () => inheritFiberRefs2,
  interrupt: () => interrupt7,
  interruptWith: () => interruptWith2,
  interruptible: () => interruptible4,
  interruptibleMask: () => interruptibleMask2,
  intoDeferred: () => intoDeferred2,
  isEffect: () => isEffect2,
  isFailure: () => isFailure4,
  isSuccess: () => isSuccess3,
  iterate: () => iterate2,
  labelMetrics: () => labelMetrics2,
  labelMetricsScoped: () => labelMetricsScoped2,
  let: () => let_4,
  liftPredicate: () => liftPredicate3,
  linkSpanCurrent: () => linkSpanCurrent2,
  linkSpans: () => linkSpans2,
  locally: () => locally,
  locallyScoped: () => locallyScoped,
  locallyScopedWith: () => locallyScopedWith,
  locallyWith: () => locallyWith,
  log: () => log4,
  logAnnotations: () => logAnnotations2,
  logDebug: () => logDebug2,
  logError: () => logError2,
  logFatal: () => logFatal2,
  logInfo: () => logInfo2,
  logTrace: () => logTrace2,
  logWarning: () => logWarning2,
  logWithLevel: () => logWithLevel2,
  loop: () => loop2,
  makeLatch: () => makeLatch2,
  makeSemaphore: () => makeSemaphore2,
  makeSpan: () => makeSpan2,
  makeSpanScoped: () => makeSpanScoped2,
  map: () => map18,
  mapAccum: () => mapAccum4,
  mapBoth: () => mapBoth5,
  mapError: () => mapError3,
  mapErrorCause: () => mapErrorCause2,
  mapInputContext: () => mapInputContext3,
  match: () => match13,
  matchCause: () => matchCause4,
  matchCauseEffect: () => matchCauseEffect3,
  matchEffect: () => matchEffect2,
  merge: () => merge7,
  mergeAll: () => mergeAll5,
  metricLabels: () => metricLabels2,
  negate: () => negate2,
  never: () => never3,
  none: () => none9,
  onError: () => onError2,
  onExit: () => onExit3,
  onInterrupt: () => onInterrupt2,
  once: () => once4,
  option: () => option3,
  optionFromOptional: () => optionFromOptional2,
  orDie: () => orDie3,
  orDieWith: () => orDieWith2,
  orElse: () => orElse5,
  orElseFail: () => orElseFail2,
  orElseSucceed: () => orElseSucceed2,
  parallelErrors: () => parallelErrors2,
  parallelFinalizers: () => parallelFinalizers2,
  partition: () => partition4,
  patchFiberRefs: () => patchFiberRefs2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  promise: () => promise2,
  provide: () => provide2,
  provideService: () => provideService3,
  provideServiceEffect: () => provideServiceEffect2,
  race: () => race2,
  raceAll: () => raceAll2,
  raceFirst: () => raceFirst2,
  raceWith: () => raceWith2,
  random: () => random3,
  randomWith: () => randomWith2,
  reduce: () => reduce12,
  reduceEffect: () => reduceEffect3,
  reduceRight: () => reduceRight4,
  reduceWhile: () => reduceWhile2,
  repeat: () => repeat,
  repeatN: () => repeatN2,
  repeatOrElse: () => repeatOrElse,
  replicate: () => replicate2,
  replicateEffect: () => replicateEffect2,
  request: () => request,
  retry: () => retry2,
  retryOrElse: () => retryOrElse,
  runCallback: () => runCallback,
  runFork: () => runFork2,
  runPromise: () => runPromise,
  runPromiseExit: () => runPromiseExit,
  runRequestBlock: () => runRequestBlock2,
  runSync: () => runSync,
  runSyncExit: () => runSyncExit,
  runtime: () => runtime4,
  sandbox: () => sandbox2,
  schedule: () => schedule,
  scheduleForked: () => scheduleForked2,
  scheduleFrom: () => scheduleFrom,
  scope: () => scope3,
  scopeWith: () => scopeWith2,
  scoped: () => scoped2,
  scopedWith: () => scopedWith2,
  sequentialFinalizers: () => sequentialFinalizers2,
  serviceConstants: () => serviceConstants2,
  serviceFunction: () => serviceFunction2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunctions: () => serviceFunctions2,
  serviceMembers: () => serviceMembers2,
  serviceOption: () => serviceOption2,
  serviceOptional: () => serviceOptional2,
  setFiberRefs: () => setFiberRefs2,
  sleep: () => sleep4,
  spanAnnotations: () => spanAnnotations2,
  spanLinks: () => spanLinks2,
  step: () => step3,
  succeed: () => succeed9,
  succeedNone: () => succeedNone2,
  succeedSome: () => succeedSome2,
  summarized: () => summarized2,
  supervised: () => supervised2,
  suspend: () => suspend4,
  sync: () => sync5,
  tagMetrics: () => tagMetrics2,
  tagMetricsScoped: () => tagMetricsScoped2,
  takeUntil: () => takeUntil2,
  takeWhile: () => takeWhile3,
  tap: () => tap4,
  tapBoth: () => tapBoth2,
  tapDefect: () => tapDefect2,
  tapError: () => tapError3,
  tapErrorCause: () => tapErrorCause3,
  tapErrorTag: () => tapErrorTag2,
  timed: () => timed2,
  timedWith: () => timedWith2,
  timeout: () => timeout2,
  timeoutFail: () => timeoutFail2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutOption: () => timeoutOption2,
  timeoutTo: () => timeoutTo2,
  tracer: () => tracer2,
  tracerWith: () => tracerWith4,
  transplant: () => transplant2,
  transposeMapOption: () => transposeMapOption,
  transposeOption: () => transposeOption,
  try: () => try_3,
  tryMap: () => tryMap2,
  tryMapPromise: () => tryMapPromise2,
  tryPromise: () => tryPromise2,
  uninterruptible: () => uninterruptible2,
  uninterruptibleMask: () => uninterruptibleMask3,
  unless: () => unless2,
  unlessEffect: () => unlessEffect2,
  unsafeMakeLatch: () => unsafeMakeLatch2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsandbox: () => unsandbox2,
  updateFiberRefs: () => updateFiberRefs2,
  updateService: () => updateService2,
  useSpan: () => useSpan2,
  using: () => using2,
  validate: () => validate2,
  validateAll: () => validateAll2,
  validateFirst: () => validateFirst2,
  validateWith: () => validateWith2,
  void: () => _void,
  when: () => when2,
  whenEffect: () => whenEffect2,
  whenFiberRef: () => whenFiberRef2,
  whenLogLevel: () => whenLogLevel2,
  whenRef: () => whenRef2,
  whileLoop: () => whileLoop3,
  withClock: () => withClock2,
  withClockScoped: () => withClockScoped2,
  withConcurrency: () => withConcurrency2,
  withConfigProvider: () => withConfigProvider2,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConsole: () => withConsole2,
  withConsoleScoped: () => withConsoleScoped2,
  withEarlyRelease: () => withEarlyRelease2,
  withExecutionPlan: () => withExecutionPlan2,
  withFiberRuntime: () => withFiberRuntime2,
  withLogSpan: () => withLogSpan2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withMetric: () => withMetric2,
  withParentSpan: () => withParentSpan3,
  withRandom: () => withRandom2,
  withRandomFixed: () => withRandomFixed,
  withRandomScoped: () => withRandomScoped2,
  withRequestBatching: () => withRequestBatching2,
  withRequestCache: () => withRequestCache2,
  withRequestCaching: () => withRequestCaching2,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withScheduler: () => withScheduler2,
  withSchedulingPriority: () => withSchedulingPriority2,
  withSpan: () => withSpan3,
  withSpanScoped: () => withSpanScoped2,
  withTracer: () => withTracer2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracerScoped: () => withTracerScoped2,
  withTracerTiming: () => withTracerTiming2,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  yieldNow: () => yieldNow4,
  zip: () => zip5,
  zipLeft: () => zipLeft4,
  zipRight: () => zipRight5,
  zipWith: () => zipWith7
});
function defineLength(length4, fn2) {
  return Object.defineProperty(fn2, "length", {
    value: length4,
    configurable: true
  });
}
function fnApply(options) {
  let effect4;
  let fnError = void 0;
  if (isGeneratorFunction(options.body)) {
    effect4 = fromIterator(() => options.body.apply(options.self, options.args));
  } else {
    try {
      effect4 = options.body.apply(options.self, options.args);
    } catch (error50) {
      fnError = error50;
      effect4 = die6(error50);
    }
  }
  if (options.pipeables.length > 0) {
    try {
      for (const x of options.pipeables) {
        effect4 = x(effect4, ...options.args);
      }
    } catch (error50) {
      effect4 = fnError ? failCause8(sequential(die(fnError), die(error50))) : die6(error50);
    }
  }
  let cache = false;
  const captureStackTrace2 = /* @__PURE__ */ __name(() => {
    if (cache !== false) {
      return cache;
    }
    if (options.errorCall.stack) {
      const stackDef = options.errorDef.stack.trim().split("\n");
      const stackCall = options.errorCall.stack.trim().split("\n");
      let endStackDef = stackDef.slice(2).join("\n").trim();
      if (!endStackDef.includes(`(`)) {
        endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
      }
      let endStackCall = stackCall.slice(2).join("\n").trim();
      if (!endStackCall.includes(`(`)) {
        endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
      }
      cache = `${endStackDef}
${endStackCall}`;
      return cache;
    }
  }, "captureStackTrace");
  const opts = options.spanOptions && "captureStackTrace" in options.spanOptions ? options.spanOptions : {
    captureStackTrace: captureStackTrace2,
    ...options.spanOptions
  };
  return withSpan3(effect4, options.spanName, opts);
}
var EffectTypeId3, isEffect2, cachedWithTTL, cachedInvalidateWithTTL2, cached3, cachedFunction2, once4, all6, allWith2, allSuccesses2, dropUntil2, dropWhile3, takeUntil2, takeWhile3, every7, exists3, filter9, filterMap6, findFirst7, forEach9, head4, mergeAll5, partition4, reduce12, reduceWhile2, reduceRight4, reduceEffect3, replicate2, replicateEffect2, validateAll2, validateFirst2, async2, asyncEffect2, custom2, withFiberRuntime2, fail9, failSync3, failCause8, failCauseSync3, die6, dieMessage2, dieSync3, gen4, never3, none9, promise2, succeed9, succeedNone2, succeedSome2, suspend4, sync5, _void, yieldNow4, _catch2, catchAll3, catchAllCause3, catchAllDefect2, catchIf2, catchSome2, catchSomeCause2, catchSomeDefect2, catchTag2, catchTags2, cause2, eventually2, ignore2, ignoreLogged2, parallelErrors2, sandbox2, retry2, withExecutionPlan2, retryOrElse, try_3, tryMap2, tryMapPromise2, tryPromise2, unsandbox2, allowInterrupt2, checkInterruptible2, disconnect3, interrupt7, interruptWith2, interruptible4, interruptibleMask2, onInterrupt2, uninterruptible2, uninterruptibleMask3, liftPredicate3, as6, asSome2, asSomeError2, asVoid4, flip2, flipWith2, map18, mapAccum4, mapBoth5, mapError3, mapErrorCause2, merge7, negate2, acquireRelease2, acquireReleaseInterruptible2, acquireUseRelease2, addFinalizer3, ensuring3, onError2, onExit3, parallelFinalizers2, sequentialFinalizers2, finalizersMask2, scope3, scopeWith2, scopedWith2, scoped2, using2, withEarlyRelease2, awaitAllChildren2, daemonChildren2, descriptor2, descriptorWith2, diffFiberRefs2, ensuringChild2, ensuringChildren2, fiberId2, fiberIdWith2, fork3, forkDaemon2, forkAll2, forkIn2, forkScoped2, forkWithErrorHandler2, fromFiber2, fromFiberEffect2, supervised2, transplant2, withConcurrency2, withScheduler2, withSchedulingPriority2, withMaxOpsBeforeYield2, clock2, clockWith4, withClockScoped2, withClock2, console3, consoleWith2, withConsoleScoped2, withConsole2, delay2, sleep4, timed2, timedWith2, timeout2, timeoutOption2, timeoutFail2, timeoutFailCause2, timeoutTo2, configProviderWith2, withConfigProvider2, withConfigProviderScoped2, context5, contextWith2, contextWithEffect2, mapInputContext3, provide2, provideService3, provideServiceEffect2, serviceFunction2, serviceFunctionEffect2, serviceFunctions2, serviceConstants2, serviceMembers2, serviceOption2, serviceOptional2, updateService2, Do3, bind4, bindAll2, bindTo4, let_4, option3, either4, exit4, intoDeferred2, if_2, filterOrDie2, filterOrDieMessage2, filterOrElse2, filterOrFail2, filterEffectOrElse2, filterEffectOrFail2, unless2, unlessEffect2, when2, whenEffect2, whenFiberRef2, whenRef2, flatMap11, andThen6, flatten10, race2, raceAll2, raceFirst2, raceWith2, summarized2, tap4, tapBoth2, tapDefect2, tapError3, tapErrorTag2, tapErrorCause3, forever3, iterate2, loop2, repeat, repeatN2, repeatOrElse, schedule, scheduleForked2, scheduleFrom, whileLoop3, getFiberRefs, inheritFiberRefs2, locally, locallyWith, locallyScoped, locallyScopedWith, patchFiberRefs2, setFiberRefs2, updateFiberRefs2, isFailure4, isSuccess3, match13, matchCause4, matchCauseEffect3, matchEffect2, log4, logWithLevel2, logTrace2, logDebug2, logInfo2, logWarning2, logError2, logFatal2, withLogSpan2, annotateLogs3, annotateLogsScoped2, logAnnotations2, withUnhandledErrorLogLevel2, whenLogLevel2, orDie3, orDieWith2, orElse5, orElseFail2, orElseSucceed2, firstSuccessOf2, random3, randomWith2, withRandom2, withRandomFixed, withRandomScoped2, runtime4, getRuntimeFlags, patchRuntimeFlags, withRuntimeFlagsPatch, withRuntimeFlagsPatchScoped, tagMetrics2, labelMetrics2, tagMetricsScoped2, labelMetricsScoped2, metricLabels2, withMetric2, unsafeMakeSemaphore2, makeSemaphore2, unsafeMakeLatch2, makeLatch2, runFork2, runCallback, runPromise, runPromiseExit, runSync, runSyncExit, validate2, validateWith2, zip5, zipLeft4, zipRight5, zipWith7, ap2, blocked2, runRequestBlock2, step3, request, cacheRequestResult, withRequestBatching2, withRequestCaching2, withRequestCache2, tracer2, tracerWith4, withTracer2, withTracerScoped2, withTracerEnabled2, withTracerTiming2, annotateSpans3, annotateCurrentSpan2, currentSpan2, currentParentSpan2, spanAnnotations2, spanLinks2, linkSpans2, linkSpanCurrent2, makeSpan2, makeSpanScoped2, useSpan2, withSpan3, functionWithSpan2, withSpanScoped2, withParentSpan3, fromNullable3, optionFromOptional2, transposeOption, transposeMapOption, makeTagProxy, Tag3, Service, fn, fnUntraced2, ensureSuccessType, ensureErrorType, ensureRequirementsType;
var init_Effect = __esm({
  "node_modules/effect/dist/esm/Effect.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_cause2();
    init_console4();
    init_context2();
    init_core_effect();
    init_core();
    init_defaultServices();
    init_circular();
    init_executionPlan();
    init_fiberRuntime();
    init_layer2();
    init_option();
    init_query();
    init_runtime();
    init_schedule();
    init_tracer();
    init_Random2();
    init_Request();
    init_Scheduler();
    init_Utils();
    EffectTypeId3 = EffectTypeId2;
    isEffect2 = isEffect;
    cachedWithTTL = cached2;
    cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
    cached3 = memoize;
    cachedFunction2 = cachedFunction;
    once4 = once2;
    all6 = all5;
    allWith2 = allWith;
    allSuccesses2 = allSuccesses;
    dropUntil2 = dropUntil;
    dropWhile3 = dropWhile2;
    takeUntil2 = takeUntil;
    takeWhile3 = takeWhile2;
    every7 = every5;
    exists3 = exists2;
    filter9 = filter7;
    filterMap6 = filterMap5;
    findFirst7 = findFirst5;
    forEach9 = forEach8;
    head4 = head3;
    mergeAll5 = mergeAll3;
    partition4 = partition3;
    reduce12 = reduce9;
    reduceWhile2 = reduceWhile;
    reduceRight4 = reduceRight3;
    reduceEffect3 = reduceEffect;
    replicate2 = replicate;
    replicateEffect2 = replicateEffect;
    validateAll2 = validateAll;
    validateFirst2 = validateFirst;
    async2 = async_;
    asyncEffect2 = asyncEffect;
    custom2 = custom;
    withFiberRuntime2 = withFiberRuntime;
    fail9 = fail2;
    failSync3 = failSync;
    failCause8 = failCause;
    failCauseSync3 = failCauseSync;
    die6 = die2;
    dieMessage2 = dieMessage;
    dieSync3 = dieSync;
    gen4 = gen3;
    never3 = never;
    none9 = none6;
    promise2 = promise;
    succeed9 = succeed;
    succeedNone2 = succeedNone;
    succeedSome2 = succeedSome;
    suspend4 = suspend;
    sync5 = sync;
    _void = void_2;
    yieldNow4 = yieldNow;
    _catch2 = _catch;
    catchAll3 = catchAll;
    catchAllCause3 = catchAllCause;
    catchAllDefect2 = catchAllDefect;
    catchIf2 = catchIf;
    catchSome2 = catchSome;
    catchSomeCause2 = catchSomeCause;
    catchSomeDefect2 = catchSomeDefect;
    catchTag2 = catchTag;
    catchTags2 = catchTags;
    cause2 = cause;
    eventually2 = eventually;
    ignore2 = ignore;
    ignoreLogged2 = ignoreLogged;
    parallelErrors2 = parallelErrors;
    sandbox2 = sandbox;
    retry2 = retry_combined;
    withExecutionPlan2 = withExecutionPlan;
    retryOrElse = retryOrElse_Effect;
    try_3 = try_2;
    tryMap2 = tryMap;
    tryMapPromise2 = tryMapPromise;
    tryPromise2 = tryPromise;
    unsandbox2 = unsandbox;
    allowInterrupt2 = allowInterrupt;
    checkInterruptible2 = checkInterruptible;
    disconnect3 = disconnect2;
    interrupt7 = interrupt2;
    interruptWith2 = interruptWith;
    interruptible4 = interruptible2;
    interruptibleMask2 = interruptibleMask;
    onInterrupt2 = onInterrupt;
    uninterruptible2 = uninterruptible;
    uninterruptibleMask3 = uninterruptibleMask;
    liftPredicate3 = liftPredicate2;
    as6 = as2;
    asSome2 = asSome;
    asSomeError2 = asSomeError;
    asVoid4 = asVoid2;
    flip2 = flip;
    flipWith2 = flipWith;
    map18 = map11;
    mapAccum4 = mapAccum3;
    mapBoth5 = mapBoth2;
    mapError3 = mapError;
    mapErrorCause2 = mapErrorCause;
    merge7 = merge5;
    negate2 = negate;
    acquireRelease2 = acquireRelease;
    acquireReleaseInterruptible2 = acquireReleaseInterruptible;
    acquireUseRelease2 = acquireUseRelease;
    addFinalizer3 = addFinalizer;
    ensuring3 = ensuring;
    onError2 = onError;
    onExit3 = onExit;
    parallelFinalizers2 = parallelFinalizers;
    sequentialFinalizers2 = sequentialFinalizers;
    finalizersMask2 = finalizersMask;
    scope3 = scope;
    scopeWith2 = scopeWith;
    scopedWith2 = scopedWith;
    scoped2 = scopedEffect;
    using2 = using;
    withEarlyRelease2 = withEarlyRelease;
    awaitAllChildren2 = awaitAllChildren;
    daemonChildren2 = daemonChildren;
    descriptor2 = descriptor;
    descriptorWith2 = descriptorWith;
    diffFiberRefs2 = diffFiberRefs;
    ensuringChild2 = ensuringChild;
    ensuringChildren2 = ensuringChildren;
    fiberId2 = fiberId;
    fiberIdWith2 = fiberIdWith;
    fork3 = fork;
    forkDaemon2 = forkDaemon;
    forkAll2 = forkAll;
    forkIn2 = forkIn;
    forkScoped2 = forkScoped;
    forkWithErrorHandler2 = forkWithErrorHandler;
    fromFiber2 = fromFiber;
    fromFiberEffect2 = fromFiberEffect;
    supervised2 = supervised;
    transplant2 = transplant;
    withConcurrency2 = withConcurrency;
    withScheduler2 = withScheduler;
    withSchedulingPriority2 = withSchedulingPriority;
    withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
    clock2 = clock;
    clockWith4 = clockWith3;
    withClockScoped2 = withClockScoped;
    withClock2 = withClock;
    console3 = console2;
    consoleWith2 = consoleWith;
    withConsoleScoped2 = withConsoleScoped;
    withConsole2 = withConsole;
    delay2 = delay;
    sleep4 = sleep3;
    timed2 = timed;
    timedWith2 = timedWith;
    timeout2 = timeout;
    timeoutOption2 = timeoutOption;
    timeoutFail2 = timeoutFail;
    timeoutFailCause2 = timeoutFailCause;
    timeoutTo2 = timeoutTo;
    configProviderWith2 = configProviderWith;
    withConfigProvider2 = withConfigProvider;
    withConfigProviderScoped2 = withConfigProviderScoped;
    context5 = context3;
    contextWith2 = contextWith;
    contextWithEffect2 = contextWithEffect;
    mapInputContext3 = mapInputContext;
    provide2 = effect_provide;
    provideService3 = provideService;
    provideServiceEffect2 = provideServiceEffect;
    serviceFunction2 = serviceFunction;
    serviceFunctionEffect2 = serviceFunctionEffect;
    serviceFunctions2 = serviceFunctions;
    serviceConstants2 = serviceConstants;
    serviceMembers2 = serviceMembers;
    serviceOption2 = serviceOption;
    serviceOptional2 = serviceOptional;
    updateService2 = updateService;
    Do3 = Do2;
    bind4 = bind3;
    bindAll2 = bindAll;
    bindTo4 = bindTo3;
    let_4 = let_3;
    option3 = option2;
    either4 = either2;
    exit4 = exit2;
    intoDeferred2 = intoDeferred;
    if_2 = if_;
    filterOrDie2 = filterOrDie;
    filterOrDieMessage2 = filterOrDieMessage;
    filterOrElse2 = filterOrElse;
    filterOrFail2 = filterOrFail;
    filterEffectOrElse2 = filterEffectOrElse;
    filterEffectOrFail2 = filterEffectOrFail;
    unless2 = unless;
    unlessEffect2 = unlessEffect;
    when2 = when;
    whenEffect2 = whenEffect;
    whenFiberRef2 = whenFiberRef;
    whenRef2 = whenRef;
    flatMap11 = flatMap8;
    andThen6 = andThen3;
    flatten10 = flatten7;
    race2 = race;
    raceAll2 = raceAll;
    raceFirst2 = raceFirst;
    raceWith2 = raceWith;
    summarized2 = summarized;
    tap4 = tap2;
    tapBoth2 = tapBoth;
    tapDefect2 = tapDefect;
    tapError3 = tapError;
    tapErrorTag2 = tapErrorTag;
    tapErrorCause3 = tapErrorCause;
    forever3 = forever;
    iterate2 = iterate;
    loop2 = loop;
    repeat = repeat_combined;
    repeatN2 = repeatN;
    repeatOrElse = repeatOrElse_Effect;
    schedule = schedule_Effect;
    scheduleForked2 = scheduleForked;
    scheduleFrom = scheduleFrom_Effect;
    whileLoop3 = whileLoop;
    getFiberRefs = fiberRefs2;
    inheritFiberRefs2 = inheritFiberRefs;
    locally = fiberRefLocally;
    locallyWith = fiberRefLocallyWith;
    locallyScoped = fiberRefLocallyScoped;
    locallyScopedWith = fiberRefLocallyScopedWith;
    patchFiberRefs2 = patchFiberRefs;
    setFiberRefs2 = setFiberRefs;
    updateFiberRefs2 = updateFiberRefs;
    isFailure4 = isFailure2;
    isSuccess3 = isSuccess2;
    match13 = match7;
    matchCause4 = matchCause;
    matchCauseEffect3 = matchCauseEffect;
    matchEffect2 = matchEffect;
    log4 = log3;
    logWithLevel2 = /* @__PURE__ */ __name((level, ...message) => logWithLevel(level)(...message), "logWithLevel");
    logTrace2 = logTrace;
    logDebug2 = logDebug;
    logInfo2 = logInfo;
    logWarning2 = logWarning;
    logError2 = logError;
    logFatal2 = logFatal;
    withLogSpan2 = withLogSpan;
    annotateLogs3 = annotateLogs;
    annotateLogsScoped2 = annotateLogsScoped;
    logAnnotations2 = logAnnotations;
    withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
    whenLogLevel2 = whenLogLevel;
    orDie3 = orDie;
    orDieWith2 = orDieWith;
    orElse5 = orElse2;
    orElseFail2 = orElseFail;
    orElseSucceed2 = orElseSucceed;
    firstSuccessOf2 = firstSuccessOf;
    random3 = random2;
    randomWith2 = randomWith;
    withRandom2 = withRandom;
    withRandomFixed = /* @__PURE__ */ dual(2, (effect4, values4) => withRandom2(effect4, fixed2(values4)));
    withRandomScoped2 = withRandomScoped;
    runtime4 = runtime3;
    getRuntimeFlags = runtimeFlags;
    patchRuntimeFlags = updateRuntimeFlags;
    withRuntimeFlagsPatch = withRuntimeFlags;
    withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
    tagMetrics2 = tagMetrics;
    labelMetrics2 = labelMetrics;
    tagMetricsScoped2 = tagMetricsScoped;
    labelMetricsScoped2 = labelMetricsScoped;
    metricLabels2 = metricLabels;
    withMetric2 = withMetric;
    unsafeMakeSemaphore2 = unsafeMakeSemaphore;
    makeSemaphore2 = makeSemaphore;
    unsafeMakeLatch2 = unsafeMakeLatch;
    makeLatch2 = makeLatch;
    runFork2 = unsafeForkEffect;
    runCallback = unsafeRunEffect;
    runPromise = unsafeRunPromiseEffect;
    runPromiseExit = unsafeRunPromiseExitEffect;
    runSync = unsafeRunSyncEffect;
    runSyncExit = unsafeRunSyncExitEffect;
    validate2 = validate;
    validateWith2 = validateWith;
    zip5 = zipOptions;
    zipLeft4 = zipLeftOptions;
    zipRight5 = zipRightOptions;
    zipWith7 = zipWithOptions;
    ap2 = /* @__PURE__ */ dual(2, (self2, that) => zipWith7(self2, that, (f, a) => f(a)));
    blocked2 = blocked;
    runRequestBlock2 = runRequestBlock;
    step3 = step2;
    request = /* @__PURE__ */ dual((args2) => isRequest2(args2[0]), fromRequest);
    cacheRequestResult = cacheRequest;
    withRequestBatching2 = withRequestBatching;
    withRequestCaching2 = withRequestCaching;
    withRequestCache2 = withRequestCache;
    tracer2 = tracer;
    tracerWith4 = tracerWith;
    withTracer2 = withTracer;
    withTracerScoped2 = withTracerScoped;
    withTracerEnabled2 = withTracerEnabled;
    withTracerTiming2 = withTracerTiming;
    annotateSpans3 = annotateSpans;
    annotateCurrentSpan2 = annotateCurrentSpan;
    currentSpan2 = currentSpan;
    currentParentSpan2 = currentParentSpan;
    spanAnnotations2 = spanAnnotations;
    spanLinks2 = spanLinks;
    linkSpans2 = linkSpans;
    linkSpanCurrent2 = linkSpanCurrent;
    makeSpan2 = makeSpan;
    makeSpanScoped2 = makeSpanScoped;
    useSpan2 = useSpan;
    withSpan3 = withSpan;
    functionWithSpan2 = functionWithSpan;
    withSpanScoped2 = withSpanScoped;
    withParentSpan3 = withParentSpan;
    fromNullable3 = fromNullable2;
    optionFromOptional2 = optionFromOptional;
    transposeOption = /* @__PURE__ */ __name((self2) => {
      return isNone(self2) ? succeedNone2 : map18(self2.value, some);
    }, "transposeOption");
    transposeMapOption = /* @__PURE__ */ dual(2, (self2, f) => isNone(self2) ? succeedNone2 : map18(f(self2.value), some));
    makeTagProxy = /* @__PURE__ */ __name((TagClass) => {
      const cache = /* @__PURE__ */ new Map();
      return new Proxy(TagClass, {
        get(target, prop, receiver) {
          if (prop in target) {
            return Reflect.get(target, prop, receiver);
          }
          if (cache.has(prop)) {
            return cache.get(prop);
          }
          const fn2 = /* @__PURE__ */ __name((...args2) => andThen3(target, (s) => {
            if (typeof s[prop] === "function") {
              cache.set(prop, (...args3) => andThen3(target, (s2) => s2[prop](...args3)));
              return s[prop](...args2);
            }
            cache.set(prop, andThen3(target, (s2) => s2[prop]));
            return s[prop];
          }), "fn");
          const cn = andThen3(target, (s) => s[prop]);
          Object.assign(fn2, cn);
          const apply = fn2.apply;
          const bind8 = fn2.bind;
          const call = fn2.call;
          const proto14 = Object.setPrototypeOf({}, Object.getPrototypeOf(cn));
          proto14.apply = apply;
          proto14.bind = bind8;
          proto14.call = call;
          Object.setPrototypeOf(fn2, proto14);
          cache.set(prop, fn2);
          return fn2;
        }
      });
    }, "makeTagProxy");
    Tag3 = /* @__PURE__ */ __name((id2) => () => {
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const creationError = new Error();
      Error.stackTraceLimit = limit;
      function TagClass() {
      }
      __name(TagClass, "TagClass");
      Object.setPrototypeOf(TagClass, TagProto);
      TagClass.key = id2;
      Object.defineProperty(TagClass, "use", {
        get() {
          return (body) => andThen3(this, body);
        }
      });
      Object.defineProperty(TagClass, "stack", {
        get() {
          return creationError.stack;
        }
      });
      return makeTagProxy(TagClass);
    }, "Tag");
    Service = /* @__PURE__ */ __name(function() {
      return function() {
        const [id2, maker] = arguments;
        const proxy = "accessors" in maker ? maker["accessors"] : false;
        const limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        const creationError = new Error();
        Error.stackTraceLimit = limit;
        let patchState = "unchecked";
        const TagClass = /* @__PURE__ */ __name(function(service3) {
          if (patchState === "unchecked") {
            const proto14 = Object.getPrototypeOf(service3);
            if (proto14 === Object.prototype || proto14 === null) {
              patchState = "plain";
            } else {
              const selfProto = Object.getPrototypeOf(this);
              Object.setPrototypeOf(selfProto, proto14);
              patchState = "patched";
            }
          }
          if (patchState === "plain") {
            Object.assign(this, service3);
          } else if (patchState === "patched") {
            Object.setPrototypeOf(service3, Object.getPrototypeOf(this));
            return service3;
          }
        }, "TagClass");
        TagClass.prototype._tag = id2;
        Object.defineProperty(TagClass, "make", {
          get() {
            return (service3) => new this(service3);
          }
        });
        Object.defineProperty(TagClass, "use", {
          get() {
            return (body) => andThen3(this, body);
          }
        });
        TagClass.key = id2;
        Object.assign(TagClass, TagProto);
        Object.defineProperty(TagClass, "stack", {
          get() {
            return creationError.stack;
          }
        });
        const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
        const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
        let layerCache;
        let isFunction4 = false;
        if ("effect" in maker) {
          isFunction4 = typeof maker.effect === "function";
          Object.defineProperty(TagClass, layerName, {
            get() {
              if (isFunction4) {
                return function() {
                  return fromEffect3(TagClass, map18(maker.effect.apply(null, arguments), (_) => new this(_)));
                }.bind(this);
              }
              return layerCache ??= fromEffect3(TagClass, map18(maker.effect, (_) => new this(_)));
            }
          });
        } else if ("scoped" in maker) {
          isFunction4 = typeof maker.scoped === "function";
          Object.defineProperty(TagClass, layerName, {
            get() {
              if (isFunction4) {
                return function() {
                  return scoped(TagClass, map18(maker.scoped.apply(null, arguments), (_) => new this(_)));
                }.bind(this);
              }
              return layerCache ??= scoped(TagClass, map18(maker.scoped, (_) => new this(_)));
            }
          });
        } else if ("sync" in maker) {
          Object.defineProperty(TagClass, layerName, {
            get() {
              return layerCache ??= sync3(TagClass, () => new this(maker.sync()));
            }
          });
        } else {
          Object.defineProperty(TagClass, layerName, {
            get() {
              return layerCache ??= succeed6(TagClass, new this(maker.succeed));
            }
          });
        }
        if (hasDeps) {
          let layerWithDepsCache;
          Object.defineProperty(TagClass, "Default", {
            get() {
              if (isFunction4) {
                return function() {
                  return provide(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
                };
              }
              return layerWithDepsCache ??= provide(this.DefaultWithoutDependencies, maker.dependencies);
            }
          });
        }
        return proxy === true ? makeTagProxy(TagClass) : TagClass;
      };
    }, "Service");
    fn = /* @__PURE__ */ __name(function(nameOrBody, ...pipeables) {
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorDef = new Error();
      Error.stackTraceLimit = limit;
      if (typeof nameOrBody !== "string") {
        return defineLength(nameOrBody.length, function(...args2) {
          const limit2 = Error.stackTraceLimit;
          Error.stackTraceLimit = 2;
          const errorCall = new Error();
          Error.stackTraceLimit = limit2;
          return fnApply({
            self: this,
            body: nameOrBody,
            args: args2,
            pipeables,
            spanName: "<anonymous>",
            spanOptions: {
              context: DisablePropagation.context(true)
            },
            errorDef,
            errorCall
          });
        });
      }
      const name = nameOrBody;
      const options = pipeables[0];
      return (body, ...pipeables2) => defineLength(body.length, {
        [name](...args2) {
          const limit2 = Error.stackTraceLimit;
          Error.stackTraceLimit = 2;
          const errorCall = new Error();
          Error.stackTraceLimit = limit2;
          return fnApply({
            self: this,
            body,
            args: args2,
            pipeables: pipeables2,
            spanName: name,
            spanOptions: options,
            errorDef,
            errorCall
          });
        }
      }[name]);
    }, "fn");
    __name(defineLength, "defineLength");
    __name(fnApply, "fnApply");
    fnUntraced2 = fnUntraced;
    ensureSuccessType = /* @__PURE__ */ __name(() => (effect4) => effect4, "ensureSuccessType");
    ensureErrorType = /* @__PURE__ */ __name(() => (effect4) => effect4, "ensureErrorType");
    ensureRequirementsType = /* @__PURE__ */ __name(() => (effect4) => effect4, "ensureRequirementsType");
  }
});

// node_modules/effect/dist/esm/FiberRef.js
var get13, getWith, currentContext2, currentSchedulingPriority2, currentScheduler2, currentTracerTimingEnabled2;
var init_FiberRef = __esm({
  "node_modules/effect/dist/esm/FiberRef.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_core();
    init_Scheduler();
    get13 = fiberRefGet;
    getWith = fiberRefGetWith;
    currentContext2 = currentContext;
    currentSchedulingPriority2 = currentSchedulingPriority;
    currentScheduler2 = currentScheduler;
    currentTracerTimingEnabled2 = currentTracerTimingEnabled;
  }
});

// node_modules/effect/dist/esm/internal/layer/circular.js
var setConfigProvider, parentSpan, span2, setTracer;
var init_circular3 = __esm({
  "node_modules/effect/dist/esm/internal/layer/circular.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Context();
    init_core();
    init_fiberRuntime();
    init_layer2();
    init_tracer();
    setConfigProvider = /* @__PURE__ */ __name((configProvider) => scopedDiscard(withConfigProviderScoped(configProvider)), "setConfigProvider");
    parentSpan = /* @__PURE__ */ __name((span4) => succeedContext(make6(spanTag, span4)), "parentSpan");
    span2 = /* @__PURE__ */ __name((name, options) => {
      options = addSpanStackTrace(options);
      return scoped(spanTag, options?.onEnd ? tap2(makeSpanScoped(name, options), (span4) => addFinalizer((exit5) => options.onEnd(span4, exit5))) : makeSpanScoped(name, options));
    }, "span");
    setTracer = /* @__PURE__ */ __name((tracer4) => scopedDiscard(withTracerScoped(tracer4)), "setTracer");
  }
});

// node_modules/effect/dist/esm/Layer.js
var Layer_exports = {};
__export(Layer_exports, {
  CurrentMemoMap: () => CurrentMemoMap2,
  LayerTypeId: () => LayerTypeId2,
  MemoMapTypeId: () => MemoMapTypeId2,
  annotateLogs: () => annotateLogs4,
  annotateSpans: () => annotateSpans4,
  build: () => build2,
  buildWithMemoMap: () => buildWithMemoMap2,
  buildWithScope: () => buildWithScope2,
  catchAll: () => catchAll4,
  catchAllCause: () => catchAllCause4,
  context: () => context6,
  die: () => die7,
  dieSync: () => dieSync4,
  discard: () => discard2,
  effect: () => effect,
  effectContext: () => effectContext,
  effectDiscard: () => effectDiscard,
  empty: () => empty33,
  extendScope: () => extendScope2,
  fail: () => fail10,
  failCause: () => failCause9,
  failCauseSync: () => failCauseSync4,
  failSync: () => failSync4,
  fiberRefLocallyScopedWith: () => fiberRefLocallyScopedWith3,
  flatMap: () => flatMap12,
  flatten: () => flatten11,
  fresh: () => fresh2,
  function: () => fromFunction3,
  isFresh: () => isFresh2,
  isLayer: () => isLayer2,
  launch: () => launch2,
  locally: () => locally2,
  locallyEffect: () => locallyEffect2,
  locallyScoped: () => locallyScoped2,
  locallyWith: () => locallyWith2,
  makeMemoMap: () => makeMemoMap2,
  map: () => map19,
  mapError: () => mapError4,
  match: () => match14,
  matchCause: () => matchCause5,
  memoize: () => memoize3,
  merge: () => merge8,
  mergeAll: () => mergeAll6,
  mock: () => mock2,
  orDie: () => orDie4,
  orElse: () => orElse6,
  parentSpan: () => parentSpan2,
  passthrough: () => passthrough3,
  project: () => project2,
  provide: () => provide3,
  provideMerge: () => provideMerge2,
  retry: () => retry3,
  scope: () => scope4,
  scoped: () => scoped3,
  scopedContext: () => scopedContext2,
  scopedDiscard: () => scopedDiscard2,
  service: () => service2,
  setClock: () => setClock,
  setConfigProvider: () => setConfigProvider2,
  setRandom: () => setRandom,
  setRequestBatching: () => setRequestBatching,
  setRequestCache: () => setRequestCache,
  setRequestCaching: () => setRequestCaching,
  setScheduler: () => setScheduler,
  setTracer: () => setTracer2,
  setTracerEnabled: () => setTracerEnabled,
  setTracerTiming: () => setTracerTiming,
  setUnhandledErrorLogLevel: () => setUnhandledErrorLogLevel,
  setVersionMismatchErrorLogLevel: () => setVersionMismatchErrorLogLevel,
  span: () => span3,
  succeed: () => succeed10,
  succeedContext: () => succeedContext2,
  suspend: () => suspend5,
  sync: () => sync6,
  syncContext: () => syncContext2,
  tap: () => tap5,
  tapError: () => tapError4,
  tapErrorCause: () => tapErrorCause4,
  toRuntime: () => toRuntime2,
  toRuntimeWithMemoMap: () => toRuntimeWithMemoMap2,
  unwrapEffect: () => unwrapEffect2,
  unwrapScoped: () => unwrapScoped2,
  updateService: () => updateService3,
  withParentSpan: () => withParentSpan4,
  withSpan: () => withSpan4,
  zipWith: () => zipWith8
});
var LayerTypeId2, MemoMapTypeId2, CurrentMemoMap2, isLayer2, isFresh2, annotateLogs4, annotateSpans4, build2, buildWithScope2, catchAll4, catchAllCause4, context6, die7, dieSync4, discard2, effect, effectDiscard, effectContext, empty33, extendScope2, fail10, failSync4, failCause9, failCauseSync4, flatMap12, flatten11, fresh2, mock2, fromFunction3, launch2, map19, mapError4, match14, matchCause5, memoize3, merge8, mergeAll6, orDie4, orElse6, passthrough3, project2, locallyEffect2, locally2, locallyWith2, locallyScoped2, fiberRefLocallyScopedWith3, retry3, scope4, scoped3, scopedDiscard2, scopedContext2, service2, succeed10, succeedContext2, suspend5, sync6, syncContext2, tap5, tapError4, tapErrorCause4, toRuntime2, toRuntimeWithMemoMap2, provide3, provideMerge2, zipWith8, unwrapEffect2, unwrapScoped2, setClock, setConfigProvider2, parentSpan2, setRandom, setRequestBatching, setRequestCaching, setRequestCache, setScheduler, span3, setTracer2, setTracerEnabled, setTracerTiming, setUnhandledErrorLogLevel, setVersionMismatchErrorLogLevel, withSpan4, withParentSpan4, makeMemoMap2, buildWithMemoMap2, updateService3;
var init_Layer = __esm({
  "node_modules/effect/dist/esm/Layer.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Context();
    init_Function();
    init_clock();
    init_core();
    init_defaultServices();
    init_fiberRuntime();
    init_layer2();
    init_circular3();
    init_query();
    init_random();
    init_Scheduler();
    LayerTypeId2 = LayerTypeId;
    MemoMapTypeId2 = MemoMapTypeId;
    CurrentMemoMap2 = CurrentMemoMap;
    isLayer2 = isLayer;
    isFresh2 = isFresh;
    annotateLogs4 = annotateLogs2;
    annotateSpans4 = annotateSpans2;
    build2 = build;
    buildWithScope2 = buildWithScope;
    catchAll4 = catchAll2;
    catchAllCause4 = catchAllCause2;
    context6 = context4;
    die7 = die5;
    dieSync4 = dieSync2;
    discard2 = discard;
    effect = fromEffect3;
    effectDiscard = fromEffectDiscard;
    effectContext = fromEffectContext;
    empty33 = empty32;
    extendScope2 = extendScope;
    fail10 = fail7;
    failSync4 = failSync2;
    failCause9 = failCause6;
    failCauseSync4 = failCauseSync2;
    flatMap12 = flatMap10;
    flatten11 = flatten9;
    fresh2 = fresh;
    mock2 = mock;
    fromFunction3 = fromFunction;
    launch2 = launch;
    map19 = map16;
    mapError4 = mapError2;
    match14 = match11;
    matchCause5 = matchCause3;
    memoize3 = memoize2;
    merge8 = merge6;
    mergeAll6 = mergeAll4;
    orDie4 = orDie2;
    orElse6 = orElse4;
    passthrough3 = passthrough;
    project2 = project;
    locallyEffect2 = locallyEffect;
    locally2 = fiberRefLocally2;
    locallyWith2 = fiberRefLocallyWith2;
    locallyScoped2 = fiberRefLocallyScoped2;
    fiberRefLocallyScopedWith3 = fiberRefLocallyScopedWith2;
    retry3 = retry;
    scope4 = scope2;
    scoped3 = scoped;
    scopedDiscard2 = scopedDiscard;
    scopedContext2 = scopedContext;
    service2 = service;
    succeed10 = succeed6;
    succeedContext2 = succeedContext;
    suspend5 = suspend3;
    sync6 = sync3;
    syncContext2 = syncContext;
    tap5 = tap3;
    tapError4 = tapError2;
    tapErrorCause4 = tapErrorCause2;
    toRuntime2 = toRuntime;
    toRuntimeWithMemoMap2 = toRuntimeWithMemoMap;
    provide3 = provide;
    provideMerge2 = provideMerge;
    zipWith8 = zipWith5;
    unwrapEffect2 = unwrapEffect;
    unwrapScoped2 = unwrapScoped;
    setClock = /* @__PURE__ */ __name((clock3) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(clockTag, clock3))), "setClock");
    setConfigProvider2 = setConfigProvider;
    parentSpan2 = parentSpan;
    setRandom = /* @__PURE__ */ __name((random4) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(randomTag, random4))), "setRandom");
    setRequestBatching = /* @__PURE__ */ __name((requestBatching) => scopedDiscard2(fiberRefLocallyScoped(currentRequestBatching, requestBatching)), "setRequestBatching");
    setRequestCaching = /* @__PURE__ */ __name((requestCaching) => scopedDiscard2(fiberRefLocallyScoped(currentCacheEnabled, requestCaching)), "setRequestCaching");
    setRequestCache = /* @__PURE__ */ __name((cache) => scopedDiscard2(isEffect(cache) ? flatMap8(cache, (x) => fiberRefLocallyScoped(currentCache, x)) : fiberRefLocallyScoped(currentCache, cache)), "setRequestCache");
    setScheduler = /* @__PURE__ */ __name((scheduler2) => scopedDiscard2(fiberRefLocallyScoped(currentScheduler, scheduler2)), "setScheduler");
    span3 = span2;
    setTracer2 = setTracer;
    setTracerEnabled = /* @__PURE__ */ __name((enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerEnabled, enabled2)), "setTracerEnabled");
    setTracerTiming = /* @__PURE__ */ __name((enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerTimingEnabled, enabled2)), "setTracerTiming");
    setUnhandledErrorLogLevel = /* @__PURE__ */ __name((level) => scopedDiscard2(fiberRefLocallyScoped(currentUnhandledErrorLogLevel, level)), "setUnhandledErrorLogLevel");
    setVersionMismatchErrorLogLevel = /* @__PURE__ */ __name((level) => scopedDiscard2(fiberRefLocallyScoped(currentVersionMismatchErrorLogLevel, level)), "setVersionMismatchErrorLogLevel");
    withSpan4 = withSpan2;
    withParentSpan4 = withParentSpan2;
    makeMemoMap2 = makeMemoMap;
    buildWithMemoMap2 = buildWithMemoMap;
    updateService3 = /* @__PURE__ */ dual(3, (layer, tag2, f) => provide3(layer, map19(context6(), (c) => add2(c, tag2, f(unsafeGet3(c, tag2))))));
  }
});

// node_modules/effect/dist/esm/internal/queue.js
var EnqueueSymbolKey, EnqueueTypeId, DequeueSymbolKey, DequeueTypeId, QueueStrategySymbolKey, QueueStrategyTypeId, BackingQueueSymbolKey, BackingQueueTypeId, queueStrategyVariance, backingQueueVariance, enqueueVariance, dequeueVariance, QueueImpl, takeRemainderLoop, bounded2, dropping, sliding, unbounded2, unsafeMake11, make43, BackingQueueFromMutableQueue, backingQueueFromMutableQueue, capacity2, size10, isFull, isEmpty10, isShutdown, awaitShutdown, shutdown, offer2, offerAll2, poll5, take2, takeAll, takeUpTo, takeBetween, takeN, backPressureStrategy, droppingStrategy, slidingStrategy, BackPressureStrategy, DroppingStrategy, SlidingStrategy, unsafeCompleteDeferred, unsafeOfferAll, unsafePollAll, unsafePollN, unsafeRemove, unsafeCompleteTakers;
var init_queue = __esm({
  "node_modules/effect/dist/esm/internal/queue.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Chunk();
    init_Effectable();
    init_Function();
    init_MutableQueue();
    init_MutableRef();
    init_Option();
    init_Pipeable();
    init_core();
    init_fiberRuntime();
    EnqueueSymbolKey = "effect/QueueEnqueue";
    EnqueueTypeId = /* @__PURE__ */ Symbol.for(EnqueueSymbolKey);
    DequeueSymbolKey = "effect/QueueDequeue";
    DequeueTypeId = /* @__PURE__ */ Symbol.for(DequeueSymbolKey);
    QueueStrategySymbolKey = "effect/QueueStrategy";
    QueueStrategyTypeId = /* @__PURE__ */ Symbol.for(QueueStrategySymbolKey);
    BackingQueueSymbolKey = "effect/BackingQueue";
    BackingQueueTypeId = /* @__PURE__ */ Symbol.for(BackingQueueSymbolKey);
    queueStrategyVariance = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    backingQueueVariance = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    enqueueVariance = {
      /* c8 ignore next */
      _In: /* @__PURE__ */ __name((_) => _, "_In")
    };
    dequeueVariance = {
      /* c8 ignore next */
      _Out: /* @__PURE__ */ __name((_) => _, "_Out")
    };
    QueueImpl = class extends Class2 {
      static {
        __name(this, "QueueImpl");
      }
      queue;
      takers;
      shutdownHook;
      shutdownFlag;
      strategy;
      [EnqueueTypeId] = enqueueVariance;
      [DequeueTypeId] = dequeueVariance;
      constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
        super();
        this.queue = queue;
        this.takers = takers;
        this.shutdownHook = shutdownHook;
        this.shutdownFlag = shutdownFlag;
        this.strategy = strategy;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
      commit() {
        return this.take;
      }
      capacity() {
        return this.queue.capacity();
      }
      get size() {
        return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
      }
      unsafeSize() {
        if (get6(this.shutdownFlag)) {
          return none2();
        }
        return some2(this.queue.length() - length2(this.takers) + this.strategy.surplusSize());
      }
      get isEmpty() {
        return map11(this.size, (size15) => size15 <= 0);
      }
      get isFull() {
        return map11(this.size, (size15) => size15 >= this.capacity());
      }
      get shutdown() {
        return uninterruptible(withFiberRuntime((state) => {
          pipe(this.shutdownFlag, set2(true));
          return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state.id()), false, false), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
        }));
      }
      get isShutdown() {
        return sync(() => get6(this.shutdownFlag));
      }
      get awaitShutdown() {
        return deferredAwait(this.shutdownHook);
      }
      isActive() {
        return !get6(this.shutdownFlag);
      }
      unsafeOffer(value3) {
        if (get6(this.shutdownFlag)) {
          return false;
        }
        let noRemaining;
        if (this.queue.length() === 0) {
          const taker = pipe(this.takers, poll2(EmptyMutableQueue));
          if (taker !== EmptyMutableQueue) {
            unsafeCompleteDeferred(taker, value3);
            noRemaining = true;
          } else {
            noRemaining = false;
          }
        } else {
          noRemaining = false;
        }
        if (noRemaining) {
          return true;
        }
        const succeeded = this.queue.offer(value3);
        unsafeCompleteTakers(this.strategy, this.queue, this.takers);
        return succeeded;
      }
      offer(value3) {
        return suspend(() => {
          if (get6(this.shutdownFlag)) {
            return interrupt2;
          }
          let noRemaining;
          if (this.queue.length() === 0) {
            const taker = pipe(this.takers, poll2(EmptyMutableQueue));
            if (taker !== EmptyMutableQueue) {
              unsafeCompleteDeferred(taker, value3);
              noRemaining = true;
            } else {
              noRemaining = false;
            }
          } else {
            noRemaining = false;
          }
          if (noRemaining) {
            return succeed(true);
          }
          const succeeded = this.queue.offer(value3);
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return succeeded ? succeed(true) : this.strategy.handleSurplus([value3], this.queue, this.takers, this.shutdownFlag);
        });
      }
      offerAll(iterable) {
        return suspend(() => {
          if (get6(this.shutdownFlag)) {
            return interrupt2;
          }
          const values4 = fromIterable2(iterable);
          const pTakers = this.queue.length() === 0 ? fromIterable2(unsafePollN(this.takers, values4.length)) : empty2;
          const [forTakers, remaining] = pipe(values4, splitAt(pTakers.length));
          for (let i = 0; i < pTakers.length; i++) {
            const taker = pTakers[i];
            const item = forTakers[i];
            unsafeCompleteDeferred(taker, item);
          }
          if (remaining.length === 0) {
            return succeed(true);
          }
          const surplus = this.queue.offerAll(remaining);
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return isEmpty(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
        });
      }
      get take() {
        return withFiberRuntime((state) => {
          if (get6(this.shutdownFlag)) {
            return interrupt2;
          }
          const item = this.queue.poll(EmptyMutableQueue);
          if (item !== EmptyMutableQueue) {
            this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
            return succeed(item);
          } else {
            const deferred = deferredUnsafeMake(state.id());
            return pipe(suspend(() => {
              pipe(this.takers, offer(deferred));
              unsafeCompleteTakers(this.strategy, this.queue, this.takers);
              return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
            }), onInterrupt(() => {
              return sync(() => unsafeRemove(this.takers, deferred));
            }));
          }
        });
      }
      get takeAll() {
        return suspend(() => {
          return get6(this.shutdownFlag) ? interrupt2 : sync(() => {
            const values4 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
            this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
            return fromIterable3(values4);
          });
        });
      }
      takeUpTo(max6) {
        return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => {
          const values4 = this.queue.pollUpTo(max6);
          this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
          return fromIterable3(values4);
        }));
      }
      takeBetween(min4, max6) {
        return suspend(() => takeRemainderLoop(this, min4, max6, empty5()));
      }
    };
    takeRemainderLoop = /* @__PURE__ */ __name((self2, min4, max6, acc) => {
      if (max6 < min4) {
        return succeed(acc);
      }
      return pipe(takeUpTo(self2, max6), flatMap8((bs) => {
        const remaining = min4 - bs.length;
        if (remaining === 1) {
          return pipe(take2(self2), map11((b) => pipe(acc, appendAll2(bs), append2(b))));
        }
        if (remaining > 1) {
          return pipe(take2(self2), flatMap8((b) => takeRemainderLoop(self2, remaining - 1, max6 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
        }
        return succeed(pipe(acc, appendAll2(bs)));
      }));
    }, "takeRemainderLoop");
    bounded2 = /* @__PURE__ */ __name((requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make43(backingQueueFromMutableQueue(queue), backPressureStrategy()))), "bounded");
    dropping = /* @__PURE__ */ __name((requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make43(backingQueueFromMutableQueue(queue), droppingStrategy()))), "dropping");
    sliding = /* @__PURE__ */ __name((requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make43(backingQueueFromMutableQueue(queue), slidingStrategy()))), "sliding");
    unbounded2 = /* @__PURE__ */ __name(() => pipe(sync(() => unbounded()), flatMap8((queue) => make43(backingQueueFromMutableQueue(queue), droppingStrategy()))), "unbounded");
    unsafeMake11 = /* @__PURE__ */ __name((queue, takers, shutdownHook, shutdownFlag, strategy) => {
      return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
    }, "unsafeMake");
    make43 = /* @__PURE__ */ __name((queue, strategy) => pipe(deferredMake(), map11((deferred) => unsafeMake11(queue, unbounded(), deferred, make12(false), strategy))), "make");
    BackingQueueFromMutableQueue = class {
      static {
        __name(this, "BackingQueueFromMutableQueue");
      }
      mutable;
      [BackingQueueTypeId] = backingQueueVariance;
      constructor(mutable3) {
        this.mutable = mutable3;
      }
      poll(def) {
        return poll2(this.mutable, def);
      }
      pollUpTo(limit) {
        return pollUpTo(this.mutable, limit);
      }
      offerAll(elements) {
        return offerAll(this.mutable, elements);
      }
      offer(element2) {
        return offer(this.mutable, element2);
      }
      capacity() {
        return capacity(this.mutable);
      }
      length() {
        return length2(this.mutable);
      }
    };
    backingQueueFromMutableQueue = /* @__PURE__ */ __name((mutable3) => new BackingQueueFromMutableQueue(mutable3), "backingQueueFromMutableQueue");
    capacity2 = /* @__PURE__ */ __name((self2) => self2.capacity(), "capacity");
    size10 = /* @__PURE__ */ __name((self2) => self2.size, "size");
    isFull = /* @__PURE__ */ __name((self2) => self2.isFull, "isFull");
    isEmpty10 = /* @__PURE__ */ __name((self2) => self2.isEmpty, "isEmpty");
    isShutdown = /* @__PURE__ */ __name((self2) => self2.isShutdown, "isShutdown");
    awaitShutdown = /* @__PURE__ */ __name((self2) => self2.awaitShutdown, "awaitShutdown");
    shutdown = /* @__PURE__ */ __name((self2) => self2.shutdown, "shutdown");
    offer2 = /* @__PURE__ */ dual(2, (self2, value3) => self2.offer(value3));
    offerAll2 = /* @__PURE__ */ dual(2, (self2, iterable) => self2.offerAll(iterable));
    poll5 = /* @__PURE__ */ __name((self2) => map11(self2.takeUpTo(1), head2), "poll");
    take2 = /* @__PURE__ */ __name((self2) => self2.take, "take");
    takeAll = /* @__PURE__ */ __name((self2) => self2.takeAll, "takeAll");
    takeUpTo = /* @__PURE__ */ dual(2, (self2, max6) => self2.takeUpTo(max6));
    takeBetween = /* @__PURE__ */ dual(3, (self2, min4, max6) => self2.takeBetween(min4, max6));
    takeN = /* @__PURE__ */ dual(2, (self2, n) => self2.takeBetween(n, n));
    backPressureStrategy = /* @__PURE__ */ __name(() => new BackPressureStrategy(), "backPressureStrategy");
    droppingStrategy = /* @__PURE__ */ __name(() => new DroppingStrategy(), "droppingStrategy");
    slidingStrategy = /* @__PURE__ */ __name(() => new SlidingStrategy(), "slidingStrategy");
    BackPressureStrategy = class {
      static {
        __name(this, "BackPressureStrategy");
      }
      [QueueStrategyTypeId] = queueStrategyVariance;
      putters = /* @__PURE__ */ unbounded();
      surplusSize() {
        return length2(this.putters);
      }
      onCompleteTakersWithEmptyQueue(takers) {
        while (!isEmpty7(this.putters) && !isEmpty7(takers)) {
          const taker = poll2(takers, void 0);
          const putter = poll2(this.putters, void 0);
          if (putter[2]) {
            unsafeCompleteDeferred(putter[1], true);
          }
          unsafeCompleteDeferred(taker, putter[0]);
        }
      }
      get shutdown() {
        return pipe(fiberId, flatMap8((fiberId3) => pipe(sync(() => unsafePollAll(this.putters)), flatMap8((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid2) : void_2, false, false)))));
      }
      handleSurplus(iterable, queue, takers, isShutdown7) {
        return withFiberRuntime((state) => {
          const deferred = deferredUnsafeMake(state.id());
          return pipe(suspend(() => {
            this.unsafeOffer(iterable, deferred);
            this.unsafeOnQueueEmptySpace(queue, takers);
            unsafeCompleteTakers(this, queue, takers);
            return get6(isShutdown7) ? interrupt2 : deferredAwait(deferred);
          }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
        });
      }
      unsafeOnQueueEmptySpace(queue, takers) {
        let keepPolling = true;
        while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
          const putter = pipe(this.putters, poll2(EmptyMutableQueue));
          if (putter === EmptyMutableQueue) {
            keepPolling = false;
          } else {
            const offered = queue.offer(putter[0]);
            if (offered && putter[2]) {
              unsafeCompleteDeferred(putter[1], true);
            } else if (!offered) {
              unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend2(putter)));
            }
            unsafeCompleteTakers(this, queue, takers);
          }
        }
      }
      unsafeOffer(iterable, deferred) {
        const stuff = fromIterable2(iterable);
        for (let i = 0; i < stuff.length; i++) {
          const value3 = stuff[i];
          if (i === stuff.length - 1) {
            pipe(this.putters, offer([value3, deferred, true]));
          } else {
            pipe(this.putters, offer([value3, deferred, false]));
          }
        }
      }
      unsafeRemove(deferred) {
        unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter3(([, _]) => _ !== deferred)));
      }
    };
    DroppingStrategy = class {
      static {
        __name(this, "DroppingStrategy");
      }
      [QueueStrategyTypeId] = queueStrategyVariance;
      surplusSize() {
        return 0;
      }
      get shutdown() {
        return void_2;
      }
      onCompleteTakersWithEmptyQueue() {
      }
      handleSurplus(_iterable, _queue, _takers, _isShutdown) {
        return succeed(false);
      }
      unsafeOnQueueEmptySpace(_queue, _takers) {
      }
    };
    SlidingStrategy = class {
      static {
        __name(this, "SlidingStrategy");
      }
      [QueueStrategyTypeId] = queueStrategyVariance;
      surplusSize() {
        return 0;
      }
      get shutdown() {
        return void_2;
      }
      onCompleteTakersWithEmptyQueue() {
      }
      handleSurplus(iterable, queue, takers, _isShutdown) {
        return sync(() => {
          this.unsafeOffer(queue, iterable);
          unsafeCompleteTakers(this, queue, takers);
          return true;
        });
      }
      unsafeOnQueueEmptySpace(_queue, _takers) {
      }
      unsafeOffer(queue, iterable) {
        const iterator2 = iterable[Symbol.iterator]();
        let next4;
        let offering = true;
        while (!(next4 = iterator2.next()).done && offering) {
          if (queue.capacity() === 0) {
            return;
          }
          queue.poll(EmptyMutableQueue);
          offering = queue.offer(next4.value);
        }
      }
    };
    unsafeCompleteDeferred = /* @__PURE__ */ __name((deferred, a) => {
      return deferredUnsafeDone(deferred, succeed(a));
    }, "unsafeCompleteDeferred");
    unsafeOfferAll = /* @__PURE__ */ __name((queue, as12) => {
      return pipe(queue, offerAll(as12));
    }, "unsafeOfferAll");
    unsafePollAll = /* @__PURE__ */ __name((queue) => {
      return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
    }, "unsafePollAll");
    unsafePollN = /* @__PURE__ */ __name((queue, max6) => {
      return pipe(queue, pollUpTo(max6));
    }, "unsafePollN");
    unsafeRemove = /* @__PURE__ */ __name((queue, a) => {
      unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter3((b) => a !== b)));
    }, "unsafeRemove");
    unsafeCompleteTakers = /* @__PURE__ */ __name((strategy, queue, takers) => {
      let keepPolling = true;
      while (keepPolling && queue.length() !== 0) {
        const taker = pipe(takers, poll2(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          const element2 = queue.poll(EmptyMutableQueue);
          if (element2 !== EmptyMutableQueue) {
            unsafeCompleteDeferred(taker, element2);
            strategy.unsafeOnQueueEmptySpace(queue, takers);
          } else {
            unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend2(taker)));
          }
          keepPolling = true;
        } else {
          keepPolling = false;
        }
      }
      if (keepPolling && queue.length() === 0 && !isEmpty7(takers)) {
        strategy.onCompleteTakersWithEmptyQueue(takers);
      }
    }, "unsafeCompleteTakers");
  }
});

// node_modules/effect/dist/esm/internal/pubsub.js
var AbsentValue, addSubscribers, removeSubscribers, bounded3, dropping2, sliding2, unbounded3, shutdown2, subscribe, makeBoundedPubSub, makeUnboundedPubSub, makeSubscription, unsafeMakeSubscription, BoundedPubSubArb, BoundedPubSubArbSubscription, BoundedPubSubPow2, BoundedPubSubPow2Subscription, BoundedPubSubSingle, BoundedPubSubSingleSubscription, UnboundedPubSub, UnboundedPubSubSubscription, SubscriptionImpl, takeRemainderLoop2, PubSubImpl, makePubSub, unsafeMakePubSub, ensureCapacity, unsafeCompleteDeferred2, unsafeOfferAll2, unsafePollAllQueue, unsafePollAllSubscription, unsafePollN2, unsafePublishAll, unsafeRemove2, BackPressureStrategy2, DroppingStrategy2, SlidingStrategy2, unsafeStrategyCompletePollers, unsafeStrategyCompleteSubscribers, ReplayBuffer, ReplayWindowImpl, emptyReplayWindow;
var init_pubsub = __esm({
  "node_modules/effect/dist/esm/internal/pubsub.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Chunk();
    init_Effectable();
    init_Function();
    init_MutableQueue();
    init_MutableRef();
    init_Number();
    init_Option();
    init_Pipeable();
    init_core();
    init_executionStrategy();
    init_fiberRuntime();
    init_queue();
    AbsentValue = /* @__PURE__ */ Symbol.for("effect/PubSub/AbsentValue");
    addSubscribers = /* @__PURE__ */ __name((subscription, pollers) => (subscribers) => {
      if (!subscribers.has(subscription)) {
        subscribers.set(subscription, /* @__PURE__ */ new Set());
      }
      const set10 = subscribers.get(subscription);
      set10.add(pollers);
    }, "addSubscribers");
    removeSubscribers = /* @__PURE__ */ __name((subscription, pollers) => (subscribers) => {
      if (!subscribers.has(subscription)) {
        return;
      }
      const set10 = subscribers.get(subscription);
      set10.delete(pollers);
      if (set10.size === 0) {
        subscribers.delete(subscription);
      }
    }, "removeSubscribers");
    bounded3 = /* @__PURE__ */ __name((capacity7) => suspend(() => {
      const pubsub = makeBoundedPubSub(capacity7);
      return makePubSub(pubsub, new BackPressureStrategy2());
    }), "bounded");
    dropping2 = /* @__PURE__ */ __name((capacity7) => suspend(() => {
      const pubsub = makeBoundedPubSub(capacity7);
      return makePubSub(pubsub, new DroppingStrategy2());
    }), "dropping");
    sliding2 = /* @__PURE__ */ __name((capacity7) => suspend(() => {
      const pubsub = makeBoundedPubSub(capacity7);
      return makePubSub(pubsub, new SlidingStrategy2());
    }), "sliding");
    unbounded3 = /* @__PURE__ */ __name((options) => suspend(() => {
      const pubsub = makeUnboundedPubSub(options);
      return makePubSub(pubsub, new DroppingStrategy2());
    }), "unbounded");
    shutdown2 = /* @__PURE__ */ __name((self2) => self2.shutdown, "shutdown");
    subscribe = /* @__PURE__ */ __name((self2) => self2.subscribe, "subscribe");
    makeBoundedPubSub = /* @__PURE__ */ __name((capacity7) => {
      const options = typeof capacity7 === "number" ? {
        capacity: capacity7
      } : capacity7;
      ensureCapacity(options.capacity);
      const replayBuffer = options.replay && options.replay > 0 ? new ReplayBuffer(Math.ceil(options.replay)) : void 0;
      if (options.capacity === 1) {
        return new BoundedPubSubSingle(replayBuffer);
      } else if (nextPow2(options.capacity) === options.capacity) {
        return new BoundedPubSubPow2(options.capacity, replayBuffer);
      } else {
        return new BoundedPubSubArb(options.capacity, replayBuffer);
      }
    }, "makeBoundedPubSub");
    makeUnboundedPubSub = /* @__PURE__ */ __name((options) => new UnboundedPubSub(options?.replay ? new ReplayBuffer(options.replay) : void 0), "makeUnboundedPubSub");
    makeSubscription = /* @__PURE__ */ __name((pubsub, subscribers, strategy) => map11(deferredMake(), (deferred) => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), unbounded(), deferred, make12(false), strategy)), "makeSubscription");
    unsafeMakeSubscription = /* @__PURE__ */ __name((pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, pubsub.replayWindow()), "unsafeMakeSubscription");
    BoundedPubSubArb = class {
      static {
        __name(this, "BoundedPubSubArb");
      }
      capacity;
      replayBuffer;
      array;
      publisherIndex = 0;
      subscribers;
      subscriberCount = 0;
      subscribersIndex = 0;
      constructor(capacity7, replayBuffer) {
        this.capacity = capacity7;
        this.replayBuffer = replayBuffer;
        this.array = Array.from({
          length: capacity7
        });
        this.subscribers = Array.from({
          length: capacity7
        });
      }
      replayWindow() {
        return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
      }
      isEmpty() {
        return this.publisherIndex === this.subscribersIndex;
      }
      isFull() {
        return this.publisherIndex === this.subscribersIndex + this.capacity;
      }
      size() {
        return this.publisherIndex - this.subscribersIndex;
      }
      publish(value3) {
        if (this.isFull()) {
          return false;
        }
        if (this.subscriberCount !== 0) {
          const index2 = this.publisherIndex % this.capacity;
          this.array[index2] = value3;
          this.subscribers[index2] = this.subscriberCount;
          this.publisherIndex += 1;
        }
        if (this.replayBuffer) {
          this.replayBuffer.offer(value3);
        }
        return true;
      }
      publishAll(elements) {
        if (this.subscriberCount === 0) {
          if (this.replayBuffer) {
            this.replayBuffer.offerAll(elements);
          }
          return empty5();
        }
        const chunk4 = fromIterable3(elements);
        const n = chunk4.length;
        const size15 = this.publisherIndex - this.subscribersIndex;
        const available = this.capacity - size15;
        const forPubSub = Math.min(n, available);
        if (forPubSub === 0) {
          return chunk4;
        }
        let iteratorIndex = 0;
        const publishAllIndex = this.publisherIndex + forPubSub;
        while (this.publisherIndex !== publishAllIndex) {
          const a = unsafeGet4(chunk4, iteratorIndex++);
          const index2 = this.publisherIndex % this.capacity;
          this.array[index2] = a;
          this.subscribers[index2] = this.subscriberCount;
          this.publisherIndex += 1;
          if (this.replayBuffer) {
            this.replayBuffer.offer(a);
          }
        }
        return drop2(chunk4, iteratorIndex);
      }
      slide() {
        if (this.subscribersIndex !== this.publisherIndex) {
          const index2 = this.subscribersIndex % this.capacity;
          this.array[index2] = AbsentValue;
          this.subscribers[index2] = 0;
          this.subscribersIndex += 1;
        }
        if (this.replayBuffer) {
          this.replayBuffer.slide();
        }
      }
      subscribe() {
        this.subscriberCount += 1;
        return new BoundedPubSubArbSubscription(this, this.publisherIndex, false);
      }
    };
    BoundedPubSubArbSubscription = class {
      static {
        __name(this, "BoundedPubSubArbSubscription");
      }
      self;
      subscriberIndex;
      unsubscribed;
      constructor(self2, subscriberIndex, unsubscribed) {
        this.self = self2;
        this.subscriberIndex = subscriberIndex;
        this.unsubscribed = unsubscribed;
      }
      isEmpty() {
        return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
      }
      size() {
        if (this.unsubscribed) {
          return 0;
        }
        return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
      }
      poll(default_) {
        if (this.unsubscribed) {
          return default_;
        }
        this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
        if (this.subscriberIndex !== this.self.publisherIndex) {
          const index2 = this.subscriberIndex % this.self.capacity;
          const elem = this.self.array[index2];
          this.self.subscribers[index2] -= 1;
          if (this.self.subscribers[index2] === 0) {
            this.self.array[index2] = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          this.subscriberIndex += 1;
          return elem;
        }
        return default_;
      }
      pollUpTo(n) {
        if (this.unsubscribed) {
          return empty5();
        }
        this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
        const size15 = this.self.publisherIndex - this.subscriberIndex;
        const toPoll = Math.min(n, size15);
        if (toPoll <= 0) {
          return empty5();
        }
        const builder = [];
        const pollUpToIndex = this.subscriberIndex + toPoll;
        while (this.subscriberIndex !== pollUpToIndex) {
          const index2 = this.subscriberIndex % this.self.capacity;
          const a = this.self.array[index2];
          this.self.subscribers[index2] -= 1;
          if (this.self.subscribers[index2] === 0) {
            this.self.array[index2] = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          builder.push(a);
          this.subscriberIndex += 1;
        }
        return fromIterable3(builder);
      }
      unsubscribe() {
        if (!this.unsubscribed) {
          this.unsubscribed = true;
          this.self.subscriberCount -= 1;
          this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
          while (this.subscriberIndex !== this.self.publisherIndex) {
            const index2 = this.subscriberIndex % this.self.capacity;
            this.self.subscribers[index2] -= 1;
            if (this.self.subscribers[index2] === 0) {
              this.self.array[index2] = AbsentValue;
              this.self.subscribersIndex += 1;
            }
            this.subscriberIndex += 1;
          }
        }
      }
    };
    BoundedPubSubPow2 = class {
      static {
        __name(this, "BoundedPubSubPow2");
      }
      capacity;
      replayBuffer;
      array;
      mask;
      publisherIndex = 0;
      subscribers;
      subscriberCount = 0;
      subscribersIndex = 0;
      constructor(capacity7, replayBuffer) {
        this.capacity = capacity7;
        this.replayBuffer = replayBuffer;
        this.array = Array.from({
          length: capacity7
        });
        this.mask = capacity7 - 1;
        this.subscribers = Array.from({
          length: capacity7
        });
      }
      replayWindow() {
        return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
      }
      isEmpty() {
        return this.publisherIndex === this.subscribersIndex;
      }
      isFull() {
        return this.publisherIndex === this.subscribersIndex + this.capacity;
      }
      size() {
        return this.publisherIndex - this.subscribersIndex;
      }
      publish(value3) {
        if (this.isFull()) {
          return false;
        }
        if (this.subscriberCount !== 0) {
          const index2 = this.publisherIndex & this.mask;
          this.array[index2] = value3;
          this.subscribers[index2] = this.subscriberCount;
          this.publisherIndex += 1;
        }
        if (this.replayBuffer) {
          this.replayBuffer.offer(value3);
        }
        return true;
      }
      publishAll(elements) {
        if (this.subscriberCount === 0) {
          if (this.replayBuffer) {
            this.replayBuffer.offerAll(elements);
          }
          return empty5();
        }
        const chunk4 = fromIterable3(elements);
        const n = chunk4.length;
        const size15 = this.publisherIndex - this.subscribersIndex;
        const available = this.capacity - size15;
        const forPubSub = Math.min(n, available);
        if (forPubSub === 0) {
          return chunk4;
        }
        let iteratorIndex = 0;
        const publishAllIndex = this.publisherIndex + forPubSub;
        while (this.publisherIndex !== publishAllIndex) {
          const elem = unsafeGet4(chunk4, iteratorIndex++);
          const index2 = this.publisherIndex & this.mask;
          this.array[index2] = elem;
          this.subscribers[index2] = this.subscriberCount;
          this.publisherIndex += 1;
          if (this.replayBuffer) {
            this.replayBuffer.offer(elem);
          }
        }
        return drop2(chunk4, iteratorIndex);
      }
      slide() {
        if (this.subscribersIndex !== this.publisherIndex) {
          const index2 = this.subscribersIndex & this.mask;
          this.array[index2] = AbsentValue;
          this.subscribers[index2] = 0;
          this.subscribersIndex += 1;
        }
        if (this.replayBuffer) {
          this.replayBuffer.slide();
        }
      }
      subscribe() {
        this.subscriberCount += 1;
        return new BoundedPubSubPow2Subscription(this, this.publisherIndex, false);
      }
    };
    BoundedPubSubPow2Subscription = class {
      static {
        __name(this, "BoundedPubSubPow2Subscription");
      }
      self;
      subscriberIndex;
      unsubscribed;
      constructor(self2, subscriberIndex, unsubscribed) {
        this.self = self2;
        this.subscriberIndex = subscriberIndex;
        this.unsubscribed = unsubscribed;
      }
      isEmpty() {
        return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
      }
      size() {
        if (this.unsubscribed) {
          return 0;
        }
        return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
      }
      poll(default_) {
        if (this.unsubscribed) {
          return default_;
        }
        this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
        if (this.subscriberIndex !== this.self.publisherIndex) {
          const index2 = this.subscriberIndex & this.self.mask;
          const elem = this.self.array[index2];
          this.self.subscribers[index2] -= 1;
          if (this.self.subscribers[index2] === 0) {
            this.self.array[index2] = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          this.subscriberIndex += 1;
          return elem;
        }
        return default_;
      }
      pollUpTo(n) {
        if (this.unsubscribed) {
          return empty5();
        }
        this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
        const size15 = this.self.publisherIndex - this.subscriberIndex;
        const toPoll = Math.min(n, size15);
        if (toPoll <= 0) {
          return empty5();
        }
        const builder = [];
        const pollUpToIndex = this.subscriberIndex + toPoll;
        while (this.subscriberIndex !== pollUpToIndex) {
          const index2 = this.subscriberIndex & this.self.mask;
          const elem = this.self.array[index2];
          this.self.subscribers[index2] -= 1;
          if (this.self.subscribers[index2] === 0) {
            this.self.array[index2] = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          builder.push(elem);
          this.subscriberIndex += 1;
        }
        return fromIterable3(builder);
      }
      unsubscribe() {
        if (!this.unsubscribed) {
          this.unsubscribed = true;
          this.self.subscriberCount -= 1;
          this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
          while (this.subscriberIndex !== this.self.publisherIndex) {
            const index2 = this.subscriberIndex & this.self.mask;
            this.self.subscribers[index2] -= 1;
            if (this.self.subscribers[index2] === 0) {
              this.self.array[index2] = AbsentValue;
              this.self.subscribersIndex += 1;
            }
            this.subscriberIndex += 1;
          }
        }
      }
    };
    BoundedPubSubSingle = class {
      static {
        __name(this, "BoundedPubSubSingle");
      }
      replayBuffer;
      publisherIndex = 0;
      subscriberCount = 0;
      subscribers = 0;
      value = AbsentValue;
      capacity = 1;
      constructor(replayBuffer) {
        this.replayBuffer = replayBuffer;
      }
      replayWindow() {
        return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
      isEmpty() {
        return this.subscribers === 0;
      }
      isFull() {
        return !this.isEmpty();
      }
      size() {
        return this.isEmpty() ? 0 : 1;
      }
      publish(value3) {
        if (this.isFull()) {
          return false;
        }
        if (this.subscriberCount !== 0) {
          this.value = value3;
          this.subscribers = this.subscriberCount;
          this.publisherIndex += 1;
        }
        if (this.replayBuffer) {
          this.replayBuffer.offer(value3);
        }
        return true;
      }
      publishAll(elements) {
        if (this.subscriberCount === 0) {
          if (this.replayBuffer) {
            this.replayBuffer.offerAll(elements);
          }
          return empty5();
        }
        const chunk4 = fromIterable3(elements);
        if (isEmpty(chunk4)) {
          return chunk4;
        }
        if (this.publish(unsafeHead(chunk4))) {
          return drop2(chunk4, 1);
        } else {
          return chunk4;
        }
      }
      slide() {
        if (this.isFull()) {
          this.subscribers = 0;
          this.value = AbsentValue;
        }
        if (this.replayBuffer) {
          this.replayBuffer.slide();
        }
      }
      subscribe() {
        this.subscriberCount += 1;
        return new BoundedPubSubSingleSubscription(this, this.publisherIndex, false);
      }
    };
    BoundedPubSubSingleSubscription = class {
      static {
        __name(this, "BoundedPubSubSingleSubscription");
      }
      self;
      subscriberIndex;
      unsubscribed;
      constructor(self2, subscriberIndex, unsubscribed) {
        this.self = self2;
        this.subscriberIndex = subscriberIndex;
        this.unsubscribed = unsubscribed;
      }
      isEmpty() {
        return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
      }
      size() {
        return this.isEmpty() ? 0 : 1;
      }
      poll(default_) {
        if (this.isEmpty()) {
          return default_;
        }
        const elem = this.self.value;
        this.self.subscribers -= 1;
        if (this.self.subscribers === 0) {
          this.self.value = AbsentValue;
        }
        this.subscriberIndex += 1;
        return elem;
      }
      pollUpTo(n) {
        if (this.isEmpty() || n < 1) {
          return empty5();
        }
        const a = this.self.value;
        this.self.subscribers -= 1;
        if (this.self.subscribers === 0) {
          this.self.value = AbsentValue;
        }
        this.subscriberIndex += 1;
        return of2(a);
      }
      unsubscribe() {
        if (!this.unsubscribed) {
          this.unsubscribed = true;
          this.self.subscriberCount -= 1;
          if (this.subscriberIndex !== this.self.publisherIndex) {
            this.self.subscribers -= 1;
            if (this.self.subscribers === 0) {
              this.self.value = AbsentValue;
            }
          }
        }
      }
    };
    UnboundedPubSub = class {
      static {
        __name(this, "UnboundedPubSub");
      }
      replayBuffer;
      publisherHead = {
        value: AbsentValue,
        subscribers: 0,
        next: null
      };
      publisherTail = this.publisherHead;
      publisherIndex = 0;
      subscribersIndex = 0;
      capacity = Number.MAX_SAFE_INTEGER;
      constructor(replayBuffer) {
        this.replayBuffer = replayBuffer;
      }
      replayWindow() {
        return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
      }
      isEmpty() {
        return this.publisherHead === this.publisherTail;
      }
      isFull() {
        return false;
      }
      size() {
        return this.publisherIndex - this.subscribersIndex;
      }
      publish(value3) {
        const subscribers = this.publisherTail.subscribers;
        if (subscribers !== 0) {
          this.publisherTail.next = {
            value: value3,
            subscribers,
            next: null
          };
          this.publisherTail = this.publisherTail.next;
          this.publisherIndex += 1;
        }
        if (this.replayBuffer) {
          this.replayBuffer.offer(value3);
        }
        return true;
      }
      publishAll(elements) {
        if (this.publisherTail.subscribers !== 0) {
          for (const a of elements) {
            this.publish(a);
          }
        } else if (this.replayBuffer) {
          this.replayBuffer.offerAll(elements);
        }
        return empty5();
      }
      slide() {
        if (this.publisherHead !== this.publisherTail) {
          this.publisherHead = this.publisherHead.next;
          this.publisherHead.value = AbsentValue;
          this.subscribersIndex += 1;
        }
        if (this.replayBuffer) {
          this.replayBuffer.slide();
        }
      }
      subscribe() {
        this.publisherTail.subscribers += 1;
        return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
      }
    };
    UnboundedPubSubSubscription = class {
      static {
        __name(this, "UnboundedPubSubSubscription");
      }
      self;
      subscriberHead;
      subscriberIndex;
      unsubscribed;
      constructor(self2, subscriberHead, subscriberIndex, unsubscribed) {
        this.self = self2;
        this.subscriberHead = subscriberHead;
        this.subscriberIndex = subscriberIndex;
        this.unsubscribed = unsubscribed;
      }
      isEmpty() {
        if (this.unsubscribed) {
          return true;
        }
        let empty36 = true;
        let loop3 = true;
        while (loop3) {
          if (this.subscriberHead === this.self.publisherTail) {
            loop3 = false;
          } else {
            if (this.subscriberHead.next.value !== AbsentValue) {
              empty36 = false;
              loop3 = false;
            } else {
              this.subscriberHead = this.subscriberHead.next;
              this.subscriberIndex += 1;
            }
          }
        }
        return empty36;
      }
      size() {
        if (this.unsubscribed) {
          return 0;
        }
        return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
      }
      poll(default_) {
        if (this.unsubscribed) {
          return default_;
        }
        let loop3 = true;
        let polled = default_;
        while (loop3) {
          if (this.subscriberHead === this.self.publisherTail) {
            loop3 = false;
          } else {
            const elem = this.subscriberHead.next.value;
            if (elem !== AbsentValue) {
              polled = elem;
              this.subscriberHead.subscribers -= 1;
              if (this.subscriberHead.subscribers === 0) {
                this.self.publisherHead = this.self.publisherHead.next;
                this.self.publisherHead.value = AbsentValue;
                this.self.subscribersIndex += 1;
              }
              loop3 = false;
            }
            this.subscriberHead = this.subscriberHead.next;
            this.subscriberIndex += 1;
          }
        }
        return polled;
      }
      pollUpTo(n) {
        const builder = [];
        const default_ = AbsentValue;
        let i = 0;
        while (i !== n) {
          const a = this.poll(default_);
          if (a === default_) {
            i = n;
          } else {
            builder.push(a);
            i += 1;
          }
        }
        return fromIterable3(builder);
      }
      unsubscribe() {
        if (!this.unsubscribed) {
          this.unsubscribed = true;
          this.self.publisherTail.subscribers -= 1;
          while (this.subscriberHead !== this.self.publisherTail) {
            if (this.subscriberHead.next.value !== AbsentValue) {
              this.subscriberHead.subscribers -= 1;
              if (this.subscriberHead.subscribers === 0) {
                this.self.publisherHead = this.self.publisherHead.next;
                this.self.publisherHead.value = AbsentValue;
                this.self.subscribersIndex += 1;
              }
            }
            this.subscriberHead = this.subscriberHead.next;
          }
        }
      }
    };
    SubscriptionImpl = class extends Class2 {
      static {
        __name(this, "SubscriptionImpl");
      }
      pubsub;
      subscribers;
      subscription;
      pollers;
      shutdownHook;
      shutdownFlag;
      strategy;
      replayWindow;
      [DequeueTypeId] = dequeueVariance;
      constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, replayWindow) {
        super();
        this.pubsub = pubsub;
        this.subscribers = subscribers;
        this.subscription = subscription;
        this.pollers = pollers;
        this.shutdownHook = shutdownHook;
        this.shutdownFlag = shutdownFlag;
        this.strategy = strategy;
        this.replayWindow = replayWindow;
      }
      commit() {
        return this.take;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
      capacity() {
        return this.pubsub.capacity;
      }
      isActive() {
        return !get6(this.shutdownFlag);
      }
      get size() {
        return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() + this.replayWindow.remaining));
      }
      unsafeSize() {
        if (get6(this.shutdownFlag)) {
          return none2();
        }
        return some2(this.subscription.size() + this.replayWindow.remaining);
      }
      get isFull() {
        return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() === this.capacity()));
      }
      get isEmpty() {
        return map11(this.size, (size15) => size15 === 0);
      }
      get shutdown() {
        return uninterruptible(withFiberRuntime((state) => {
          set2(this.shutdownFlag, true);
          return pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers), (d) => deferredInterruptWith(d, state.id()), false), zipRight2(sync(() => {
            this.subscribers.delete(this.subscription);
            this.subscription.unsubscribe();
            this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
          })), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
        }));
      }
      get isShutdown() {
        return sync(() => get6(this.shutdownFlag));
      }
      get awaitShutdown() {
        return deferredAwait(this.shutdownHook);
      }
      get take() {
        return withFiberRuntime((state) => {
          if (get6(this.shutdownFlag)) {
            return interrupt2;
          }
          if (this.replayWindow.remaining > 0) {
            const message2 = this.replayWindow.take();
            return succeed(message2);
          }
          const message = isEmpty7(this.pollers) ? this.subscription.poll(EmptyMutableQueue) : EmptyMutableQueue;
          if (message === EmptyMutableQueue) {
            const deferred = deferredUnsafeMake(state.id());
            return pipe(suspend(() => {
              pipe(this.pollers, offer(deferred));
              pipe(this.subscribers, addSubscribers(this.subscription, this.pollers));
              this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
              return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
            }), onInterrupt(() => sync(() => unsafeRemove2(this.pollers, deferred))));
          } else {
            this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
            return succeed(message);
          }
        });
      }
      get takeAll() {
        return suspend(() => {
          if (get6(this.shutdownFlag)) {
            return interrupt2;
          }
          const as12 = isEmpty7(this.pollers) ? unsafePollAllSubscription(this.subscription) : empty5();
          this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
          if (this.replayWindow.remaining > 0) {
            return succeed(appendAll2(this.replayWindow.takeAll(), as12));
          }
          return succeed(as12);
        });
      }
      takeUpTo(max6) {
        return suspend(() => {
          if (get6(this.shutdownFlag)) {
            return interrupt2;
          }
          let replay = void 0;
          if (this.replayWindow.remaining >= max6) {
            const as13 = this.replayWindow.takeN(max6);
            return succeed(as13);
          } else if (this.replayWindow.remaining > 0) {
            replay = this.replayWindow.takeAll();
            max6 = max6 - replay.length;
          }
          const as12 = isEmpty7(this.pollers) ? unsafePollN2(this.subscription, max6) : empty5();
          this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
          return replay ? succeed(appendAll2(replay, as12)) : succeed(as12);
        });
      }
      takeBetween(min4, max6) {
        return suspend(() => takeRemainderLoop2(this, min4, max6, empty5()));
      }
    };
    takeRemainderLoop2 = /* @__PURE__ */ __name((self2, min4, max6, acc) => {
      if (max6 < min4) {
        return succeed(acc);
      }
      return pipe(self2.takeUpTo(max6), flatMap8((bs) => {
        const remaining = min4 - bs.length;
        if (remaining === 1) {
          return pipe(self2.take, map11((b) => pipe(acc, appendAll2(bs), append2(b))));
        }
        if (remaining > 1) {
          return pipe(self2.take, flatMap8((b) => takeRemainderLoop2(self2, remaining - 1, max6 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
        }
        return succeed(pipe(acc, appendAll2(bs)));
      }));
    }, "takeRemainderLoop");
    PubSubImpl = class {
      static {
        __name(this, "PubSubImpl");
      }
      pubsub;
      subscribers;
      scope;
      shutdownHook;
      shutdownFlag;
      strategy;
      [EnqueueTypeId] = enqueueVariance;
      [DequeueTypeId] = dequeueVariance;
      constructor(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) {
        this.pubsub = pubsub;
        this.subscribers = subscribers;
        this.scope = scope5;
        this.shutdownHook = shutdownHook;
        this.shutdownFlag = shutdownFlag;
        this.strategy = strategy;
      }
      capacity() {
        return this.pubsub.capacity;
      }
      get size() {
        return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => this.pubsub.size()));
      }
      unsafeSize() {
        if (get6(this.shutdownFlag)) {
          return none2();
        }
        return some2(this.pubsub.size());
      }
      get isFull() {
        return map11(this.size, (size15) => size15 === this.capacity());
      }
      get isEmpty() {
        return map11(this.size, (size15) => size15 === 0);
      }
      get awaitShutdown() {
        return deferredAwait(this.shutdownHook);
      }
      get isShutdown() {
        return sync(() => get6(this.shutdownFlag));
      }
      get shutdown() {
        return uninterruptible(withFiberRuntime((state) => {
          pipe(this.shutdownFlag, set2(true));
          return pipe(this.scope.close(exitInterrupt(state.id())), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
        }));
      }
      publish(value3) {
        return suspend(() => {
          if (get6(this.shutdownFlag)) {
            return interrupt2;
          }
          if (this.pubsub.publish(value3)) {
            this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
            return succeed(true);
          }
          return this.strategy.handleSurplus(this.pubsub, this.subscribers, of2(value3), this.shutdownFlag);
        });
      }
      isActive() {
        return !get6(this.shutdownFlag);
      }
      unsafeOffer(value3) {
        if (get6(this.shutdownFlag)) {
          return false;
        }
        if (this.pubsub.publish(value3)) {
          this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
          return true;
        }
        return false;
      }
      publishAll(elements) {
        return suspend(() => {
          if (get6(this.shutdownFlag)) {
            return interrupt2;
          }
          const surplus = unsafePublishAll(this.pubsub, elements);
          this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
          if (isEmpty(surplus)) {
            return succeed(true);
          }
          return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
        });
      }
      get subscribe() {
        const acquire2 = tap2(all5([this.scope.fork(sequential2), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), (tuple4) => tuple4[0].addFinalizer(() => tuple4[1].shutdown));
        return map11(acquireRelease(acquire2, (tuple4, exit5) => tuple4[0].close(exit5)), (tuple4) => tuple4[1]);
      }
      offer(value3) {
        return this.publish(value3);
      }
      offerAll(elements) {
        return this.publishAll(elements);
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    makePubSub = /* @__PURE__ */ __name((pubsub, strategy) => flatMap8(scopeMake(), (scope5) => map11(deferredMake(), (deferred) => unsafeMakePubSub(pubsub, /* @__PURE__ */ new Map(), scope5, deferred, make12(false), strategy))), "makePubSub");
    unsafeMakePubSub = /* @__PURE__ */ __name((pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) => new PubSubImpl(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy), "unsafeMakePubSub");
    ensureCapacity = /* @__PURE__ */ __name((capacity7) => {
      if (capacity7 <= 0) {
        throw new InvalidPubSubCapacityException(`Cannot construct PubSub with capacity of ${capacity7}`);
      }
    }, "ensureCapacity");
    unsafeCompleteDeferred2 = /* @__PURE__ */ __name((deferred, a) => {
      deferredUnsafeDone(deferred, succeed(a));
    }, "unsafeCompleteDeferred");
    unsafeOfferAll2 = /* @__PURE__ */ __name((queue, as12) => {
      return pipe(queue, offerAll(as12));
    }, "unsafeOfferAll");
    unsafePollAllQueue = /* @__PURE__ */ __name((queue) => {
      return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
    }, "unsafePollAllQueue");
    unsafePollAllSubscription = /* @__PURE__ */ __name((subscription) => {
      return subscription.pollUpTo(Number.POSITIVE_INFINITY);
    }, "unsafePollAllSubscription");
    unsafePollN2 = /* @__PURE__ */ __name((subscription, max6) => {
      return subscription.pollUpTo(max6);
    }, "unsafePollN");
    unsafePublishAll = /* @__PURE__ */ __name((pubsub, as12) => {
      return pubsub.publishAll(as12);
    }, "unsafePublishAll");
    unsafeRemove2 = /* @__PURE__ */ __name((queue, value3) => {
      unsafeOfferAll2(queue, pipe(unsafePollAllQueue(queue), filter3((elem) => elem !== value3)));
    }, "unsafeRemove");
    BackPressureStrategy2 = class {
      static {
        __name(this, "BackPressureStrategy");
      }
      publishers = /* @__PURE__ */ unbounded();
      get shutdown() {
        return flatMap8(fiberId, (fiberId3) => flatMap8(sync(() => unsafePollAllQueue(this.publishers)), (publishers) => forEachConcurrentDiscard(publishers, ([_, deferred, last6]) => last6 ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid2) : void_2, false, false)));
      }
      handleSurplus(pubsub, subscribers, elements, isShutdown7) {
        return withFiberRuntime((state) => {
          const deferred = deferredUnsafeMake(state.id());
          return pipe(suspend(() => {
            this.unsafeOffer(elements, deferred);
            this.unsafeOnPubSubEmptySpace(pubsub, subscribers);
            this.unsafeCompleteSubscribers(pubsub, subscribers);
            return get6(isShutdown7) ? interrupt2 : deferredAwait(deferred);
          }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
        });
      }
      unsafeOnPubSubEmptySpace(pubsub, subscribers) {
        let keepPolling = true;
        while (keepPolling && !pubsub.isFull()) {
          const publisher = pipe(this.publishers, poll2(EmptyMutableQueue));
          if (publisher === EmptyMutableQueue) {
            keepPolling = false;
          } else {
            const published = pubsub.publish(publisher[0]);
            if (published && publisher[2]) {
              unsafeCompleteDeferred2(publisher[1], true);
            } else if (!published) {
              unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), prepend2(publisher)));
            }
            this.unsafeCompleteSubscribers(pubsub, subscribers);
          }
        }
      }
      unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
        return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
      }
      unsafeCompleteSubscribers(pubsub, subscribers) {
        return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
      }
      unsafeOffer(elements, deferred) {
        const iterator2 = elements[Symbol.iterator]();
        let next4 = iterator2.next();
        if (!next4.done) {
          while (1) {
            const value3 = next4.value;
            next4 = iterator2.next();
            if (next4.done) {
              pipe(this.publishers, offer([value3, deferred, true]));
              break;
            }
            pipe(this.publishers, offer([value3, deferred, false]));
          }
        }
      }
      unsafeRemove(deferred) {
        unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), filter3(([_, a]) => a !== deferred)));
      }
    };
    DroppingStrategy2 = class {
      static {
        __name(this, "DroppingStrategy");
      }
      get shutdown() {
        return void_2;
      }
      handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
        return succeed(false);
      }
      unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
      }
      unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
        return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
      }
      unsafeCompleteSubscribers(pubsub, subscribers) {
        return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
      }
    };
    SlidingStrategy2 = class {
      static {
        __name(this, "SlidingStrategy");
      }
      get shutdown() {
        return void_2;
      }
      handleSurplus(pubsub, subscribers, elements, _isShutdown) {
        return sync(() => {
          this.unsafeSlidingPublish(pubsub, elements);
          this.unsafeCompleteSubscribers(pubsub, subscribers);
          return true;
        });
      }
      unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
      }
      unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
        return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
      }
      unsafeCompleteSubscribers(pubsub, subscribers) {
        return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
      }
      unsafeSlidingPublish(pubsub, elements) {
        const it = elements[Symbol.iterator]();
        let next4 = it.next();
        if (!next4.done && pubsub.capacity > 0) {
          let a = next4.value;
          let loop3 = true;
          while (loop3) {
            pubsub.slide();
            const pub = pubsub.publish(a);
            if (pub && (next4 = it.next()) && !next4.done) {
              a = next4.value;
            } else if (pub) {
              loop3 = false;
            }
          }
        }
      }
    };
    unsafeStrategyCompletePollers = /* @__PURE__ */ __name((strategy, pubsub, subscribers, subscription, pollers) => {
      let keepPolling = true;
      while (keepPolling && !subscription.isEmpty()) {
        const poller = pipe(pollers, poll2(EmptyMutableQueue));
        if (poller === EmptyMutableQueue) {
          pipe(subscribers, removeSubscribers(subscription, pollers));
          if (isEmpty7(pollers)) {
            keepPolling = false;
          } else {
            pipe(subscribers, addSubscribers(subscription, pollers));
          }
        } else {
          const pollResult = subscription.poll(EmptyMutableQueue);
          if (pollResult === EmptyMutableQueue) {
            unsafeOfferAll2(pollers, pipe(unsafePollAllQueue(pollers), prepend2(poller)));
          } else {
            unsafeCompleteDeferred2(poller, pollResult);
            strategy.unsafeOnPubSubEmptySpace(pubsub, subscribers);
          }
        }
      }
    }, "unsafeStrategyCompletePollers");
    unsafeStrategyCompleteSubscribers = /* @__PURE__ */ __name((strategy, pubsub, subscribers) => {
      for (const [subscription, pollersSet] of subscribers) {
        for (const pollers of pollersSet) {
          strategy.unsafeCompletePollers(pubsub, subscribers, subscription, pollers);
        }
      }
    }, "unsafeStrategyCompleteSubscribers");
    ReplayBuffer = class {
      static {
        __name(this, "ReplayBuffer");
      }
      capacity;
      constructor(capacity7) {
        this.capacity = capacity7;
      }
      head = {
        value: AbsentValue,
        next: null
      };
      tail = this.head;
      size = 0;
      index = 0;
      slide() {
        this.index++;
      }
      offer(a) {
        this.tail.value = a;
        this.tail.next = {
          value: AbsentValue,
          next: null
        };
        this.tail = this.tail.next;
        if (this.size === this.capacity) {
          this.head = this.head.next;
        } else {
          this.size += 1;
        }
      }
      offerAll(as12) {
        for (const a of as12) {
          this.offer(a);
        }
      }
    };
    ReplayWindowImpl = class {
      static {
        __name(this, "ReplayWindowImpl");
      }
      buffer;
      head;
      index;
      remaining;
      constructor(buffer3) {
        this.buffer = buffer3;
        this.index = buffer3.index;
        this.remaining = buffer3.size;
        this.head = buffer3.head;
      }
      fastForward() {
        while (this.index < this.buffer.index) {
          this.head = this.head.next;
          this.index++;
        }
      }
      take() {
        if (this.remaining === 0) {
          return void 0;
        } else if (this.index < this.buffer.index) {
          this.fastForward();
        }
        this.remaining--;
        const value3 = this.head.value;
        this.head = this.head.next;
        return value3;
      }
      takeN(n) {
        if (this.remaining === 0) {
          return empty5();
        } else if (this.index < this.buffer.index) {
          this.fastForward();
        }
        const len = Math.min(n, this.remaining);
        const items = new Array(len);
        for (let i = 0; i < len; i++) {
          const value3 = this.head.value;
          this.head = this.head.next;
          items[i] = value3;
        }
        this.remaining -= len;
        return unsafeFromArray(items);
      }
      takeAll() {
        return this.takeN(this.remaining);
      }
    };
    emptyReplayWindow = {
      remaining: 0,
      take: /* @__PURE__ */ __name(() => void 0, "take"),
      takeN: /* @__PURE__ */ __name(() => empty5(), "takeN"),
      takeAll: /* @__PURE__ */ __name(() => empty5(), "takeAll")
    };
  }
});

// node_modules/effect/dist/esm/PubSub.js
var bounded4, dropping3, sliding3, unbounded4, shutdown3, subscribe2;
var init_PubSub = __esm({
  "node_modules/effect/dist/esm/PubSub.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_pubsub();
    bounded4 = bounded3;
    dropping3 = dropping2;
    sliding3 = sliding2;
    unbounded4 = unbounded3;
    shutdown3 = shutdown2;
    subscribe2 = subscribe;
  }
});

// node_modules/effect/dist/esm/Queue.js
var DequeueTypeId2, bounded5, dropping4, sliding4, unbounded5, capacity4, size12, isEmpty12, isFull3, isShutdown3, awaitShutdown3, shutdown4, offer3, offerAll3, poll6, take3, takeAll2, takeUpTo2, takeBetween2, takeN2;
var init_Queue = __esm({
  "node_modules/effect/dist/esm/Queue.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_queue();
    DequeueTypeId2 = DequeueTypeId;
    bounded5 = bounded2;
    dropping4 = dropping;
    sliding4 = sliding;
    unbounded5 = unbounded2;
    capacity4 = capacity2;
    size12 = size10;
    isEmpty12 = isEmpty10;
    isFull3 = isFull;
    isShutdown3 = isShutdown;
    awaitShutdown3 = awaitShutdown;
    shutdown4 = shutdown;
    offer3 = offer2;
    offerAll3 = offerAll2;
    poll6 = poll5;
    take3 = take2;
    takeAll2 = takeAll;
    takeUpTo2 = takeUpTo;
    takeBetween2 = takeBetween;
    takeN2 = takeN;
  }
});

// node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
var OP_CONTINUE2, OP_CLOSE, OP_YIELD2;
var init_channelChildExecutorDecision = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_CONTINUE2 = "Continue";
    OP_CLOSE = "Close";
    OP_YIELD2 = "Yield";
  }
});

// node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey, ChildExecutorDecisionTypeId, proto4, Continue;
var init_childExecutorDecision = __esm({
  "node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_channelChildExecutorDecision();
    ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
    ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
    proto4 = {
      [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
    };
    Continue = /* @__PURE__ */ __name((_) => {
      const op = Object.create(proto4);
      op._tag = OP_CONTINUE2;
      return op;
    }, "Continue");
  }
});

// node_modules/effect/dist/esm/internal/opCodes/continuation.js
var OP_CONTINUATION_K, OP_CONTINUATION_FINALIZER;
var init_continuation = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/continuation.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_CONTINUATION_K = "ContinuationK";
    OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";
  }
});

// node_modules/effect/dist/esm/internal/channel/continuation.js
var ContinuationTypeId, continuationVariance, ContinuationKImpl, ContinuationFinalizerImpl;
var init_continuation2 = __esm({
  "node_modules/effect/dist/esm/internal/channel/continuation.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Exit();
    init_continuation();
    ContinuationTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelContinuation");
    continuationVariance = {
      /* c8 ignore next */
      _Env: /* @__PURE__ */ __name((_) => _, "_Env"),
      /* c8 ignore next */
      _InErr: /* @__PURE__ */ __name((_) => _, "_InErr"),
      /* c8 ignore next */
      _InElem: /* @__PURE__ */ __name((_) => _, "_InElem"),
      /* c8 ignore next */
      _InDone: /* @__PURE__ */ __name((_) => _, "_InDone"),
      /* c8 ignore next */
      _OutErr: /* @__PURE__ */ __name((_) => _, "_OutErr"),
      /* c8 ignore next */
      _OutDone: /* @__PURE__ */ __name((_) => _, "_OutDone"),
      /* c8 ignore next */
      _OutErr2: /* @__PURE__ */ __name((_) => _, "_OutErr2"),
      /* c8 ignore next */
      _OutElem: /* @__PURE__ */ __name((_) => _, "_OutElem"),
      /* c8 ignore next */
      _OutDone2: /* @__PURE__ */ __name((_) => _, "_OutDone2")
    };
    ContinuationKImpl = class {
      static {
        __name(this, "ContinuationKImpl");
      }
      onSuccess;
      onHalt;
      _tag = OP_CONTINUATION_K;
      [ContinuationTypeId] = continuationVariance;
      constructor(onSuccess, onHalt) {
        this.onSuccess = onSuccess;
        this.onHalt = onHalt;
      }
      onExit(exit5) {
        return isFailure(exit5) ? this.onHalt(exit5.cause) : this.onSuccess(exit5.value);
      }
    };
    ContinuationFinalizerImpl = class {
      static {
        __name(this, "ContinuationFinalizerImpl");
      }
      finalizer;
      _tag = OP_CONTINUATION_FINALIZER;
      [ContinuationTypeId] = continuationVariance;
      constructor(finalizer3) {
        this.finalizer = finalizer3;
      }
    };
  }
});

// node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
var OP_PULL_AFTER_NEXT, OP_PULL_AFTER_ALL_ENQUEUED;
var init_channelUpstreamPullStrategy = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_PULL_AFTER_NEXT = "PullAfterNext";
    OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";
  }
});

// node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey, UpstreamPullStrategyTypeId, upstreamPullStrategyVariance, proto5, PullAfterNext;
var init_upstreamPullStrategy = __esm({
  "node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_channelUpstreamPullStrategy();
    UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
    UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
    upstreamPullStrategyVariance = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    proto5 = {
      [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
    };
    PullAfterNext = /* @__PURE__ */ __name((emitSeparator) => {
      const op = Object.create(proto5);
      op._tag = OP_PULL_AFTER_NEXT;
      op.emitSeparator = emitSeparator;
      return op;
    }, "PullAfterNext");
  }
});

// node_modules/effect/dist/esm/internal/opCodes/channel.js
var OP_BRACKET_OUT, OP_BRIDGE, OP_CONCAT_ALL, OP_EMIT, OP_ENSURING, OP_FAIL3, OP_FOLD2, OP_FROM_EFFECT2, OP_PIPE_TO, OP_PROVIDE2, OP_READ, OP_SUCCEED, OP_SUCCEED_NOW, OP_SUSPEND2;
var init_channel = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/channel.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_BRACKET_OUT = "BracketOut";
    OP_BRIDGE = "Bridge";
    OP_CONCAT_ALL = "ConcatAll";
    OP_EMIT = "Emit";
    OP_ENSURING = "Ensuring";
    OP_FAIL3 = "Fail";
    OP_FOLD2 = "Fold";
    OP_FROM_EFFECT2 = "FromEffect";
    OP_PIPE_TO = "PipeTo";
    OP_PROVIDE2 = "Provide";
    OP_READ = "Read";
    OP_SUCCEED = "Succeed";
    OP_SUCCEED_NOW = "SucceedNow";
    OP_SUSPEND2 = "Suspend";
  }
});

// node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey, ChannelTypeId2, channelVariance2, proto6, isChannel, acquireReleaseOut, catchAllCause5, collectElements, collectElementsReader, concatAllWith, concatMapWith, embedInput, ensuringWith, fail11, failCause10, failCauseSync5, flatMap13, foldCauseChannel, fromEffect4, pipeTo, provideContext4, readWith, readWithCause, succeed11, succeedNow, suspend6, sync7, void_6, write;
var init_core_stream = __esm({
  "node_modules/effect/dist/esm/internal/core-stream.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Cause();
    init_Chunk();
    init_Effect();
    init_Either();
    init_Function();
    init_Option();
    init_Pipeable();
    init_Predicate();
    init_childExecutorDecision();
    init_continuation2();
    init_upstreamPullStrategy();
    init_channel();
    ChannelSymbolKey = "effect/Channel";
    ChannelTypeId2 = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
    channelVariance2 = {
      /* c8 ignore next */
      _Env: /* @__PURE__ */ __name((_) => _, "_Env"),
      /* c8 ignore next */
      _InErr: /* @__PURE__ */ __name((_) => _, "_InErr"),
      /* c8 ignore next */
      _InElem: /* @__PURE__ */ __name((_) => _, "_InElem"),
      /* c8 ignore next */
      _InDone: /* @__PURE__ */ __name((_) => _, "_InDone"),
      /* c8 ignore next */
      _OutErr: /* @__PURE__ */ __name((_) => _, "_OutErr"),
      /* c8 ignore next */
      _OutElem: /* @__PURE__ */ __name((_) => _, "_OutElem"),
      /* c8 ignore next */
      _OutDone: /* @__PURE__ */ __name((_) => _, "_OutDone")
    };
    proto6 = {
      [ChannelTypeId2]: channelVariance2,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    isChannel = /* @__PURE__ */ __name((u) => hasProperty(u, ChannelTypeId2) || isEffect2(u), "isChannel");
    acquireReleaseOut = /* @__PURE__ */ dual(2, (self2, release2) => {
      const op = Object.create(proto6);
      op._tag = OP_BRACKET_OUT;
      op.acquire = () => self2;
      op.finalizer = release2;
      return op;
    });
    catchAllCause5 = /* @__PURE__ */ dual(2, (self2, f) => {
      const op = Object.create(proto6);
      op._tag = OP_FOLD2;
      op.channel = self2;
      op.k = new ContinuationKImpl(succeed11, f);
      return op;
    });
    collectElements = /* @__PURE__ */ __name((self2) => {
      return suspend6(() => {
        const builder = [];
        return flatMap13(pipeTo(self2, collectElementsReader(builder)), (value3) => sync7(() => [fromIterable3(builder), value3]));
      });
    }, "collectElements");
    collectElementsReader = /* @__PURE__ */ __name((builder) => readWith({
      onInput: /* @__PURE__ */ __name((outElem) => flatMap13(sync7(() => {
        builder.push(outElem);
      }), () => collectElementsReader(builder)), "onInput"),
      onFailure: fail11,
      onDone: succeedNow
    }), "collectElementsReader");
    concatAllWith = /* @__PURE__ */ __name((channels, f, g) => {
      const op = Object.create(proto6);
      op._tag = OP_CONCAT_ALL;
      op.combineInners = f;
      op.combineAll = g;
      op.onPull = () => PullAfterNext(none2());
      op.onEmit = () => Continue;
      op.value = () => channels;
      op.k = identity;
      return op;
    }, "concatAllWith");
    concatMapWith = /* @__PURE__ */ dual(4, (self2, f, g, h) => {
      const op = Object.create(proto6);
      op._tag = OP_CONCAT_ALL;
      op.combineInners = g;
      op.combineAll = h;
      op.onPull = () => PullAfterNext(none2());
      op.onEmit = () => Continue;
      op.value = () => self2;
      op.k = f;
      return op;
    });
    embedInput = /* @__PURE__ */ dual(2, (self2, input) => {
      const op = Object.create(proto6);
      op._tag = OP_BRIDGE;
      op.input = input;
      op.channel = self2;
      return op;
    });
    ensuringWith = /* @__PURE__ */ dual(2, (self2, finalizer3) => {
      const op = Object.create(proto6);
      op._tag = OP_ENSURING;
      op.channel = self2;
      op.finalizer = finalizer3;
      return op;
    });
    fail11 = /* @__PURE__ */ __name((error50) => failCause10(fail5(error50)), "fail");
    failCause10 = /* @__PURE__ */ __name((cause3) => failCauseSync5(() => cause3), "failCause");
    failCauseSync5 = /* @__PURE__ */ __name((evaluate3) => {
      const op = Object.create(proto6);
      op._tag = OP_FAIL3;
      op.error = evaluate3;
      return op;
    }, "failCauseSync");
    flatMap13 = /* @__PURE__ */ dual(2, (self2, f) => {
      const op = Object.create(proto6);
      op._tag = OP_FOLD2;
      op.channel = self2;
      op.k = new ContinuationKImpl(f, failCause10);
      return op;
    });
    foldCauseChannel = /* @__PURE__ */ dual(2, (self2, options) => {
      const op = Object.create(proto6);
      op._tag = OP_FOLD2;
      op.channel = self2;
      op.k = new ContinuationKImpl(options.onSuccess, options.onFailure);
      return op;
    });
    fromEffect4 = /* @__PURE__ */ __name((effect4) => {
      const op = Object.create(proto6);
      op._tag = OP_FROM_EFFECT2;
      op.effect = () => effect4;
      return op;
    }, "fromEffect");
    pipeTo = /* @__PURE__ */ dual(2, (self2, that) => {
      const op = Object.create(proto6);
      op._tag = OP_PIPE_TO;
      op.left = () => self2;
      op.right = () => that;
      return op;
    });
    provideContext4 = /* @__PURE__ */ dual(2, (self2, env2) => {
      const op = Object.create(proto6);
      op._tag = OP_PROVIDE2;
      op.context = () => env2;
      op.inner = self2;
      return op;
    });
    readWith = /* @__PURE__ */ __name((options) => readWithCause({
      onInput: options.onInput,
      onFailure: /* @__PURE__ */ __name((cause3) => match(failureOrCause2(cause3), {
        onLeft: options.onFailure,
        onRight: failCause10
      }), "onFailure"),
      onDone: options.onDone
    }), "readWith");
    readWithCause = /* @__PURE__ */ __name((options) => {
      const op = Object.create(proto6);
      op._tag = OP_READ;
      op.more = options.onInput;
      op.done = new ContinuationKImpl(options.onDone, options.onFailure);
      return op;
    }, "readWithCause");
    succeed11 = /* @__PURE__ */ __name((value3) => sync7(() => value3), "succeed");
    succeedNow = /* @__PURE__ */ __name((result) => {
      const op = Object.create(proto6);
      op._tag = OP_SUCCEED_NOW;
      op.terminal = result;
      return op;
    }, "succeedNow");
    suspend6 = /* @__PURE__ */ __name((evaluate3) => {
      const op = Object.create(proto6);
      op._tag = OP_SUSPEND2;
      op.channel = evaluate3;
      return op;
    }, "suspend");
    sync7 = /* @__PURE__ */ __name((evaluate3) => {
      const op = Object.create(proto6);
      op._tag = OP_SUCCEED;
      op.evaluate = evaluate3;
      return op;
    }, "sync");
    void_6 = /* @__PURE__ */ succeedNow(void 0);
    write = /* @__PURE__ */ __name((out) => {
      const op = Object.create(proto6);
      op._tag = OP_EMIT;
      op.out = out;
      return op;
    }, "write");
  }
});

// node_modules/effect/dist/esm/internal/opCodes/channelState.js
var OP_DONE3, OP_EMIT2, OP_FROM_EFFECT3, OP_READ2;
var init_channelState = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/channelState.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_DONE3 = "Done";
    OP_EMIT2 = "Emit";
    OP_FROM_EFFECT3 = "FromEffect";
    OP_READ2 = "Read";
  }
});

// node_modules/effect/dist/esm/internal/channel/channelState.js
var ChannelStateTypeId, channelStateVariance, proto7, Done2, Emit, fromEffect5, Read, isFromEffect, effect2, effectOrUndefinedIgnored;
var init_channelState2 = __esm({
  "node_modules/effect/dist/esm/internal/channel/channelState.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Effect();
    init_channelState();
    ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
    channelStateVariance = {
      /* c8 ignore next */
      _E: /* @__PURE__ */ __name((_) => _, "_E"),
      /* c8 ignore next */
      _R: /* @__PURE__ */ __name((_) => _, "_R")
    };
    proto7 = {
      [ChannelStateTypeId]: channelStateVariance
    };
    Done2 = /* @__PURE__ */ __name(() => {
      const op = Object.create(proto7);
      op._tag = OP_DONE3;
      return op;
    }, "Done");
    Emit = /* @__PURE__ */ __name(() => {
      const op = Object.create(proto7);
      op._tag = OP_EMIT2;
      return op;
    }, "Emit");
    fromEffect5 = /* @__PURE__ */ __name((effect4) => {
      const op = Object.create(proto7);
      op._tag = OP_FROM_EFFECT3;
      op.effect = effect4;
      return op;
    }, "fromEffect");
    Read = /* @__PURE__ */ __name((upstream, onEffect, onEmit, onDone3) => {
      const op = Object.create(proto7);
      op._tag = OP_READ2;
      op.upstream = upstream;
      op.onEffect = onEffect;
      op.onEmit = onEmit;
      op.onDone = onDone3;
      return op;
    }, "Read");
    isFromEffect = /* @__PURE__ */ __name((self2) => self2._tag === OP_FROM_EFFECT3, "isFromEffect");
    effect2 = /* @__PURE__ */ __name((self2) => isFromEffect(self2) ? self2.effect : _void, "effect");
    effectOrUndefinedIgnored = /* @__PURE__ */ __name((self2) => isFromEffect(self2) ? ignore2(self2.effect) : void 0, "effectOrUndefinedIgnored");
  }
});

// node_modules/effect/dist/esm/internal/channel/subexecutor.js
var OP_PULL_FROM_CHILD, OP_PULL_FROM_UPSTREAM, OP_DRAIN_CHILD_EXECUTORS, OP_EMIT3, PullFromChild, PullFromUpstream, DrainChildExecutors, Emit2;
var init_subexecutor = __esm({
  "node_modules/effect/dist/esm/internal/channel/subexecutor.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Effect();
    init_Exit();
    init_Function();
    OP_PULL_FROM_CHILD = "PullFromChild";
    OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
    OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
    OP_EMIT3 = "Emit";
    PullFromChild = class {
      static {
        __name(this, "PullFromChild");
      }
      childExecutor;
      parentSubexecutor;
      onEmit;
      _tag = OP_PULL_FROM_CHILD;
      constructor(childExecutor, parentSubexecutor, onEmit) {
        this.childExecutor = childExecutor;
        this.parentSubexecutor = parentSubexecutor;
        this.onEmit = onEmit;
      }
      close(exit5) {
        const fin1 = this.childExecutor.close(exit5);
        const fin2 = this.parentSubexecutor.close(exit5);
        if (fin1 !== void 0 && fin2 !== void 0) {
          return zipWith7(exit4(fin1), exit4(fin2), (exit1, exit22) => pipe(exit1, zipRight3(exit22)));
        } else if (fin1 !== void 0) {
          return fin1;
        } else if (fin2 !== void 0) {
          return fin2;
        } else {
          return void 0;
        }
      }
      enqueuePullFromChild(_child) {
        return this;
      }
    };
    PullFromUpstream = class _PullFromUpstream {
      static {
        __name(this, "PullFromUpstream");
      }
      upstreamExecutor;
      createChild;
      lastDone;
      activeChildExecutors;
      combineChildResults;
      combineWithChildResult;
      onPull;
      onEmit;
      _tag = OP_PULL_FROM_UPSTREAM;
      constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
        this.upstreamExecutor = upstreamExecutor;
        this.createChild = createChild;
        this.lastDone = lastDone;
        this.activeChildExecutors = activeChildExecutors;
        this.combineChildResults = combineChildResults;
        this.combineWithChildResult = combineWithChildResult;
        this.onPull = onPull;
        this.onEmit = onEmit;
      }
      close(exit5) {
        const fin1 = this.upstreamExecutor.close(exit5);
        const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit5) : void 0), fin1];
        const result = fins.reduce((acc, next4) => {
          if (acc !== void 0 && next4 !== void 0) {
            return zipWith7(acc, exit4(next4), (exit1, exit22) => zipRight3(exit1, exit22));
          } else if (acc !== void 0) {
            return acc;
          } else if (next4 !== void 0) {
            return exit4(next4);
          } else {
            return void 0;
          }
        }, void 0);
        return result === void 0 ? result : result;
      }
      enqueuePullFromChild(child) {
        return new _PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
      }
    };
    DrainChildExecutors = class _DrainChildExecutors {
      static {
        __name(this, "DrainChildExecutors");
      }
      upstreamExecutor;
      lastDone;
      activeChildExecutors;
      upstreamDone;
      combineChildResults;
      combineWithChildResult;
      onPull;
      _tag = OP_DRAIN_CHILD_EXECUTORS;
      constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
        this.upstreamExecutor = upstreamExecutor;
        this.lastDone = lastDone;
        this.activeChildExecutors = activeChildExecutors;
        this.upstreamDone = upstreamDone;
        this.combineChildResults = combineChildResults;
        this.combineWithChildResult = combineWithChildResult;
        this.onPull = onPull;
      }
      close(exit5) {
        const fin1 = this.upstreamExecutor.close(exit5);
        const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit5) : void 0), fin1];
        const result = fins.reduce((acc, next4) => {
          if (acc !== void 0 && next4 !== void 0) {
            return zipWith7(acc, exit4(next4), (exit1, exit22) => zipRight3(exit1, exit22));
          } else if (acc !== void 0) {
            return acc;
          } else if (next4 !== void 0) {
            return exit4(next4);
          } else {
            return void 0;
          }
        }, void 0);
        return result === void 0 ? result : result;
      }
      enqueuePullFromChild(child) {
        return new _DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
      }
    };
    Emit2 = class {
      static {
        __name(this, "Emit");
      }
      value;
      next;
      _tag = OP_EMIT3;
      constructor(value3, next4) {
        this.value = value3;
        this.next = next4;
      }
      close(exit5) {
        const result = this.next.close(exit5);
        return result === void 0 ? result : result;
      }
      enqueuePullFromChild(_child) {
        return this;
      }
    };
  }
});

// node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
var OP_PULLED, OP_NO_UPSTREAM;
var init_channelUpstreamPullRequest = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_PULLED = "Pulled";
    OP_NO_UPSTREAM = "NoUpstream";
  }
});

// node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey, UpstreamPullRequestTypeId, upstreamPullRequestVariance, proto8, Pulled, NoUpstream;
var init_upstreamPullRequest = __esm({
  "node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_channelUpstreamPullRequest();
    UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
    UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
    upstreamPullRequestVariance = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    proto8 = {
      [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
    };
    Pulled = /* @__PURE__ */ __name((value3) => {
      const op = Object.create(proto8);
      op._tag = OP_PULLED;
      op.value = value3;
      return op;
    }, "Pulled");
    NoUpstream = /* @__PURE__ */ __name((activeDownstreamCount) => {
      const op = Object.create(proto8);
      op._tag = OP_NO_UPSTREAM;
      op.activeDownstreamCount = activeDownstreamCount;
      return op;
    }, "NoUpstream");
  }
});

// node_modules/effect/dist/esm/internal/channel/channelExecutor.js
var ChannelExecutor, ifNotNull, runFinalizers, readUpstream, runIn, runScopedInterpret;
var init_channelExecutor = __esm({
  "node_modules/effect/dist/esm/internal/channel/channelExecutor.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Cause();
    init_Deferred();
    init_Effect();
    init_ExecutionStrategy();
    init_Exit();
    init_Fiber();
    init_FiberId();
    init_Function();
    init_HashSet();
    init_Option();
    init_Scope();
    init_core_stream();
    init_channel();
    init_channelChildExecutorDecision();
    init_channelState();
    init_channelUpstreamPullStrategy();
    init_continuation();
    init_channelState2();
    init_continuation2();
    init_subexecutor();
    init_upstreamPullRequest();
    ChannelExecutor = class _ChannelExecutor {
      static {
        __name(this, "ChannelExecutor");
      }
      _activeSubexecutor = void 0;
      _cancelled = void 0;
      _closeLastSubstream = void 0;
      _currentChannel;
      _done = void 0;
      _doneStack = [];
      _emitted = void 0;
      _executeCloseLastSubstream;
      _input = void 0;
      _inProgressFinalizer = void 0;
      _providedEnv;
      constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
        this._currentChannel = initialChannel;
        this._executeCloseLastSubstream = executeCloseLastSubstream;
        this._providedEnv = providedEnv;
      }
      run() {
        let result = void 0;
        while (result === void 0) {
          if (this._cancelled !== void 0) {
            result = this.processCancellation();
          } else if (this._activeSubexecutor !== void 0) {
            result = this.runSubexecutor();
          } else {
            try {
              if (this._currentChannel === void 0) {
                result = Done2();
              } else {
                if (isEffect2(this._currentChannel)) {
                  this._currentChannel = fromEffect4(this._currentChannel);
                }
                switch (this._currentChannel._tag) {
                  case OP_BRACKET_OUT: {
                    result = this.runBracketOut(this._currentChannel);
                    break;
                  }
                  case OP_BRIDGE: {
                    const bridgeInput = this._currentChannel.input;
                    this._currentChannel = this._currentChannel.channel;
                    if (this._input !== void 0) {
                      const inputExecutor = this._input;
                      this._input = void 0;
                      const drainer = /* @__PURE__ */ __name(() => flatMap11(bridgeInput.awaitRead(), () => suspend4(() => {
                        const state = inputExecutor.run();
                        switch (state._tag) {
                          case OP_DONE3: {
                            return match6(inputExecutor.getDone(), {
                              onFailure: /* @__PURE__ */ __name((cause3) => bridgeInput.error(cause3), "onFailure"),
                              onSuccess: /* @__PURE__ */ __name((value3) => bridgeInput.done(value3), "onSuccess")
                            });
                          }
                          case OP_EMIT2: {
                            return flatMap11(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                          }
                          case OP_FROM_EFFECT3: {
                            return matchCauseEffect3(state.effect, {
                              onFailure: /* @__PURE__ */ __name((cause3) => bridgeInput.error(cause3), "onFailure"),
                              onSuccess: /* @__PURE__ */ __name(() => drainer(), "onSuccess")
                            });
                          }
                          case OP_READ2: {
                            return readUpstream(state, () => drainer(), (cause3) => bridgeInput.error(cause3));
                          }
                        }
                      })), "drainer");
                      result = fromEffect5(flatMap11(forkDaemon2(interruptible4(drainer())), (fiber) => sync5(() => this.addFinalizer((exit5) => flatMap11(interrupt6(fiber), () => suspend4(() => {
                        const effect4 = this.restorePipe(exit5, inputExecutor);
                        return effect4 !== void 0 ? effect4 : _void;
                      }))))));
                    }
                    break;
                  }
                  case OP_CONCAT_ALL: {
                    const executor = new _ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect4) => sync5(() => {
                      const prevLastClose = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
                      this._closeLastSubstream = pipe(prevLastClose, zipRight5(effect4));
                    }));
                    executor._input = this._input;
                    const channel2 = this._currentChannel;
                    this._activeSubexecutor = new PullFromUpstream(executor, (value3) => channel2.k(value3), void 0, [], (x, y) => channel2.combineInners(x, y), (x, y) => channel2.combineAll(x, y), (request2) => channel2.onPull(request2), (value3) => channel2.onEmit(value3));
                    this._closeLastSubstream = void 0;
                    this._currentChannel = void 0;
                    break;
                  }
                  case OP_EMIT: {
                    this._emitted = this._currentChannel.out;
                    this._currentChannel = this._activeSubexecutor !== void 0 ? void 0 : void_6;
                    result = Emit();
                    break;
                  }
                  case OP_ENSURING: {
                    this.runEnsuring(this._currentChannel);
                    break;
                  }
                  case OP_FAIL3: {
                    result = this.doneHalt(this._currentChannel.error());
                    break;
                  }
                  case OP_FOLD2: {
                    this._doneStack.push(this._currentChannel.k);
                    this._currentChannel = this._currentChannel.channel;
                    break;
                  }
                  case OP_FROM_EFFECT2: {
                    const effect4 = this._providedEnv === void 0 ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                    result = fromEffect5(matchCauseEffect3(effect4, {
                      onFailure: /* @__PURE__ */ __name((cause3) => {
                        const state = this.doneHalt(cause3);
                        return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                      }, "onFailure"),
                      onSuccess: /* @__PURE__ */ __name((value3) => {
                        const state = this.doneSucceed(value3);
                        return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                      }, "onSuccess")
                    }));
                    break;
                  }
                  case OP_PIPE_TO: {
                    const previousInput = this._input;
                    const leftExec = new _ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect4) => this._executeCloseLastSubstream(effect4));
                    leftExec._input = previousInput;
                    this._input = leftExec;
                    this.addFinalizer((exit5) => {
                      const effect4 = this.restorePipe(exit5, previousInput);
                      return effect4 !== void 0 ? effect4 : _void;
                    });
                    this._currentChannel = this._currentChannel.right();
                    break;
                  }
                  case OP_PROVIDE2: {
                    const previousEnv = this._providedEnv;
                    this._providedEnv = this._currentChannel.context();
                    this._currentChannel = this._currentChannel.inner;
                    this.addFinalizer(() => sync5(() => {
                      this._providedEnv = previousEnv;
                    }));
                    break;
                  }
                  case OP_READ: {
                    const read = this._currentChannel;
                    result = Read(this._input, identity, (emitted) => {
                      try {
                        this._currentChannel = read.more(emitted);
                      } catch (error50) {
                        this._currentChannel = read.done.onExit(die3(error50));
                      }
                      return void 0;
                    }, (exit5) => {
                      const onExit4 = /* @__PURE__ */ __name((exit6) => {
                        return read.done.onExit(exit6);
                      }, "onExit");
                      this._currentChannel = onExit4(exit5);
                      return void 0;
                    });
                    break;
                  }
                  case OP_SUCCEED: {
                    result = this.doneSucceed(this._currentChannel.evaluate());
                    break;
                  }
                  case OP_SUCCEED_NOW: {
                    result = this.doneSucceed(this._currentChannel.terminal);
                    break;
                  }
                  case OP_SUSPEND2: {
                    this._currentChannel = this._currentChannel.channel();
                    break;
                  }
                }
              }
            } catch (error50) {
              this._currentChannel = failCause10(die4(error50));
            }
          }
        }
        return result;
      }
      getDone() {
        return this._done;
      }
      getEmit() {
        return this._emitted;
      }
      cancelWith(exit5) {
        this._cancelled = exit5;
      }
      clearInProgressFinalizer() {
        this._inProgressFinalizer = void 0;
      }
      storeInProgressFinalizer(finalizer3) {
        this._inProgressFinalizer = finalizer3;
      }
      popAllFinalizers(exit5) {
        const finalizers = [];
        let next4 = this._doneStack.pop();
        while (next4) {
          if (next4._tag === "ContinuationFinalizer") {
            finalizers.push(next4.finalizer);
          }
          next4 = this._doneStack.pop();
        }
        const effect4 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit5);
        this.storeInProgressFinalizer(effect4);
        return effect4;
      }
      popNextFinalizers() {
        const builder = [];
        while (this._doneStack.length !== 0) {
          const cont = this._doneStack[this._doneStack.length - 1];
          if (cont._tag === OP_CONTINUATION_K) {
            return builder;
          }
          builder.push(cont);
          this._doneStack.pop();
        }
        return builder;
      }
      restorePipe(exit5, prev) {
        const currInput = this._input;
        this._input = prev;
        if (currInput !== void 0) {
          const effect4 = currInput.close(exit5);
          return effect4;
        }
        return _void;
      }
      close(exit5) {
        let runInProgressFinalizers = void 0;
        const finalizer3 = this._inProgressFinalizer;
        if (finalizer3 !== void 0) {
          runInProgressFinalizers = pipe(finalizer3, ensuring3(sync5(() => this.clearInProgressFinalizer())));
        }
        let closeSelf = void 0;
        const selfFinalizers = this.popAllFinalizers(exit5);
        if (selfFinalizers !== void 0) {
          closeSelf = pipe(selfFinalizers, ensuring3(sync5(() => this.clearInProgressFinalizer())));
        }
        const closeSubexecutors = this._activeSubexecutor === void 0 ? void 0 : this._activeSubexecutor.close(exit5);
        if (closeSubexecutors === void 0 && runInProgressFinalizers === void 0 && closeSelf === void 0) {
          return void 0;
        }
        return pipe(
          exit4(ifNotNull(closeSubexecutors)),
          zip5(exit4(ifNotNull(runInProgressFinalizers))),
          zip5(exit4(ifNotNull(closeSelf))),
          map18(([[exit1, exit22], exit32]) => pipe(exit1, zipRight3(exit22), zipRight3(exit32))),
          uninterruptible2,
          // TODO: remove
          flatMap11((exit6) => suspend4(() => exit6))
        );
      }
      doneSucceed(value3) {
        if (this._doneStack.length === 0) {
          this._done = succeed3(value3);
          this._currentChannel = void 0;
          return Done2();
        }
        const head7 = this._doneStack[this._doneStack.length - 1];
        if (head7._tag === OP_CONTINUATION_K) {
          this._doneStack.pop();
          this._currentChannel = head7.onSuccess(value3);
          return void 0;
        }
        const finalizers = this.popNextFinalizers();
        if (this._doneStack.length === 0) {
          this._doneStack = finalizers.reverse();
          this._done = succeed3(value3);
          this._currentChannel = void 0;
          return Done2();
        }
        const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), succeed3(value3));
        this.storeInProgressFinalizer(finalizerEffect);
        const effect4 = pipe(finalizerEffect, ensuring3(sync5(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap11(() => sync5(() => this.doneSucceed(value3))));
        return fromEffect5(effect4);
      }
      doneHalt(cause3) {
        if (this._doneStack.length === 0) {
          this._done = failCause3(cause3);
          this._currentChannel = void 0;
          return Done2();
        }
        const head7 = this._doneStack[this._doneStack.length - 1];
        if (head7._tag === OP_CONTINUATION_K) {
          this._doneStack.pop();
          try {
            this._currentChannel = head7.onHalt(cause3);
          } catch (error50) {
            this._currentChannel = failCause10(die4(error50));
          }
          return void 0;
        }
        const finalizers = this.popNextFinalizers();
        if (this._doneStack.length === 0) {
          this._doneStack = finalizers.reverse();
          this._done = failCause3(cause3);
          this._currentChannel = void 0;
          return Done2();
        }
        const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), failCause3(cause3));
        this.storeInProgressFinalizer(finalizerEffect);
        const effect4 = pipe(finalizerEffect, ensuring3(sync5(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap11(() => sync5(() => this.doneHalt(cause3))));
        return fromEffect5(effect4);
      }
      processCancellation() {
        this._currentChannel = void 0;
        this._done = this._cancelled;
        this._cancelled = void 0;
        return Done2();
      }
      runBracketOut(bracketOut) {
        const effect4 = uninterruptible2(matchCauseEffect3(this.provide(bracketOut.acquire()), {
          onFailure: /* @__PURE__ */ __name((cause3) => sync5(() => {
            this._currentChannel = failCause10(cause3);
          }), "onFailure"),
          onSuccess: /* @__PURE__ */ __name((out) => sync5(() => {
            this.addFinalizer((exit5) => this.provide(bracketOut.finalizer(out, exit5)));
            this._currentChannel = write(out);
          }), "onSuccess")
        }));
        return fromEffect5(effect4);
      }
      provide(effect4) {
        if (this._providedEnv === void 0) {
          return effect4;
        }
        return pipe(effect4, provide2(this._providedEnv));
      }
      runEnsuring(ensuring9) {
        this.addFinalizer(ensuring9.finalizer);
        this._currentChannel = ensuring9.channel;
      }
      addFinalizer(f) {
        this._doneStack.push(new ContinuationFinalizerImpl(f));
      }
      runSubexecutor() {
        const subexecutor = this._activeSubexecutor;
        switch (subexecutor._tag) {
          case OP_PULL_FROM_CHILD: {
            return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
          }
          case OP_PULL_FROM_UPSTREAM: {
            return this.pullFromUpstream(subexecutor);
          }
          case OP_DRAIN_CHILD_EXECUTORS: {
            return this.drainChildExecutors(subexecutor);
          }
          case OP_EMIT3: {
            this._emitted = subexecutor.value;
            this._activeSubexecutor = subexecutor.next;
            return Emit();
          }
        }
      }
      replaceSubexecutor(nextSubExec) {
        this._currentChannel = void 0;
        this._activeSubexecutor = nextSubExec;
      }
      finishWithExit(exit5) {
        const state = match6(exit5, {
          onFailure: /* @__PURE__ */ __name((cause3) => this.doneHalt(cause3), "onFailure"),
          onSuccess: /* @__PURE__ */ __name((value3) => this.doneSucceed(value3), "onSuccess")
        });
        this._activeSubexecutor = void 0;
        return state === void 0 ? _void : effect2(state);
      }
      finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
        this.addFinalizer(() => pipe(closeFuncs, forEach9((closeFunc) => pipe(sync5(() => closeFunc(subexecutorDone)), flatMap11((closeEffect) => closeEffect !== void 0 ? closeEffect : _void)), {
          discard: true
        })));
        const state = pipe(subexecutorDone, match6({
          onFailure: /* @__PURE__ */ __name((cause3) => this.doneHalt(cause3), "onFailure"),
          onSuccess: /* @__PURE__ */ __name((value3) => this.doneSucceed(value3), "onSuccess")
        }));
        this._activeSubexecutor = void 0;
        return state;
      }
      applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
        switch (strategy._tag) {
          case OP_PULL_AFTER_NEXT: {
            const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
            return [strategy.emitSeparator, shouldPrepend ? [void 0, ...queue] : queue];
          }
          case OP_PULL_AFTER_ALL_ENQUEUED: {
            const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
            return [strategy.emitSeparator, shouldEnqueue ? [...queue, void 0] : queue];
          }
        }
      }
      pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
        return Read(childExecutor, identity, (emitted) => {
          const childExecutorDecision = onEmitted(emitted);
          switch (childExecutorDecision._tag) {
            case OP_CONTINUE2: {
              break;
            }
            case OP_CLOSE: {
              this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
              break;
            }
            case OP_YIELD2: {
              const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
              this.replaceSubexecutor(modifiedParent);
              break;
            }
          }
          this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
          return void 0;
        }, match6({
          onFailure: /* @__PURE__ */ __name((cause3) => {
            const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3);
            return state === void 0 ? void 0 : effectOrUndefinedIgnored(state);
          }, "onFailure"),
          onSuccess: /* @__PURE__ */ __name((doneValue) => {
            this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
            return void 0;
          }, "onSuccess")
        }));
      }
      finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
        const subexecutor = parentSubexecutor;
        switch (subexecutor._tag) {
          case OP_PULL_FROM_UPSTREAM: {
            const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
            this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
            this.replaceSubexecutor(modifiedParent);
            break;
          }
          case OP_DRAIN_CHILD_EXECUTORS: {
            const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
            this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
            this.replaceSubexecutor(modifiedParent);
            break;
          }
          default: {
            break;
          }
        }
      }
      handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3) {
        return this.finishSubexecutorWithCloseEffect(failCause3(cause3), (exit5) => parentSubexecutor.close(exit5), (exit5) => childExecutor.close(exit5));
      }
      pullFromUpstream(subexecutor) {
        if (subexecutor.activeChildExecutors.length === 0) {
          return this.performPullFromUpstream(subexecutor);
        }
        const activeChild = subexecutor.activeChildExecutors[0];
        const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
        if (activeChild === void 0) {
          return this.performPullFromUpstream(parentSubexecutor);
        }
        this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
        return void 0;
      }
      performPullFromUpstream(subexecutor) {
        return Read(subexecutor.upstreamExecutor, (effect4) => {
          const closeLastSubstream = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
          this._closeLastSubstream = void 0;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight5(effect4));
        }, (emitted) => {
          if (this._closeLastSubstream !== void 0) {
            const closeLastSubstream = this._closeLastSubstream;
            this._closeLastSubstream = void 0;
            return pipe(this._executeCloseLastSubstream(closeLastSubstream), map18(() => {
              const childExecutor2 = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
              childExecutor2._input = this._input;
              const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
              this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
              if (isSome2(emitSeparator2)) {
                this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
              }
              return void 0;
            }));
          }
          const childExecutor = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor._input = this._input;
          const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
          this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (isSome2(emitSeparator)) {
            this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
          }
          return void 0;
        }, (exit5) => {
          if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== void 0)) {
            const drain5 = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [void 0, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
            if (this._closeLastSubstream !== void 0) {
              const closeLastSubstream2 = this._closeLastSubstream;
              this._closeLastSubstream = void 0;
              return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map18(() => this.replaceSubexecutor(drain5)));
            }
            this.replaceSubexecutor(drain5);
            return void 0;
          }
          const closeLastSubstream = this._closeLastSubstream;
          const state = this.finishSubexecutorWithCloseEffect(pipe(exit5, map12((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit6) => subexecutor.upstreamExecutor.close(exit6));
          return state === void 0 ? void 0 : (
            // NOTE: assuming finalizers cannot fail
            effectOrUndefinedIgnored(state)
          );
        });
      }
      drainChildExecutors(subexecutor) {
        if (subexecutor.activeChildExecutors.length === 0) {
          const lastClose = this._closeLastSubstream;
          if (lastClose !== void 0) {
            this.addFinalizer(() => succeed9(lastClose));
          }
          return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit5) => subexecutor.upstreamExecutor.close(exit5));
        }
        const activeChild = subexecutor.activeChildExecutors[0];
        const rest = subexecutor.activeChildExecutors.slice(1);
        if (activeChild === void 0) {
          const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== void 0 ? n + 1 : n, 0))));
          this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
          if (isSome2(emitSeparator)) {
            this._emitted = emitSeparator.value;
            return Emit();
          }
          return void 0;
        }
        const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
        return void 0;
      }
    };
    ifNotNull = /* @__PURE__ */ __name((effect4) => effect4 !== void 0 ? effect4 : _void, "ifNotNull");
    runFinalizers = /* @__PURE__ */ __name((finalizers, exit5) => {
      return pipe(forEach9(finalizers, (fin) => exit4(fin(exit5))), map18((exits) => pipe(all4(exits), getOrElse(() => void_3))), flatMap11((exit6) => suspend4(() => exit6)));
    }, "runFinalizers");
    readUpstream = /* @__PURE__ */ __name((r, onSuccess, onFailure) => {
      const readStack = [r];
      const read = /* @__PURE__ */ __name(() => {
        const current2 = readStack.pop();
        if (current2 === void 0 || current2.upstream === void 0) {
          return dieMessage2("Unexpected end of input for channel execution");
        }
        const state = current2.upstream.run();
        switch (state._tag) {
          case OP_EMIT2: {
            const emitEffect = current2.onEmit(current2.upstream.getEmit());
            if (readStack.length === 0) {
              if (emitEffect === void 0) {
                return suspend4(onSuccess);
              }
              return pipe(emitEffect, matchCauseEffect3({
                onFailure,
                onSuccess
              }));
            }
            if (emitEffect === void 0) {
              return suspend4(() => read());
            }
            return pipe(emitEffect, matchCauseEffect3({
              onFailure,
              onSuccess: /* @__PURE__ */ __name(() => read(), "onSuccess")
            }));
          }
          case OP_DONE3: {
            const doneEffect = current2.onDone(current2.upstream.getDone());
            if (readStack.length === 0) {
              if (doneEffect === void 0) {
                return suspend4(onSuccess);
              }
              return pipe(doneEffect, matchCauseEffect3({
                onFailure,
                onSuccess
              }));
            }
            if (doneEffect === void 0) {
              return suspend4(() => read());
            }
            return pipe(doneEffect, matchCauseEffect3({
              onFailure,
              onSuccess: /* @__PURE__ */ __name(() => read(), "onSuccess")
            }));
          }
          case OP_FROM_EFFECT3: {
            readStack.push(current2);
            return pipe(current2.onEffect(state.effect), catchAllCause3((cause3) => suspend4(() => {
              const doneEffect = current2.onDone(failCause3(cause3));
              return doneEffect === void 0 ? _void : doneEffect;
            })), matchCauseEffect3({
              onFailure,
              onSuccess: /* @__PURE__ */ __name(() => read(), "onSuccess")
            }));
          }
          case OP_READ2: {
            readStack.push(current2);
            readStack.push(state);
            return suspend4(() => read());
          }
        }
      }, "read");
      return read();
    }, "readUpstream");
    runIn = /* @__PURE__ */ dual(2, (self2, scope5) => {
      const run6 = /* @__PURE__ */ __name((channelDeferred, scopeDeferred, scope6) => acquireUseRelease2(sync5(() => new ChannelExecutor(self2, void 0, identity)), (exec) => suspend4(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred2(channelDeferred), zipRight5(_await(channelDeferred)), zipLeft4(_await(scopeDeferred)))), (exec, exit5) => {
        const finalize2 = exec.close(exit5);
        if (finalize2 === void 0) {
          return _void;
        }
        return tapErrorCause3(finalize2, (cause3) => addFinalizer2(scope6, failCause8(cause3)));
      }), "run");
      return uninterruptibleMask3((restore) => all6([fork2(scope5, sequential3), make19(), make19()]).pipe(flatMap11(([child, channelDeferred, scopeDeferred]) => restore(run6(channelDeferred, scopeDeferred, child)).pipe(forkIn2(scope5), flatMap11((fiber) => scope5.addFinalizer((exit5) => {
        const interruptors3 = isFailure(exit5) ? interruptors2(exit5.cause) : void 0;
        return isDone(channelDeferred).pipe(flatMap11((isDone7) => isDone7 ? succeed2(scopeDeferred, void 0).pipe(zipRight5(_await3(fiber)), zipRight5(inheritAll2(fiber))) : succeed2(scopeDeferred, void 0).pipe(zipRight5(interruptors3 && size3(interruptors3) > 0 ? interruptAs(fiber, combineAll2(interruptors3)) : interrupt6(fiber)), zipRight5(inheritAll2(fiber)))));
      }).pipe(zipRight5(restore(_await(channelDeferred)))))))));
    });
    runScopedInterpret = /* @__PURE__ */ __name((channelState, exec) => {
      const op = channelState;
      switch (op._tag) {
        case OP_FROM_EFFECT3: {
          return pipe(op.effect, flatMap11(() => runScopedInterpret(exec.run(), exec)));
        }
        case OP_EMIT2: {
          return runScopedInterpret(exec.run(), exec);
        }
        case OP_DONE3: {
          return suspend4(() => exec.getDone());
        }
        case OP_READ2: {
          return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause8);
        }
      }
    }, "runScopedInterpret");
  }
});

// node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
var OP_DONE4, OP_AWAIT;
var init_channelMergeDecision = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_DONE4 = "Done";
    OP_AWAIT = "Await";
  }
});

// node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey, MergeDecisionTypeId, proto9, Done3, Await;
var init_mergeDecision = __esm({
  "node_modules/effect/dist/esm/internal/channel/mergeDecision.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_channelMergeDecision();
    MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
    MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
    proto9 = {
      [MergeDecisionTypeId]: {
        _R: /* @__PURE__ */ __name((_) => _, "_R"),
        _E0: /* @__PURE__ */ __name((_) => _, "_E0"),
        _Z0: /* @__PURE__ */ __name((_) => _, "_Z0"),
        _E: /* @__PURE__ */ __name((_) => _, "_E"),
        _Z: /* @__PURE__ */ __name((_) => _, "_Z")
      }
    };
    Done3 = /* @__PURE__ */ __name((effect4) => {
      const op = Object.create(proto9);
      op._tag = OP_DONE4;
      op.effect = effect4;
      return op;
    }, "Done");
    Await = /* @__PURE__ */ __name((f) => {
      const op = Object.create(proto9);
      op._tag = OP_AWAIT;
      op.f = f;
      return op;
    }, "Await");
  }
});

// node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
var OP_BOTH_RUNNING, OP_LEFT_DONE, OP_RIGHT_DONE;
var init_channelMergeState = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_BOTH_RUNNING = "BothRunning";
    OP_LEFT_DONE = "LeftDone";
    OP_RIGHT_DONE = "RightDone";
  }
});

// node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey, MergeStateTypeId, proto10, BothRunning, LeftDone, RightDone;
var init_mergeState = __esm({
  "node_modules/effect/dist/esm/internal/channel/mergeState.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_channelMergeState();
    MergeStateSymbolKey = "effect/ChannelMergeState";
    MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
    proto10 = {
      [MergeStateTypeId]: MergeStateTypeId
    };
    BothRunning = /* @__PURE__ */ __name((left3, right3) => {
      const op = Object.create(proto10);
      op._tag = OP_BOTH_RUNNING;
      op.left = left3;
      op.right = right3;
      return op;
    }, "BothRunning");
    LeftDone = /* @__PURE__ */ __name((f) => {
      const op = Object.create(proto10);
      op._tag = OP_LEFT_DONE;
      op.f = f;
      return op;
    }, "LeftDone");
    RightDone = /* @__PURE__ */ __name((f) => {
      const op = Object.create(proto10);
      op._tag = OP_RIGHT_DONE;
      op.f = f;
      return op;
    }, "RightDone");
  }
});

// node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
var OP_BACK_PRESSURE, OP_BUFFER_SLIDING;
var init_channelMergeStrategy = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_BACK_PRESSURE = "BackPressure";
    OP_BUFFER_SLIDING = "BufferSliding";
  }
});

// node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey, MergeStrategyTypeId, proto11, BackPressure, BufferSliding, match15;
var init_mergeStrategy = __esm({
  "node_modules/effect/dist/esm/internal/channel/mergeStrategy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_channelMergeStrategy();
    MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
    MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
    proto11 = {
      [MergeStrategyTypeId]: MergeStrategyTypeId
    };
    BackPressure = /* @__PURE__ */ __name((_) => {
      const op = Object.create(proto11);
      op._tag = OP_BACK_PRESSURE;
      return op;
    }, "BackPressure");
    BufferSliding = /* @__PURE__ */ __name((_) => {
      const op = Object.create(proto11);
      op._tag = OP_BUFFER_SLIDING;
      return op;
    }, "BufferSliding");
    match15 = /* @__PURE__ */ dual(2, (self2, {
      onBackPressure,
      onBufferSliding
    }) => {
      switch (self2._tag) {
        case OP_BACK_PRESSURE: {
          return onBackPressure();
        }
        case OP_BUFFER_SLIDING: {
          return onBufferSliding();
        }
      }
    });
  }
});

// node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
var OP_STATE_EMPTY, OP_STATE_EMIT, OP_STATE_ERROR, OP_STATE_DONE2, stateEmpty, stateEmit, stateError, stateDone, SingleProducerAsyncInputImpl, make44;
var init_singleProducerAsyncInput = __esm({
  "node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Cause();
    init_Deferred();
    init_Effect();
    init_Either();
    init_Exit();
    init_Function();
    init_Ref();
    OP_STATE_EMPTY = "Empty";
    OP_STATE_EMIT = "Emit";
    OP_STATE_ERROR = "Error";
    OP_STATE_DONE2 = "Done";
    stateEmpty = /* @__PURE__ */ __name((notifyProducer) => ({
      _tag: OP_STATE_EMPTY,
      notifyProducer
    }), "stateEmpty");
    stateEmit = /* @__PURE__ */ __name((notifyConsumers) => ({
      _tag: OP_STATE_EMIT,
      notifyConsumers
    }), "stateEmit");
    stateError = /* @__PURE__ */ __name((cause3) => ({
      _tag: OP_STATE_ERROR,
      cause: cause3
    }), "stateError");
    stateDone = /* @__PURE__ */ __name((done13) => ({
      _tag: OP_STATE_DONE2,
      done: done13
    }), "stateDone");
    SingleProducerAsyncInputImpl = class {
      static {
        __name(this, "SingleProducerAsyncInputImpl");
      }
      ref;
      constructor(ref2) {
        this.ref = ref2;
      }
      awaitRead() {
        return flatten10(modify4(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await(state.notifyProducer), state] : [_void, state]));
      }
      get close() {
        return fiberIdWith2((fiberId3) => this.error(interrupt5(fiberId3)));
      }
      done(value3) {
        return flatten10(modify4(this.ref, (state) => {
          switch (state._tag) {
            case OP_STATE_EMPTY: {
              return [_await(state.notifyProducer), state];
            }
            case OP_STATE_EMIT: {
              return [forEach9(state.notifyConsumers, (deferred) => succeed2(deferred, left2(value3)), {
                discard: true
              }), stateDone(value3)];
            }
            case OP_STATE_ERROR: {
              return [interrupt7, state];
            }
            case OP_STATE_DONE2: {
              return [interrupt7, state];
            }
          }
        }));
      }
      emit(element2) {
        return flatMap11(make19(), (deferred) => flatten10(modify4(this.ref, (state) => {
          switch (state._tag) {
            case OP_STATE_EMPTY: {
              return [_await(state.notifyProducer), state];
            }
            case OP_STATE_EMIT: {
              const notifyConsumer = state.notifyConsumers[0];
              const notifyConsumers = state.notifyConsumers.slice(1);
              if (notifyConsumer !== void 0) {
                return [succeed2(notifyConsumer, right2(element2)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
              }
              throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
            }
            case OP_STATE_ERROR: {
              return [interrupt7, state];
            }
            case OP_STATE_DONE2: {
              return [interrupt7, state];
            }
          }
        })));
      }
      error(cause3) {
        return flatten10(modify4(this.ref, (state) => {
          switch (state._tag) {
            case OP_STATE_EMPTY: {
              return [_await(state.notifyProducer), state];
            }
            case OP_STATE_EMIT: {
              return [forEach9(state.notifyConsumers, (deferred) => failCause2(deferred, cause3), {
                discard: true
              }), stateError(cause3)];
            }
            case OP_STATE_ERROR: {
              return [interrupt7, state];
            }
            case OP_STATE_DONE2: {
              return [interrupt7, state];
            }
          }
        }));
      }
      get take() {
        return this.takeWith((cause3) => failCause3(map14(cause3, left2)), (elem) => succeed3(elem), (done13) => fail4(right2(done13)));
      }
      takeWith(onError5, onElement, onDone3) {
        return flatMap11(make19(), (deferred) => flatten10(modify4(this.ref, (state) => {
          switch (state._tag) {
            case OP_STATE_EMPTY: {
              return [zipRight5(succeed2(state.notifyProducer, void 0), matchCause4(_await(deferred), {
                onFailure: onError5,
                onSuccess: match({
                  onLeft: onDone3,
                  onRight: onElement
                })
              })), stateEmit([deferred])];
            }
            case OP_STATE_EMIT: {
              return [matchCause4(_await(deferred), {
                onFailure: onError5,
                onSuccess: match({
                  onLeft: onDone3,
                  onRight: onElement
                })
              }), stateEmit([...state.notifyConsumers, deferred])];
            }
            case OP_STATE_ERROR: {
              return [succeed9(onError5(state.cause)), state];
            }
            case OP_STATE_DONE2: {
              return [succeed9(onDone3(state.done)), state];
            }
          }
        })));
      }
    };
    make44 = /* @__PURE__ */ __name(() => pipe(make19(), flatMap11((deferred) => make29(stateEmpty(deferred))), map18((ref2) => new SingleProducerAsyncInputImpl(ref2))), "make");
  }
});

// node_modules/effect/dist/esm/internal/channel.js
var acquireUseRelease3, as7, catchAll5, concatMap, drain, ensuring4, flatten12, foldChannel, fromInput, fromQueue, fromQueueInternal, identityChannel, interruptWhen, interruptWhenDeferred, map20, mapError5, mapErrorCause3, mapOut, mapOutEffect, mapOutEffectPar, mergeAll7, mergeAllWith, mergeMap, mergeWith2, orDieWith3, orElse7, pipeToOrFail, repeated, run2, runDrain, runScoped, scoped4, scopedWith3, splitLines, toPubSub, toPull, toPullIn, interpretToPull, toQueue, toQueueInternal, unwrap, unwrapScoped3, unwrapScopedWith, withSpan5, writeAll, writeChunk, writeChunkWriter, zip6, zipLeft5, zipRight6, ChannelExceptionTypeId, ChannelException, isChannelException;
var init_channel2 = __esm({
  "node_modules/effect/dist/esm/internal/channel.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Cause();
    init_Chunk();
    init_Context();
    init_Deferred();
    init_Effect();
    init_Either();
    init_Equal();
    init_Exit();
    init_Fiber();
    init_FiberRef();
    init_Function();
    init_Option();
    init_Predicate();
    init_Queue();
    init_Ref();
    init_Scope();
    init_channelExecutor();
    init_mergeDecision();
    init_mergeState();
    init_mergeStrategy();
    init_singleProducerAsyncInput();
    init_core_effect();
    init_core_stream();
    init_channelMergeDecision();
    init_channelMergeState();
    init_channelState();
    init_tracer();
    acquireUseRelease3 = /* @__PURE__ */ __name((acquire2, use, release2) => flatMap13(fromEffect4(make29(() => _void)), (ref2) => pipe(fromEffect4(uninterruptible2(tap4(acquire2, (a) => set6(ref2, (exit5) => release2(a, exit5))))), flatMap13(use), ensuringWith((exit5) => flatMap11(get12(ref2), (f) => f(exit5))))), "acquireUseRelease");
    as7 = /* @__PURE__ */ dual(2, (self2, value3) => map20(self2, () => value3));
    catchAll5 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause5(self2, (cause3) => match(failureOrCause2(cause3), {
      onLeft: f,
      onRight: failCause10
    })));
    concatMap = /* @__PURE__ */ dual(2, (self2, f) => concatMapWith(self2, f, () => void 0, () => void 0));
    drain = /* @__PURE__ */ __name((self2) => {
      const drainer = readWithCause({
        onInput: /* @__PURE__ */ __name(() => drainer, "onInput"),
        onFailure: failCause10,
        onDone: succeed11
      });
      return pipeTo(self2, drainer);
    }, "drain");
    ensuring4 = /* @__PURE__ */ dual(2, (self2, finalizer3) => ensuringWith(self2, () => finalizer3));
    flatten12 = /* @__PURE__ */ __name((self2) => flatMap13(self2, identity), "flatten");
    foldChannel = /* @__PURE__ */ dual(2, (self2, options) => foldCauseChannel(self2, {
      onFailure: /* @__PURE__ */ __name((cause3) => {
        const either8 = failureOrCause2(cause3);
        switch (either8._tag) {
          case "Left": {
            return options.onFailure(either8.left);
          }
          case "Right": {
            return failCause10(either8.right);
          }
        }
      }, "onFailure"),
      onSuccess: options.onSuccess
    }));
    fromInput = /* @__PURE__ */ __name((input) => unwrap(input.takeWith(failCause10, (elem) => flatMap13(write(elem), () => fromInput(input)), succeed11)), "fromInput");
    fromQueue = /* @__PURE__ */ __name((queue) => suspend6(() => fromQueueInternal(queue)), "fromQueue");
    fromQueueInternal = /* @__PURE__ */ __name((queue) => pipe(fromEffect4(take3(queue)), flatMap13(match({
      onLeft: match6({
        onFailure: failCause10,
        onSuccess: succeedNow
      }),
      onRight: /* @__PURE__ */ __name((elem) => flatMap13(write(elem), () => fromQueueInternal(queue)), "onRight")
    }))), "fromQueueInternal");
    identityChannel = /* @__PURE__ */ __name(() => readWith({
      onInput: /* @__PURE__ */ __name((input) => flatMap13(write(input), () => identityChannel()), "onInput"),
      onFailure: fail11,
      onDone: succeedNow
    }), "identityChannel");
    interruptWhen = /* @__PURE__ */ dual(2, (self2, effect4) => mergeWith2(self2, {
      other: fromEffect4(effect4),
      onSelfDone: /* @__PURE__ */ __name((selfDone) => Done3(suspend4(() => selfDone)), "onSelfDone"),
      onOtherDone: /* @__PURE__ */ __name((effectDone) => Done3(suspend4(() => effectDone)), "onOtherDone")
    }));
    interruptWhenDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => interruptWhen(self2, _await(deferred)));
    map20 = /* @__PURE__ */ dual(2, (self2, f) => flatMap13(self2, (a) => sync7(() => f(a))));
    mapError5 = /* @__PURE__ */ dual(2, (self2, f) => mapErrorCause3(self2, map14(f)));
    mapErrorCause3 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause5(self2, (cause3) => failCause10(f(cause3))));
    mapOut = /* @__PURE__ */ dual(2, (self2, f) => {
      const reader = readWith({
        onInput: /* @__PURE__ */ __name((outElem) => flatMap13(write(f(outElem)), () => reader), "onInput"),
        onFailure: fail11,
        onDone: succeedNow
      });
      return pipeTo(self2, reader);
    });
    mapOutEffect = /* @__PURE__ */ dual(2, (self2, f) => {
      const reader = readWithCause({
        onInput: /* @__PURE__ */ __name((outElem) => pipe(fromEffect4(f(outElem)), flatMap13(write), flatMap13(() => reader)), "onInput"),
        onFailure: failCause10,
        onDone: succeedNow
      });
      return pipeTo(self2, reader);
    });
    mapOutEffectPar = /* @__PURE__ */ dual(3, (self2, f, n) => unwrapScopedWith((scope5) => gen4(function* () {
      const input = yield* make44();
      const queueReader = fromInput(input);
      const queue = yield* bounded5(n);
      yield* addFinalizer2(scope5, shutdown4(queue));
      const errorSignal = yield* make19();
      const withPermits = n === Number.POSITIVE_INFINITY ? (_) => identity : (yield* makeSemaphore2(n)).withPermits;
      const pull = yield* queueReader.pipe(pipeTo(self2), toPullIn(scope5));
      yield* pull.pipe(matchCauseEffect3({
        onFailure: /* @__PURE__ */ __name((cause3) => offer3(queue, failCause8(cause3)), "onFailure"),
        onSuccess: match({
          onLeft: /* @__PURE__ */ __name((outDone) => zipRight5(interruptible4(withPermits(n)(_void)), asVoid4(offer3(queue, succeed9(left2(outDone))))), "onLeft"),
          onRight: /* @__PURE__ */ __name((outElem) => gen4(function* () {
            const deferred = yield* make19();
            const latch = yield* make19();
            yield* offer3(queue, map18(_await(deferred), right2));
            yield* succeed2(latch, void 0).pipe(zipRight5(uninterruptibleMask3((restore) => exit4(restore(_await(errorSignal))).pipe(raceFirst2(exit4(restore(f(outElem)))), flatMap11(identity))).pipe(tapErrorCause3((cause3) => failCause2(errorSignal, cause3)), intoDeferred2(deferred))), withPermits(1), forkIn2(scope5));
            yield* _await(latch);
          }), "onRight")
        })
      }), forever3, interruptible4, forkIn2(scope5));
      const consumer = unwrap(matchCause4(flatten10(take3(queue)), {
        onFailure: failCause10,
        onSuccess: match({
          onLeft: succeedNow,
          onRight: /* @__PURE__ */ __name((outElem) => flatMap13(write(outElem), () => consumer), "onRight")
        })
      }));
      return embedInput(consumer, input);
    })));
    mergeAll7 = /* @__PURE__ */ __name((options) => {
      return (channels) => mergeAllWith(options)(channels, constVoid);
    }, "mergeAll");
    mergeAllWith = /* @__PURE__ */ __name(({
      bufferSize = 16,
      concurrency,
      mergeStrategy = BackPressure()
    }) => (channels, f) => unwrapScopedWith((scope5) => gen4(function* () {
      const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
      const input = yield* make44();
      const queueReader = fromInput(input);
      const queue = yield* bounded5(bufferSize);
      yield* addFinalizer2(scope5, shutdown4(queue));
      const cancelers = yield* unbounded5();
      yield* addFinalizer2(scope5, shutdown4(cancelers));
      const lastDone = yield* make29(none2());
      const errorSignal = yield* make19();
      const withPermits = (yield* makeSemaphore2(concurrencyN)).withPermits;
      const pull = yield* toPullIn(pipeTo(queueReader, channels), scope5);
      function evaluatePull(pull2) {
        return pull2.pipe(flatMap11(match({
          onLeft: /* @__PURE__ */ __name((done13) => succeed9(some2(done13)), "onLeft"),
          onRight: /* @__PURE__ */ __name((outElem) => as6(offer3(queue, succeed9(right2(outElem))), none2()), "onRight")
        })), repeat({
          until: /* @__PURE__ */ __name((_) => isSome2(_), "until")
        }), flatMap11((outDone) => update3(lastDone, match2({
          onNone: /* @__PURE__ */ __name(() => some2(outDone.value), "onNone"),
          onSome: /* @__PURE__ */ __name((lastDone2) => some2(f(lastDone2, outDone.value)), "onSome")
        }))), catchAllCause3((cause3) => isInterrupted2(cause3) ? failCause8(cause3) : offer3(queue, failCause8(cause3)).pipe(zipRight5(succeed2(errorSignal, void 0)), asVoid4)));
      }
      __name(evaluatePull, "evaluatePull");
      yield* pull.pipe(matchCauseEffect3({
        onFailure: /* @__PURE__ */ __name((cause3) => offer3(queue, failCause8(cause3)).pipe(zipRight5(succeed9(false))), "onFailure"),
        onSuccess: match({
          onLeft: /* @__PURE__ */ __name((outDone) => raceWith2(interruptible4(_await(errorSignal)), interruptible4(withPermits(concurrencyN)(_void)), {
            onSelfDone: /* @__PURE__ */ __name((_, permitAcquisition) => as6(interrupt6(permitAcquisition), false), "onSelfDone"),
            onOtherDone: /* @__PURE__ */ __name((_, failureAwait) => zipRight5(interrupt6(failureAwait), get12(lastDone).pipe(flatMap11(match2({
              onNone: /* @__PURE__ */ __name(() => offer3(queue, succeed9(left2(outDone))), "onNone"),
              onSome: /* @__PURE__ */ __name((lastDone2) => offer3(queue, succeed9(left2(f(lastDone2, outDone)))), "onSome")
            })), as6(false))), "onOtherDone")
          }), "onLeft"),
          onRight: /* @__PURE__ */ __name((channel2) => match15(mergeStrategy, {
            onBackPressure: /* @__PURE__ */ __name(() => gen4(function* () {
              const latch = yield* make19();
              const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel2), scope6).pipe(flatMap11((pull2) => race2(exit4(evaluatePull(pull2)), exit4(interruptible4(_await(errorSignal))))), flatMap11(identity)));
              yield* succeed2(latch, void 0).pipe(zipRight5(raceEffects), withPermits(1), forkIn2(scope5));
              yield* _await(latch);
              const errored = yield* isDone(errorSignal);
              return !errored;
            }), "onBackPressure"),
            onBufferSliding: /* @__PURE__ */ __name(() => gen4(function* () {
              const canceler = yield* make19();
              const latch = yield* make19();
              const size15 = yield* size12(cancelers);
              yield* take3(cancelers).pipe(flatMap11((canceler2) => succeed2(canceler2, void 0)), when2(() => size15 >= concurrencyN));
              yield* offer3(cancelers, canceler);
              const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel2), scope6).pipe(flatMap11((pull2) => exit4(evaluatePull(pull2)).pipe(race2(exit4(interruptible4(_await(errorSignal)))), race2(exit4(interruptible4(_await(canceler)))))), flatMap11(identity)));
              yield* succeed2(latch, void 0).pipe(zipRight5(raceEffects), withPermits(1), forkIn2(scope5));
              yield* _await(latch);
              const errored = yield* isDone(errorSignal);
              return !errored;
            }), "onBufferSliding")
          }), "onRight")
        })
      }), repeat({
        while: /* @__PURE__ */ __name((_) => _, "while")
      }), forkIn2(scope5));
      const consumer = pipe(take3(queue), flatten10, matchCause4({
        onFailure: failCause10,
        onSuccess: match({
          onLeft: succeedNow,
          onRight: /* @__PURE__ */ __name((outElem) => flatMap13(write(outElem), () => consumer), "onRight")
        })
      }), unwrap);
      return embedInput(consumer, input);
    })), "mergeAllWith");
    mergeMap = /* @__PURE__ */ dual(3, (self2, f, options) => mergeAll7(options)(mapOut(self2, f)));
    mergeWith2 = /* @__PURE__ */ dual(2, (self2, options) => {
      function merge13(scope5) {
        return gen4(function* () {
          const input = yield* make44();
          const queueReader = fromInput(input);
          const pullL = yield* toPullIn(pipeTo(queueReader, self2), scope5);
          const pullR = yield* toPullIn(pipeTo(queueReader, options.other), scope5);
          function handleSide(exit5, fiber, pull) {
            return (done13, both2, single2) => {
              function onDecision3(decision) {
                const op = decision;
                if (op._tag === OP_DONE4) {
                  return succeed9(fromEffect4(zipRight5(interrupt6(fiber), op.effect)));
                }
                return map18(_await3(fiber), match6({
                  onFailure: /* @__PURE__ */ __name((cause3) => fromEffect4(op.f(failCause3(cause3))), "onFailure"),
                  onSuccess: match({
                    onLeft: /* @__PURE__ */ __name((done14) => fromEffect4(op.f(succeed3(done14))), "onLeft"),
                    onRight: /* @__PURE__ */ __name((elem) => zipRight6(write(elem), go3(single2(op.f))), "onRight")
                  })
                }));
              }
              __name(onDecision3, "onDecision");
              return match6(exit5, {
                onFailure: /* @__PURE__ */ __name((cause3) => onDecision3(done13(failCause3(cause3))), "onFailure"),
                onSuccess: match({
                  onLeft: /* @__PURE__ */ __name((z2) => onDecision3(done13(succeed3(z2))), "onLeft"),
                  onRight: /* @__PURE__ */ __name((elem) => succeed9(flatMap13(write(elem), () => flatMap13(fromEffect4(forkIn2(interruptible4(pull), scope5)), (leftFiber) => go3(both2(leftFiber, fiber))))), "onRight")
                })
              });
            };
          }
          __name(handleSide, "handleSide");
          function go3(state) {
            switch (state._tag) {
              case OP_BOTH_RUNNING: {
                const leftJoin = interruptible4(join3(state.left));
                const rightJoin = interruptible4(join3(state.right));
                return unwrap(raceWith2(leftJoin, rightJoin, {
                  onSelfDone: /* @__PURE__ */ __name((leftExit, rf) => zipRight5(interrupt6(rf), handleSide(leftExit, state.right, pullL)(options.onSelfDone, BothRunning, (f) => LeftDone(f))), "onSelfDone"),
                  onOtherDone: /* @__PURE__ */ __name((rightExit, lf) => zipRight5(interrupt6(lf), handleSide(rightExit, state.left, pullR)(options.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f) => RightDone(f))), "onOtherDone")
                }));
              }
              case OP_LEFT_DONE: {
                return unwrap(map18(exit4(pullR), match6({
                  onFailure: /* @__PURE__ */ __name((cause3) => fromEffect4(state.f(failCause3(cause3))), "onFailure"),
                  onSuccess: match({
                    onLeft: /* @__PURE__ */ __name((done13) => fromEffect4(state.f(succeed3(done13))), "onLeft"),
                    onRight: /* @__PURE__ */ __name((elem) => flatMap13(write(elem), () => go3(LeftDone(state.f))), "onRight")
                  })
                })));
              }
              case OP_RIGHT_DONE: {
                return unwrap(map18(exit4(pullL), match6({
                  onFailure: /* @__PURE__ */ __name((cause3) => fromEffect4(state.f(failCause3(cause3))), "onFailure"),
                  onSuccess: match({
                    onLeft: /* @__PURE__ */ __name((done13) => fromEffect4(state.f(succeed3(done13))), "onLeft"),
                    onRight: /* @__PURE__ */ __name((elem) => flatMap13(write(elem), () => go3(RightDone(state.f))), "onRight")
                  })
                })));
              }
            }
          }
          __name(go3, "go");
          return fromEffect4(withFiberRuntime2((parent) => {
            const inherit = withFiberRuntime2((state) => {
              ;
              state.transferChildren(parent.scope());
              return _void;
            });
            const leftFiber = interruptible4(pullL).pipe(ensuring3(inherit), forkIn2(scope5));
            const rightFiber = interruptible4(pullR).pipe(ensuring3(inherit), forkIn2(scope5));
            return zipWith7(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
          })).pipe(flatMap13(go3), embedInput(input));
        });
      }
      __name(merge13, "merge");
      return unwrapScopedWith(merge13);
    });
    orDieWith3 = /* @__PURE__ */ dual(2, (self2, f) => catchAll5(self2, (e) => failCauseSync5(() => die4(f(e)))));
    orElse7 = /* @__PURE__ */ dual(2, (self2, that) => catchAll5(self2, that));
    pipeToOrFail = /* @__PURE__ */ dual(2, (self2, that) => suspend6(() => {
      let channelException = void 0;
      const reader = readWith({
        onInput: /* @__PURE__ */ __name((outElem) => flatMap13(write(outElem), () => reader), "onInput"),
        onFailure: /* @__PURE__ */ __name((outErr) => {
          channelException = ChannelException(outErr);
          return failCause10(die4(channelException));
        }, "onFailure"),
        onDone: succeedNow
      });
      const writer = readWithCause({
        onInput: /* @__PURE__ */ __name((outElem) => pipe(write(outElem), flatMap13(() => writer)), "onInput"),
        onFailure: /* @__PURE__ */ __name((cause3) => isDieType2(cause3) && isChannelException(cause3.defect) && equals(cause3.defect, channelException) ? fail11(cause3.defect.error) : failCause10(cause3), "onFailure"),
        onDone: succeedNow
      });
      return pipeTo(pipeTo(pipeTo(self2, reader), that), writer);
    }));
    repeated = /* @__PURE__ */ __name((self2) => flatMap13(self2, () => repeated(self2)), "repeated");
    run2 = /* @__PURE__ */ __name((self2) => scopedWith2((scope5) => runIn(self2, scope5)), "run");
    runDrain = /* @__PURE__ */ __name((self2) => run2(drain(self2)), "runDrain");
    runScoped = /* @__PURE__ */ __name((self2) => scopeWith2((scope5) => runIn(self2, scope5)), "runScoped");
    scoped4 = /* @__PURE__ */ __name((effect4) => unwrap(uninterruptibleMask3((restore) => map18(make40(), (scope5) => acquireReleaseOut(tapErrorCause3(restore(extend2(effect4, scope5)), (cause3) => close(scope5, failCause3(cause3))), (_, exit5) => close(scope5, exit5))))), "scoped");
    scopedWith3 = /* @__PURE__ */ __name((f) => unwrapScoped3(map18(scope3, (scope5) => flatMap13(fromEffect4(f(scope5)), write))), "scopedWith");
    splitLines = /* @__PURE__ */ __name(() => suspend6(() => {
      let stringBuilder = "";
      let midCRLF = false;
      const splitLinesChunk = /* @__PURE__ */ __name((chunk4) => {
        const chunkBuilder = [];
        map5(chunk4, (str) => {
          if (str.length !== 0) {
            let from2 = 0;
            let indexOfCR = str.indexOf("\r");
            let indexOfLF = str.indexOf("\n");
            if (midCRLF) {
              if (indexOfLF === 0) {
                chunkBuilder.push(stringBuilder);
                stringBuilder = "";
                from2 = 1;
                indexOfLF = str.indexOf("\n", from2);
              } else {
                stringBuilder = stringBuilder + "\r";
              }
              midCRLF = false;
            }
            while (indexOfCR !== -1 || indexOfLF !== -1) {
              if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
                if (stringBuilder.length === 0) {
                  chunkBuilder.push(str.substring(from2, indexOfLF));
                } else {
                  chunkBuilder.push(stringBuilder + str.substring(from2, indexOfLF));
                  stringBuilder = "";
                }
                from2 = indexOfLF + 1;
                indexOfLF = str.indexOf("\n", from2);
              } else {
                if (str.length === indexOfCR + 1) {
                  midCRLF = true;
                  indexOfCR = -1;
                } else {
                  if (indexOfLF === indexOfCR + 1) {
                    if (stringBuilder.length === 0) {
                      chunkBuilder.push(str.substring(from2, indexOfCR));
                    } else {
                      stringBuilder = stringBuilder + str.substring(from2, indexOfCR);
                      chunkBuilder.push(stringBuilder);
                      stringBuilder = "";
                    }
                    from2 = indexOfCR + 2;
                    indexOfCR = str.indexOf("\r", from2);
                    indexOfLF = str.indexOf("\n", from2);
                  } else {
                    indexOfCR = str.indexOf("\r", indexOfCR + 1);
                  }
                }
              }
            }
            if (midCRLF) {
              stringBuilder = stringBuilder + str.substring(from2, str.length - 1);
            } else {
              stringBuilder = stringBuilder + str.substring(from2, str.length);
            }
          }
        });
        return unsafeFromArray(chunkBuilder);
      }, "splitLinesChunk");
      const loop3 = readWithCause({
        onInput: /* @__PURE__ */ __name((input) => {
          const out = splitLinesChunk(input);
          return isEmpty(out) ? loop3 : flatMap13(write(out), () => loop3);
        }, "onInput"),
        onFailure: /* @__PURE__ */ __name((cause3) => stringBuilder.length === 0 ? failCause10(cause3) : flatMap13(write(of2(stringBuilder)), () => failCause10(cause3)), "onFailure"),
        onDone: /* @__PURE__ */ __name((done13) => stringBuilder.length === 0 ? succeed11(done13) : flatMap13(write(of2(stringBuilder)), () => succeed11(done13)), "onDone")
      });
      return loop3;
    }), "splitLines");
    toPubSub = /* @__PURE__ */ __name((pubsub) => toQueue(pubsub), "toPubSub");
    toPull = /* @__PURE__ */ __name((self2) => flatMap11(scope3, (scope5) => toPullIn(self2, scope5)), "toPull");
    toPullIn = /* @__PURE__ */ dual(2, (self2, scope5) => zip5(sync5(() => new ChannelExecutor(self2, void 0, identity)), runtime4()).pipe(tap4(([executor, runtime5]) => addFinalizerExit(scope5, (exit5) => {
      const finalizer3 = executor.close(exit5);
      return finalizer3 !== void 0 ? provide2(finalizer3, runtime5) : _void;
    })), uninterruptible2, map18(([executor]) => suspend4(() => interpretToPull(executor.run(), executor)))));
    interpretToPull = /* @__PURE__ */ __name((channelState, exec) => {
      const state = channelState;
      switch (state._tag) {
        case OP_DONE3: {
          return match6(exec.getDone(), {
            onFailure: failCause8,
            onSuccess: /* @__PURE__ */ __name((done13) => succeed9(left2(done13)), "onSuccess")
          });
        }
        case OP_EMIT2: {
          return succeed9(right2(exec.getEmit()));
        }
        case OP_FROM_EFFECT3: {
          return pipe(state.effect, flatMap11(() => interpretToPull(exec.run(), exec)));
        }
        case OP_READ2: {
          return readUpstream(state, () => interpretToPull(exec.run(), exec), (cause3) => failCause8(cause3));
        }
      }
    }, "interpretToPull");
    toQueue = /* @__PURE__ */ __name((queue) => suspend6(() => toQueueInternal(queue)), "toQueue");
    toQueueInternal = /* @__PURE__ */ __name((queue) => {
      return readWithCause({
        onInput: /* @__PURE__ */ __name((elem) => flatMap13(fromEffect4(offer3(queue, right2(elem))), () => toQueueInternal(queue)), "onInput"),
        onFailure: /* @__PURE__ */ __name((cause3) => fromEffect4(offer3(queue, left2(failCause3(cause3)))), "onFailure"),
        onDone: /* @__PURE__ */ __name((done13) => fromEffect4(offer3(queue, left2(succeed3(done13)))), "onDone")
      });
    }, "toQueueInternal");
    unwrap = /* @__PURE__ */ __name((channel2) => flatten12(fromEffect4(channel2)), "unwrap");
    unwrapScoped3 = /* @__PURE__ */ __name((self2) => concatAllWith(scoped4(self2), (d, _) => d, (d, _) => d), "unwrapScoped");
    unwrapScopedWith = /* @__PURE__ */ __name((f) => concatAllWith(scopedWith3(f), (d, _) => d, (d, _) => d), "unwrapScopedWith");
    withSpan5 = /* @__PURE__ */ __name(function() {
      const dataFirst = typeof arguments[0] !== "string";
      const name = dataFirst ? arguments[1] : arguments[0];
      const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
      const acquire2 = all6([makeSpan2(name, options), context5(), clock2, get13(currentTracerTimingEnabled2)]);
      if (dataFirst) {
        const self2 = arguments[0];
        return acquireUseRelease3(acquire2, ([span4, context10]) => provideContext4(self2, add2(context10, spanTag, span4)), ([span4, , clock3, timingEnabled], exit5) => endSpan(span4, exit5, clock3, timingEnabled));
      }
      return (self2) => acquireUseRelease3(acquire2, ([span4, context10]) => provideContext4(self2, add2(context10, spanTag, span4)), ([span4, , clock3, timingEnabled], exit5) => endSpan(span4, exit5, clock3, timingEnabled));
    }, "withSpan");
    writeAll = /* @__PURE__ */ __name((...outs) => writeChunk(fromIterable3(outs)), "writeAll");
    writeChunk = /* @__PURE__ */ __name((outs) => writeChunkWriter(0, outs.length, outs), "writeChunk");
    writeChunkWriter = /* @__PURE__ */ __name((idx, len, chunk4) => {
      return idx === len ? void_6 : pipe(write(pipe(chunk4, unsafeGet4(idx))), flatMap13(() => writeChunkWriter(idx + 1, len, chunk4)));
    }, "writeChunkWriter");
    zip6 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options) => options?.concurrent ? mergeWith2(self2, {
      other: that,
      onSelfDone: /* @__PURE__ */ __name((exit1) => Await((exit22) => suspend4(() => zip3(exit1, exit22))), "onSelfDone"),
      onOtherDone: /* @__PURE__ */ __name((exit22) => Await((exit1) => suspend4(() => zip3(exit1, exit22))), "onOtherDone")
    }) : flatMap13(self2, (a) => map20(that, (b) => [a, b])));
    zipLeft5 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options) => options?.concurrent ? map20(zip6(self2, that, {
      concurrent: true
    }), (tuple4) => tuple4[0]) : flatMap13(self2, (z2) => as7(that, z2)));
    zipRight6 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options) => options?.concurrent ? map20(zip6(self2, that, {
      concurrent: true
    }), (tuple4) => tuple4[1]) : flatMap13(self2, () => that));
    ChannelExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Channel/ChannelException");
    ChannelException = /* @__PURE__ */ __name((error50) => ({
      _tag: "ChannelException",
      [ChannelExceptionTypeId]: ChannelExceptionTypeId,
      error: error50
    }), "ChannelException");
    isChannelException = /* @__PURE__ */ __name((u) => hasProperty(u, ChannelExceptionTypeId), "isChannelException");
  }
});

// node_modules/effect/dist/esm/internal/sink.js
var SinkTypeId2, sinkVariance2, SinkImpl, isSink, suspend7, collectAll, collectAllLoop, collectAllN, collectAllNLoop, collectLeftover, drain2, fail12, fold, foldReader, foldChunkSplit, foldSink, foldChunks, foldChunksReader, foldEffect, foldEffectReader, foldChunkSplitEffect, foldChunkSplitEffectInternal, foldLeftChunks, flatMap14, forEach10, forEachChunk, forEachWhile, forEachWhileReader, fromChannel, fromEffect6, head5, last4, map21, raceWith3, sum2, toChannel, unwrapScopedWith2, zipRight7, zipWith9, count4, mkString;
var init_sink = __esm({
  "node_modules/effect/dist/esm/internal/sink.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Chunk();
    init_Effect();
    init_Exit();
    init_Function();
    init_Option();
    init_Pipeable();
    init_Predicate();
    init_PubSub();
    init_Queue();
    init_Scope();
    init_channel2();
    init_mergeDecision();
    init_core_stream();
    SinkTypeId2 = /* @__PURE__ */ Symbol.for("effect/Sink");
    sinkVariance2 = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A"),
      /* c8 ignore next */
      _In: /* @__PURE__ */ __name((_) => _, "_In"),
      /* c8 ignore next */
      _L: /* @__PURE__ */ __name((_) => _, "_L"),
      /* c8 ignore next */
      _E: /* @__PURE__ */ __name((_) => _, "_E"),
      /* c8 ignore next */
      _R: /* @__PURE__ */ __name((_) => _, "_R")
    };
    SinkImpl = class {
      static {
        __name(this, "SinkImpl");
      }
      channel;
      [SinkTypeId2] = sinkVariance2;
      constructor(channel2) {
        this.channel = channel2;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    isSink = /* @__PURE__ */ __name((u) => hasProperty(u, SinkTypeId2), "isSink");
    suspend7 = /* @__PURE__ */ __name((evaluate3) => new SinkImpl(suspend6(() => toChannel(evaluate3()))), "suspend");
    collectAll = /* @__PURE__ */ __name(() => new SinkImpl(collectAllLoop(empty5())), "collectAll");
    collectAllLoop = /* @__PURE__ */ __name((acc) => readWithCause({
      onInput: /* @__PURE__ */ __name((chunk4) => collectAllLoop(pipe(acc, appendAll2(chunk4))), "onInput"),
      onFailure: failCause10,
      onDone: /* @__PURE__ */ __name(() => succeed11(acc), "onDone")
    }), "collectAllLoop");
    collectAllN = /* @__PURE__ */ __name((n) => suspend7(() => fromChannel(collectAllNLoop(n, empty5()))), "collectAllN");
    collectAllNLoop = /* @__PURE__ */ __name((n, acc) => readWithCause({
      onInput: /* @__PURE__ */ __name((chunk4) => {
        const [collected, leftovers] = splitAt2(chunk4, n);
        if (collected.length < n) {
          return collectAllNLoop(n - collected.length, appendAll2(acc, collected));
        }
        if (isEmpty(leftovers)) {
          return succeed11(appendAll2(acc, collected));
        }
        return flatMap13(write(leftovers), () => succeed11(appendAll2(acc, collected)));
      }, "onInput"),
      onFailure: failCause10,
      onDone: /* @__PURE__ */ __name(() => succeed11(acc), "onDone")
    }), "collectAllNLoop");
    collectLeftover = /* @__PURE__ */ __name((self2) => new SinkImpl(pipe(collectElements(toChannel(self2)), map20(([chunks3, z2]) => [z2, flatten4(chunks3)]))), "collectLeftover");
    drain2 = /* @__PURE__ */ new SinkImpl(/* @__PURE__ */ drain(/* @__PURE__ */ identityChannel()));
    fail12 = /* @__PURE__ */ __name((e) => new SinkImpl(fail11(e)), "fail");
    fold = /* @__PURE__ */ __name((s, contFn, f) => suspend7(() => new SinkImpl(foldReader(s, contFn, f))), "fold");
    foldReader = /* @__PURE__ */ __name((s, contFn, f) => {
      if (!contFn(s)) {
        return succeedNow(s);
      }
      return readWith({
        onInput: /* @__PURE__ */ __name((input) => {
          const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length);
          if (isNonEmpty2(leftovers)) {
            return pipe(write(leftovers), as7(nextS));
          }
          return foldReader(nextS, contFn, f);
        }, "onInput"),
        onFailure: fail11,
        onDone: /* @__PURE__ */ __name(() => succeedNow(s), "onDone")
      });
    }, "foldReader");
    foldChunkSplit = /* @__PURE__ */ __name((s, chunk4, contFn, f, index2, length4) => {
      if (index2 === length4) {
        return [s, empty5()];
      }
      const s1 = f(s, pipe(chunk4, unsafeGet4(index2)));
      if (contFn(s1)) {
        return foldChunkSplit(s1, chunk4, contFn, f, index2 + 1, length4);
      }
      return [s1, pipe(chunk4, drop2(index2 + 1))];
    }, "foldChunkSplit");
    foldSink = /* @__PURE__ */ dual(2, (self2, options) => {
      const newChannel = pipe(toChannel(self2), collectElements, foldChannel({
        onFailure: /* @__PURE__ */ __name((error50) => toChannel(options.onFailure(error50)), "onFailure"),
        onSuccess: /* @__PURE__ */ __name(([leftovers, z2]) => suspend6(() => {
          const leftoversRef = {
            ref: pipe(leftovers, filter3(isNonEmpty2))
          };
          const refReader = pipe(
            sync7(() => {
              const ref2 = leftoversRef.ref;
              leftoversRef.ref = empty5();
              return ref2;
            }),
            // This cast is safe because of the L1 >: L <: In1 bound. It follows that
            // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].
            flatMap13((chunk4) => writeChunk(chunk4))
          );
          const passthrough5 = identityChannel();
          const continuationSink = pipe(refReader, zipRight6(passthrough5), pipeTo(toChannel(options.onSuccess(z2))));
          return flatMap13(collectElements(continuationSink), ([newLeftovers, z1]) => pipe(succeed11(leftoversRef.ref), flatMap13(writeChunk), zipRight6(writeChunk(newLeftovers)), as7(z1)));
        }), "onSuccess")
      }));
      return new SinkImpl(newChannel);
    });
    foldChunks = /* @__PURE__ */ __name((s, contFn, f) => suspend7(() => new SinkImpl(foldChunksReader(s, contFn, f))), "foldChunks");
    foldChunksReader = /* @__PURE__ */ __name((s, contFn, f) => {
      if (!contFn(s)) {
        return succeedNow(s);
      }
      return readWith({
        onInput: /* @__PURE__ */ __name((input) => foldChunksReader(f(s, input), contFn, f), "onInput"),
        onFailure: fail11,
        onDone: /* @__PURE__ */ __name(() => succeedNow(s), "onDone")
      });
    }, "foldChunksReader");
    foldEffect = /* @__PURE__ */ __name((s, contFn, f) => suspend7(() => new SinkImpl(foldEffectReader(s, contFn, f))), "foldEffect");
    foldEffectReader = /* @__PURE__ */ __name((s, contFn, f) => {
      if (!contFn(s)) {
        return succeedNow(s);
      }
      return readWith({
        onInput: /* @__PURE__ */ __name((input) => pipe(fromEffect4(foldChunkSplitEffect(s, input, contFn, f)), flatMap13(([nextS, leftovers]) => pipe(leftovers, match2({
          onNone: /* @__PURE__ */ __name(() => foldEffectReader(nextS, contFn, f), "onNone"),
          onSome: /* @__PURE__ */ __name((leftover) => pipe(write(leftover), as7(nextS)), "onSome")
        })))), "onInput"),
        onFailure: fail11,
        onDone: /* @__PURE__ */ __name(() => succeedNow(s), "onDone")
      });
    }, "foldEffectReader");
    foldChunkSplitEffect = /* @__PURE__ */ __name((s, chunk4, contFn, f) => foldChunkSplitEffectInternal(s, chunk4, 0, chunk4.length, contFn, f), "foldChunkSplitEffect");
    foldChunkSplitEffectInternal = /* @__PURE__ */ __name((s, chunk4, index2, length4, contFn, f) => {
      if (index2 === length4) {
        return succeed9([s, none2()]);
      }
      return pipe(f(s, pipe(chunk4, unsafeGet4(index2))), flatMap11((s1) => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk4, index2 + 1, length4, contFn, f) : succeed9([s1, some2(pipe(chunk4, drop2(index2 + 1)))])));
    }, "foldChunkSplitEffectInternal");
    foldLeftChunks = /* @__PURE__ */ __name((s, f) => foldChunks(s, constTrue, f), "foldLeftChunks");
    flatMap14 = /* @__PURE__ */ dual(2, (self2, f) => foldSink(self2, {
      onFailure: fail12,
      onSuccess: f
    }));
    forEach10 = /* @__PURE__ */ __name((f) => {
      const process4 = readWithCause({
        onInput: /* @__PURE__ */ __name((input) => pipe(fromEffect4(forEach9(input, (v) => f(v), {
          discard: true
        })), flatMap13(() => process4)), "onInput"),
        onFailure: failCause10,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      });
      return new SinkImpl(process4);
    }, "forEach");
    forEachChunk = /* @__PURE__ */ __name((f) => {
      const process4 = readWithCause({
        onInput: /* @__PURE__ */ __name((input) => pipe(fromEffect4(f(input)), flatMap13(() => process4)), "onInput"),
        onFailure: failCause10,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      });
      return new SinkImpl(process4);
    }, "forEachChunk");
    forEachWhile = /* @__PURE__ */ __name((f) => {
      const process4 = readWithCause({
        onInput: /* @__PURE__ */ __name((input) => forEachWhileReader(f, input, 0, input.length, process4), "onInput"),
        onFailure: failCause10,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      });
      return new SinkImpl(process4);
    }, "forEachWhile");
    forEachWhileReader = /* @__PURE__ */ __name((f, input, index2, length4, cont) => {
      if (index2 === length4) {
        return cont;
      }
      return pipe(fromEffect4(f(pipe(input, unsafeGet4(index2)))), flatMap13((bool) => bool ? forEachWhileReader(f, input, index2 + 1, length4, cont) : write(pipe(input, drop2(index2)))), catchAll5((error50) => pipe(write(pipe(input, drop2(index2))), zipRight6(fail11(error50)))));
    }, "forEachWhileReader");
    fromChannel = /* @__PURE__ */ __name((channel2) => new SinkImpl(channel2), "fromChannel");
    fromEffect6 = /* @__PURE__ */ __name((effect4) => new SinkImpl(fromEffect4(effect4)), "fromEffect");
    head5 = /* @__PURE__ */ __name(() => fold(none2(), isNone2, (option5, input) => match2(option5, {
      onNone: /* @__PURE__ */ __name(() => some2(input), "onNone"),
      onSome: /* @__PURE__ */ __name(() => option5, "onSome")
    })), "head");
    last4 = /* @__PURE__ */ __name(() => foldLeftChunks(none2(), (s, input) => orElse(last2(input), () => s)), "last");
    map21 = /* @__PURE__ */ dual(2, (self2, f) => {
      return new SinkImpl(pipe(toChannel(self2), map20(f)));
    });
    raceWith3 = /* @__PURE__ */ dual(2, (self2, options) => {
      function race6(scope5) {
        return gen4(function* () {
          const pubsub = yield* bounded4(options?.capacity ?? 16);
          const subscription1 = yield* extend2(subscribe2(pubsub), scope5);
          const subscription2 = yield* extend2(subscribe2(pubsub), scope5);
          const reader = toPubSub(pubsub);
          const writer = fromQueue(subscription1).pipe(pipeTo(toChannel(self2)), zipLeft5(fromEffect4(shutdown4(subscription1))), mergeWith2({
            other: fromQueue(subscription2).pipe(pipeTo(toChannel(options.other)), zipLeft5(fromEffect4(shutdown4(subscription2)))),
            onSelfDone: options.onSelfDone,
            onOtherDone: options.onOtherDone
          }));
          const racedChannel = mergeWith2(reader, {
            other: writer,
            onSelfDone: /* @__PURE__ */ __name(() => Await(identity), "onSelfDone"),
            onOtherDone: /* @__PURE__ */ __name((exit5) => Done3(exit5), "onOtherDone")
          });
          return new SinkImpl(racedChannel);
        });
      }
      __name(race6, "race");
      return unwrapScopedWith2(race6);
    });
    sum2 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk4) => acc + reduce2(chunk4, 0, (s, a) => s + a));
    toChannel = /* @__PURE__ */ __name((self2) => isEffect2(self2) ? toChannel(fromEffect6(self2)) : self2.channel, "toChannel");
    unwrapScopedWith2 = /* @__PURE__ */ __name((f) => new SinkImpl(unwrapScopedWith((scope5) => f(scope5).pipe(map18((sink) => toChannel(sink))))), "unwrapScopedWith");
    zipRight7 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self2, that, options) => zipWith9(self2, that, (_, z2) => z2, options));
    zipWith9 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self2, that, f, options) => options?.concurrent ? raceWith3(self2, {
      other: that,
      onSelfDone: match6({
        onFailure: /* @__PURE__ */ __name((cause3) => Done3(failCause8(cause3)), "onFailure"),
        onSuccess: /* @__PURE__ */ __name((leftZ) => Await(match6({
          onFailure: failCause8,
          onSuccess: /* @__PURE__ */ __name((rightZ) => succeed9(f(leftZ, rightZ)), "onSuccess")
        })), "onSuccess")
      }),
      onOtherDone: match6({
        onFailure: /* @__PURE__ */ __name((cause3) => Done3(failCause8(cause3)), "onFailure"),
        onSuccess: /* @__PURE__ */ __name((rightZ) => Await(match6({
          onFailure: failCause8,
          onSuccess: /* @__PURE__ */ __name((leftZ) => succeed9(f(leftZ, rightZ)), "onSuccess")
        })), "onSuccess")
      })
    }) : flatMap14(self2, (z2) => map21(that, (z22) => f(z2, z22))));
    count4 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk4) => acc + chunk4.length);
    mkString = /* @__PURE__ */ suspend7(() => {
      const strings = [];
      return pipe(foldLeftChunks(void 0, (_, elems) => map5(elems, (elem) => {
        strings.push(String(elem));
      })), map21(() => strings.join("")));
    });
  }
});

// node_modules/effect/dist/esm/MergeDecision.js
var Done4, Await2;
var init_MergeDecision = __esm({
  "node_modules/effect/dist/esm/MergeDecision.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_mergeDecision();
    Done4 = Done3;
    Await2 = Await;
  }
});

// node_modules/effect/dist/esm/internal/rcRef.js
var TypeId21, stateEmpty2, stateClosed, variance5, RcRefImpl, make45, get14;
var init_rcRef = __esm({
  "node_modules/effect/dist/esm/internal/rcRef.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Context();
    init_Duration();
    init_Effectable();
    init_Function();
    init_Readable();
    init_core_effect();
    init_core();
    init_circular();
    init_fiberRuntime();
    TypeId21 = /* @__PURE__ */ Symbol.for("effect/RcRef");
    stateEmpty2 = {
      _tag: "Empty"
    };
    stateClosed = {
      _tag: "Closed"
    };
    variance5 = {
      _A: identity,
      _E: identity
    };
    RcRefImpl = class extends Class2 {
      static {
        __name(this, "RcRefImpl");
      }
      acquire;
      context;
      scope;
      idleTimeToLive;
      [TypeId21] = variance5;
      [TypeId14] = TypeId14;
      state = stateEmpty2;
      semaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
      constructor(acquire2, context10, scope5, idleTimeToLive) {
        super();
        this.acquire = acquire2;
        this.context = context10;
        this.scope = scope5;
        this.idleTimeToLive = idleTimeToLive;
        this.get = get14(this);
      }
      get;
      commit() {
        return this.get;
      }
    };
    make45 = /* @__PURE__ */ __name((options) => withFiberRuntime((fiber) => {
      const context10 = fiber.getFiberRef(currentContext);
      const scope5 = get3(context10, scopeTag);
      const ref2 = new RcRefImpl(options.acquire, context10, scope5, options.idleTimeToLive ? decode(options.idleTimeToLive) : void 0);
      return as2(scope5.addFinalizer(() => ref2.semaphore.withPermits(1)(suspend(() => {
        const close2 = ref2.state._tag === "Acquired" ? scopeClose(ref2.state.scope, exitVoid) : void_2;
        ref2.state = stateClosed;
        return close2;
      }))), ref2);
    }), "make");
    get14 = /* @__PURE__ */ __name((self_) => {
      const self2 = self_;
      const isInfinite = self2.idleTimeToLive && !isFinite2(self2.idleTimeToLive);
      return uninterruptibleMask((restore) => suspend(() => {
        switch (self2.state._tag) {
          case "Closed": {
            return interrupt2;
          }
          case "Acquired": {
            self2.state.refCount++;
            return self2.state.fiber ? as2(interruptFiber(self2.state.fiber), self2.state) : succeed(self2.state);
          }
          case "Empty": {
            return scopeMake().pipe(bindTo3("scope"), bind3("value", ({
              scope: scope5
            }) => restore(fiberRefLocally(self2.acquire, currentContext, add2(self2.context, scopeTag, scope5)))), map11(({
              scope: scope5,
              value: value3
            }) => {
              const state = {
                _tag: "Acquired",
                value: value3,
                scope: scope5,
                fiber: void 0,
                refCount: 1
              };
              self2.state = state;
              return state;
            }));
          }
        }
      })).pipe(self2.semaphore.withPermits(1), bindTo3("state"), bind3("scope", () => scopeTag), tap2(({
        scope: scope5,
        state
      }) => scope5.addFinalizer(() => suspend(() => {
        state.refCount--;
        if (state.refCount > 0 || isInfinite) {
          return void_2;
        }
        if (self2.idleTimeToLive === void 0) {
          self2.state = stateEmpty2;
          return scopeClose(state.scope, exitVoid);
        }
        return sleep3(self2.idleTimeToLive).pipe(interruptible2, zipRight2(suspend(() => {
          if (self2.state._tag === "Acquired" && self2.state.refCount === 0) {
            self2.state = stateEmpty2;
            return scopeClose(state.scope, exitVoid);
          }
          return void_2;
        })), ensuring(sync(() => {
          state.fiber = void 0;
        })), forkIn(self2.scope), tap2((fiber) => {
          state.fiber = fiber;
        }), self2.semaphore.withPermits(1));
      }))), map11(({
        state
      }) => state.value));
    }, "get");
  }
});

// node_modules/effect/dist/esm/RcRef.js
var make46, get15;
var init_RcRef = __esm({
  "node_modules/effect/dist/esm/RcRef.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_rcRef();
    make46 = make45;
    get15 = get14;
  }
});

// node_modules/effect/dist/esm/Runtime.js
var runFork3, runPromiseExit2, defaultRuntime2;
var init_Runtime = __esm({
  "node_modules/effect/dist/esm/Runtime.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_runtime();
    runFork3 = unsafeFork3;
    runPromiseExit2 = unsafeRunPromiseExit;
    defaultRuntime2 = defaultRuntime;
  }
});

// node_modules/effect/dist/esm/Schedule.js
var Schedule_exports = {};
__export(Schedule_exports, {
  CurrentIterationMetadata: () => CurrentIterationMetadata2,
  ScheduleDriverTypeId: () => ScheduleDriverTypeId2,
  ScheduleTypeId: () => ScheduleTypeId2,
  addDelay: () => addDelay2,
  addDelayEffect: () => addDelayEffect2,
  andThen: () => andThen7,
  andThenEither: () => andThenEither2,
  as: () => as8,
  asVoid: () => asVoid5,
  bothInOut: () => bothInOut2,
  check: () => check3,
  checkEffect: () => checkEffect2,
  collectAllInputs: () => collectAllInputs2,
  collectAllOutputs: () => collectAllOutputs2,
  collectUntil: () => collectUntil2,
  collectUntilEffect: () => collectUntilEffect2,
  collectWhile: () => collectWhile2,
  collectWhileEffect: () => collectWhileEffect2,
  compose: () => compose3,
  count: () => count5,
  cron: () => cron2,
  dayOfMonth: () => dayOfMonth2,
  dayOfWeek: () => dayOfWeek2,
  delayed: () => delayed2,
  delayedEffect: () => delayedEffect2,
  delayedSchedule: () => delayedSchedule2,
  delays: () => delays2,
  driver: () => driver2,
  duration: () => duration2,
  either: () => either5,
  eitherWith: () => eitherWith2,
  elapsed: () => elapsed2,
  ensuring: () => ensuring5,
  exponential: () => exponential3,
  fibonacci: () => fibonacci2,
  fixed: () => fixed4,
  forever: () => forever4,
  fromDelay: () => fromDelay2,
  fromDelays: () => fromDelays2,
  fromFunction: () => fromFunction4,
  hourOfDay: () => hourOfDay2,
  identity: () => identity4,
  intersect: () => intersect6,
  intersectWith: () => intersectWith2,
  isSchedule: () => isSchedule2,
  jittered: () => jittered2,
  jitteredWith: () => jitteredWith2,
  linear: () => linear2,
  makeWithState: () => makeWithState2,
  map: () => map22,
  mapBoth: () => mapBoth6,
  mapBothEffect: () => mapBothEffect2,
  mapEffect: () => mapEffect4,
  mapInput: () => mapInput4,
  mapInputContext: () => mapInputContext4,
  mapInputEffect: () => mapInputEffect2,
  minuteOfHour: () => minuteOfHour2,
  modifyDelay: () => modifyDelay2,
  modifyDelayEffect: () => modifyDelayEffect2,
  onDecision: () => onDecision2,
  once: () => once5,
  passthrough: () => passthrough4,
  provideContext: () => provideContext5,
  provideService: () => provideService5,
  recurUntil: () => recurUntil2,
  recurUntilEffect: () => recurUntilEffect2,
  recurUntilOption: () => recurUntilOption2,
  recurUpTo: () => recurUpTo2,
  recurWhile: () => recurWhile2,
  recurWhileEffect: () => recurWhileEffect2,
  recurs: () => recurs2,
  reduce: () => reduce13,
  reduceEffect: () => reduceEffect4,
  repeatForever: () => repeatForever,
  repetitions: () => repetitions2,
  resetAfter: () => resetAfter2,
  resetWhen: () => resetWhen2,
  run: () => run3,
  secondOfMinute: () => secondOfMinute2,
  spaced: () => spaced2,
  stop: () => stop2,
  succeed: () => succeed12,
  sync: () => sync8,
  tapInput: () => tapInput2,
  tapOutput: () => tapOutput2,
  unfold: () => unfold3,
  union: () => union10,
  unionWith: () => unionWith3,
  untilInput: () => untilInput2,
  untilInputEffect: () => untilInputEffect2,
  untilOutput: () => untilOutput2,
  untilOutputEffect: () => untilOutputEffect2,
  upTo: () => upTo2,
  whileInput: () => whileInput2,
  whileInputEffect: () => whileInputEffect2,
  whileOutput: () => whileOutput2,
  whileOutputEffect: () => whileOutputEffect2,
  windowed: () => windowed2,
  zipLeft: () => zipLeft6,
  zipRight: () => zipRight8,
  zipWith: () => zipWith10
});
var ScheduleTypeId2, ScheduleDriverTypeId2, makeWithState2, isSchedule2, addDelay2, addDelayEffect2, andThen7, andThenEither2, as8, asVoid5, bothInOut2, check3, checkEffect2, collectAllInputs2, collectAllOutputs2, collectUntil2, collectUntilEffect2, collectWhile2, collectWhileEffect2, compose3, mapInput4, mapInputEffect2, mapInputContext4, count5, cron2, secondOfMinute2, minuteOfHour2, hourOfDay2, dayOfMonth2, dayOfWeek2, delayed2, delayedEffect2, delayedSchedule2, delays2, mapBoth6, mapBothEffect2, driver2, duration2, either5, eitherWith2, elapsed2, ensuring5, exponential3, fibonacci2, fixed4, forever4, fromDelay2, fromDelays2, fromFunction4, identity4, passthrough4, intersect6, intersectWith2, jittered2, jitteredWith2, linear2, map22, mapEffect4, modifyDelay2, modifyDelayEffect2, onDecision2, once5, provideContext5, provideService5, recurUntil2, recurUntilEffect2, recurUntilOption2, recurUpTo2, recurWhile2, recurWhileEffect2, recurs2, reduce13, reduceEffect4, repeatForever, repetitions2, resetAfter2, resetWhen2, run3, spaced2, stop2, succeed12, sync8, tapInput2, tapOutput2, unfold3, union10, unionWith3, untilInput2, untilInputEffect2, untilOutput2, untilOutputEffect2, upTo2, whileInput2, whileInputEffect2, whileOutput2, whileOutputEffect2, windowed2, zipLeft6, zipRight8, zipWith10, CurrentIterationMetadata2;
var init_Schedule = __esm({
  "node_modules/effect/dist/esm/Schedule.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_schedule();
    ScheduleTypeId2 = ScheduleTypeId;
    ScheduleDriverTypeId2 = ScheduleDriverTypeId;
    makeWithState2 = makeWithState;
    isSchedule2 = isSchedule;
    addDelay2 = addDelay;
    addDelayEffect2 = addDelayEffect;
    andThen7 = andThen5;
    andThenEither2 = andThenEither;
    as8 = as5;
    asVoid5 = asVoid3;
    bothInOut2 = bothInOut;
    check3 = check2;
    checkEffect2 = checkEffect;
    collectAllInputs2 = collectAllInputs;
    collectAllOutputs2 = collectAllOutputs;
    collectUntil2 = collectUntil;
    collectUntilEffect2 = collectUntilEffect;
    collectWhile2 = collectWhile;
    collectWhileEffect2 = collectWhileEffect;
    compose3 = compose2;
    mapInput4 = mapInput3;
    mapInputEffect2 = mapInputEffect;
    mapInputContext4 = mapInputContext2;
    count5 = count3;
    cron2 = cron;
    secondOfMinute2 = secondOfMinute;
    minuteOfHour2 = minuteOfHour;
    hourOfDay2 = hourOfDay;
    dayOfMonth2 = dayOfMonth;
    dayOfWeek2 = dayOfWeek;
    delayed2 = delayed;
    delayedEffect2 = delayedEffect;
    delayedSchedule2 = delayedSchedule;
    delays2 = delays;
    mapBoth6 = mapBoth4;
    mapBothEffect2 = mapBothEffect;
    driver2 = driver;
    duration2 = duration;
    either5 = either3;
    eitherWith2 = eitherWith;
    elapsed2 = elapsed;
    ensuring5 = ensuring2;
    exponential3 = exponential2;
    fibonacci2 = fibonacci;
    fixed4 = fixed3;
    forever4 = forever2;
    fromDelay2 = fromDelay;
    fromDelays2 = fromDelays;
    fromFunction4 = fromFunction2;
    identity4 = identity3;
    passthrough4 = passthrough2;
    intersect6 = intersect5;
    intersectWith2 = intersectWith;
    jittered2 = jittered;
    jitteredWith2 = jitteredWith;
    linear2 = linear;
    map22 = map17;
    mapEffect4 = mapEffect2;
    modifyDelay2 = modifyDelay;
    modifyDelayEffect2 = modifyDelayEffect;
    onDecision2 = onDecision;
    once5 = once3;
    provideContext5 = provideContext3;
    provideService5 = provideService2;
    recurUntil2 = recurUntil;
    recurUntilEffect2 = recurUntilEffect;
    recurUntilOption2 = recurUntilOption;
    recurUpTo2 = recurUpTo;
    recurWhile2 = recurWhile;
    recurWhileEffect2 = recurWhileEffect;
    recurs2 = recurs;
    reduce13 = reduce11;
    reduceEffect4 = reduceEffect2;
    repeatForever = forever2;
    repetitions2 = repetitions;
    resetAfter2 = resetAfter;
    resetWhen2 = resetWhen;
    run3 = run;
    spaced2 = spaced;
    stop2 = stop;
    succeed12 = succeed7;
    sync8 = sync4;
    tapInput2 = tapInput;
    tapOutput2 = tapOutput;
    unfold3 = unfold2;
    union10 = union9;
    unionWith3 = unionWith2;
    untilInput2 = untilInput;
    untilInputEffect2 = untilInputEffect;
    untilOutput2 = untilOutput;
    untilOutputEffect2 = untilOutputEffect;
    upTo2 = upTo;
    whileInput2 = whileInput;
    whileInputEffect2 = whileInputEffect;
    whileOutput2 = whileOutput;
    whileOutputEffect2 = whileOutputEffect;
    windowed2 = windowed;
    zipLeft6 = zipLeft3;
    zipRight8 = zipRight4;
    zipWith10 = zipWith6;
    CurrentIterationMetadata2 = CurrentIterationMetadata;
  }
});

// node_modules/effect/dist/esm/internal/opCodes/streamHaltStrategy.js
var OP_LEFT, OP_RIGHT, OP_BOTH, OP_EITHER;
var init_streamHaltStrategy = __esm({
  "node_modules/effect/dist/esm/internal/opCodes/streamHaltStrategy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_LEFT = "Left";
    OP_RIGHT = "Right";
    OP_BOTH = "Both";
    OP_EITHER = "Either";
  }
});

// node_modules/effect/dist/esm/internal/stream/haltStrategy.js
var Left, Right, Both, Either, fromInput2;
var init_haltStrategy = __esm({
  "node_modules/effect/dist/esm/internal/stream/haltStrategy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_streamHaltStrategy();
    Left = {
      _tag: OP_LEFT
    };
    Right = {
      _tag: OP_RIGHT
    };
    Both = {
      _tag: OP_BOTH
    };
    Either = {
      _tag: OP_EITHER
    };
    fromInput2 = /* @__PURE__ */ __name((input) => {
      switch (input) {
        case "left":
          return Left;
        case "right":
          return Right;
        case "both":
          return Both;
        case "either":
          return Either;
        default:
          return input;
      }
    }, "fromInput");
  }
});

// node_modules/effect/dist/esm/StreamHaltStrategy.js
var Both2;
var init_StreamHaltStrategy = __esm({
  "node_modules/effect/dist/esm/StreamHaltStrategy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_haltStrategy();
    Both2 = Both;
  }
});

// node_modules/effect/dist/esm/internal/stm/versioned.js
var Versioned;
var init_versioned = __esm({
  "node_modules/effect/dist/esm/internal/stm/versioned.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Versioned = class {
      static {
        __name(this, "Versioned");
      }
      value;
      constructor(value3) {
        this.value = value3;
      }
    };
  }
});

// node_modules/effect/dist/esm/internal/stm/entry.js
var make47, unsafeGet8, unsafeSet, commit, isInvalid, isChanged;
var init_entry = __esm({
  "node_modules/effect/dist/esm/internal/stm/entry.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_versioned();
    make47 = /* @__PURE__ */ __name((ref2, isNew) => ({
      ref: ref2,
      isNew,
      isChanged: false,
      expected: ref2.versioned,
      newValue: ref2.versioned.value
    }), "make");
    unsafeGet8 = /* @__PURE__ */ __name((self2) => {
      return self2.newValue;
    }, "unsafeGet");
    unsafeSet = /* @__PURE__ */ __name((self2, value3) => {
      self2.isChanged = true;
      self2.newValue = value3;
    }, "unsafeSet");
    commit = /* @__PURE__ */ __name((self2) => {
      self2.ref.versioned = new Versioned(self2.newValue);
    }, "commit");
    isInvalid = /* @__PURE__ */ __name((self2) => {
      return self2.ref.versioned !== self2.expected;
    }, "isInvalid");
    isChanged = /* @__PURE__ */ __name((self2) => {
      return self2.isChanged;
    }, "isChanged");
  }
});

// node_modules/effect/dist/esm/internal/stm/journal.js
var JournalAnalysisInvalid, JournalAnalysisReadWrite, JournalAnalysisReadOnly, commitJournal, analyzeJournal, collectTodos, execTodos, addTodo;
var init_journal = __esm({
  "node_modules/effect/dist/esm/internal/stm/journal.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_entry();
    JournalAnalysisInvalid = "Invalid";
    JournalAnalysisReadWrite = "ReadWrite";
    JournalAnalysisReadOnly = "ReadOnly";
    commitJournal = /* @__PURE__ */ __name((journal) => {
      for (const entry of journal) {
        commit(entry[1]);
      }
    }, "commitJournal");
    analyzeJournal = /* @__PURE__ */ __name((journal) => {
      let val = JournalAnalysisReadOnly;
      for (const [, entry] of journal) {
        val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
        if (val === JournalAnalysisInvalid) {
          return val;
        }
      }
      return val;
    }, "analyzeJournal");
    collectTodos = /* @__PURE__ */ __name((journal) => {
      const allTodos = /* @__PURE__ */ new Map();
      for (const [, entry] of journal) {
        for (const todo of entry.ref.todos) {
          allTodos.set(todo[0], todo[1]);
        }
        entry.ref.todos = /* @__PURE__ */ new Map();
      }
      return allTodos;
    }, "collectTodos");
    execTodos = /* @__PURE__ */ __name((todos) => {
      const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
      for (const [_, todo] of todosSorted) {
        todo();
      }
    }, "execTodos");
    addTodo = /* @__PURE__ */ __name((txnId, journal, todoEffect) => {
      let added = false;
      for (const [, entry] of journal) {
        if (!entry.ref.todos.has(txnId)) {
          entry.ref.todos.set(txnId, todoEffect);
          added = true;
        }
      }
      return added;
    }, "addTodo");
  }
});

// node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
var OP_WITH_STM_RUNTIME, OP_ON_FAILURE2, OP_ON_RETRY, OP_ON_SUCCESS2, OP_PROVIDE3, OP_SYNC2, OP_SUCCEED2, OP_RETRY, OP_FAIL4, OP_DIE2, OP_INTERRUPT2;
var init_stm = __esm({
  "node_modules/effect/dist/esm/internal/stm/opCodes/stm.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_WITH_STM_RUNTIME = "WithSTMRuntime";
    OP_ON_FAILURE2 = "OnFailure";
    OP_ON_RETRY = "OnRetry";
    OP_ON_SUCCESS2 = "OnSuccess";
    OP_PROVIDE3 = "Provide";
    OP_SYNC2 = "Sync";
    OP_SUCCEED2 = "Succeed";
    OP_RETRY = "Retry";
    OP_FAIL4 = "Fail";
    OP_DIE2 = "Die";
    OP_INTERRUPT2 = "Interrupt";
  }
});

// node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
var OP_FAIL5, OP_DIE3, OP_INTERRUPT3, OP_SUCCEED3, OP_RETRY2;
var init_tExit = __esm({
  "node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_FAIL5 = "Fail";
    OP_DIE3 = "Die";
    OP_INTERRUPT3 = "Interrupt";
    OP_SUCCEED3 = "Succeed";
    OP_RETRY2 = "Retry";
  }
});

// node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
var OP_DONE5, OP_SUSPEND3;
var init_tryCommit = __esm({
  "node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_DONE5 = "Done";
    OP_SUSPEND3 = "Suspend";
  }
});

// node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
var OP_DONE6, OP_INTERRUPTED, OP_RUNNING2;
var init_stmState = __esm({
  "node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_DONE6 = "Done";
    OP_INTERRUPTED = "Interrupted";
    OP_RUNNING2 = "Running";
  }
});

// node_modules/effect/dist/esm/internal/stm/stmState.js
var STMStateSymbolKey, STMStateTypeId, isSTMState, isRunning2, isDone6, done8, interruptedHash, interrupted2, runningHash, running3, fromTExit;
var init_stmState2 = __esm({
  "node_modules/effect/dist/esm/internal/stm/stmState.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Exit();
    init_Function();
    init_Hash();
    init_Predicate();
    init_stmState();
    init_tExit();
    STMStateSymbolKey = "effect/STM/State";
    STMStateTypeId = /* @__PURE__ */ Symbol.for(STMStateSymbolKey);
    isSTMState = /* @__PURE__ */ __name((u) => hasProperty(u, STMStateTypeId), "isSTMState");
    isRunning2 = /* @__PURE__ */ __name((self2) => {
      return self2._tag === OP_RUNNING2;
    }, "isRunning");
    isDone6 = /* @__PURE__ */ __name((self2) => {
      return self2._tag === OP_DONE6;
    }, "isDone");
    done8 = /* @__PURE__ */ __name((exit5) => {
      return {
        [STMStateTypeId]: STMStateTypeId,
        _tag: OP_DONE6,
        exit: exit5,
        [symbol]() {
          return pipe(hash(STMStateSymbolKey), combine(hash(OP_DONE6)), combine(hash(exit5)), cached(this));
        },
        [symbol2](that) {
          return isSTMState(that) && that._tag === OP_DONE6 && equals(exit5, that.exit);
        }
      };
    }, "done");
    interruptedHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_INTERRUPTED)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("interrupted")));
    interrupted2 = {
      [STMStateTypeId]: STMStateTypeId,
      _tag: OP_INTERRUPTED,
      [symbol]() {
        return interruptedHash;
      },
      [symbol2](that) {
        return isSTMState(that) && that._tag === OP_INTERRUPTED;
      }
    };
    runningHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RUNNING2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("running")));
    running3 = {
      [STMStateTypeId]: STMStateTypeId,
      _tag: OP_RUNNING2,
      [symbol]() {
        return runningHash;
      },
      [symbol2](that) {
        return isSTMState(that) && that._tag === OP_RUNNING2;
      }
    };
    fromTExit = /* @__PURE__ */ __name((tExit) => {
      switch (tExit._tag) {
        case OP_FAIL5: {
          return done8(fail4(tExit.error));
        }
        case OP_DIE3: {
          return done8(die3(tExit.defect));
        }
        case OP_INTERRUPT3: {
          return done8(interrupt4(tExit.fiberId));
        }
        case OP_SUCCEED3: {
          return done8(succeed3(tExit.value));
        }
        case OP_RETRY2: {
          throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
        }
      }
    }, "fromTExit");
  }
});

// node_modules/effect/dist/esm/internal/stm/tExit.js
var TExitSymbolKey, TExitTypeId, variance6, isExit2, isSuccess4, isRetry, fail13, die8, interrupt8, succeed13, retryHash, retry4;
var init_tExit2 = __esm({
  "node_modules/effect/dist/esm/internal/stm/tExit.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_Hash();
    init_Predicate();
    init_tExit();
    TExitSymbolKey = "effect/TExit";
    TExitTypeId = /* @__PURE__ */ Symbol.for(TExitSymbolKey);
    variance6 = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A"),
      /* c8 ignore next */
      _E: /* @__PURE__ */ __name((_) => _, "_E")
    };
    isExit2 = /* @__PURE__ */ __name((u) => hasProperty(u, TExitTypeId), "isExit");
    isSuccess4 = /* @__PURE__ */ __name((self2) => {
      return self2._tag === OP_SUCCEED3;
    }, "isSuccess");
    isRetry = /* @__PURE__ */ __name((self2) => {
      return self2._tag === OP_RETRY2;
    }, "isRetry");
    fail13 = /* @__PURE__ */ __name((error50) => ({
      [TExitTypeId]: variance6,
      _tag: OP_FAIL5,
      error: error50,
      [symbol]() {
        return pipe(hash(TExitSymbolKey), combine(hash(OP_FAIL5)), combine(hash(error50)), cached(this));
      },
      [symbol2](that) {
        return isExit2(that) && that._tag === OP_FAIL5 && equals(error50, that.error);
      }
    }), "fail");
    die8 = /* @__PURE__ */ __name((defect) => ({
      [TExitTypeId]: variance6,
      _tag: OP_DIE3,
      defect,
      [symbol]() {
        return pipe(hash(TExitSymbolKey), combine(hash(OP_DIE3)), combine(hash(defect)), cached(this));
      },
      [symbol2](that) {
        return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
      }
    }), "die");
    interrupt8 = /* @__PURE__ */ __name((fiberId3) => ({
      [TExitTypeId]: variance6,
      _tag: OP_INTERRUPT3,
      fiberId: fiberId3,
      [symbol]() {
        return pipe(hash(TExitSymbolKey), combine(hash(OP_INTERRUPT3)), combine(hash(fiberId3)), cached(this));
      },
      [symbol2](that) {
        return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId3, that.fiberId);
      }
    }), "interrupt");
    succeed13 = /* @__PURE__ */ __name((value3) => ({
      [TExitTypeId]: variance6,
      _tag: OP_SUCCEED3,
      value: value3,
      [symbol]() {
        return pipe(hash(TExitSymbolKey), combine(hash(OP_SUCCEED3)), combine(hash(value3)), cached(this));
      },
      [symbol2](that) {
        return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value3, that.value);
      }
    }), "succeed");
    retryHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(TExitSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RETRY2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("retry")));
    retry4 = {
      [TExitTypeId]: variance6,
      _tag: OP_RETRY2,
      [symbol]() {
        return retryHash;
      },
      [symbol2](that) {
        return isExit2(that) && isRetry(that);
      }
    };
  }
});

// node_modules/effect/dist/esm/internal/stm/tryCommit.js
var done9, suspend8;
var init_tryCommit2 = __esm({
  "node_modules/effect/dist/esm/internal/stm/tryCommit.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tryCommit();
    done9 = /* @__PURE__ */ __name((exit5) => {
      return {
        _tag: OP_DONE5,
        exit: exit5
      };
    }, "done");
    suspend8 = /* @__PURE__ */ __name((journal) => {
      return {
        _tag: OP_SUSPEND3,
        journal
      };
    }, "suspend");
  }
});

// node_modules/effect/dist/esm/internal/stm/txnId.js
var txnCounter, make48;
var init_txnId = __esm({
  "node_modules/effect/dist/esm/internal/stm/txnId.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    txnCounter = {
      ref: 0
    };
    make48 = /* @__PURE__ */ __name(() => {
      const newId = txnCounter.ref + 1;
      txnCounter.ref = newId;
      return newId;
    }, "make");
  }
});

// node_modules/effect/dist/esm/internal/stm/core.js
var STMSymbolKey2, STMTypeId2, stmVariance, STMPrimitive, unsafeAtomically, tryCommit, tryCommitSync, tryCommitAsync, completeTodos, completeTryCommit, STMDriver, catchAll6, die9, dieSync5, effect3, ensuring6, fail14, failSync6, flatMap15, matchSTM, withSTMRuntime, interruptAs2, map23, retry5, succeed14, sync9, zipRight9, zipWith11;
var init_core2 = __esm({
  "node_modules/effect/dist/esm/internal/stm/core.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Cause();
    init_Context();
    init_Effect();
    init_Either();
    init_Equal();
    init_Exit();
    init_FiberRef();
    init_Function();
    init_Hash();
    init_Pipeable();
    init_Utils();
    init_core_stream();
    init_core();
    init_effectable();
    init_effect();
    init_singleShotGen();
    init_sink();
    init_journal();
    init_stm();
    init_tExit();
    init_tryCommit();
    init_stmState2();
    init_tExit2();
    init_tryCommit2();
    init_txnId();
    STMSymbolKey2 = "effect/STM";
    STMTypeId2 = /* @__PURE__ */ Symbol.for(STMSymbolKey2);
    stmVariance = {
      /* c8 ignore next */
      _R: /* @__PURE__ */ __name((_) => _, "_R"),
      /* c8 ignore next */
      _E: /* @__PURE__ */ __name((_) => _, "_E"),
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    STMPrimitive = class {
      static {
        __name(this, "STMPrimitive");
      }
      effect_instruction_i0;
      _op = OP_COMMIT;
      effect_instruction_i1 = void 0;
      effect_instruction_i2 = void 0;
      [EffectTypeId3];
      [StreamTypeId];
      [SinkTypeId2];
      [ChannelTypeId2];
      get [STMTypeId2]() {
        return stmVariance;
      }
      constructor(effect_instruction_i0) {
        this.effect_instruction_i0 = effect_instruction_i0;
        this[EffectTypeId3] = effectVariance;
        this[StreamTypeId] = stmVariance;
        this[SinkTypeId2] = stmVariance;
        this[ChannelTypeId2] = stmVariance;
      }
      [symbol2](that) {
        return this === that;
      }
      [symbol]() {
        return cached(this, random(this));
      }
      [Symbol.iterator]() {
        return new SingleShotGen2(new YieldWrap(this));
      }
      commit() {
        return unsafeAtomically(this, constVoid, constVoid);
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    unsafeAtomically = /* @__PURE__ */ __name((self2, onDone3, onInterrupt3) => withFiberRuntime((state) => {
      const fiberId3 = state.id();
      const env2 = state.getFiberRef(currentContext2);
      const scheduler2 = state.getFiberRef(currentScheduler2);
      const priority = state.getFiberRef(currentSchedulingPriority2);
      const commitResult = tryCommitSync(fiberId3, self2, env2, scheduler2, priority);
      switch (commitResult._tag) {
        case OP_DONE5: {
          onDone3(commitResult.exit);
          return commitResult.exit;
        }
        case OP_SUSPEND3: {
          const txnId = make48();
          const state2 = {
            value: running3
          };
          const effect4 = async2((k) => tryCommitAsync(fiberId3, self2, txnId, state2, env2, scheduler2, priority, k));
          return uninterruptibleMask3((restore) => pipe(restore(effect4), catchAllCause3((cause3) => {
            let currentState = state2.value;
            if (isRunning2(currentState)) {
              state2.value = interrupted2;
            }
            currentState = state2.value;
            if (isDone6(currentState)) {
              onDone3(currentState.exit);
              return currentState.exit;
            }
            onInterrupt3();
            return failCause8(cause3);
          })));
        }
      }
    }), "unsafeAtomically");
    tryCommit = /* @__PURE__ */ __name((fiberId3, stm, state, env2, scheduler2, priority) => {
      const journal = /* @__PURE__ */ new Map();
      const tExit = new STMDriver(stm, journal, fiberId3, env2).run();
      const analysis = analyzeJournal(journal);
      if (analysis === JournalAnalysisReadWrite) {
        commitJournal(journal);
      } else if (analysis === JournalAnalysisInvalid) {
        throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
      }
      switch (tExit._tag) {
        case OP_SUCCEED3: {
          state.value = fromTExit(tExit);
          return completeTodos(succeed3(tExit.value), journal, scheduler2, priority);
        }
        case OP_FAIL5: {
          state.value = fromTExit(tExit);
          const cause3 = fail5(tExit.error);
          return completeTodos(failCause3(cause3), journal, scheduler2, priority);
        }
        case OP_DIE3: {
          state.value = fromTExit(tExit);
          const cause3 = die4(tExit.defect);
          return completeTodos(failCause3(cause3), journal, scheduler2, priority);
        }
        case OP_INTERRUPT3: {
          state.value = fromTExit(tExit);
          const cause3 = interrupt5(fiberId3);
          return completeTodos(failCause3(cause3), journal, scheduler2, priority);
        }
        case OP_RETRY2: {
          return suspend8(journal);
        }
      }
    }, "tryCommit");
    tryCommitSync = /* @__PURE__ */ __name((fiberId3, stm, env2, scheduler2, priority) => {
      const journal = /* @__PURE__ */ new Map();
      const tExit = new STMDriver(stm, journal, fiberId3, env2).run();
      const analysis = analyzeJournal(journal);
      if (analysis === JournalAnalysisReadWrite && isSuccess4(tExit)) {
        commitJournal(journal);
      } else if (analysis === JournalAnalysisInvalid) {
        throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
      }
      switch (tExit._tag) {
        case OP_SUCCEED3: {
          return completeTodos(succeed3(tExit.value), journal, scheduler2, priority);
        }
        case OP_FAIL5: {
          const cause3 = fail5(tExit.error);
          return completeTodos(failCause3(cause3), journal, scheduler2, priority);
        }
        case OP_DIE3: {
          const cause3 = die4(tExit.defect);
          return completeTodos(failCause3(cause3), journal, scheduler2, priority);
        }
        case OP_INTERRUPT3: {
          const cause3 = interrupt5(fiberId3);
          return completeTodos(failCause3(cause3), journal, scheduler2, priority);
        }
        case OP_RETRY2: {
          return suspend8(journal);
        }
      }
    }, "tryCommitSync");
    tryCommitAsync = /* @__PURE__ */ __name((fiberId3, self2, txnId, state, context10, scheduler2, priority, k) => {
      if (isRunning2(state.value)) {
        const result = tryCommit(fiberId3, self2, state, context10, scheduler2, priority);
        switch (result._tag) {
          case OP_DONE5: {
            completeTryCommit(result.exit, k);
            break;
          }
          case OP_SUSPEND3: {
            addTodo(txnId, result.journal, () => tryCommitAsync(fiberId3, self2, txnId, state, context10, scheduler2, priority, k));
            break;
          }
        }
      }
    }, "tryCommitAsync");
    completeTodos = /* @__PURE__ */ __name((exit5, journal, scheduler2, priority) => {
      const todos = collectTodos(journal);
      if (todos.size > 0) {
        scheduler2.scheduleTask(() => execTodos(todos), priority);
      }
      return done9(exit5);
    }, "completeTodos");
    completeTryCommit = /* @__PURE__ */ __name((exit5, k) => {
      k(exit5);
    }, "completeTryCommit");
    STMDriver = class {
      static {
        __name(this, "STMDriver");
      }
      self;
      journal;
      fiberId;
      contStack = [];
      env;
      constructor(self2, journal, fiberId3, r0) {
        this.self = self2;
        this.journal = journal;
        this.fiberId = fiberId3;
        this.env = r0;
      }
      getEnv() {
        return this.env;
      }
      pushStack(cont) {
        this.contStack.push(cont);
      }
      popStack() {
        return this.contStack.pop();
      }
      nextSuccess() {
        let current2 = this.popStack();
        while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_SUCCESS2) {
          current2 = this.popStack();
        }
        return current2;
      }
      nextFailure() {
        let current2 = this.popStack();
        while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_FAILURE2) {
          current2 = this.popStack();
        }
        return current2;
      }
      nextRetry() {
        let current2 = this.popStack();
        while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_RETRY) {
          current2 = this.popStack();
        }
        return current2;
      }
      run() {
        let curr = this.self;
        let exit5 = void 0;
        while (exit5 === void 0 && curr !== void 0) {
          try {
            const current2 = curr;
            if (current2) {
              switch (current2._op) {
                case "Tag": {
                  curr = effect3((_, __, env2) => unsafeGet3(env2, current2));
                  break;
                }
                case "Left": {
                  curr = fail14(current2.left);
                  break;
                }
                case "None": {
                  curr = fail14(new NoSuchElementException2());
                  break;
                }
                case "Right": {
                  curr = succeed14(current2.right);
                  break;
                }
                case "Some": {
                  curr = succeed14(current2.value);
                  break;
                }
                case "Commit": {
                  switch (current2.effect_instruction_i0) {
                    case OP_DIE2: {
                      exit5 = die8(internalCall(() => current2.effect_instruction_i1()));
                      break;
                    }
                    case OP_FAIL4: {
                      const cont = this.nextFailure();
                      if (cont === void 0) {
                        exit5 = fail13(internalCall(() => current2.effect_instruction_i1()));
                      } else {
                        curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current2.effect_instruction_i1())));
                      }
                      break;
                    }
                    case OP_RETRY: {
                      const cont = this.nextRetry();
                      if (cont === void 0) {
                        exit5 = retry4;
                      } else {
                        curr = internalCall(() => cont.effect_instruction_i2());
                      }
                      break;
                    }
                    case OP_INTERRUPT2: {
                      exit5 = interrupt8(this.fiberId);
                      break;
                    }
                    case OP_WITH_STM_RUNTIME: {
                      curr = internalCall(() => current2.effect_instruction_i1(this));
                      break;
                    }
                    case OP_ON_SUCCESS2:
                    case OP_ON_FAILURE2:
                    case OP_ON_RETRY: {
                      this.pushStack(current2);
                      curr = current2.effect_instruction_i1;
                      break;
                    }
                    case OP_PROVIDE3: {
                      const env2 = this.env;
                      this.env = internalCall(() => current2.effect_instruction_i2(env2));
                      curr = pipe(current2.effect_instruction_i1, ensuring6(sync9(() => this.env = env2)));
                      break;
                    }
                    case OP_SUCCEED2: {
                      const value3 = current2.effect_instruction_i1;
                      const cont = this.nextSuccess();
                      if (cont === void 0) {
                        exit5 = succeed13(value3);
                      } else {
                        curr = internalCall(() => cont.effect_instruction_i2(value3));
                      }
                      break;
                    }
                    case OP_SYNC2: {
                      const value3 = internalCall(() => current2.effect_instruction_i1());
                      const cont = this.nextSuccess();
                      if (cont === void 0) {
                        exit5 = succeed13(value3);
                      } else {
                        curr = internalCall(() => cont.effect_instruction_i2(value3));
                      }
                      break;
                    }
                  }
                  break;
                }
              }
            }
          } catch (e) {
            curr = die9(e);
          }
        }
        return exit5;
      }
    };
    catchAll6 = /* @__PURE__ */ dual(2, (self2, f) => {
      const stm = new STMPrimitive(OP_ON_FAILURE2);
      stm.effect_instruction_i1 = self2;
      stm.effect_instruction_i2 = f;
      return stm;
    });
    die9 = /* @__PURE__ */ __name((defect) => dieSync5(() => defect), "die");
    dieSync5 = /* @__PURE__ */ __name((evaluate3) => {
      const stm = new STMPrimitive(OP_DIE2);
      stm.effect_instruction_i1 = evaluate3;
      return stm;
    }, "dieSync");
    effect3 = /* @__PURE__ */ __name((f) => withSTMRuntime((_) => succeed14(f(_.journal, _.fiberId, _.getEnv()))), "effect");
    ensuring6 = /* @__PURE__ */ dual(2, (self2, finalizer3) => matchSTM(self2, {
      onFailure: /* @__PURE__ */ __name((e) => zipRight9(finalizer3, fail14(e)), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((a) => zipRight9(finalizer3, succeed14(a)), "onSuccess")
    }));
    fail14 = /* @__PURE__ */ __name((error50) => failSync6(() => error50), "fail");
    failSync6 = /* @__PURE__ */ __name((evaluate3) => {
      const stm = new STMPrimitive(OP_FAIL4);
      stm.effect_instruction_i1 = evaluate3;
      return stm;
    }, "failSync");
    flatMap15 = /* @__PURE__ */ dual(2, (self2, f) => {
      const stm = new STMPrimitive(OP_ON_SUCCESS2);
      stm.effect_instruction_i1 = self2;
      stm.effect_instruction_i2 = f;
      return stm;
    });
    matchSTM = /* @__PURE__ */ dual(2, (self2, {
      onFailure,
      onSuccess
    }) => pipe(self2, map23(right2), catchAll6((e) => pipe(onFailure(e), map23(left2))), flatMap15((either8) => {
      switch (either8._tag) {
        case "Left": {
          return succeed14(either8.left);
        }
        case "Right": {
          return onSuccess(either8.right);
        }
      }
    })));
    withSTMRuntime = /* @__PURE__ */ __name((f) => {
      const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
      stm.effect_instruction_i1 = f;
      return stm;
    }, "withSTMRuntime");
    interruptAs2 = /* @__PURE__ */ __name((fiberId3) => {
      const stm = new STMPrimitive(OP_INTERRUPT2);
      stm.effect_instruction_i1 = fiberId3;
      return stm;
    }, "interruptAs");
    map23 = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, flatMap15((a) => sync9(() => f(a)))));
    retry5 = /* @__PURE__ */ new STMPrimitive(OP_RETRY);
    succeed14 = /* @__PURE__ */ __name((value3) => {
      const stm = new STMPrimitive(OP_SUCCEED2);
      stm.effect_instruction_i1 = value3;
      return stm;
    }, "succeed");
    sync9 = /* @__PURE__ */ __name((evaluate3) => {
      const stm = new STMPrimitive(OP_SYNC2);
      stm.effect_instruction_i1 = evaluate3;
      return stm;
    }, "sync");
    zipRight9 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, flatMap15(() => that)));
    zipWith11 = /* @__PURE__ */ dual(3, (self2, that, f) => pipe(self2, flatMap15((a) => pipe(that, map23((b) => f(a, b))))));
  }
});

// node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
var OP_BACKPRESSURE_STRATEGY, OP_DROPPING_STRATEGY, OP_SLIDING_STRATEGY;
var init_strategy = __esm({
  "node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_BACKPRESSURE_STRATEGY = "BackPressure";
    OP_DROPPING_STRATEGY = "Dropping";
    OP_SLIDING_STRATEGY = "Sliding";
  }
});

// node_modules/effect/dist/esm/internal/stm/stm.js
var as9, flatten13, forEach11, all7, suspend9, tap6, void_7;
var init_stm2 = __esm({
  "node_modules/effect/dist/esm/internal/stm/stm.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Function();
    init_Predicate();
    init_core2();
    as9 = /* @__PURE__ */ dual(2, (self2, value3) => pipe(self2, map23(() => value3)));
    flatten13 = /* @__PURE__ */ __name((self2) => flatMap15(self2, identity), "flatten");
    forEach11 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (iterable, f, options) => {
      if (options?.discard) {
        return pipe(sync9(() => iterable[Symbol.iterator]()), flatMap15((iterator2) => {
          const loop3 = suspend9(() => {
            const next4 = iterator2.next();
            if (next4.done) {
              return void_7;
            }
            return pipe(f(next4.value), flatMap15(() => loop3));
          });
          return loop3;
        }));
      }
      return suspend9(() => fromIterable2(iterable).reduce((acc, curr) => zipWith11(acc, f(curr), (array7, elem) => {
        array7.push(elem);
        return array7;
      }), succeed14([])));
    });
    all7 = /* @__PURE__ */ __name((input, options) => {
      if (Symbol.iterator in input) {
        return forEach11(input, identity, options);
      } else if (options?.discard) {
        return forEach11(Object.values(input), identity, options);
      }
      return map23(forEach11(Object.entries(input), ([_, e]) => map23(e, (a) => [_, a])), (values4) => {
        const res = {};
        for (const [k, v] of values4) {
          ;
          res[k] = v;
        }
        return res;
      });
    }, "all");
    suspend9 = /* @__PURE__ */ __name((evaluate3) => flatten13(sync9(evaluate3)), "suspend");
    tap6 = /* @__PURE__ */ dual(2, (self2, f) => flatMap15(self2, (a) => as9(f(a), a)));
    void_7 = /* @__PURE__ */ succeed14(void 0);
  }
});

// node_modules/effect/dist/esm/internal/stm/tRef.js
var TRefSymbolKey, TRefTypeId, tRefVariance, TRefImpl, make49, get16, set7, getOrMakeEntry, unsafeGet9, unsafeSet2;
var init_tRef = __esm({
  "node_modules/effect/dist/esm/internal/stm/tRef.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_Pipeable();
    init_core2();
    init_entry();
    init_versioned();
    TRefSymbolKey = "effect/TRef";
    TRefTypeId = /* @__PURE__ */ Symbol.for(TRefSymbolKey);
    tRefVariance = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    TRefImpl = class {
      static {
        __name(this, "TRefImpl");
      }
      [TRefTypeId] = tRefVariance;
      /** @internal */
      todos;
      /** @internal */
      versioned;
      constructor(value3) {
        this.versioned = new Versioned(value3);
        this.todos = /* @__PURE__ */ new Map();
      }
      modify(f) {
        return effect3((journal) => {
          const entry = getOrMakeEntry(this, journal);
          const [retValue, newValue] = f(unsafeGet8(entry));
          unsafeSet(entry, newValue);
          return retValue;
        });
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    make49 = /* @__PURE__ */ __name((value3) => effect3((journal) => {
      const ref2 = new TRefImpl(value3);
      journal.set(ref2, make47(ref2, true));
      return ref2;
    }), "make");
    get16 = /* @__PURE__ */ __name((self2) => self2.modify((a) => [a, a]), "get");
    set7 = /* @__PURE__ */ dual(2, (self2, value3) => self2.modify(() => [void 0, value3]));
    getOrMakeEntry = /* @__PURE__ */ __name((self2, journal) => {
      if (journal.has(self2)) {
        return journal.get(self2);
      }
      const entry = make47(self2, false);
      journal.set(self2, entry);
      return entry;
    }, "getOrMakeEntry");
    unsafeGet9 = /* @__PURE__ */ dual(2, (self2, journal) => unsafeGet8(getOrMakeEntry(self2, journal)));
    unsafeSet2 = /* @__PURE__ */ dual(3, (self2, value3, journal) => {
      const entry = getOrMakeEntry(self2, journal);
      unsafeSet(entry, value3);
      return void 0;
    });
  }
});

// node_modules/effect/dist/esm/internal/stm/tQueue.js
var TEnqueueSymbolKey, TEnqueueTypeId, TDequeueSymbolKey, TDequeueTypeId, tDequeueVariance, tEnqueueVariance, TQueueImpl, isShutdown4, shutdown5, take4;
var init_tQueue = __esm({
  "node_modules/effect/dist/esm/internal/stm/tQueue.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Chunk();
    init_Function();
    init_Option();
    init_core2();
    init_strategy();
    init_stm2();
    init_tRef();
    TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
    TEnqueueTypeId = /* @__PURE__ */ Symbol.for(TEnqueueSymbolKey);
    TDequeueSymbolKey = "effect/TQueue/TDequeue";
    TDequeueTypeId = /* @__PURE__ */ Symbol.for(TDequeueSymbolKey);
    tDequeueVariance = {
      /* c8 ignore next */
      _Out: /* @__PURE__ */ __name((_) => _, "_Out")
    };
    tEnqueueVariance = {
      /* c8 ignore next */
      _In: /* @__PURE__ */ __name((_) => _, "_In")
    };
    TQueueImpl = class {
      static {
        __name(this, "TQueueImpl");
      }
      ref;
      requestedCapacity;
      strategy;
      [TDequeueTypeId] = tDequeueVariance;
      [TEnqueueTypeId] = tEnqueueVariance;
      constructor(ref2, requestedCapacity, strategy) {
        this.ref = ref2;
        this.requestedCapacity = requestedCapacity;
        this.strategy = strategy;
      }
      capacity() {
        return this.requestedCapacity;
      }
      size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
        const queue = unsafeGet9(this.ref, runtime5.journal);
        if (queue === void 0) {
          return interruptAs2(runtime5.fiberId);
        }
        return succeed14(queue.length);
      });
      isFull = /* @__PURE__ */ map23(this.size, (size15) => size15 === this.requestedCapacity);
      isEmpty = /* @__PURE__ */ map23(this.size, (size15) => size15 === 0);
      shutdown = /* @__PURE__ */ withSTMRuntime((runtime5) => {
        unsafeSet2(this.ref, void 0, runtime5.journal);
        return void_7;
      });
      isShutdown = /* @__PURE__ */ effect3((journal) => {
        const queue = unsafeGet9(this.ref, journal);
        return queue === void 0;
      });
      awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown7) => isShutdown7 ? void_7 : retry5);
      offer(value3) {
        return withSTMRuntime((runtime5) => {
          const queue = pipe(this.ref, unsafeGet9(runtime5.journal));
          if (queue === void 0) {
            return interruptAs2(runtime5.fiberId);
          }
          if (queue.length < this.requestedCapacity) {
            queue.push(value3);
            unsafeSet2(this.ref, queue, runtime5.journal);
            return succeed14(true);
          }
          switch (this.strategy._tag) {
            case OP_BACKPRESSURE_STRATEGY: {
              return retry5;
            }
            case OP_DROPPING_STRATEGY: {
              return succeed14(false);
            }
            case OP_SLIDING_STRATEGY: {
              if (queue.length === 0) {
                return succeed14(true);
              }
              queue.shift();
              queue.push(value3);
              unsafeSet2(this.ref, queue, runtime5.journal);
              return succeed14(true);
            }
          }
        });
      }
      offerAll(iterable) {
        return withSTMRuntime((runtime5) => {
          const as12 = Array.from(iterable);
          const queue = unsafeGet9(this.ref, runtime5.journal);
          if (queue === void 0) {
            return interruptAs2(runtime5.fiberId);
          }
          if (queue.length + as12.length <= this.requestedCapacity) {
            unsafeSet2(this.ref, [...queue, ...as12], runtime5.journal);
            return succeed14(true);
          }
          switch (this.strategy._tag) {
            case OP_BACKPRESSURE_STRATEGY: {
              return retry5;
            }
            case OP_DROPPING_STRATEGY: {
              const forQueue = as12.slice(0, this.requestedCapacity - queue.length);
              unsafeSet2(this.ref, [...queue, ...forQueue], runtime5.journal);
              return succeed14(false);
            }
            case OP_SLIDING_STRATEGY: {
              const forQueue = as12.slice(0, this.requestedCapacity - queue.length);
              const toDrop = queue.length + forQueue.length - this.requestedCapacity;
              const newQueue = queue.slice(toDrop);
              unsafeSet2(this.ref, [...newQueue, ...forQueue], runtime5.journal);
              return succeed14(true);
            }
          }
        });
      }
      peek = /* @__PURE__ */ withSTMRuntime((runtime5) => {
        const queue = unsafeGet9(this.ref, runtime5.journal);
        if (queue === void 0) {
          return interruptAs2(runtime5.fiberId);
        }
        if (queue.length === 0) {
          return retry5;
        }
        return succeed14(queue[0]);
      });
      peekOption = /* @__PURE__ */ withSTMRuntime((runtime5) => {
        const queue = unsafeGet9(this.ref, runtime5.journal);
        if (queue === void 0) {
          return interruptAs2(runtime5.fiberId);
        }
        return succeed14(fromNullable(queue[0]));
      });
      take = /* @__PURE__ */ withSTMRuntime((runtime5) => {
        const queue = unsafeGet9(this.ref, runtime5.journal);
        if (queue === void 0) {
          return interruptAs2(runtime5.fiberId);
        }
        if (queue.length === 0) {
          return retry5;
        }
        const dequeued = queue.shift();
        unsafeSet2(this.ref, queue, runtime5.journal);
        return succeed14(dequeued);
      });
      takeAll = /* @__PURE__ */ withSTMRuntime((runtime5) => {
        const queue = unsafeGet9(this.ref, runtime5.journal);
        if (queue === void 0) {
          return interruptAs2(runtime5.fiberId);
        }
        unsafeSet2(this.ref, [], runtime5.journal);
        return succeed14(queue);
      });
      takeUpTo(max6) {
        return withSTMRuntime((runtime5) => {
          const queue = unsafeGet9(this.ref, runtime5.journal);
          if (queue === void 0) {
            return interruptAs2(runtime5.fiberId);
          }
          const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max6);
          unsafeSet2(this.ref, Array.from(remaining), runtime5.journal);
          return succeed14(Array.from(toTake));
        });
      }
    };
    isShutdown4 = /* @__PURE__ */ __name((self2) => self2.isShutdown, "isShutdown");
    shutdown5 = /* @__PURE__ */ __name((self2) => self2.shutdown, "shutdown");
    take4 = /* @__PURE__ */ __name((self2) => self2.take, "take");
  }
});

// node_modules/effect/dist/esm/internal/stm/tPubSub.js
var TPubSubSymbolKey, TPubSubTypeId, AbsentValue2, makeNode2, TPubSubImpl, TPubSubSubscriptionImpl, makeSubscription2, subscribe3, subscribeScoped;
var init_tPubSub = __esm({
  "node_modules/effect/dist/esm/internal/stm/tPubSub.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Effect();
    init_Function();
    init_HashSet();
    init_Option();
    init_core2();
    init_strategy();
    init_stm2();
    init_tQueue();
    init_tRef();
    TPubSubSymbolKey = "effect/TPubSub";
    TPubSubTypeId = /* @__PURE__ */ Symbol.for(TPubSubSymbolKey);
    AbsentValue2 = /* @__PURE__ */ Symbol.for("effect/TPubSub/AbsentValue");
    makeNode2 = /* @__PURE__ */ __name((head7, subscribers, tail) => ({
      head: head7,
      subscribers,
      tail
    }), "makeNode");
    TPubSubImpl = class {
      static {
        __name(this, "TPubSubImpl");
      }
      pubsubSize;
      publisherHead;
      publisherTail;
      requestedCapacity;
      strategy;
      subscriberCount;
      subscribers;
      [TPubSubTypeId] = {
        _A: /* @__PURE__ */ __name((_) => _, "_A")
      };
      [TEnqueueTypeId] = tEnqueueVariance;
      constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
        this.pubsubSize = pubsubSize;
        this.publisherHead = publisherHead;
        this.publisherTail = publisherTail;
        this.requestedCapacity = requestedCapacity;
        this.strategy = strategy;
        this.subscriberCount = subscriberCount;
        this.subscribers = subscribers;
      }
      isShutdown = /* @__PURE__ */ effect3((journal) => {
        const currentPublisherTail = unsafeGet9(this.publisherTail, journal);
        return currentPublisherTail === void 0;
      });
      awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown7) => isShutdown7 ? void_7 : retry5);
      capacity() {
        return this.requestedCapacity;
      }
      size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
        const currentPublisherTail = unsafeGet9(this.publisherTail, runtime5.journal);
        if (currentPublisherTail === void 0) {
          return interruptAs2(runtime5.fiberId);
        }
        return succeed14(unsafeGet9(this.pubsubSize, runtime5.journal));
      });
      isEmpty = /* @__PURE__ */ map23(this.size, (size15) => size15 === 0);
      isFull = /* @__PURE__ */ map23(this.size, (size15) => size15 === this.capacity());
      offer(value3) {
        return withSTMRuntime((runtime5) => {
          const currentPublisherTail = unsafeGet9(this.publisherTail, runtime5.journal);
          if (currentPublisherTail === void 0) {
            return interruptAs2(runtime5.fiberId);
          }
          const currentSubscriberCount = unsafeGet9(this.subscriberCount, runtime5.journal);
          if (currentSubscriberCount === 0) {
            return succeed14(true);
          }
          const currentPubSubSize = unsafeGet9(this.pubsubSize, runtime5.journal);
          if (currentPubSubSize < this.requestedCapacity) {
            const updatedPublisherTail = new TRefImpl(void 0);
            const updatedNode = makeNode2(value3, currentSubscriberCount, updatedPublisherTail);
            unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
            unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
            unsafeSet2(this.pubsubSize, currentPubSubSize + 1, runtime5.journal);
            return succeed14(true);
          }
          switch (this.strategy._tag) {
            case OP_BACKPRESSURE_STRATEGY: {
              return retry5;
            }
            case OP_DROPPING_STRATEGY: {
              return succeed14(false);
            }
            case OP_SLIDING_STRATEGY: {
              if (this.requestedCapacity > 0) {
                let currentPublisherHead = unsafeGet9(this.publisherHead, runtime5.journal);
                let loop3 = true;
                while (loop3) {
                  const node = unsafeGet9(currentPublisherHead, runtime5.journal);
                  if (node === void 0) {
                    return retry5;
                  }
                  const head7 = node.head;
                  const tail = node.tail;
                  if (head7 !== AbsentValue2) {
                    const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                    unsafeSet2(currentPublisherHead, updatedNode2, runtime5.journal);
                    unsafeSet2(this.publisherHead, tail, runtime5.journal);
                    loop3 = false;
                  } else {
                    currentPublisherHead = tail;
                  }
                }
              }
              const updatedPublisherTail = new TRefImpl(void 0);
              const updatedNode = makeNode2(value3, currentSubscriberCount, updatedPublisherTail);
              unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
              unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
              return succeed14(true);
            }
          }
        });
      }
      offerAll(iterable) {
        return map23(forEach11(iterable, (a) => this.offer(a)), every(identity));
      }
      shutdown = /* @__PURE__ */ effect3((journal) => {
        const currentPublisherTail = unsafeGet9(this.publisherTail, journal);
        if (currentPublisherTail !== void 0) {
          unsafeSet2(this.publisherTail, void 0, journal);
          const currentSubscribers = unsafeGet9(this.subscribers, journal);
          forEach3(currentSubscribers, (subscriber) => {
            unsafeSet2(subscriber, void 0, journal);
          });
          unsafeSet2(this.subscribers, empty8(), journal);
        }
      });
    };
    TPubSubSubscriptionImpl = class {
      static {
        __name(this, "TPubSubSubscriptionImpl");
      }
      pubsubSize;
      publisherHead;
      requestedCapacity;
      subscriberHead;
      subscriberCount;
      subscribers;
      [TPubSubTypeId] = TPubSubTypeId;
      [TDequeueTypeId] = tDequeueVariance;
      constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
        this.pubsubSize = pubsubSize;
        this.publisherHead = publisherHead;
        this.requestedCapacity = requestedCapacity;
        this.subscriberHead = subscriberHead;
        this.subscriberCount = subscriberCount;
        this.subscribers = subscribers;
      }
      isShutdown = /* @__PURE__ */ effect3((journal) => {
        const currentSubscriberHead = unsafeGet9(this.subscriberHead, journal);
        return currentSubscriberHead === void 0;
      });
      awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown7) => isShutdown7 ? void_7 : retry5);
      capacity() {
        return this.requestedCapacity;
      }
      size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
        let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime5.journal);
        if (currentSubscriberHead === void 0) {
          return interruptAs2(runtime5.fiberId);
        }
        let loop3 = true;
        let size15 = 0;
        while (loop3) {
          const node = unsafeGet9(currentSubscriberHead, runtime5.journal);
          if (node === void 0) {
            loop3 = false;
          } else {
            const head7 = node.head;
            const tail = node.tail;
            if (head7 !== AbsentValue2) {
              size15 = size15 + 1;
              if (size15 >= Number.MAX_SAFE_INTEGER) {
                loop3 = false;
              }
            }
            currentSubscriberHead = tail;
          }
        }
        return succeed14(size15);
      });
      isEmpty = /* @__PURE__ */ map23(this.size, (size15) => size15 === 0);
      isFull = /* @__PURE__ */ map23(this.size, (size15) => size15 === this.capacity());
      peek = /* @__PURE__ */ withSTMRuntime((runtime5) => {
        let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime5.journal);
        if (currentSubscriberHead === void 0) {
          return interruptAs2(runtime5.fiberId);
        }
        let value3 = AbsentValue2;
        let loop3 = true;
        while (loop3) {
          const node = unsafeGet9(currentSubscriberHead, runtime5.journal);
          if (node === void 0) {
            return retry5;
          }
          const head7 = node.head;
          const tail = node.tail;
          if (head7 !== AbsentValue2) {
            value3 = head7;
            loop3 = false;
          } else {
            currentSubscriberHead = tail;
          }
        }
        return succeed14(value3);
      });
      peekOption = /* @__PURE__ */ withSTMRuntime((runtime5) => {
        let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime5.journal);
        if (currentSubscriberHead === void 0) {
          return interruptAs2(runtime5.fiberId);
        }
        let value3 = none2();
        let loop3 = true;
        while (loop3) {
          const node = unsafeGet9(currentSubscriberHead, runtime5.journal);
          if (node === void 0) {
            value3 = none2();
            loop3 = false;
          } else {
            const head7 = node.head;
            const tail = node.tail;
            if (head7 !== AbsentValue2) {
              value3 = some2(head7);
              loop3 = false;
            } else {
              currentSubscriberHead = tail;
            }
          }
        }
        return succeed14(value3);
      });
      shutdown = /* @__PURE__ */ effect3((journal) => {
        let currentSubscriberHead = unsafeGet9(this.subscriberHead, journal);
        if (currentSubscriberHead !== void 0) {
          unsafeSet2(this.subscriberHead, void 0, journal);
          let loop3 = true;
          while (loop3) {
            const node = unsafeGet9(currentSubscriberHead, journal);
            if (node === void 0) {
              loop3 = false;
            } else {
              const head7 = node.head;
              const tail = node.tail;
              if (head7 !== AbsentValue2) {
                const subscribers = node.subscribers;
                if (subscribers === 1) {
                  const size15 = unsafeGet9(this.pubsubSize, journal);
                  const updatedNode = makeNode2(AbsentValue2, 0, tail);
                  unsafeSet2(currentSubscriberHead, updatedNode, journal);
                  unsafeSet2(this.publisherHead, tail, journal);
                  unsafeSet2(this.pubsubSize, size15 - 1, journal);
                } else {
                  const updatedNode = makeNode2(head7, subscribers - 1, tail);
                  unsafeSet2(currentSubscriberHead, updatedNode, journal);
                }
              }
              currentSubscriberHead = tail;
            }
          }
          const currentSubscriberCount = unsafeGet9(this.subscriberCount, journal);
          unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
          unsafeSet2(this.subscribers, remove4(unsafeGet9(this.subscribers, journal), this.subscriberHead), journal);
        }
      });
      take = /* @__PURE__ */ withSTMRuntime((runtime5) => {
        let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime5.journal);
        if (currentSubscriberHead === void 0) {
          return interruptAs2(runtime5.fiberId);
        }
        let value3 = AbsentValue2;
        let loop3 = true;
        while (loop3) {
          const node = unsafeGet9(currentSubscriberHead, runtime5.journal);
          if (node === void 0) {
            return retry5;
          }
          const head7 = node.head;
          const tail = node.tail;
          if (head7 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size15 = unsafeGet9(this.pubsubSize, runtime5.journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
              unsafeSet2(this.publisherHead, tail, runtime5.journal);
              unsafeSet2(this.pubsubSize, size15 - 1, runtime5.journal);
            } else {
              const updatedNode = makeNode2(head7, subscribers - 1, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
            }
            unsafeSet2(this.subscriberHead, tail, runtime5.journal);
            value3 = head7;
            loop3 = false;
          } else {
            currentSubscriberHead = tail;
          }
        }
        return succeed14(value3);
      });
      takeAll = /* @__PURE__ */ this.takeUpTo(Number.POSITIVE_INFINITY);
      takeUpTo(max6) {
        return withSTMRuntime((runtime5) => {
          let currentSubscriberHead = unsafeGet9(this.subscriberHead, runtime5.journal);
          if (currentSubscriberHead === void 0) {
            return interruptAs2(runtime5.fiberId);
          }
          const builder = [];
          let n = 0;
          while (n !== max6) {
            const node = unsafeGet9(currentSubscriberHead, runtime5.journal);
            if (node === void 0) {
              n = max6;
            } else {
              const head7 = node.head;
              const tail = node.tail;
              if (head7 !== AbsentValue2) {
                const subscribers = node.subscribers;
                if (subscribers === 1) {
                  const size15 = unsafeGet9(this.pubsubSize, runtime5.journal);
                  const updatedNode = makeNode2(AbsentValue2, 0, tail);
                  unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
                  unsafeSet2(this.publisherHead, tail, runtime5.journal);
                  unsafeSet2(this.pubsubSize, size15 - 1, runtime5.journal);
                } else {
                  const updatedNode = makeNode2(head7, subscribers - 1, tail);
                  unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
                }
                builder.push(head7);
                n = n + 1;
              }
              currentSubscriberHead = tail;
            }
          }
          unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime5.journal);
          return succeed14(builder);
        });
      }
    };
    makeSubscription2 = /* @__PURE__ */ __name((pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => pipe(get16(publisherTail), flatMap15((currentPublisherTail) => pipe(all7([make49(currentPublisherTail), get16(subscriberCount), get16(subscribers)]), tap6(([_, currentSubscriberCount]) => pipe(subscriberCount, set7(currentSubscriberCount + 1))), tap6(([subscriberHead, _, currentSubscribers]) => pipe(subscribers, set7(pipe(currentSubscribers, add4(subscriberHead))))), map23(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers))))), "makeSubscription");
    subscribe3 = /* @__PURE__ */ __name((self2) => makeSubscription2(self2.pubsubSize, self2.publisherHead, self2.publisherTail, self2.requestedCapacity, self2.subscriberCount, self2.subscribers), "subscribe");
    subscribeScoped = /* @__PURE__ */ __name((self2) => acquireRelease2(subscribe3(self2), (dequeue) => shutdown5(dequeue)), "subscribeScoped");
  }
});

// node_modules/effect/dist/esm/TPubSub.js
var subscribeScoped2;
var init_TPubSub = __esm({
  "node_modules/effect/dist/esm/TPubSub.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tPubSub();
    subscribeScoped2 = subscribeScoped;
  }
});

// node_modules/effect/dist/esm/TQueue.js
var isShutdown6, take5;
var init_TQueue = __esm({
  "node_modules/effect/dist/esm/TQueue.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tQueue();
    isShutdown6 = isShutdown4;
    take5 = take4;
  }
});

// node_modules/effect/dist/esm/internal/ringBuffer.js
var RingBuffer;
var init_ringBuffer = __esm({
  "node_modules/effect/dist/esm/internal/ringBuffer.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Chunk();
    init_Function();
    init_Option();
    RingBuffer = class {
      static {
        __name(this, "RingBuffer");
      }
      capacity;
      array;
      size = 0;
      current = 0;
      constructor(capacity7) {
        this.capacity = capacity7;
        this.array = Array.from({
          length: capacity7
        }, constUndefined);
      }
      head() {
        return fromNullable(this.array[this.current]);
      }
      lastOrNull() {
        if (this.size === 0) {
          return void 0;
        }
        const index2 = this.current === 0 ? this.array.length - 1 : this.current - 1;
        return this.array[index2] ?? void 0;
      }
      put(value3) {
        this.array[this.current] = value3;
        this.increment();
      }
      dropLast() {
        if (this.size > 0) {
          this.decrement();
          this.array[this.current] = void 0;
        }
      }
      toChunk() {
        const begin = this.current - this.size;
        const newArray = begin < 0 ? [...this.array.slice(this.capacity + begin, this.capacity), ...this.array.slice(0, this.current)] : this.array.slice(begin, this.current);
        return fromIterable3(newArray);
      }
      increment() {
        if (this.size < this.capacity) {
          this.size += 1;
        }
        this.current = (this.current + 1) % this.capacity;
      }
      decrement() {
        this.size -= 1;
        if (this.current > 0) {
          this.current -= 1;
        } else {
          this.current = this.capacity - 1;
        }
      }
    };
  }
});

// node_modules/effect/dist/esm/internal/stream/debounceState.js
var OP_NOT_STARTED, OP_PREVIOUS, OP_CURRENT, notStarted, previous, current;
var init_debounceState = __esm({
  "node_modules/effect/dist/esm/internal/stream/debounceState.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_NOT_STARTED = "NotStarted";
    OP_PREVIOUS = "Previous";
    OP_CURRENT = "Current";
    notStarted = {
      _tag: OP_NOT_STARTED
    };
    previous = /* @__PURE__ */ __name((fiber) => ({
      _tag: OP_PREVIOUS,
      fiber
    }), "previous");
    current = /* @__PURE__ */ __name((fiber) => ({
      _tag: OP_CURRENT,
      fiber
    }), "current");
  }
});

// node_modules/effect/dist/esm/internal/stream/emit.js
var make50, makePush;
var init_emit = __esm({
  "node_modules/effect/dist/esm/internal/stream/emit.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Cause();
    init_Chunk();
    init_Effect();
    init_Exit();
    init_Function();
    init_Option();
    make50 = /* @__PURE__ */ __name((emit3) => {
      const ops = {
        chunk(as12) {
          return this(succeed9(as12));
        },
        die(defect) {
          return this(die6(defect));
        },
        dieMessage(message) {
          return this(dieMessage2(message));
        },
        done(exit5) {
          return this(suspend4(() => mapBoth3(exit5, {
            onFailure: some2,
            onSuccess: of2
          })));
        },
        end() {
          return this(fail9(none2()));
        },
        fail(e) {
          return this(fail9(some2(e)));
        },
        fromEffect(effect4) {
          return this(mapBoth5(effect4, {
            onFailure: some2,
            onSuccess: of2
          }));
        },
        fromEffectChunk(effect4) {
          return this(pipe(effect4, mapError3(some2)));
        },
        halt(cause3) {
          return this(failCause8(pipe(cause3, map14(some2))));
        },
        single(value3) {
          return this(succeed9(of2(value3)));
        }
      };
      return Object.assign(emit3, ops);
    }, "make");
    makePush = /* @__PURE__ */ __name((queue, scheduler2) => {
      let finished = false;
      let buffer3 = [];
      let running4 = false;
      function array7(items) {
        if (finished) return false;
        if (items.length <= 5e4) {
          buffer3.push.apply(buffer3, items);
        } else {
          for (let i = 0; i < items.length; i++) {
            buffer3.push(items[0]);
          }
        }
        if (!running4) {
          running4 = true;
          scheduler2.scheduleTask(flush, 0);
        }
        return true;
      }
      __name(array7, "array");
      function flush() {
        running4 = false;
        if (buffer3.length > 0) {
          queue.unsafeOffer(buffer3);
          buffer3 = [];
        }
      }
      __name(flush, "flush");
      function done13(exit5) {
        if (finished) return;
        finished = true;
        if (exit5._tag === "Success") {
          buffer3.push(exit5.value);
        }
        flush();
        queue.unsafeOffer(exit5._tag === "Success" ? void_3 : exit5);
      }
      __name(done13, "done");
      return {
        single(value3) {
          if (finished) return false;
          buffer3.push(value3);
          if (!running4) {
            running4 = true;
            scheduler2.scheduleTask(flush, 0);
          }
          return true;
        },
        array: array7,
        chunk(chunk4) {
          return array7(toReadonlyArray(chunk4));
        },
        done: done13,
        end() {
          if (finished) return;
          finished = true;
          flush();
          queue.unsafeOffer(void_3);
        },
        halt(cause3) {
          return done13(failCause3(cause3));
        },
        fail(error50) {
          return done13(fail4(error50));
        },
        die(defect) {
          return done13(die3(defect));
        },
        dieMessage(message) {
          return done13(die3(new Error(message)));
        }
      };
    }, "makePush");
  }
});

// node_modules/effect/dist/esm/internal/stream/handoff.js
var HandoffTypeId, OP_HANDOFF_STATE_EMPTY, OP_HANDOFF_STATE_FULL, handoffStateEmpty, handoffStateFull, handoffStateMatch, handoffVariance, make51, offer5, take6;
var init_handoff = __esm({
  "node_modules/effect/dist/esm/internal/stream/handoff.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Deferred();
    init_Effect();
    init_Function();
    init_Ref();
    HandoffTypeId = /* @__PURE__ */ Symbol.for("effect/Stream/Handoff");
    OP_HANDOFF_STATE_EMPTY = "Empty";
    OP_HANDOFF_STATE_FULL = "Full";
    handoffStateEmpty = /* @__PURE__ */ __name((notifyConsumer) => ({
      _tag: OP_HANDOFF_STATE_EMPTY,
      notifyConsumer
    }), "handoffStateEmpty");
    handoffStateFull = /* @__PURE__ */ __name((value3, notifyProducer) => ({
      _tag: OP_HANDOFF_STATE_FULL,
      value: value3,
      notifyProducer
    }), "handoffStateFull");
    handoffStateMatch = /* @__PURE__ */ __name((onEmpty, onFull) => {
      return (self2) => {
        switch (self2._tag) {
          case OP_HANDOFF_STATE_EMPTY: {
            return onEmpty(self2.notifyConsumer);
          }
          case OP_HANDOFF_STATE_FULL: {
            return onFull(self2.value, self2.notifyProducer);
          }
        }
      };
    }, "handoffStateMatch");
    handoffVariance = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    make51 = /* @__PURE__ */ __name(() => pipe(make19(), flatMap11((deferred) => make29(handoffStateEmpty(deferred))), map18((ref2) => ({
      [HandoffTypeId]: handoffVariance,
      ref: ref2
    }))), "make");
    offer5 = /* @__PURE__ */ dual(2, (self2, value3) => {
      return flatMap11(make19(), (deferred) => flatten10(modify4(self2.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [zipRight5(succeed2(notifyConsumer, void 0), _await(deferred)), handoffStateFull(value3, deferred)], (_, notifyProducer) => [flatMap11(_await(notifyProducer), () => pipe(self2, offer5(value3))), state])))));
    });
    take6 = /* @__PURE__ */ __name((self2) => flatMap11(make19(), (deferred) => flatten10(modify4(self2.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [flatMap11(_await(notifyConsumer), () => take6(self2)), state], (value3, notifyProducer) => [as6(succeed2(notifyProducer, void 0), value3), handoffStateEmpty(deferred)]))))), "take");
  }
});

// node_modules/effect/dist/esm/internal/stream/handoffSignal.js
var OP_EMIT4, OP_HALT, OP_END, emit2, halt, end3;
var init_handoffSignal = __esm({
  "node_modules/effect/dist/esm/internal/stream/handoffSignal.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_EMIT4 = "Emit";
    OP_HALT = "Halt";
    OP_END = "End";
    emit2 = /* @__PURE__ */ __name((elements) => ({
      _tag: OP_EMIT4,
      elements
    }), "emit");
    halt = /* @__PURE__ */ __name((cause3) => ({
      _tag: OP_HALT,
      cause: cause3
    }), "halt");
    end3 = /* @__PURE__ */ __name((reason) => ({
      _tag: OP_END,
      reason
    }), "end");
  }
});

// node_modules/effect/dist/esm/internal/take.js
var TakeSymbolKey, TakeTypeId, takeVariance, TakeImpl, chunk2, done10, end4, failCause11, fromPull, match18, of5;
var init_take = __esm({
  "node_modules/effect/dist/esm/internal/take.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Cause();
    init_Chunk();
    init_Effect();
    init_Exit();
    init_Function();
    init_Option();
    init_Pipeable();
    TakeSymbolKey = "effect/Take";
    TakeTypeId = /* @__PURE__ */ Symbol.for(TakeSymbolKey);
    takeVariance = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A"),
      /* c8 ignore next */
      _E: /* @__PURE__ */ __name((_) => _, "_E")
    };
    TakeImpl = class {
      static {
        __name(this, "TakeImpl");
      }
      exit;
      [TakeTypeId] = takeVariance;
      constructor(exit5) {
        this.exit = exit5;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    chunk2 = /* @__PURE__ */ __name((chunk4) => new TakeImpl(succeed3(chunk4)), "chunk");
    done10 = /* @__PURE__ */ __name((self2) => suspend4(() => self2.exit), "done");
    end4 = /* @__PURE__ */ new TakeImpl(/* @__PURE__ */ fail4(/* @__PURE__ */ none2()));
    failCause11 = /* @__PURE__ */ __name((cause3) => new TakeImpl(failCause3(pipe(cause3, map14(some2)))), "failCause");
    fromPull = /* @__PURE__ */ __name((pull) => matchCause4(pull, {
      onFailure: /* @__PURE__ */ __name((cause3) => match2(flipCauseOption2(cause3), {
        onNone: /* @__PURE__ */ __name(() => end4, "onNone"),
        onSome: failCause11
      }), "onFailure"),
      onSuccess: chunk2
    }), "fromPull");
    match18 = /* @__PURE__ */ dual(2, (self2, {
      onEnd: onEnd3,
      onFailure,
      onSuccess
    }) => match6(self2.exit, {
      onFailure: /* @__PURE__ */ __name((cause3) => match2(flipCauseOption2(cause3), {
        onNone: onEnd3,
        onSome: onFailure
      }), "onFailure"),
      onSuccess
    }));
    of5 = /* @__PURE__ */ __name((value3) => new TakeImpl(succeed3(of2(value3))), "of");
  }
});

// node_modules/effect/dist/esm/internal/stream/pull.js
var end5, failCause12;
var init_pull = __esm({
  "node_modules/effect/dist/esm/internal/stream/pull.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Effect();
    init_Option();
    end5 = /* @__PURE__ */ __name(() => fail9(none2()), "end");
    failCause12 = /* @__PURE__ */ __name((cause3) => mapError3(failCause8(cause3), some2), "failCause");
  }
});

// node_modules/effect/dist/esm/internal/stream/sinkEndReason.js
var OP_SCHEDULE_END, OP_UPSTREAM_END, ScheduleEnd, UpstreamEnd;
var init_sinkEndReason = __esm({
  "node_modules/effect/dist/esm/internal/stream/sinkEndReason.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_SCHEDULE_END = "ScheduleEnd";
    OP_UPSTREAM_END = "UpstreamEnd";
    ScheduleEnd = {
      _tag: OP_SCHEDULE_END
    };
    UpstreamEnd = {
      _tag: OP_UPSTREAM_END
    };
  }
});

// node_modules/effect/dist/esm/internal/stream/zipAllState.js
var OP_DRAIN_LEFT, OP_DRAIN_RIGHT, OP_PULL_BOTH, OP_PULL_LEFT, OP_PULL_RIGHT, DrainLeft, DrainRight, PullBoth, PullLeft, PullRight;
var init_zipAllState = __esm({
  "node_modules/effect/dist/esm/internal/stream/zipAllState.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_DRAIN_LEFT = "DrainLeft";
    OP_DRAIN_RIGHT = "DrainRight";
    OP_PULL_BOTH = "PullBoth";
    OP_PULL_LEFT = "PullLeft";
    OP_PULL_RIGHT = "PullRight";
    DrainLeft = {
      _tag: OP_DRAIN_LEFT
    };
    DrainRight = {
      _tag: OP_DRAIN_RIGHT
    };
    PullBoth = {
      _tag: OP_PULL_BOTH
    };
    PullLeft = /* @__PURE__ */ __name((rightChunk) => ({
      _tag: OP_PULL_LEFT,
      rightChunk
    }), "PullLeft");
    PullRight = /* @__PURE__ */ __name((leftChunk) => ({
      _tag: OP_PULL_RIGHT,
      leftChunk
    }), "PullRight");
  }
});

// node_modules/effect/dist/esm/internal/stream/zipChunksState.js
var OP_PULL_BOTH2, OP_PULL_LEFT2, OP_PULL_RIGHT2, PullBoth2, PullLeft2, PullRight2;
var init_zipChunksState = __esm({
  "node_modules/effect/dist/esm/internal/stream/zipChunksState.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_PULL_BOTH2 = "PullBoth";
    OP_PULL_LEFT2 = "PullLet";
    OP_PULL_RIGHT2 = "PullRight";
    PullBoth2 = {
      _tag: OP_PULL_BOTH2
    };
    PullLeft2 = /* @__PURE__ */ __name((rightChunk) => ({
      _tag: OP_PULL_LEFT2,
      rightChunk
    }), "PullLeft");
    PullRight2 = /* @__PURE__ */ __name((leftChunk) => ({
      _tag: OP_PULL_RIGHT2,
      leftChunk
    }), "PullRight");
  }
});

// node_modules/effect/dist/esm/internal/stream.js
var StreamSymbolKey, StreamTypeId2, streamVariance, StreamImpl, isStream, DefaultChunkSize, accumulate, accumulateChunks, acquireRelease3, aggregate, aggregateWithin, aggregateWithinEither, as10, queueFromBufferOptions, _async, asyncEffect3, queueFromBufferOptionsPush, asyncPush, asyncScoped, branchAfter, broadcast, broadcastDynamic, share, broadcastedQueues, broadcastedQueuesDynamic, buffer, bufferChunks, bufferChunksDropping, bufferChunksSliding, bufferDropping, bufferSliding, bufferUnbounded, bufferSignal, catchAll7, catchAllCause6, catchSome3, catchSomeCause3, catchTag3, catchTags3, changes, changesWith, changesWithEffect, chunks, chunksWith, unsome, combine9, combineChunks, concat2, concatAll2, cross, crossLeft, crossRight, crossWith, debounce, die10, dieSync6, dieMessage4, distributedWith, distributedWithDynamicId, newDistributedWithDynamicId, distributedWithDynamic, distributedWithDynamicCallback, drain3, drainFork, drop3, dropRight, dropUntil3, dropUntilEffect, dropWhile4, dropWhileEffect, either6, empty34, ensuring7, ensuringWith2, context7, contextWith3, contextWithEffect3, contextWithStream, execute, fail15, failSync7, failCause13, failCauseSync6, filter10, filterEffect, filterMap7, filterMapEffect, filterMapWhile3, filterMapWhileEffect, finalizer, find2, findEffect, flatMap16, matchConcurrency, flatMapParSwitchBuffer, flatten14, flattenChunks, flattenEffect, flattenExitOption, flattenIterables, flattenTake, forever5, fromAsyncIterable, fromChannel2, toChannel2, fromChunk, fromChunkPubSub, fromChunkQueue, fromChunks, fromEffect7, fromEffectOption, fromPubSub, fromTPubSub, fromIterable14, fromIterableEffect, fromIteratorSucceed, fromPull2, fromQueue2, fromTQueue, fromSchedule, fromReadableStream, fromReadableStreamByob, EOF, readChunkStreamByobReader, groupAdjacentBy, grouped, groupedWithin, haltWhen, haltAfter, haltWhenDeferred, identityStream, interleave, interleaveWith, intersperse, intersperseAffixes, interruptAfter, interruptWhen2, interruptWhenDeferred2, iterate3, make52, map24, mapAccum5, mapAccumEffect, mapBoth7, mapChunks, mapChunksEffect, mapConcat, mapConcatChunk, mapConcatChunkEffect, mapConcatEffect, mapEffectSequential, mapEffectPar, mapError6, mapErrorCause4, merge9, mergeAll8, mergeWithTag, mergeEither, mergeLeft, mergeRight, mergeWith3, mkString2, never4, onEnd, onError3, onDone, onStart, orDie5, orDieWith4, orElse8, orElseEither4, orElseFail3, orElseIfEmpty, orElseIfEmptyChunk, orElseIfEmptyStream, orElseSucceed3, paginate, paginateChunk, paginateChunkEffect, paginateEffect, peel, partition5, partitionEither, pipeThrough, pipeThroughChannel, pipeThroughChannelOrFail, prepend4, provideContext6, provideSomeContext2, provideLayer, provideService6, provideServiceEffect3, provideServiceStream, mapInputContext6, provideSomeLayer2, range2, race3, raceAll3, rechunk, rechunkProcess, StreamRechunker, refineOrDie, refineOrDieWith, repeat2, repeatEffect, repeatEffectChunk, repeatEffectChunkOption, repeatEffectOption, repeatEither, repeatElements, repeatElementsWith, repeatValue, repeatWith, repeatWithSchedule, repeatEffectWithSchedule, retry6, withExecutionPlan3, scheduleDefectRefail2, run4, runCollect, runCount, runDrain2, runFold, runFoldEffect, runFoldScoped, runFoldScopedEffect, runFoldWhile, runFoldWhileEffect, runFoldWhileScoped, runFoldWhileScopedEffect, runForEach, runForEachChunk, runForEachChunkScoped, runForEachScoped, runForEachWhile, runForEachWhileScoped, runHead, runIntoPubSub, runIntoPubSubScoped, runIntoQueue, runIntoQueueElementsScoped, runIntoQueueScoped, runLast, runScoped2, runSum, scan, scanReduce, scanReduceEffect, schedule2, scheduleWith, scanEffect, scoped5, scopedWith4, some5, someOrElse, someOrFail, sliding7, slidingSize, split, splitOnChunk, splitLines2, succeed15, sync10, suspend10, take7, takeRight2, takeUntil3, takeUntilEffect, takeWhile4, tap7, tapBoth3, tapError5, tapErrorCause5, tapSink, throttle, throttleEffect, throttleEnforceEffect, throttleShapeEffect, tick, timeout3, timeoutFail3, timeoutFailCause3, timeoutTo3, pubsubFromOptions, toPubSub2, toPull2, toQueue2, toQueueOfElements, toReadableStream, toReadableStreamEffect, toReadableStreamRuntime, transduce, toAsyncIterableRuntime, toAsyncIterable, toAsyncIterableEffect, unfold4, unfoldChunk, unfoldChunkEffect, unfoldEffect, void_8, unwrap2, unwrapScoped4, unwrapScopedWith3, updateService4, when3, whenCase, whenCaseEffect, whenEffect3, withSpan6, zip7, zipFlatten, zipAll, zipAllLeft, zipAllRight, zipAllSortedByKey, zipAllSortedByKeyLeft, zipAllSortedByKeyRight, zipAllSortedByKeyWith, zipAllWith, zipLatest, zipLatestAll, zipLatestWith, zipLeft7, zipRight10, zipWith12, zipWithChunks, zipWithIndex, zipWithNext, zipWithPrevious, zipWithPreviousAndNext, zipChunks, Do4, bind5, bindTo5, let_5, decodeText, encodeText, fromEventListener;
var init_stream = __esm({
  "node_modules/effect/dist/esm/internal/stream.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Cause();
    init_Chunk();
    init_Clock();
    init_Context();
    init_Deferred();
    init_Duration();
    init_Effect();
    init_Either();
    init_Equal();
    init_Exit();
    init_Fiber();
    init_FiberRef();
    init_Function();
    init_executionPlan();
    init_Layer();
    init_MergeDecision();
    init_Option();
    init_Pipeable();
    init_Predicate();
    init_PubSub();
    init_Queue();
    init_RcRef();
    init_Ref();
    init_Runtime();
    init_Schedule();
    init_StreamHaltStrategy();
    init_TPubSub();
    init_TQueue();
    init_Tuple();
    init_channel2();
    init_channelExecutor();
    init_mergeStrategy();
    init_core_stream();
    init_doNotation();
    init_ringBuffer();
    init_schedule();
    init_sink();
    init_debounceState();
    init_emit();
    init_haltStrategy();
    init_handoff();
    init_handoffSignal();
    init_pull();
    init_sinkEndReason();
    init_zipAllState();
    init_zipChunksState();
    init_take();
    init_tracer();
    StreamSymbolKey = "effect/Stream";
    StreamTypeId2 = /* @__PURE__ */ Symbol.for(StreamSymbolKey);
    streamVariance = {
      _R: /* @__PURE__ */ __name((_) => _, "_R"),
      _E: /* @__PURE__ */ __name((_) => _, "_E"),
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    StreamImpl = class {
      static {
        __name(this, "StreamImpl");
      }
      channel;
      [StreamTypeId2] = streamVariance;
      constructor(channel2) {
        this.channel = channel2;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    isStream = /* @__PURE__ */ __name((u) => hasProperty(u, StreamTypeId2) || isEffect2(u), "isStream");
    DefaultChunkSize = 4096;
    accumulate = /* @__PURE__ */ __name((self2) => chunks(accumulateChunks(self2)), "accumulate");
    accumulateChunks = /* @__PURE__ */ __name((self2) => {
      const accumulator = /* @__PURE__ */ __name((s) => readWith({
        onInput: /* @__PURE__ */ __name((input) => {
          const next4 = appendAll2(s, input);
          return flatMap13(write(next4), () => accumulator(next4));
        }, "onInput"),
        onFailure: fail11,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      }), "accumulator");
      return new StreamImpl(pipeTo(toChannel2(self2), accumulator(empty5())));
    }, "accumulateChunks");
    acquireRelease3 = /* @__PURE__ */ __name((acquire2, release2) => scoped5(acquireRelease2(acquire2, release2)), "acquireRelease");
    aggregate = /* @__PURE__ */ dual(2, (self2, sink) => aggregateWithin(self2, sink, forever4));
    aggregateWithin = /* @__PURE__ */ dual(3, (self2, sink, schedule4) => filterMap7(aggregateWithinEither(self2, sink, schedule4), (_) => match(_, {
      onLeft: none2,
      onRight: some2
    })));
    aggregateWithinEither = /* @__PURE__ */ dual(3, (self2, sink, schedule4) => {
      const layer = all6([make51(), make29(ScheduleEnd), make29(empty5()), driver2(schedule4), make29(false), make29(false)]);
      return fromEffect7(layer).pipe(flatMap16(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
        const handoffProducer = readWithCause({
          onInput: /* @__PURE__ */ __name((input) => flatMap13(fromEffect4(pipe(handoff, offer5(emit2(input)), when2(() => isNonEmpty2(input)))), () => handoffProducer), "onInput"),
          onFailure: /* @__PURE__ */ __name((cause3) => fromEffect4(offer5(handoff, halt(cause3))), "onFailure"),
          onDone: /* @__PURE__ */ __name(() => fromEffect4(offer5(handoff, end3(UpstreamEnd))), "onDone")
        });
        const handoffConsumer = pipe(getAndSet2(sinkLeftovers, empty5()), flatMap11((leftovers) => {
          if (isNonEmpty2(leftovers)) {
            return pipe(set6(consumed, true), zipRight5(succeed9(pipe(write(leftovers), flatMap13(() => handoffConsumer)))));
          }
          return pipe(take6(handoff), map18((signal) => {
            switch (signal._tag) {
              case OP_EMIT4: {
                return pipe(fromEffect4(set6(consumed, true)), zipRight6(write(signal.elements)), zipRight6(fromEffect4(get12(endAfterEmit))), flatMap13((bool) => bool ? void_6 : handoffConsumer));
              }
              case OP_HALT: {
                return failCause10(signal.cause);
              }
              case OP_END: {
                if (signal.reason._tag === OP_SCHEDULE_END) {
                  return pipe(get12(consumed), map18((bool) => bool ? fromEffect4(pipe(set6(sinkEndReason, ScheduleEnd), zipRight5(set6(endAfterEmit, true)))) : pipe(fromEffect4(pipe(set6(sinkEndReason, ScheduleEnd), zipRight5(set6(endAfterEmit, true)))), flatMap13(() => handoffConsumer))), unwrap);
                }
                return pipe(set6(sinkEndReason, signal.reason), zipRight5(set6(endAfterEmit, true)), fromEffect4);
              }
            }
          }));
        }), unwrap);
        const timeout6 = /* @__PURE__ */ __name((lastB) => scheduleDriver.next(lastB), "timeout");
        const scheduledAggregator = /* @__PURE__ */ __name((sinkFiber, scheduleFiber, scope5) => {
          const forkSink = pipe(set6(consumed, false), zipRight5(set6(endAfterEmit, false)), zipRight5(pipe(handoffConsumer, pipeToOrFail(toChannel(sink)), collectElements, run2, forkIn2(scope5))));
          const handleSide = /* @__PURE__ */ __name((leftovers, b, c) => pipe(set6(sinkLeftovers, flatten4(leftovers)), zipRight5(map18(get12(sinkEndReason), (reason) => {
            switch (reason._tag) {
              case OP_SCHEDULE_END: {
                return pipe(all6([get12(consumed), forkSink, pipe(timeout6(some2(b)), forkIn2(scope5))]), map18(([wasConsumed, sinkFiber2, scheduleFiber2]) => {
                  const toWrite = pipe(c, match2({
                    onNone: /* @__PURE__ */ __name(() => of2(right2(b)), "onNone"),
                    onSome: /* @__PURE__ */ __name((c2) => make7(right2(b), left2(c2)), "onSome")
                  }));
                  if (wasConsumed) {
                    return pipe(write(toWrite), flatMap13(() => scheduledAggregator(sinkFiber2, scheduleFiber2, scope5)));
                  }
                  return scheduledAggregator(sinkFiber2, scheduleFiber2, scope5);
                }), unwrap);
              }
              case OP_UPSTREAM_END: {
                return pipe(get12(consumed), map18((wasConsumed) => wasConsumed ? write(of2(right2(b))) : void_6), unwrap);
              }
            }
          })), unwrap), "handleSide");
          return unwrap(raceWith2(join3(sinkFiber), join3(scheduleFiber), {
            onSelfDone: /* @__PURE__ */ __name((sinkExit, _) => pipe(interrupt6(scheduleFiber), zipRight5(pipe(suspend4(() => sinkExit), map18(([leftovers, b]) => handleSide(leftovers, b, none2()))))), "onSelfDone"),
            onOtherDone: /* @__PURE__ */ __name((scheduleExit, _) => matchCauseEffect3(suspend4(() => scheduleExit), {
              onFailure: /* @__PURE__ */ __name((cause3) => match(failureOrCause2(cause3), {
                onLeft: /* @__PURE__ */ __name(() => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight5(pipe(join3(sinkFiber), map18(([leftovers, b]) => handleSide(leftovers, b, none2()))))), "onLeft"),
                onRight: /* @__PURE__ */ __name((cause4) => pipe(handoff, offer5(halt(cause4)), forkDaemon2, zipRight5(pipe(join3(sinkFiber), map18(([leftovers, b]) => handleSide(leftovers, b, none2()))))), "onRight")
              }), "onFailure"),
              onSuccess: /* @__PURE__ */ __name((c) => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight5(pipe(join3(sinkFiber), map18(([leftovers, b]) => handleSide(leftovers, b, some2(c)))))), "onSuccess")
            }), "onOtherDone")
          }));
        }, "scheduledAggregator");
        return unwrapScopedWith3((scope5) => pipeTo(toChannel2(self2), handoffProducer).pipe(run2, forkIn2(scope5), zipRight5(pipeToOrFail(handoffConsumer, toChannel(sink)).pipe(collectElements, run2, forkIn2(scope5), flatMap11((sinkFiber) => timeout6(none2()).pipe(forkIn2(scope5), map18((scheduleFiber) => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope5)))))))));
      }));
    });
    as10 = /* @__PURE__ */ dual(2, (self2, value3) => map24(self2, () => value3));
    queueFromBufferOptions = /* @__PURE__ */ __name((bufferSize) => {
      if (bufferSize === "unbounded") {
        return unbounded5();
      } else if (typeof bufferSize === "number" || bufferSize === void 0) {
        return bounded5(bufferSize ?? 16);
      }
      switch (bufferSize.strategy) {
        case "dropping":
          return dropping4(bufferSize.bufferSize ?? 16);
        case "sliding":
          return sliding4(bufferSize.bufferSize ?? 16);
        default:
          return bounded5(bufferSize.bufferSize ?? 16);
      }
    }, "queueFromBufferOptions");
    _async = /* @__PURE__ */ __name((register, bufferSize) => acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)).pipe(flatMap11((output) => runtime4().pipe(flatMap11((runtime5) => sync5(() => {
      const runPromiseExit3 = runPromiseExit2(runtime5);
      const canceler = register(make50((resume2) => fromPull(resume2).pipe(flatMap11((take10) => offer3(output, take10)), asVoid4, runPromiseExit3).then((exit5) => {
        if (isFailure(exit5)) {
          if (!isInterrupted2(exit5.cause)) {
            throw squash(exit5.cause);
          }
        }
      })));
      return canceler;
    })), map18((value3) => {
      const loop3 = take3(output).pipe(flatMap11((take10) => done10(take10)), match13({
        onFailure: /* @__PURE__ */ __name((maybeError) => fromEffect4(shutdown4(output)).pipe(zipRight6(match2(maybeError, {
          onNone: /* @__PURE__ */ __name(() => void_6, "onNone"),
          onSome: /* @__PURE__ */ __name((error50) => fail11(error50), "onSome")
        }))), "onFailure"),
        onSuccess: /* @__PURE__ */ __name((chunk4) => write(chunk4).pipe(flatMap13(() => loop3)), "onSuccess")
      }), unwrap);
      return fromChannel2(loop3).pipe(ensuring7(value3 ?? _void));
    }))), unwrapScoped4), "_async");
    asyncEffect3 = /* @__PURE__ */ __name((register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap11((output) => pipe(runtime4(), flatMap11((runtime5) => pipe(register(make50((k) => pipe(fromPull(k), flatMap11((take10) => offer3(output, take10)), asVoid4, runPromiseExit2(runtime5)).then((exit5) => {
      if (isFailure(exit5)) {
        if (!isInterrupted2(exit5.cause)) {
          throw squash(exit5.cause);
        }
      }
    }))), map18(() => {
      const loop3 = pipe(take3(output), flatMap11(done10), match13({
        onFailure: /* @__PURE__ */ __name((maybeError) => pipe(fromEffect4(shutdown4(output)), zipRight6(match2(maybeError, {
          onNone: /* @__PURE__ */ __name(() => void_6, "onNone"),
          onSome: fail11
        }))), "onFailure"),
        onSuccess: /* @__PURE__ */ __name((chunk4) => pipe(write(chunk4), flatMap13(() => loop3)), "onSuccess")
      }), unwrap);
      return loop3;
    }))))), unwrapScoped3, fromChannel2), "asyncEffect");
    queueFromBufferOptionsPush = /* @__PURE__ */ __name((options) => {
      if (options?.bufferSize === "unbounded" || options?.bufferSize === void 0 && options?.strategy === void 0) {
        return unbounded5();
      }
      switch (options?.strategy) {
        case "sliding":
          return sliding4(options.bufferSize ?? 16);
        default:
          return dropping4(options?.bufferSize ?? 16);
      }
    }, "queueFromBufferOptionsPush");
    asyncPush = /* @__PURE__ */ __name((register, options) => acquireRelease2(queueFromBufferOptionsPush(options), shutdown4).pipe(tap4((queue) => getWith(currentScheduler2, (scheduler2) => register(makePush(queue, scheduler2)))), map18((queue) => {
      const loop3 = flatMap13(take3(queue), (item) => isExit(item) ? isSuccess(item) ? void_6 : failCause10(item.cause) : zipRight6(write(unsafeFromArray(item)), loop3));
      return loop3;
    }), unwrapScoped3, fromChannel2), "asyncPush");
    asyncScoped = /* @__PURE__ */ __name((register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap11((output) => pipe(runtime4(), flatMap11((runtime5) => pipe(register(make50((k) => pipe(fromPull(k), flatMap11((take10) => offer3(output, take10)), asVoid4, runPromiseExit2(runtime5)).then((exit5) => {
      if (isFailure(exit5)) {
        if (!isInterrupted2(exit5.cause)) {
          throw squash(exit5.cause);
        }
      }
    }))), zipRight5(make29(false)), flatMap11((ref2) => pipe(get12(ref2), map18((isDone7) => isDone7 ? end5() : pipe(take3(output), flatMap11(done10), onError2(() => pipe(set6(ref2, true), zipRight5(shutdown4(output)))))))))))), scoped5, flatMap16(repeatEffectChunkOption)), "asyncScoped");
    branchAfter = /* @__PURE__ */ dual(3, (self2, n, f) => suspend10(() => {
      const buffering = /* @__PURE__ */ __name((acc) => readWith({
        onInput: /* @__PURE__ */ __name((input) => {
          const nextSize = acc.length + input.length;
          if (nextSize >= n) {
            const [b1, b2] = pipe(input, splitAt2(n - acc.length));
            return running4(pipe(acc, appendAll2(b1)), b2);
          }
          return buffering(pipe(acc, appendAll2(input)));
        }, "onInput"),
        onFailure: fail11,
        onDone: /* @__PURE__ */ __name(() => running4(acc, empty5()), "onDone")
      }), "buffering");
      const running4 = /* @__PURE__ */ __name((prefix, leftover) => pipeTo(zipRight6(write(leftover), identityChannel()), toChannel2(f(prefix))), "running");
      return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(buffering(empty5()))));
    }));
    broadcast = /* @__PURE__ */ dual(3, (self2, n, maximumLag) => pipe(self2, broadcastedQueues(n, maximumLag), map18((tuple4) => tuple4.map((queue) => flattenTake(fromQueue2(queue, {
      shutdown: true
    }))))));
    broadcastDynamic = /* @__PURE__ */ dual(2, (self2, maximumLag) => map18(toPubSub2(self2, maximumLag), (pubsub) => flattenTake(fromPubSub(pubsub))));
    share = /* @__PURE__ */ dual(2, (self2, options) => map18(make46({
      acquire: broadcastDynamic(self2, options),
      idleTimeToLive: options.idleTimeToLive
    }), (rcRef) => unwrapScoped4(get15(rcRef))));
    broadcastedQueues = /* @__PURE__ */ dual(3, (self2, n, maximumLag) => flatMap11(pubsubFromOptions(maximumLag), (pubsub) => pipe(all6(Array.from({
      length: n
    }, () => subscribe2(pubsub))), tap4(() => forkScoped2(runIntoPubSubScoped(self2, pubsub))))));
    broadcastedQueuesDynamic = /* @__PURE__ */ dual(2, (self2, maximumLag) => map18(toPubSub2(self2, maximumLag), subscribe2));
    buffer = /* @__PURE__ */ dual(2, (self2, options) => {
      if (options.capacity === "unbounded") {
        return bufferUnbounded(self2);
      } else if (options.strategy === "dropping") {
        return bufferDropping(self2, options.capacity);
      } else if (options.strategy === "sliding") {
        return bufferSliding(self2, options.capacity);
      }
      const queue = toQueueOfElements(self2, options);
      return new StreamImpl(unwrapScoped3(map18(queue, (queue2) => {
        const process4 = pipe(fromEffect4(take3(queue2)), flatMap13(match6({
          onFailure: /* @__PURE__ */ __name((cause3) => pipe(flipCauseOption2(cause3), match2({
            onNone: /* @__PURE__ */ __name(() => void_6, "onNone"),
            onSome: failCause10
          })), "onFailure"),
          onSuccess: /* @__PURE__ */ __name((value3) => flatMap13(write(of2(value3)), () => process4), "onSuccess")
        })));
        return process4;
      })));
    });
    bufferChunks = /* @__PURE__ */ dual(2, (self2, options) => {
      if (options.strategy === "dropping") {
        return bufferChunksDropping(self2, options.capacity);
      } else if (options.strategy === "sliding") {
        return bufferChunksSliding(self2, options.capacity);
      }
      const queue = toQueue2(self2, options);
      return new StreamImpl(unwrapScoped3(map18(queue, (queue2) => {
        const process4 = pipe(fromEffect4(take3(queue2)), flatMap13(match18({
          onEnd: /* @__PURE__ */ __name(() => void_6, "onEnd"),
          onFailure: failCause10,
          onSuccess: /* @__PURE__ */ __name((value3) => pipe(write(value3), flatMap13(() => process4)), "onSuccess")
        })));
        return process4;
      })));
    });
    bufferChunksDropping = /* @__PURE__ */ dual(2, (self2, capacity7) => {
      const queue = acquireRelease2(dropping4(capacity7), (queue2) => shutdown4(queue2));
      return new StreamImpl(bufferSignal(queue, toChannel2(self2)));
    });
    bufferChunksSliding = /* @__PURE__ */ dual(2, (self2, capacity7) => {
      const queue = acquireRelease2(sliding4(capacity7), (queue2) => shutdown4(queue2));
      return new StreamImpl(bufferSignal(queue, toChannel2(self2)));
    });
    bufferDropping = /* @__PURE__ */ dual(2, (self2, capacity7) => {
      const queue = acquireRelease2(dropping4(capacity7), (queue2) => shutdown4(queue2));
      return new StreamImpl(bufferSignal(queue, toChannel2(rechunk(1)(self2))));
    });
    bufferSliding = /* @__PURE__ */ dual(2, (self2, capacity7) => {
      const queue = acquireRelease2(sliding4(capacity7), (queue2) => shutdown4(queue2));
      return new StreamImpl(bufferSignal(queue, toChannel2(pipe(self2, rechunk(1)))));
    });
    bufferUnbounded = /* @__PURE__ */ __name((self2) => {
      const queue = toQueue2(self2, {
        strategy: "unbounded"
      });
      return new StreamImpl(unwrapScoped3(map18(queue, (queue2) => {
        const process4 = pipe(fromEffect4(take3(queue2)), flatMap13(match18({
          onEnd: /* @__PURE__ */ __name(() => void_6, "onEnd"),
          onFailure: failCause10,
          onSuccess: /* @__PURE__ */ __name((value3) => flatMap13(write(value3), () => process4), "onSuccess")
        })));
        return process4;
      })));
    }, "bufferUnbounded");
    bufferSignal = /* @__PURE__ */ __name((scoped7, bufferChannel) => {
      const producer = /* @__PURE__ */ __name((queue, ref2) => {
        const terminate = /* @__PURE__ */ __name((take10) => pipe(get12(ref2), tap4(_await), zipRight5(make19()), flatMap11((deferred) => pipe(offer3(queue, [take10, deferred]), zipRight5(set6(ref2, deferred)), zipRight5(_await(deferred)))), asVoid4, fromEffect4), "terminate");
        return readWithCause({
          onInput: /* @__PURE__ */ __name((input) => pipe(make19(), flatMap11((deferred) => pipe(offer3(queue, [chunk2(input), deferred]), flatMap11((added) => pipe(set6(ref2, deferred), when2(() => added))))), asVoid4, fromEffect4, flatMap13(() => producer(queue, ref2))), "onInput"),
          onFailure: /* @__PURE__ */ __name((error50) => terminate(failCause11(error50)), "onFailure"),
          onDone: /* @__PURE__ */ __name(() => terminate(end4), "onDone")
        });
      }, "producer");
      const consumer = /* @__PURE__ */ __name((queue) => {
        const process4 = pipe(fromEffect4(take3(queue)), flatMap13(([take10, deferred]) => zipRight6(fromEffect4(succeed2(deferred, void 0)), match18(take10, {
          onEnd: /* @__PURE__ */ __name(() => void_6, "onEnd"),
          onFailure: failCause10,
          onSuccess: /* @__PURE__ */ __name((value3) => pipe(write(value3), flatMap13(() => process4)), "onSuccess")
        }))));
        return process4;
      }, "consumer");
      return unwrapScoped3(pipe(scoped7, flatMap11((queue) => pipe(make19(), tap4((start5) => succeed2(start5, void 0)), flatMap11((start5) => pipe(make29(start5), flatMap11((ref2) => pipe(bufferChannel, pipeTo(producer(queue, ref2)), runScoped, forkScoped2)), as6(consumer(queue))))))));
    }, "bufferSignal");
    catchAll7 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause6(self2, (cause3) => match(failureOrCause2(cause3), {
      onLeft: f,
      onRight: failCause13
    })));
    catchAllCause6 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), catchAllCause5((cause3) => toChannel2(f(cause3))))));
    catchSome3 = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, catchAll7((error50) => pipe(pf(error50), getOrElse(() => fail15(error50))))));
    catchSomeCause3 = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, catchAllCause6((cause3) => pipe(pf(cause3), getOrElse(() => failCause13(cause3))))));
    catchTag3 = /* @__PURE__ */ dual(3, (self2, k, f) => catchAll7(self2, (e) => {
      if ("_tag" in e && e["_tag"] === k) {
        return f(e);
      }
      return fail15(e);
    }));
    catchTags3 = /* @__PURE__ */ dual(2, (self2, cases) => catchAll7(self2, (e) => {
      const keys5 = Object.keys(cases);
      if ("_tag" in e && keys5.includes(e["_tag"])) {
        return cases[e["_tag"]](e);
      }
      return fail15(e);
    }));
    changes = /* @__PURE__ */ __name((self2) => pipe(self2, changesWith((x, y) => equals(y)(x))), "changes");
    changesWith = /* @__PURE__ */ dual(2, (self2, f) => {
      const writer = /* @__PURE__ */ __name((last6) => readWithCause({
        onInput: /* @__PURE__ */ __name((input) => {
          const [newLast, newChunk] = reduce2(input, [last6, empty5()], ([option5, outputs], output) => {
            if (isSome2(option5) && f(option5.value, output)) {
              return [some2(output), outputs];
            }
            return [some2(output), pipe(outputs, append2(output))];
          });
          return flatMap13(write(newChunk), () => writer(newLast));
        }, "onInput"),
        onFailure: failCause10,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      }), "writer");
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer(none2()))));
    });
    changesWithEffect = /* @__PURE__ */ dual(2, (self2, f) => {
      const writer = /* @__PURE__ */ __name((last6) => readWithCause({
        onInput: /* @__PURE__ */ __name((input) => pipe(input, reduce12([last6, empty5()], ([option5, outputs], output) => {
          if (isSome2(option5)) {
            return pipe(f(option5.value, output), map18((bool) => bool ? [some2(output), outputs] : [some2(output), pipe(outputs, append2(output))]));
          }
          return succeed9([some2(output), pipe(outputs, append2(output))]);
        }), fromEffect4, flatMap13(([newLast, newChunk]) => pipe(write(newChunk), flatMap13(() => writer(newLast))))), "onInput"),
        onFailure: failCause10,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      }), "writer");
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer(none2()))));
    });
    chunks = /* @__PURE__ */ __name((self2) => pipe(self2, mapChunks(of2)), "chunks");
    chunksWith = /* @__PURE__ */ dual(2, (self2, f) => flattenChunks(f(chunks(self2))));
    unsome = /* @__PURE__ */ __name((effect4) => catchAll3(asSome2(effect4), (o) => o._tag === "None" ? succeedNone2 : fail9(o.value)), "unsome");
    combine9 = /* @__PURE__ */ dual(4, (self2, that, s, f) => {
      function producer(handoff, latch) {
        return fromEffect4(take6(latch)).pipe(zipRight6(readWithCause({
          onInput: /* @__PURE__ */ __name((input) => flatMap13(fromEffect4(offer5(handoff, succeed3(input))), () => producer(handoff, latch)), "onInput"),
          onFailure: /* @__PURE__ */ __name((cause3) => fromEffect4(offer5(handoff, failCause3(pipe(cause3, map14(some2))))), "onFailure"),
          onDone: /* @__PURE__ */ __name(() => flatMap13(fromEffect4(offer5(handoff, fail4(none2()))), () => producer(handoff, latch)), "onDone")
        })));
      }
      __name(producer, "producer");
      return new StreamImpl(unwrapScopedWith((scope5) => all6([make51(), make51(), make51(), make51()]).pipe(tap4(([left3, _, latchL]) => toChannel2(self2).pipe(concatMap(writeChunk), pipeTo(producer(left3, latchL)), runIn(scope5), forkIn2(scope5))), tap4(([, right3, _, rightL]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3, rightL)), runIn(scope5), forkIn2(scope5))), map18(([left3, right3, latchL, latchR]) => {
        const pullLeft = offer5(latchL, void 0).pipe(zipRight5(take6(left3).pipe(flatMap11(identity))));
        const pullRight = offer5(latchR, void 0).pipe(zipRight5(take6(right3).pipe(flatMap11(identity))));
        return toChannel2(unfoldEffect(s, (s2) => flatMap11(f(s2, pullLeft, pullRight), unsome)));
      }))));
    });
    combineChunks = /* @__PURE__ */ dual(4, (self2, that, s, f) => {
      const producer = /* @__PURE__ */ __name((handoff, latch) => zipRight6(fromEffect4(take6(latch)), readWithCause({
        onInput: /* @__PURE__ */ __name((input) => flatMap13(fromEffect4(pipe(handoff, offer5(chunk2(input)))), () => producer(handoff, latch)), "onInput"),
        onFailure: /* @__PURE__ */ __name((cause3) => fromEffect4(offer5(handoff, failCause11(cause3))), "onFailure"),
        onDone: /* @__PURE__ */ __name(() => fromEffect4(offer5(handoff, end4)), "onDone")
      })), "producer");
      return new StreamImpl(unwrapScopedWith((scope5) => all6([make51(), make51(), make51(), make51()]).pipe(tap4(([left3, _, latchL]) => pipeTo(toChannel2(self2), producer(left3, latchL)).pipe(runIn(scope5), forkIn2(scope5))), tap4(([_, right3, __, latchR]) => pipeTo(toChannel2(that), producer(right3, latchR)).pipe(runIn(scope5), forkIn2(scope5))), map18(([left3, right3, latchL, latchR]) => {
        const pullLeft = offer5(latchL, void 0).pipe(zipRight5(take6(left3).pipe(flatMap11(done10))));
        const pullRight = offer5(latchR, void 0).pipe(zipRight5(take6(right3).pipe(flatMap11(done10))));
        return toChannel2(unfoldChunkEffect(s, (s2) => flatMap11(f(s2, pullLeft, pullRight), unsome)));
      }))));
    });
    concat2 = /* @__PURE__ */ dual(2, (self2, that) => new StreamImpl(pipe(toChannel2(self2), zipRight6(toChannel2(that)))));
    concatAll2 = /* @__PURE__ */ __name((streams) => suspend10(() => pipe(streams, reduce2(empty34, (x, y) => concat2(y)(x)))), "concatAll");
    cross = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, a2) => [a, a2])));
    crossLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, _) => a)));
    crossRight = /* @__PURE__ */ dual(2, (left3, right3) => flatMap16(left3, () => right3));
    crossWith = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, flatMap16((a) => pipe(right3, map24((b) => f(a, b))))));
    debounce = /* @__PURE__ */ dual(2, (self2, duration6) => unwrapScopedWith3((scope5) => gen4(function* () {
      const handoff = yield* make51();
      function enqueue(last6) {
        return sleep2(duration6).pipe(as6(last6), forkIn2(scope5), map18((fiber) => consumer(previous(fiber))));
      }
      __name(enqueue, "enqueue");
      const producer = readWithCause({
        onInput: /* @__PURE__ */ __name((input) => match2(last2(input), {
          onNone: /* @__PURE__ */ __name(() => producer, "onNone"),
          onSome: /* @__PURE__ */ __name((elem) => fromEffect4(offer5(handoff, emit2(of2(elem)))).pipe(flatMap13(() => producer)), "onSome")
        }), "onInput"),
        onFailure: /* @__PURE__ */ __name((cause3) => fromEffect4(offer5(handoff, halt(cause3))), "onFailure"),
        onDone: /* @__PURE__ */ __name(() => fromEffect4(offer5(handoff, end3(UpstreamEnd))), "onDone")
      });
      function consumer(state) {
        switch (state._tag) {
          case OP_NOT_STARTED: {
            return unwrap(take6(handoff).pipe(map18((signal) => {
              switch (signal._tag) {
                case OP_EMIT4: {
                  return unwrap(enqueue(signal.elements));
                }
                case OP_HALT: {
                  return failCause10(signal.cause);
                }
                case OP_END: {
                  return void_6;
                }
              }
            })));
          }
          case OP_PREVIOUS: {
            return unwrap(take6(handoff).pipe(forkIn2(scope5), flatMap11((handoffFiber) => raceWith2(join3(state.fiber), join3(handoffFiber), {
              onSelfDone: /* @__PURE__ */ __name((leftExit, current2) => match6(leftExit, {
                onFailure: /* @__PURE__ */ __name((cause3) => interrupt6(current2).pipe(as6(failCause10(cause3))), "onFailure"),
                onSuccess: /* @__PURE__ */ __name((chunk4) => interrupt6(current2).pipe(zipRight5(succeed9(write(chunk4).pipe(flatMap13(() => consumer(current(handoffFiber))))))), "onSuccess")
              }), "onSelfDone"),
              onOtherDone: /* @__PURE__ */ __name((rightExit, previous2) => match6(rightExit, {
                onFailure: /* @__PURE__ */ __name((cause3) => interrupt6(previous2).pipe(as6(failCause10(cause3))), "onFailure"),
                onSuccess: /* @__PURE__ */ __name((signal) => {
                  switch (signal._tag) {
                    case OP_EMIT4: {
                      return interrupt6(previous2).pipe(zipRight5(enqueue(signal.elements)));
                    }
                    case OP_HALT: {
                      return interrupt6(previous2).pipe(as6(failCause10(signal.cause)));
                    }
                    case OP_END: {
                      return join3(previous2).pipe(map18((chunk4) => write(chunk4).pipe(zipRight6(void_6))));
                    }
                  }
                }, "onSuccess")
              }), "onOtherDone")
            }))));
          }
          case OP_CURRENT: {
            return unwrap(join3(state.fiber).pipe(map18((signal) => {
              switch (signal._tag) {
                case OP_EMIT4: {
                  return unwrap(enqueue(signal.elements));
                }
                case OP_HALT: {
                  return failCause10(signal.cause);
                }
                case OP_END: {
                  return void_6;
                }
              }
            })));
          }
        }
      }
      __name(consumer, "consumer");
      return scopedWith4((scope6) => pipeTo(toChannel2(self2), producer).pipe(runIn(scope6), forkIn2(scope6))).pipe(crossRight(new StreamImpl(consumer(notStarted))));
    })));
    die10 = /* @__PURE__ */ __name((defect) => fromEffect7(die6(defect)), "die");
    dieSync6 = /* @__PURE__ */ __name((evaluate3) => fromEffect7(dieSync3(evaluate3)), "dieSync");
    dieMessage4 = /* @__PURE__ */ __name((message) => fromEffect7(dieMessage2(message)), "dieMessage");
    distributedWith = /* @__PURE__ */ dual(2, (self2, options) => pipe(make19(), flatMap11((deferred) => pipe(self2, distributedWithDynamic({
      maximumLag: options.maximumLag,
      decide: /* @__PURE__ */ __name((a) => flatMap11(_await(deferred), (f) => f(a)), "decide")
    }), flatMap11((next4) => pipe(all6(map5(range(0, options.size - 1), (id2) => map18(next4, ([key, queue]) => [[key, id2], queue]))), map18(unsafeFromArray), flatMap11((entries2) => {
      const [mappings, queues] = reduceRight2(entries2, [/* @__PURE__ */ new Map(), empty5()], ([mappings2, queues2], [mapping, queue]) => [mappings2.set(mapping[0], mapping[1]), pipe(queues2, prepend2(queue))]);
      return pipe(succeed2(deferred, (a) => map18(options.decide(a), (f) => (key) => f(mappings.get(key)))), as6(Array.from(queues)));
    })))))));
    distributedWithDynamicId = {
      ref: 0
    };
    newDistributedWithDynamicId = /* @__PURE__ */ __name(() => {
      const current2 = distributedWithDynamicId.ref;
      distributedWithDynamicId.ref = current2 + 1;
      return current2;
    }, "newDistributedWithDynamicId");
    distributedWithDynamic = /* @__PURE__ */ dual(2, (self2, options) => distributedWithDynamicCallback(self2, options.maximumLag, options.decide, () => _void));
    distributedWithDynamicCallback = /* @__PURE__ */ dual(4, (self2, maximumLag, decide, done13) => pipe(acquireRelease2(make29(/* @__PURE__ */ new Map()), (ref2, _) => pipe(get12(ref2), flatMap11((queues) => pipe(queues.values(), forEach9(shutdown4))))), flatMap11((queuesRef) => gen4(function* () {
      const offer6 = /* @__PURE__ */ __name((a) => pipe(decide(a), flatMap11((shouldProcess) => pipe(get12(queuesRef), flatMap11((queues) => pipe(queues.entries(), reduce12(empty5(), (acc, [id2, queue]) => {
        if (shouldProcess(id2)) {
          return pipe(offer3(queue, succeed3(a)), matchCauseEffect3({
            onFailure: /* @__PURE__ */ __name((cause3) => (
              // Ignore all downstream queues that were shut
              // down and remove them later
              isInterrupted2(cause3) ? succeed9(pipe(acc, prepend2(id2))) : failCause8(cause3)
            ), "onFailure"),
            onSuccess: /* @__PURE__ */ __name(() => succeed9(acc), "onSuccess")
          }));
        }
        return succeed9(acc);
      }), flatMap11((ids3) => {
        if (isNonEmpty2(ids3)) {
          return update3(queuesRef, (map31) => {
            for (const id2 of ids3) {
              map31.delete(id2);
            }
            return map31;
          });
        }
        return _void;
      }))))), asVoid4), "offer");
      const queuesLock = yield* makeSemaphore2(1);
      const newQueue = yield* make29(pipe(bounded5(maximumLag), flatMap11((queue) => {
        const id2 = newDistributedWithDynamicId();
        return pipe(update3(queuesRef, (map31) => map31.set(id2, queue)), as6([id2, queue]));
      })));
      const finalize2 = /* @__PURE__ */ __name((endTake) => (
        // Make sure that no queues are currently being added
        queuesLock.withPermits(1)(pipe(set6(newQueue, pipe(
          // All newly created queues should end immediately
          bounded5(1),
          tap4((queue) => offer3(queue, endTake)),
          flatMap11((queue) => {
            const id2 = newDistributedWithDynamicId();
            return pipe(update3(queuesRef, (map31) => map31.set(id2, queue)), as6(make3(id2, queue)));
          })
        )), zipRight5(pipe(get12(queuesRef), flatMap11((map31) => pipe(fromIterable3(map31.values()), forEach9((queue) => pipe(offer3(queue, endTake), catchSomeCause2((cause3) => isInterrupted2(cause3) ? some2(_void) : none2()))))))), zipRight5(done13(endTake)), asVoid4))
      ), "finalize");
      yield* pipe(self2, runForEachScoped(offer6), matchCauseEffect3({
        onFailure: /* @__PURE__ */ __name((cause3) => finalize2(failCause3(pipe(cause3, map14(some2)))), "onFailure"),
        onSuccess: /* @__PURE__ */ __name(() => finalize2(fail4(none2())), "onSuccess")
      }), forkScoped2);
      return queuesLock.withPermits(1)(flatten10(get12(newQueue)));
    }))));
    drain3 = /* @__PURE__ */ __name((self2) => new StreamImpl(drain(toChannel2(self2))), "drain");
    drainFork = /* @__PURE__ */ dual(2, (self2, that) => fromEffect7(make19()).pipe(flatMap16((backgroundDied) => scopedWith4((scope5) => toChannel2(that).pipe(drain, runIn(scope5), catchAllCause3((cause3) => failCause2(backgroundDied, cause3)), forkIn2(scope5))).pipe(crossRight(interruptWhenDeferred2(self2, backgroundDied))))));
    drop3 = /* @__PURE__ */ dual(2, (self2, n) => {
      const loop3 = /* @__PURE__ */ __name((r) => readWith({
        onInput: /* @__PURE__ */ __name((input) => {
          const dropped = pipe(input, drop2(r));
          const leftover = Math.max(0, r - input.length);
          const more = isEmpty(input) || leftover > 0;
          if (more) {
            return loop3(leftover);
          }
          return pipe(write(dropped), zipRight6(identityChannel()));
        }, "onInput"),
        onFailure: fail11,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      }), "loop");
      return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3(n))));
    });
    dropRight = /* @__PURE__ */ dual(2, (self2, n) => {
      if (n <= 0) {
        return identityStream();
      }
      return suspend10(() => {
        const queue = new RingBuffer(n);
        const reader = readWith({
          onInput: /* @__PURE__ */ __name((input) => {
            const outputs = pipe(input, filterMap3((elem) => {
              const head7 = queue.head();
              queue.put(elem);
              return head7;
            }));
            return pipe(write(outputs), flatMap13(() => reader));
          }, "onInput"),
          onFailure: fail11,
          onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
        });
        return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(reader)));
      });
    });
    dropUntil3 = /* @__PURE__ */ dual(2, (self2, predicate) => drop3(dropWhile4(self2, (a) => !predicate(a)), 1));
    dropUntilEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
      const loop3 = readWith({
        onInput: /* @__PURE__ */ __name((input) => pipe(dropUntil2(input, predicate), map18(unsafeFromArray), map18((leftover) => {
          const more = isEmpty(leftover);
          if (more) {
            return suspend6(() => loop3);
          }
          return pipe(write(leftover), zipRight6(identityChannel()));
        }), unwrap), "onInput"),
        onFailure: fail11,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      });
      return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
    });
    dropWhile4 = /* @__PURE__ */ dual(2, (self2, predicate) => {
      const loop3 = readWith({
        onInput: /* @__PURE__ */ __name((input) => {
          const output = dropWhile(input, predicate);
          if (isEmpty(output)) {
            return suspend6(() => loop3);
          }
          return zipRight6(write(output), identityChannel());
        }, "onInput"),
        onFailure: fail11,
        onDone: succeedNow
      });
      return new StreamImpl(pipeToOrFail(toChannel2(self2), loop3));
    });
    dropWhileEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
      const loop3 = readWith({
        onInput: /* @__PURE__ */ __name((input) => pipe(dropWhile3(input, predicate), map18(unsafeFromArray), map18((leftover) => {
          const more = isEmpty(leftover);
          if (more) {
            return suspend6(() => loop3);
          }
          return zipRight6(write(leftover), identityChannel());
        }), unwrap), "onInput"),
        onFailure: fail11,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      });
      return new StreamImpl(pipeToOrFail(toChannel2(self2), loop3));
    });
    either6 = /* @__PURE__ */ __name((self2) => pipe(self2, map24(right2), catchAll7((error50) => make52(left2(error50)))), "either");
    empty34 = /* @__PURE__ */ new StreamImpl(void_6);
    ensuring7 = /* @__PURE__ */ dual(2, (self2, finalizer3) => new StreamImpl(pipe(toChannel2(self2), ensuring4(finalizer3))));
    ensuringWith2 = /* @__PURE__ */ dual(2, (self2, finalizer3) => new StreamImpl(ensuringWith(toChannel2(self2), finalizer3)));
    context7 = /* @__PURE__ */ __name(() => fromEffect7(context5()), "context");
    contextWith3 = /* @__PURE__ */ __name((f) => pipe(context7(), map24(f)), "contextWith");
    contextWithEffect3 = /* @__PURE__ */ __name((f) => pipe(context7(), mapEffectSequential(f)), "contextWithEffect");
    contextWithStream = /* @__PURE__ */ __name((f) => pipe(context7(), flatMap16(f)), "contextWithStream");
    execute = /* @__PURE__ */ __name((effect4) => drain3(fromEffect7(effect4)), "execute");
    fail15 = /* @__PURE__ */ __name((error50) => fromEffectOption(fail9(some2(error50))), "fail");
    failSync7 = /* @__PURE__ */ __name((evaluate3) => fromEffectOption(failSync3(() => some2(evaluate3()))), "failSync");
    failCause13 = /* @__PURE__ */ __name((cause3) => fromEffect7(failCause8(cause3)), "failCause");
    failCauseSync6 = /* @__PURE__ */ __name((evaluate3) => fromEffect7(failCauseSync3(evaluate3)), "failCauseSync");
    filter10 = /* @__PURE__ */ dual(2, (self2, predicate) => mapChunks(self2, filter3(predicate)));
    filterEffect = /* @__PURE__ */ dual(2, (self2, f) => {
      const loop3 = /* @__PURE__ */ __name((iterator2) => {
        const next4 = iterator2.next();
        if (next4.done) {
          return readWithCause({
            onInput: /* @__PURE__ */ __name((input) => loop3(input[Symbol.iterator]()), "onInput"),
            onFailure: failCause10,
            onDone: succeed11
          });
        } else {
          return pipe(f(next4.value), map18((bool) => bool ? pipe(write(of2(next4.value)), flatMap13(() => loop3(iterator2))) : loop3(iterator2)), unwrap);
        }
      }, "loop");
      return new StreamImpl(suspend6(() => pipe(toChannel2(self2), pipeTo(loop3(empty5()[Symbol.iterator]())))));
    });
    filterMap7 = /* @__PURE__ */ dual(2, (self2, pf) => mapChunks(self2, filterMap3(pf)));
    filterMapEffect = /* @__PURE__ */ dual(2, (self2, pf) => suspend10(() => {
      const loop3 = /* @__PURE__ */ __name((iterator2) => {
        const next4 = iterator2.next();
        if (next4.done) {
          return readWithCause({
            onInput: /* @__PURE__ */ __name((input) => loop3(input[Symbol.iterator]()), "onInput"),
            onFailure: failCause10,
            onDone: succeed11
          });
        } else {
          return pipe(pf(next4.value), match2({
            onNone: /* @__PURE__ */ __name(() => sync5(() => loop3(iterator2)), "onNone"),
            onSome: map18((a2) => flatMap13(write(of2(a2)), () => loop3(iterator2)))
          }), unwrap);
        }
      }, "loop");
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty5()[Symbol.iterator]()))));
    }));
    filterMapWhile3 = /* @__PURE__ */ dual(2, (self2, pf) => {
      const loop3 = readWith({
        onInput: /* @__PURE__ */ __name((input) => {
          const mapped = filterMapWhile2(input, pf);
          if (mapped.length === input.length) {
            return pipe(write(mapped), flatMap13(() => loop3));
          }
          return write(mapped);
        }, "onInput"),
        onFailure: fail11,
        onDone: succeed11
      });
      return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
    });
    filterMapWhileEffect = /* @__PURE__ */ dual(2, (self2, pf) => suspend10(() => {
      const loop3 = /* @__PURE__ */ __name((iterator2) => {
        const next4 = iterator2.next();
        if (next4.done) {
          return readWithCause({
            onInput: /* @__PURE__ */ __name((input) => loop3(input[Symbol.iterator]()), "onInput"),
            onFailure: failCause10,
            onDone: succeed11
          });
        } else {
          return unwrap(match2(pf(next4.value), {
            onNone: /* @__PURE__ */ __name(() => succeed9(void_6), "onNone"),
            onSome: map18((a2) => flatMap13(write(of2(a2)), () => loop3(iterator2)))
          }));
        }
      }, "loop");
      return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3(empty5()[Symbol.iterator]()))));
    }));
    finalizer = /* @__PURE__ */ __name((finalizer3) => acquireRelease3(_void, () => finalizer3), "finalizer");
    find2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
      const loop3 = readWith({
        onInput: /* @__PURE__ */ __name((input) => match2(findFirst3(input, predicate), {
          onNone: /* @__PURE__ */ __name(() => loop3, "onNone"),
          onSome: /* @__PURE__ */ __name((n) => write(of2(n)), "onSome")
        }), "onInput"),
        onFailure: fail11,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      });
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
    });
    findEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
      const loop3 = readWith({
        onInput: /* @__PURE__ */ __name((input) => pipe(findFirst7(input, predicate), map18(match2({
          onNone: /* @__PURE__ */ __name(() => loop3, "onNone"),
          onSome: /* @__PURE__ */ __name((n) => write(of2(n)), "onSome")
        })), unwrap), "onInput"),
        onFailure: fail11,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      });
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
    });
    flatMap16 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, f, options) => {
      const bufferSize = options?.bufferSize ?? 16;
      if (options?.switch) {
        return matchConcurrency(options?.concurrency, () => flatMapParSwitchBuffer(self2, 1, bufferSize, f), (n) => flatMapParSwitchBuffer(self2, n, bufferSize, f));
      }
      return matchConcurrency(options?.concurrency, () => new StreamImpl(concatMap(toChannel2(self2), (as12) => pipe(as12, map5((a) => toChannel2(f(a))), reduce2(void_6, (left3, right3) => pipe(left3, zipRight6(right3)))))), (_) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), options))));
    });
    matchConcurrency = /* @__PURE__ */ __name((concurrency, sequential5, bounded8) => {
      switch (concurrency) {
        case void 0:
          return sequential5();
        case "unbounded":
          return bounded8(Number.MAX_SAFE_INTEGER);
        default:
          return concurrency > 1 ? bounded8(concurrency) : sequential5();
      }
    }, "matchConcurrency");
    flatMapParSwitchBuffer = /* @__PURE__ */ dual(4, (self2, n, bufferSize, f) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), {
      concurrency: n,
      mergeStrategy: BufferSliding(),
      bufferSize
    }))));
    flatten14 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => flatMap16(self2, identity, options));
    flattenChunks = /* @__PURE__ */ __name((self2) => {
      const flatten17 = readWithCause({
        onInput: /* @__PURE__ */ __name((chunks3) => flatMap13(writeChunk(chunks3), () => flatten17), "onInput"),
        onFailure: failCause10,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      });
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(flatten17)));
    }, "flattenChunks");
    flattenEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => options?.unordered ? flatMap16(self2, (a) => fromEffect7(a), {
      concurrency: options.concurrency
    }) : matchConcurrency(options?.concurrency, () => mapEffectSequential(self2, identity), (n) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mapOutEffectPar(identity, n), mapOut(of2)))));
    flattenExitOption = /* @__PURE__ */ __name((self2) => {
      const processChunk = /* @__PURE__ */ __name((chunk4, cont) => {
        const [toEmit, rest] = pipe(chunk4, splitWhere((exit5) => !isSuccess(exit5)));
        const next4 = pipe(head2(rest), match2({
          onNone: /* @__PURE__ */ __name(() => cont, "onNone"),
          onSome: match6({
            onFailure: /* @__PURE__ */ __name((cause3) => match2(flipCauseOption2(cause3), {
              onNone: /* @__PURE__ */ __name(() => void_6, "onNone"),
              onSome: failCause10
            }), "onFailure"),
            onSuccess: /* @__PURE__ */ __name(() => void_6, "onSuccess")
          })
        }));
        return pipe(write(pipe(toEmit, filterMap3((exit5) => isSuccess(exit5) ? some2(exit5.value) : none2()))), flatMap13(() => next4));
      }, "processChunk");
      const process4 = readWithCause({
        onInput: /* @__PURE__ */ __name((chunk4) => processChunk(chunk4, process4), "onInput"),
        onFailure: /* @__PURE__ */ __name((cause3) => failCause10(cause3), "onFailure"),
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      });
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(process4)));
    }, "flattenExitOption");
    flattenIterables = /* @__PURE__ */ __name((self2) => pipe(self2, map24(fromIterable3), flattenChunks), "flattenIterables");
    flattenTake = /* @__PURE__ */ __name((self2) => flattenChunks(flattenExitOption(pipe(self2, map24((take10) => take10.exit)))), "flattenTake");
    forever5 = /* @__PURE__ */ __name((self2) => new StreamImpl(repeated(toChannel2(self2))), "forever");
    fromAsyncIterable = /* @__PURE__ */ __name((iterable, onError5) => pipe(acquireRelease2(sync5(() => iterable[Symbol.asyncIterator]()), (iterator2) => iterator2.return ? promise2(async () => iterator2.return()) : _void), map18((iterator2) => repeatEffectOption(pipe(tryPromise2({
      try: /* @__PURE__ */ __name(async () => iterator2.next(), "try"),
      catch: /* @__PURE__ */ __name((reason) => some2(onError5(reason)), "catch")
    }), flatMap11((result) => result.done ? fail9(none2()) : succeed9(result.value))))), unwrapScoped4), "fromAsyncIterable");
    fromChannel2 = /* @__PURE__ */ __name((channel2) => new StreamImpl(channel2), "fromChannel");
    toChannel2 = /* @__PURE__ */ __name((stream2) => {
      if ("channel" in stream2) {
        return stream2.channel;
      } else if (isEffect2(stream2)) {
        return toChannel2(fromEffect7(stream2));
      } else {
        throw new TypeError(`Expected a Stream.`);
      }
    }, "toChannel");
    fromChunk = /* @__PURE__ */ __name((chunk4) => new StreamImpl(isEmpty(chunk4) ? void_6 : write(chunk4)), "fromChunk");
    fromChunkPubSub = /* @__PURE__ */ __name((pubsub, options) => {
      if (options?.scoped) {
        const effect4 = map18(subscribe2(pubsub), fromChunkQueue);
        return options.shutdown ? map18(effect4, ensuring7(shutdown3(pubsub))) : effect4;
      }
      const stream2 = flatMap16(scoped5(subscribe2(pubsub)), fromChunkQueue);
      return options?.shutdown ? ensuring7(stream2, shutdown3(pubsub)) : stream2;
    }, "fromChunkPubSub");
    fromChunkQueue = /* @__PURE__ */ __name((queue, options) => pipe(take3(queue), catchAllCause3((cause3) => pipe(isShutdown3(queue), flatMap11((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause12(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring7(shutdown4(queue)) : identity), "fromChunkQueue");
    fromChunks = /* @__PURE__ */ __name((...chunks3) => pipe(fromIterable14(chunks3), flatMap16(fromChunk)), "fromChunks");
    fromEffect7 = /* @__PURE__ */ __name((effect4) => pipe(effect4, mapError3(some2), fromEffectOption), "fromEffect");
    fromEffectOption = /* @__PURE__ */ __name((effect4) => new StreamImpl(unwrap(match13(effect4, {
      onFailure: match2({
        onNone: /* @__PURE__ */ __name(() => void_6, "onNone"),
        onSome: fail11
      }),
      onSuccess: /* @__PURE__ */ __name((a) => write(of2(a)), "onSuccess")
    }))), "fromEffectOption");
    fromPubSub = /* @__PURE__ */ __name((pubsub, options) => {
      const maxChunkSize = options?.maxChunkSize ?? DefaultChunkSize;
      if (options?.scoped) {
        const effect4 = map18(subscribe2(pubsub), (queue) => fromQueue2(queue, {
          maxChunkSize,
          shutdown: true
        }));
        return options.shutdown ? map18(effect4, ensuring7(shutdown3(pubsub))) : effect4;
      }
      const stream2 = flatMap16(scoped5(subscribe2(pubsub)), (queue) => fromQueue2(queue, {
        maxChunkSize
      }));
      return options?.shutdown ? ensuring7(stream2, shutdown3(pubsub)) : stream2;
    }, "fromPubSub");
    fromTPubSub = /* @__PURE__ */ __name((pubsub) => {
      return unwrapScoped4(map18(subscribeScoped2(pubsub), (queue) => fromTQueue(queue)));
    }, "fromTPubSub");
    fromIterable14 = /* @__PURE__ */ __name((iterable) => suspend10(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]())), "fromIterable");
    fromIterableEffect = /* @__PURE__ */ __name((effect4) => pipe(effect4, map18(fromIterable14), unwrap2), "fromIterableEffect");
    fromIteratorSucceed = /* @__PURE__ */ __name((iterator2, maxChunkSize = DefaultChunkSize) => {
      return pipe(sync5(() => {
        let builder = [];
        const loop3 = /* @__PURE__ */ __name((iterator3) => pipe(sync5(() => {
          let next4 = iterator3.next();
          if (maxChunkSize === 1) {
            if (next4.done) {
              return void_6;
            }
            return pipe(write(of2(next4.value)), flatMap13(() => loop3(iterator3)));
          }
          builder = [];
          let count6 = 0;
          while (next4.done === false) {
            builder.push(next4.value);
            count6 = count6 + 1;
            if (count6 >= maxChunkSize) {
              break;
            }
            next4 = iterator3.next();
          }
          if (count6 > 0) {
            return pipe(write(unsafeFromArray(builder)), flatMap13(() => loop3(iterator3)));
          }
          return void_6;
        }), unwrap), "loop");
        return new StreamImpl(loop3(iterator2));
      }), unwrap2);
    }, "fromIteratorSucceed");
    fromPull2 = /* @__PURE__ */ __name((effect4) => pipe(effect4, map18(repeatEffectChunkOption), unwrapScoped4), "fromPull");
    fromQueue2 = /* @__PURE__ */ __name((queue, options) => pipe(takeBetween2(queue, 1, options?.maxChunkSize ?? DefaultChunkSize), catchAllCause3((cause3) => pipe(isShutdown3(queue), flatMap11((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause12(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring7(shutdown4(queue)) : identity), "fromQueue");
    fromTQueue = /* @__PURE__ */ __name((queue) => pipe(take5(queue), map18(of2), catchAllCause3((cause3) => pipe(isShutdown6(queue), flatMap11((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause12(cause3)))), repeatEffectChunkOption), "fromTQueue");
    fromSchedule = /* @__PURE__ */ __name((schedule4) => pipe(driver2(schedule4), map18((driver3) => repeatEffectOption(driver3.next(void 0))), unwrap2), "fromSchedule");
    fromReadableStream = /* @__PURE__ */ __name((...args2) => {
      const evaluate3 = args2.length === 1 ? args2[0].evaluate : args2[0];
      const onError5 = args2.length === 1 ? args2[0].onError : args2[1];
      const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
      return unwrapScoped4(map18(acquireRelease2(sync5(() => evaluate3().getReader()), (reader) => releaseLockOnEnd ? sync5(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => repeatEffectOption(flatMap11(tryPromise2({
        try: /* @__PURE__ */ __name(() => reader.read(), "try"),
        catch: /* @__PURE__ */ __name((reason) => some2(onError5(reason)), "catch")
      }), ({
        done: done13,
        value: value3
      }) => done13 ? fail9(none2()) : succeed9(value3)))));
    }, "fromReadableStream");
    fromReadableStreamByob = /* @__PURE__ */ __name((...args2) => {
      const evaluate3 = args2.length === 1 ? args2[0].evaluate : args2[0];
      const onError5 = args2.length === 1 ? args2[0].onError : args2[1];
      const allocSize = (args2.length === 1 ? args2[0].bufferSize : args2[2]) ?? 4096;
      const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
      return unwrapScoped4(map18(acquireRelease2(sync5(() => evaluate3().getReader({
        mode: "byob"
      })), (reader) => releaseLockOnEnd ? sync5(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => catchAll7(forever5(readChunkStreamByobReader(reader, onError5, allocSize)), (error50) => error50 === EOF ? empty34 : fail15(error50))));
    }, "fromReadableStreamByob");
    EOF = /* @__PURE__ */ Symbol.for("effect/Stream/EOF");
    readChunkStreamByobReader = /* @__PURE__ */ __name((reader, onError5, size15) => {
      const buffer3 = new ArrayBuffer(size15);
      return paginateEffect(0, (offset) => flatMap11(tryPromise2({
        try: /* @__PURE__ */ __name(() => reader.read(new Uint8Array(buffer3, offset, buffer3.byteLength - offset)), "try"),
        catch: /* @__PURE__ */ __name((reason) => onError5(reason), "catch")
      }), ({
        done: done13,
        value: value3
      }) => {
        if (done13) {
          return fail9(EOF);
        }
        const newOffset = offset + value3.byteLength;
        return succeed9([value3, newOffset >= buffer3.byteLength ? none2() : some2(newOffset)]);
      }));
    }, "readChunkStreamByobReader");
    groupAdjacentBy = /* @__PURE__ */ dual(2, (self2, f) => {
      const groupAdjacentByChunk = /* @__PURE__ */ __name((state, chunk4) => {
        if (isEmpty(chunk4)) {
          return [state, empty5()];
        }
        const builder = [];
        let from2 = 0;
        let until = 0;
        let key = void 0;
        let previousChunk = empty5();
        switch (state._tag) {
          case "Some": {
            const tuple4 = state.value;
            key = tuple4[0];
            let loop3 = true;
            while (loop3 && until < chunk4.length) {
              const input = unsafeGet4(chunk4, until);
              const updatedKey = f(input);
              if (!equals(key, updatedKey)) {
                const previousChunk2 = tuple4[1];
                const additionalChunk = unsafeFromArray(Array.from(chunk4).slice(from2, until));
                const group3 = appendAll2(previousChunk2, additionalChunk);
                builder.push([key, group3]);
                key = updatedKey;
                from2 = until;
                loop3 = false;
              }
              until = until + 1;
            }
            if (loop3) {
              previousChunk = tuple4[1];
            }
            break;
          }
          case "None": {
            key = f(unsafeGet4(chunk4, until));
            until = until + 1;
            break;
          }
        }
        while (until < chunk4.length) {
          const input = unsafeGet4(chunk4, until);
          const updatedKey = f(input);
          if (!equals(key, updatedKey)) {
            builder.push([key, unsafeFromArray(Array.from(chunk4).slice(from2, until))]);
            key = updatedKey;
            from2 = until;
          }
          until = until + 1;
        }
        const nonEmptyChunk = appendAll2(previousChunk, unsafeFromArray(Array.from(chunk4).slice(from2, until)));
        const output = unsafeFromArray(builder);
        return [some2([key, nonEmptyChunk]), output];
      }, "groupAdjacentByChunk");
      const groupAdjacent = /* @__PURE__ */ __name((state) => readWithCause({
        onInput: /* @__PURE__ */ __name((input) => {
          const [updatedState, output] = groupAdjacentByChunk(state, input);
          return isEmpty(output) ? groupAdjacent(updatedState) : flatMap13(write(output), () => groupAdjacent(updatedState));
        }, "onInput"),
        onFailure: /* @__PURE__ */ __name((cause3) => match2(state, {
          onNone: /* @__PURE__ */ __name(() => failCause10(cause3), "onNone"),
          onSome: /* @__PURE__ */ __name((output) => flatMap13(write(of2(output)), () => failCause10(cause3)), "onSome")
        }), "onFailure"),
        onDone: /* @__PURE__ */ __name((done13) => match2(state, {
          onNone: /* @__PURE__ */ __name(() => succeedNow(done13), "onNone"),
          onSome: /* @__PURE__ */ __name((output) => flatMap13(write(of2(output)), () => succeedNow(done13)), "onSome")
        }), "onDone")
      }), "groupAdjacent");
      return new StreamImpl(pipeToOrFail(toChannel2(self2), groupAdjacent(none2())));
    });
    grouped = /* @__PURE__ */ dual(2, (self2, chunkSize) => pipe(self2, rechunk(chunkSize), chunks));
    groupedWithin = /* @__PURE__ */ dual(3, (self2, chunkSize, duration6) => aggregateWithin(self2, collectAllN(chunkSize), spaced2(duration6)));
    haltWhen = /* @__PURE__ */ dual(2, (self2, effect4) => {
      const writer = /* @__PURE__ */ __name((fiber) => pipe(poll4(fiber), map18(match2({
        onNone: /* @__PURE__ */ __name(() => readWith({
          onInput: /* @__PURE__ */ __name((input) => flatMap13(write(input), () => writer(fiber)), "onInput"),
          onFailure: fail11,
          onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
        }), "onNone"),
        onSome: match6({
          onFailure: failCause10,
          onSuccess: /* @__PURE__ */ __name(() => void_6, "onSuccess")
        })
      })), unwrap), "writer");
      return new StreamImpl(unwrapScopedWith((scope5) => effect4.pipe(forkIn2(scope5), map18((fiber) => toChannel2(self2).pipe(pipeTo(writer(fiber)))))));
    });
    haltAfter = /* @__PURE__ */ dual(2, (self2, duration6) => pipe(self2, haltWhen(sleep2(duration6))));
    haltWhenDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => {
      const writer = pipe(poll(deferred), map18(match2({
        onNone: /* @__PURE__ */ __name(() => readWith({
          onInput: /* @__PURE__ */ __name((input) => pipe(write(input), flatMap13(() => writer)), "onInput"),
          onFailure: fail11,
          onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
        }), "onNone"),
        onSome: /* @__PURE__ */ __name((effect4) => unwrap(match13(effect4, {
          onFailure: fail11,
          onSuccess: /* @__PURE__ */ __name(() => void_6, "onSuccess")
        })), "onSome")
      })), unwrap);
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer)));
    });
    identityStream = /* @__PURE__ */ __name(() => new StreamImpl(identityChannel()), "identityStream");
    interleave = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, interleaveWith(that, forever5(make52(true, false)))));
    interleaveWith = /* @__PURE__ */ dual(3, (self2, that, decider) => {
      const producer = /* @__PURE__ */ __name((handoff) => readWithCause({
        onInput: /* @__PURE__ */ __name((value3) => flatMap13(fromEffect4(offer5(handoff, of5(value3))), () => producer(handoff)), "onInput"),
        onFailure: /* @__PURE__ */ __name((cause3) => fromEffect4(offer5(handoff, failCause11(cause3))), "onFailure"),
        onDone: /* @__PURE__ */ __name(() => fromEffect4(offer5(handoff, end4)), "onDone")
      }), "producer");
      return new StreamImpl(unwrapScopedWith((scope5) => pipe(make51(), zip5(make51()), tap4(([left3]) => toChannel2(self2).pipe(concatMap(writeChunk), pipeTo(producer(left3)), runIn(scope5), forkIn2(scope5))), tap4(([_, right3]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3)), runIn(scope5), forkIn2(scope5))), map18(([left3, right3]) => {
        const process4 = /* @__PURE__ */ __name((leftDone, rightDone) => readWithCause({
          onInput: /* @__PURE__ */ __name((bool) => {
            if (bool && !leftDone) {
              return pipe(fromEffect4(take6(left3)), flatMap13(match18({
                onEnd: /* @__PURE__ */ __name(() => rightDone ? void_6 : process4(true, rightDone), "onEnd"),
                onFailure: failCause10,
                onSuccess: /* @__PURE__ */ __name((chunk4) => pipe(write(chunk4), flatMap13(() => process4(leftDone, rightDone))), "onSuccess")
              })));
            }
            if (!bool && !rightDone) {
              return pipe(fromEffect4(take6(right3)), flatMap13(match18({
                onEnd: /* @__PURE__ */ __name(() => leftDone ? void_6 : process4(leftDone, true), "onEnd"),
                onFailure: failCause10,
                onSuccess: /* @__PURE__ */ __name((chunk4) => pipe(write(chunk4), flatMap13(() => process4(leftDone, rightDone))), "onSuccess")
              })));
            }
            return process4(leftDone, rightDone);
          }, "onInput"),
          onFailure: failCause10,
          onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
        }), "process");
        return pipe(toChannel2(decider), concatMap(writeChunk), pipeTo(process4(false, false)));
      }))));
    });
    intersperse = /* @__PURE__ */ dual(2, (self2, element2) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(suspend6(() => {
      const writer = /* @__PURE__ */ __name((isFirst) => readWithCause({
        onInput: /* @__PURE__ */ __name((chunk4) => {
          const builder = [];
          let flagResult = isFirst;
          for (const output of chunk4) {
            if (flagResult) {
              flagResult = false;
              builder.push(output);
            } else {
              builder.push(element2);
              builder.push(output);
            }
          }
          return pipe(write(unsafeFromArray(builder)), flatMap13(() => writer(flagResult)));
        }, "onInput"),
        onFailure: failCause10,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      }), "writer");
      return writer(true);
    })))));
    intersperseAffixes = /* @__PURE__ */ dual(2, (self2, {
      end: end6,
      middle,
      start: start5
    }) => pipe(make52(start5), concat2(pipe(self2, intersperse(middle))), concat2(make52(end6))));
    interruptAfter = /* @__PURE__ */ dual(2, (self2, duration6) => pipe(self2, interruptWhen2(sleep2(duration6))));
    interruptWhen2 = /* @__PURE__ */ dual(2, (self2, effect4) => new StreamImpl(pipe(toChannel2(self2), interruptWhen(effect4))));
    interruptWhenDeferred2 = /* @__PURE__ */ dual(2, (self2, deferred) => new StreamImpl(pipe(toChannel2(self2), interruptWhenDeferred(deferred))));
    iterate3 = /* @__PURE__ */ __name((value3, next4) => unfold4(value3, (a) => some2([a, next4(a)])), "iterate");
    make52 = /* @__PURE__ */ __name((...as12) => fromIterable14(as12), "make");
    map24 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOut(map5(f)))));
    mapAccum5 = /* @__PURE__ */ dual(3, (self2, s, f) => {
      const accumulator = /* @__PURE__ */ __name((s2) => readWith({
        onInput: /* @__PURE__ */ __name((input) => {
          const [nextS, chunk4] = mapAccum2(input, s2, f);
          return flatMap13(write(chunk4), () => accumulator(nextS));
        }, "onInput"),
        onFailure: fail11,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      }), "accumulator");
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(accumulator(s))));
    });
    mapAccumEffect = /* @__PURE__ */ dual(3, (self2, s, f) => suspend10(() => {
      const accumulator = /* @__PURE__ */ __name((s2) => readWith({
        onInput: /* @__PURE__ */ __name((input) => pipe(suspend4(() => {
          const outputs = [];
          const emit3 = /* @__PURE__ */ __name((output) => sync5(() => {
            outputs.push(output);
          }), "emit");
          return pipe(input, reduce12(s2, (s3, a) => pipe(f(s3, a), flatMap11(([s4, a2]) => pipe(emit3(a2), as6(s4))))), match13({
            onFailure: /* @__PURE__ */ __name((error50) => {
              if (outputs.length !== 0) {
                return zipRight6(write(unsafeFromArray(outputs)), fail11(error50));
              }
              return fail11(error50);
            }, "onFailure"),
            onSuccess: /* @__PURE__ */ __name((s3) => flatMap13(write(unsafeFromArray(outputs)), () => accumulator(s3)), "onSuccess")
          }));
        }), unwrap), "onInput"),
        onFailure: fail11,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      }), "accumulator");
      return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(accumulator(s))));
    }));
    mapBoth7 = /* @__PURE__ */ dual(2, (self2, options) => pipe(self2, mapError6(options.onFailure), map24(options.onSuccess)));
    mapChunks = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOut(f))));
    mapChunksEffect = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOutEffect(f))));
    mapConcat = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapConcatChunk((a) => fromIterable3(f(a)))));
    mapConcatChunk = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapChunks(flatMap3(f))));
    mapConcatChunkEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapEffectSequential(f), mapConcatChunk(identity)));
    mapConcatEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapEffectSequential((a) => pipe(f(a), map18(fromIterable3))), mapConcatChunk(identity)));
    mapEffectSequential = /* @__PURE__ */ dual(2, (self2, f) => {
      const loop3 = /* @__PURE__ */ __name((iterator2) => {
        const next4 = iterator2.next();
        if (next4.done) {
          return readWithCause({
            onInput: /* @__PURE__ */ __name((elem) => loop3(elem[Symbol.iterator]()), "onInput"),
            onFailure: failCause10,
            onDone: succeed11
          });
        } else {
          const value3 = next4.value;
          return unwrap(map18(f(value3), (a2) => flatMap13(write(of2(a2)), () => loop3(iterator2))));
        }
      }, "loop");
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(suspend6(() => loop3(empty5()[Symbol.iterator]())))));
    });
    mapEffectPar = /* @__PURE__ */ dual(3, (self2, n, f) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mapOutEffectPar(f, n), mapOut(of2))));
    mapError6 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapError5(f))));
    mapErrorCause4 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapErrorCause3(f))));
    merge9 = /* @__PURE__ */ dual((args2) => isStream(args2[1]), (self2, that, options) => mergeWith3(self2, that, {
      onSelf: identity,
      onOther: identity,
      haltStrategy: options?.haltStrategy
    }));
    mergeAll8 = /* @__PURE__ */ dual((args2) => Symbol.iterator in args2[0], (streams, options) => flatten14(fromIterable14(streams), options));
    mergeWithTag = /* @__PURE__ */ dual(2, (streams, options) => {
      const keys5 = Object.keys(streams);
      const values4 = keys5.map((key) => streams[key].pipe(map24((value3) => ({
        _tag: key,
        value: value3
      }))));
      return mergeAll8(values4, options);
    });
    mergeEither = /* @__PURE__ */ dual(2, (self2, that) => mergeWith3(self2, that, {
      onSelf: left2,
      onOther: right2
    }));
    mergeLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, merge9(drain3(right3))));
    mergeRight = /* @__PURE__ */ dual(2, (left3, right3) => pipe(drain3(left3), merge9(right3)));
    mergeWith3 = /* @__PURE__ */ dual(3, (self2, other, options) => {
      const strategy = options.haltStrategy ? fromInput2(options.haltStrategy) : Both2;
      const handler = /* @__PURE__ */ __name((terminate) => (exit5) => terminate || !isSuccess(exit5) ? (
        // TODO: remove
        Done4(suspend4(() => exit5))
      ) : Await2((exit6) => suspend4(() => exit6)), "handler");
      return new StreamImpl(mergeWith2(toChannel2(map24(self2, options.onSelf)), {
        other: toChannel2(map24(other, options.onOther)),
        onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
        onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
      }));
    });
    mkString2 = /* @__PURE__ */ __name((self2) => run4(self2, mkString), "mkString");
    never4 = /* @__PURE__ */ fromEffect7(never3);
    onEnd = /* @__PURE__ */ dual(2, (self2, effect4) => concat2(self2, drain3(fromEffect7(effect4))));
    onError3 = /* @__PURE__ */ dual(2, (self2, cleanup) => pipe(self2, catchAllCause6((cause3) => fromEffect7(pipe(cleanup(cause3), zipRight5(failCause8(cause3)))))));
    onDone = /* @__PURE__ */ dual(2, (self2, cleanup) => new StreamImpl(pipe(toChannel2(self2), ensuringWith((exit5) => isSuccess(exit5) ? cleanup() : _void))));
    onStart = /* @__PURE__ */ dual(2, (self2, effect4) => unwrap2(as6(effect4, self2)));
    orDie5 = /* @__PURE__ */ __name((self2) => pipe(self2, orDieWith4(identity)), "orDie");
    orDieWith4 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), orDieWith3(f))));
    orElse8 = /* @__PURE__ */ dual(2, (self2, that) => new StreamImpl(pipe(toChannel2(self2), orElse7(() => toChannel2(that())))));
    orElseEither4 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, map24(left2), orElse8(() => pipe(that(), map24(right2)))));
    orElseFail3 = /* @__PURE__ */ dual(2, (self2, error50) => pipe(self2, orElse8(() => failSync7(error50))));
    orElseIfEmpty = /* @__PURE__ */ dual(2, (self2, element2) => pipe(self2, orElseIfEmptyChunk(() => of2(element2()))));
    orElseIfEmptyChunk = /* @__PURE__ */ dual(2, (self2, chunk4) => pipe(self2, orElseIfEmptyStream(() => new StreamImpl(write(chunk4())))));
    orElseIfEmptyStream = /* @__PURE__ */ dual(2, (self2, stream2) => {
      const writer = readWith({
        onInput: /* @__PURE__ */ __name((input) => {
          if (isEmpty(input)) {
            return suspend6(() => writer);
          }
          return pipe(write(input), zipRight6(identityChannel()));
        }, "onInput"),
        onFailure: fail11,
        onDone: /* @__PURE__ */ __name(() => suspend6(() => toChannel2(stream2())), "onDone")
      });
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer)));
    });
    orElseSucceed3 = /* @__PURE__ */ dual(2, (self2, value3) => pipe(self2, orElse8(() => sync10(value3))));
    paginate = /* @__PURE__ */ __name((s, f) => paginateChunk(s, (s2) => {
      const page = f(s2);
      return [of2(page[0]), page[1]];
    }), "paginate");
    paginateChunk = /* @__PURE__ */ __name((s, f) => {
      const loop3 = /* @__PURE__ */ __name((s2) => {
        const page = f(s2);
        return match2(page[1], {
          onNone: /* @__PURE__ */ __name(() => zipRight6(write(page[0]), void_6), "onNone"),
          onSome: /* @__PURE__ */ __name((s3) => flatMap13(write(page[0]), () => loop3(s3)), "onSome")
        });
      }, "loop");
      return new StreamImpl(suspend6(() => loop3(s)));
    }, "paginateChunk");
    paginateChunkEffect = /* @__PURE__ */ __name((s, f) => {
      const loop3 = /* @__PURE__ */ __name((s2) => unwrap(map18(f(s2), ([chunk4, option5]) => match2(option5, {
        onNone: /* @__PURE__ */ __name(() => zipRight6(write(chunk4), void_6), "onNone"),
        onSome: /* @__PURE__ */ __name((s3) => flatMap13(write(chunk4), () => loop3(s3)), "onSome")
      }))), "loop");
      return new StreamImpl(suspend6(() => loop3(s)));
    }, "paginateChunkEffect");
    paginateEffect = /* @__PURE__ */ __name((s, f) => paginateChunkEffect(s, (s2) => pipe(f(s2), map18(([a, s3]) => [of2(a), s3]))), "paginateEffect");
    peel = /* @__PURE__ */ dual(2, (self2, sink) => {
      const OP_EMIT5 = "Emit";
      const OP_HALT2 = "Halt";
      const OP_END2 = "End";
      return pipe(make19(), flatMap11((deferred) => pipe(make51(), map18((handoff) => {
        const consumer = foldSink(collectLeftover(sink), {
          onFailure: /* @__PURE__ */ __name((error50) => zipRight7(fromEffect6(fail3(deferred, error50)), fail12(error50)), "onFailure"),
          onSuccess: /* @__PURE__ */ __name(([z2, leftovers]) => {
            const loop3 = readWithCause({
              onInput: /* @__PURE__ */ __name((elements) => flatMap13(fromEffect4(offer5(handoff, {
                _tag: OP_EMIT5,
                elements
              })), () => loop3), "onInput"),
              onFailure: /* @__PURE__ */ __name((cause3) => zipRight6(fromEffect4(offer5(handoff, {
                _tag: OP_HALT2,
                cause: cause3
              })), failCause10(cause3)), "onFailure"),
              onDone: /* @__PURE__ */ __name((_) => zipRight6(fromEffect4(offer5(handoff, {
                _tag: OP_END2
              })), void_6), "onDone")
            });
            return fromChannel(pipe(fromEffect4(succeed2(deferred, z2)), zipRight6(fromEffect4(pipe(handoff, offer5({
              _tag: OP_EMIT5,
              elements: leftovers
            })))), zipRight6(loop3)));
          }, "onSuccess")
        });
        const producer = pipe(take6(handoff), map18((signal) => {
          switch (signal._tag) {
            case OP_EMIT5: {
              return pipe(write(signal.elements), flatMap13(() => producer));
            }
            case OP_HALT2: {
              return failCause10(signal.cause);
            }
            case OP_END2: {
              return void_6;
            }
          }
        }), unwrap);
        return pipe(self2, tapErrorCause5((cause3) => failCause2(deferred, cause3)), run4(consumer), forkScoped2, zipRight5(_await(deferred)), map18((z2) => [z2, new StreamImpl(producer)]));
      }))), flatten10);
    });
    partition5 = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self2, predicate, options) => partitionEither(self2, (a) => succeed9(predicate(a) ? right2(a) : left2(a)), options));
    partitionEither = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self2, predicate, options) => pipe(mapEffectSequential(self2, predicate), distributedWith({
      size: 2,
      maximumLag: options?.bufferSize ?? 16,
      decide: match({
        onLeft: /* @__PURE__ */ __name(() => succeed9((n) => n === 0), "onLeft"),
        onRight: /* @__PURE__ */ __name(() => succeed9((n) => n === 1), "onRight")
      })
    }), flatMap11(([queue1, queue2]) => succeed9([filterMap7(flattenExitOption(fromQueue2(queue1, {
      shutdown: true
    })), (_) => match(_, {
      onLeft: some2,
      onRight: none2
    })), filterMap7(flattenExitOption(fromQueue2(queue2, {
      shutdown: true
    })), (_) => match(_, {
      onLeft: none2,
      onRight: some2
    }))]))));
    pipeThrough = /* @__PURE__ */ dual(2, (self2, sink) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(toChannel(sink)))));
    pipeThroughChannel = /* @__PURE__ */ dual(2, (self2, channel2) => new StreamImpl(pipeTo(toChannel2(self2), channel2)));
    pipeThroughChannelOrFail = /* @__PURE__ */ dual(2, (self2, chan) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(chan))));
    prepend4 = /* @__PURE__ */ dual(2, (self2, values4) => new StreamImpl(zipRight6(write(values4), toChannel2(self2))));
    provideContext6 = /* @__PURE__ */ dual(2, (self2, context10) => new StreamImpl(pipe(toChannel2(self2), provideContext4(context10))));
    provideSomeContext2 = /* @__PURE__ */ dual(2, (self2, context10) => mapInputContext6(self2, merge3(context10)));
    provideLayer = /* @__PURE__ */ dual(2, (self2, layer) => new StreamImpl(unwrapScopedWith((scope5) => buildWithScope2(layer, scope5).pipe(map18((env2) => pipe(toChannel2(self2), provideContext4(env2)))))));
    provideService6 = /* @__PURE__ */ dual(3, (self2, tag2, resource) => provideServiceEffect3(self2, tag2, succeed9(resource)));
    provideServiceEffect3 = /* @__PURE__ */ dual(3, (self2, tag2, effect4) => provideServiceStream(self2, tag2, fromEffect7(effect4)));
    provideServiceStream = /* @__PURE__ */ dual(3, (self2, tag2, stream2) => contextWithStream((env2) => flatMap16(stream2, (service3) => pipe(self2, provideContext6(add2(env2, tag2, service3))))));
    mapInputContext6 = /* @__PURE__ */ dual(2, (self2, f) => contextWithStream((env2) => pipe(self2, provideContext6(f(env2)))));
    provideSomeLayer2 = /* @__PURE__ */ dual(2, (self2, layer) => (
      // @ts-expect-error
      // @effect-diagnostics-next-line missingEffectContext:off
      pipe(self2, provideLayer(pipe(context6(), merge8(layer))))
    ));
    range2 = /* @__PURE__ */ __name((min4, max6, chunkSize = DefaultChunkSize) => suspend10(() => {
      if (min4 > max6) {
        return empty34;
      }
      const go3 = /* @__PURE__ */ __name((min5, max7, chunkSize2) => {
        const remaining = max7 - min5 + 1;
        if (remaining > chunkSize2) {
          return pipe(write(range(min5, min5 + chunkSize2 - 1)), flatMap13(() => go3(min5 + chunkSize2, max7, chunkSize2)));
        }
        return write(range(min5, min5 + remaining - 1));
      }, "go");
      return new StreamImpl(go3(min4, max6, chunkSize));
    }), "range");
    race3 = /* @__PURE__ */ dual(2, (left3, right3) => raceAll3(left3, right3));
    raceAll3 = /* @__PURE__ */ __name((...streams) => make19().pipe(map18((halt2) => {
      let winner = null;
      return mergeAll8(streams.map((stream2, index2) => stream2.pipe(takeWhile4(() => {
        if (winner === null) {
          winner = index2;
          unsafeDone(halt2, void_3);
          return true;
        }
        return winner === index2;
      }), interruptWhen2(_await(halt2).pipe(flatMap11(() => winner === index2 ? never3 : _void))))), {
        concurrency: streams.length
      });
    }), unwrap2), "raceAll");
    rechunk = /* @__PURE__ */ dual(2, (self2, n) => suspend10(() => {
      const target = Math.max(n, 1);
      const process4 = rechunkProcess(new StreamRechunker(target), target);
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(process4)));
    }));
    rechunkProcess = /* @__PURE__ */ __name((rechunker, target) => readWithCause({
      onInput: /* @__PURE__ */ __name((chunk4) => {
        if (chunk4.length === target && rechunker.isEmpty()) {
          return flatMap13(write(chunk4), () => rechunkProcess(rechunker, target));
        }
        if (chunk4.length > 0) {
          const chunks3 = [];
          let result = void 0;
          let index2 = 0;
          while (index2 < chunk4.length) {
            while (index2 < chunk4.length && result === void 0) {
              result = rechunker.write(pipe(chunk4, unsafeGet4(index2)));
              index2 = index2 + 1;
            }
            if (result !== void 0) {
              chunks3.push(result);
              result = void 0;
            }
          }
          return flatMap13(writeAll(...chunks3), () => rechunkProcess(rechunker, target));
        }
        return suspend6(() => rechunkProcess(rechunker, target));
      }, "onInput"),
      onFailure: /* @__PURE__ */ __name((cause3) => zipRight6(rechunker.emitIfNotEmpty(), failCause10(cause3)), "onFailure"),
      onDone: /* @__PURE__ */ __name(() => rechunker.emitIfNotEmpty(), "onDone")
    }), "rechunkProcess");
    StreamRechunker = class {
      static {
        __name(this, "StreamRechunker");
      }
      n;
      builder = [];
      pos = 0;
      constructor(n) {
        this.n = n;
      }
      isEmpty() {
        return this.pos === 0;
      }
      write(elem) {
        this.builder.push(elem);
        this.pos += 1;
        if (this.pos === this.n) {
          const result = unsafeFromArray(this.builder);
          this.builder = [];
          this.pos = 0;
          return result;
        }
        return void 0;
      }
      emitIfNotEmpty() {
        if (this.pos !== 0) {
          return write(unsafeFromArray(this.builder));
        }
        return void_6;
      }
    };
    refineOrDie = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, refineOrDieWith(pf, identity)));
    refineOrDieWith = /* @__PURE__ */ dual(3, (self2, pf, f) => new StreamImpl(catchAll5(toChannel2(self2), (error50) => match2(pf(error50), {
      onNone: /* @__PURE__ */ __name(() => failCause10(die4(f(error50))), "onNone"),
      onSome: fail11
    }))));
    repeat2 = /* @__PURE__ */ dual(2, (self2, schedule4) => filterMap7(repeatEither(self2, schedule4), (_) => match(_, {
      onLeft: none2,
      onRight: some2
    })));
    repeatEffect = /* @__PURE__ */ __name((effect4) => repeatEffectOption(pipe(effect4, mapError3(some2))), "repeatEffect");
    repeatEffectChunk = /* @__PURE__ */ __name((effect4) => repeatEffectChunkOption(pipe(effect4, mapError3(some2))), "repeatEffectChunk");
    repeatEffectChunkOption = /* @__PURE__ */ __name((effect4) => unfoldChunkEffect(effect4, (effect5) => pipe(map18(effect5, (chunk4) => some2([chunk4, effect5])), catchAll3(match2({
      onNone: /* @__PURE__ */ __name(() => succeed9(none2()), "onNone"),
      onSome: fail9
    })))), "repeatEffectChunkOption");
    repeatEffectOption = /* @__PURE__ */ __name((effect4) => repeatEffectChunkOption(pipe(effect4, map18(of2))), "repeatEffectOption");
    repeatEither = /* @__PURE__ */ dual(2, (self2, schedule4) => repeatWith(self2, schedule4, {
      onElement: /* @__PURE__ */ __name((a) => right2(a), "onElement"),
      onSchedule: left2
    }));
    repeatElements = /* @__PURE__ */ dual(2, (self2, schedule4) => filterMap7(repeatElementsWith(self2, schedule4, {
      onElement: /* @__PURE__ */ __name((a) => some2(a), "onElement"),
      onSchedule: none2
    }), identity));
    repeatElementsWith = /* @__PURE__ */ dual(3, (self2, schedule4, options) => {
      const driver3 = pipe(driver2(schedule4), map18((driver4) => {
        const feed = /* @__PURE__ */ __name((input) => match2(head2(input), {
          onNone: /* @__PURE__ */ __name(() => loop3, "onNone"),
          onSome: /* @__PURE__ */ __name((a) => zipRight6(write(of2(options.onElement(a))), step4(pipe(input, drop2(1)), a)), "onSome")
        }), "feed");
        const step4 = /* @__PURE__ */ __name((input, a) => {
          const advance = pipe(driver4.next(a), as6(pipe(write(of2(options.onElement(a))), flatMap13(() => step4(input, a)))));
          const reset = pipe(driver4.last, orDie3, flatMap11((b) => pipe(driver4.reset, map18(() => pipe(write(of2(options.onSchedule(b))), zipRight6(feed(input)))))));
          return pipe(advance, orElse5(() => reset), unwrap);
        }, "step");
        const loop3 = readWith({
          onInput: feed,
          onFailure: fail11,
          onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
        });
        return loop3;
      }), unwrap);
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(driver3)));
    });
    repeatValue = /* @__PURE__ */ __name((value3) => new StreamImpl(repeated(write(of2(value3)))), "repeatValue");
    repeatWith = /* @__PURE__ */ dual(3, (self2, schedule4, options) => {
      return pipe(driver2(schedule4), map18((driver3) => {
        const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get12(driver3.iterationMeta));
        const process4 = pipe(self2, provideLastIterationInfo, map24(options.onElement), toChannel2);
        const loop3 = unwrap(match13(driver3.next(void 0), {
          onFailure: /* @__PURE__ */ __name(() => void_6, "onFailure"),
          onSuccess: /* @__PURE__ */ __name((output) => flatMap13(process4, () => zipRight6(write(of2(options.onSchedule(output))), loop3)), "onSuccess")
        }));
        return new StreamImpl(zipRight6(process4, loop3));
      }), unwrap2);
    });
    repeatWithSchedule = /* @__PURE__ */ __name((value3, schedule4) => repeatEffectWithSchedule(succeed9(value3), schedule4), "repeatWithSchedule");
    repeatEffectWithSchedule = /* @__PURE__ */ __name((effect4, schedule4) => flatMap16(fromEffect7(zip5(effect4, driver2(schedule4))), ([a, driver3]) => {
      const provideLastIterationInfo = provideServiceEffect2(CurrentIterationMetadata2, get12(driver3.iterationMeta));
      return concat2(succeed15(a), unfoldEffect(a, (s) => matchEffect2(driver3.next(s), {
        onFailure: succeed9,
        onSuccess: /* @__PURE__ */ __name(() => map18(provideLastIterationInfo(effect4), (nextA) => some2([nextA, nextA])), "onSuccess")
      })));
    }), "repeatEffectWithSchedule");
    retry6 = /* @__PURE__ */ dual(2, (self2, policy) => driver2(policy).pipe(map18((driver3) => {
      const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get12(driver3.iterationMeta));
      const loop3 = toChannel2(provideLastIterationInfo(self2)).pipe(mapOutEffect((out) => as6(driver3.reset, out)), catchAll5((error50) => driver3.next(error50).pipe(match13({
        onFailure: /* @__PURE__ */ __name(() => fail11(error50), "onFailure"),
        onSuccess: /* @__PURE__ */ __name(() => loop3, "onSuccess")
      }), unwrap)));
      return loop3;
    }), unwrap, fromChannel2));
    withExecutionPlan3 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, policy, options) => suspend10(() => {
      const preventFallbackOnPartialStream = options?.preventFallbackOnPartialStream ?? false;
      let i = 0;
      let lastError = none2();
      const loop3 = suspend10(() => {
        const step4 = policy.steps[i++];
        if (!step4) {
          return fail15(getOrThrow2(lastError));
        }
        let nextStream = isContext2(step4.provide) ? provideSomeContext2(self2, step4.provide) : provideSomeLayer2(self2, step4.provide);
        let receivedElements = false;
        if (isSome2(lastError)) {
          const error50 = lastError.value;
          let attempted = false;
          const wrapped = nextStream;
          nextStream = suspend10(() => {
            if (attempted) return wrapped;
            attempted = true;
            return fail15(error50);
          });
          nextStream = scheduleDefectRefail2(retry6(nextStream, scheduleFromStep(step4, false)));
        } else {
          const schedule4 = scheduleFromStep(step4, true);
          nextStream = schedule4 ? scheduleDefectRefail2(retry6(nextStream, schedule4)) : nextStream;
        }
        return catchAll7(preventFallbackOnPartialStream ? mapChunks(nextStream, (chunk4) => {
          receivedElements = true;
          return chunk4;
        }) : nextStream, (error50) => {
          if (preventFallbackOnPartialStream && receivedElements) {
            return fail15(error50);
          }
          lastError = some2(error50);
          return loop3;
        });
      });
      return loop3;
    }));
    scheduleDefectRefail2 = /* @__PURE__ */ __name((self2) => catchAllCause6(self2, (cause3) => failCause13(scheduleDefectRefailCause(cause3))), "scheduleDefectRefail");
    run4 = /* @__PURE__ */ dual(2, (self2, sink) => toChannel2(self2).pipe(pipeToOrFail(toChannel(sink)), runDrain));
    runCollect = /* @__PURE__ */ __name((self2) => run4(self2, collectAll()), "runCollect");
    runCount = /* @__PURE__ */ __name((self2) => run4(self2, count4), "runCount");
    runDrain2 = /* @__PURE__ */ __name((self2) => run4(self2, drain2), "runDrain");
    runFold = /* @__PURE__ */ dual(3, (self2, s, f) => runFoldWhile(self2, s, constTrue, f));
    runFoldEffect = /* @__PURE__ */ dual(3, (self2, s, f) => runFoldWhileEffect(self2, s, constTrue, f));
    runFoldScoped = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, runFoldWhileScoped(s, constTrue, f)));
    runFoldScopedEffect = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, runFoldWhileScopedEffect(s, constTrue, f)));
    runFoldWhile = /* @__PURE__ */ dual(4, (self2, s, cont, f) => run4(self2, fold(s, cont, f)));
    runFoldWhileEffect = /* @__PURE__ */ dual(4, (self2, s, cont, f) => run4(self2, foldEffect(s, cont, f)));
    runFoldWhileScoped = /* @__PURE__ */ dual(4, (self2, s, cont, f) => pipe(self2, runScoped2(fold(s, cont, f))));
    runFoldWhileScopedEffect = /* @__PURE__ */ dual(4, (self2, s, cont, f) => pipe(self2, runScoped2(foldEffect(s, cont, f))));
    runForEach = /* @__PURE__ */ dual(2, (self2, f) => run4(self2, forEach10(f)));
    runForEachChunk = /* @__PURE__ */ dual(2, (self2, f) => run4(self2, forEachChunk(f)));
    runForEachChunkScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEachChunk(f))));
    runForEachScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEach10(f))));
    runForEachWhile = /* @__PURE__ */ dual(2, (self2, f) => run4(self2, forEachWhile(f)));
    runForEachWhileScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEachWhile(f))));
    runHead = /* @__PURE__ */ __name((self2) => run4(self2, head5()), "runHead");
    runIntoPubSub = /* @__PURE__ */ dual(2, (self2, pubsub) => pipe(self2, runIntoQueue(pubsub)));
    runIntoPubSubScoped = /* @__PURE__ */ dual(2, (self2, pubsub) => pipe(self2, runIntoQueueScoped(pubsub)));
    runIntoQueue = /* @__PURE__ */ dual(2, (self2, queue) => pipe(self2, runIntoQueueScoped(queue), scoped2));
    runIntoQueueElementsScoped = /* @__PURE__ */ dual(2, (self2, queue) => {
      const writer = readWithCause({
        onInput: /* @__PURE__ */ __name((input) => flatMap13(fromEffect4(offerAll3(queue, map5(input, succeed3))), () => writer), "onInput"),
        onFailure: /* @__PURE__ */ __name((cause3) => fromEffect4(offer3(queue, failCause3(map14(cause3, some2)))), "onFailure"),
        onDone: /* @__PURE__ */ __name(() => fromEffect4(offer3(queue, fail4(none2()))), "onDone")
      });
      return pipe(pipeTo(toChannel2(self2), writer), drain, runScoped, asVoid4);
    });
    runIntoQueueScoped = /* @__PURE__ */ dual(2, (self2, queue) => {
      const writer = readWithCause({
        onInput: /* @__PURE__ */ __name((input) => flatMap13(write(chunk2(input)), () => writer), "onInput"),
        onFailure: /* @__PURE__ */ __name((cause3) => write(failCause11(cause3)), "onFailure"),
        onDone: /* @__PURE__ */ __name(() => write(end4), "onDone")
      });
      return pipe(pipeTo(toChannel2(self2), writer), mapOutEffect((take10) => offer3(queue, take10)), drain, runScoped, asVoid4);
    });
    runLast = /* @__PURE__ */ __name((self2) => run4(self2, last4()), "runLast");
    runScoped2 = /* @__PURE__ */ dual(2, (self2, sink) => pipe(toChannel2(self2), pipeToOrFail(toChannel(sink)), drain, runScoped));
    runSum = /* @__PURE__ */ __name((self2) => run4(self2, sum2), "runSum");
    scan = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, scanEffect(s, (s2, a) => succeed9(f(s2, a)))));
    scanReduce = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, scanReduceEffect((a2, a) => succeed9(f(a2, a)))));
    scanReduceEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapAccumEffect(none2(), (option5, a) => {
      switch (option5._tag) {
        case "None": {
          return succeed9([some2(a), a]);
        }
        case "Some": {
          return pipe(f(option5.value, a), map18((b) => [some2(b), b]));
        }
      }
    })));
    schedule2 = /* @__PURE__ */ dual(2, (self2, schedule4) => filterMap7(scheduleWith(self2, schedule4, {
      onElement: some2,
      onSchedule: none2
    }), identity));
    scheduleWith = /* @__PURE__ */ dual(3, (self2, schedule4, options) => {
      const loop3 = /* @__PURE__ */ __name((driver3, iterator2) => {
        const next4 = iterator2.next();
        if (next4.done) {
          return readWithCause({
            onInput: /* @__PURE__ */ __name((chunk4) => loop3(driver3, chunk4[Symbol.iterator]()), "onInput"),
            onFailure: failCause10,
            onDone: succeedNow
          });
        }
        return unwrap(matchEffect2(driver3.next(next4.value), {
          onFailure: /* @__PURE__ */ __name(() => pipe(driver3.last, orDie3, map18((b) => pipe(write(make7(options.onElement(next4.value), options.onSchedule(b))), flatMap13(() => loop3(driver3, iterator2)))), zipLeft4(driver3.reset)), "onFailure"),
          onSuccess: /* @__PURE__ */ __name(() => succeed9(pipe(write(of2(options.onElement(next4.value))), flatMap13(() => loop3(driver3, iterator2)))), "onSuccess")
        }));
      }, "loop");
      return new StreamImpl(pipe(fromEffect4(driver2(schedule4)), flatMap13((driver3) => pipe(toChannel2(self2), pipeTo(loop3(driver3, empty5()[Symbol.iterator]()))))));
    });
    scanEffect = /* @__PURE__ */ dual(3, (self2, s, f) => new StreamImpl(pipe(write(of2(s)), flatMap13(() => toChannel2(pipe(self2, mapAccumEffect(s, (s2, a) => pipe(f(s2, a), map18((s3) => [s3, s3])))))))));
    scoped5 = /* @__PURE__ */ __name((effect4) => new StreamImpl(ensuring4(scoped4(pipe(effect4, map18(of2))), _void)), "scoped");
    scopedWith4 = /* @__PURE__ */ __name((f) => new StreamImpl(scopedWith3((scope5) => f(scope5).pipe(map18(of2)))), "scopedWith");
    some5 = /* @__PURE__ */ __name((self2) => pipe(self2, mapError6(some2), someOrFail(() => none2())), "some");
    someOrElse = /* @__PURE__ */ dual(2, (self2, fallback) => pipe(self2, map24(getOrElse(fallback))));
    someOrFail = /* @__PURE__ */ dual(2, (self2, error50) => mapEffectSequential(self2, match2({
      onNone: /* @__PURE__ */ __name(() => failSync3(error50), "onNone"),
      onSome: succeed9
    })));
    sliding7 = /* @__PURE__ */ dual(2, (self2, chunkSize) => slidingSize(self2, chunkSize, 1));
    slidingSize = /* @__PURE__ */ dual(3, (self2, chunkSize, stepSize) => {
      if (chunkSize <= 0 || stepSize <= 0) {
        return die10(new IllegalArgumentException2("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
      }
      return new StreamImpl(suspend6(() => {
        const queue = new RingBuffer(chunkSize);
        const emitOnStreamEnd = /* @__PURE__ */ __name((queueSize, channelEnd) => {
          if (queueSize < chunkSize) {
            const items = queue.toChunk();
            const result2 = isEmpty(items) ? empty5() : of2(items);
            return pipe(write(result2), flatMap13(() => channelEnd));
          }
          const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
          if (lastEmitIndex === queueSize) {
            return channelEnd;
          }
          const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
          const lastItems = pipe(queue.toChunk(), takeRight(leftovers));
          const result = isEmpty(lastItems) ? empty5() : of2(lastItems);
          return pipe(write(result), flatMap13(() => channelEnd));
        }, "emitOnStreamEnd");
        const reader = /* @__PURE__ */ __name((queueSize) => readWithCause({
          onInput: /* @__PURE__ */ __name((input) => flatMap13(write(filterMap3(input, (element2, index2) => {
            queue.put(element2);
            const currentIndex = queueSize + index2 + 1;
            if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
              return none2();
            }
            return some2(queue.toChunk());
          })), () => reader(queueSize + input.length)), "onInput"),
          onFailure: /* @__PURE__ */ __name((cause3) => emitOnStreamEnd(queueSize, failCause10(cause3)), "onFailure"),
          onDone: /* @__PURE__ */ __name(() => emitOnStreamEnd(queueSize, void_6), "onDone")
        }), "reader");
        return pipe(toChannel2(self2), pipeTo(reader(0)));
      }));
    });
    split = /* @__PURE__ */ dual(2, (self2, predicate) => {
      const split4 = /* @__PURE__ */ __name((leftovers, input) => {
        const [chunk4, remaining] = pipe(leftovers, appendAll2(input), splitWhere(predicate));
        if (isEmpty(chunk4) || isEmpty(remaining)) {
          return loop3(pipe(chunk4, appendAll2(pipe(remaining, drop2(1)))));
        }
        return pipe(write(of2(chunk4)), flatMap13(() => split4(empty5(), pipe(remaining, drop2(1)))));
      }, "split");
      const loop3 = /* @__PURE__ */ __name((leftovers) => readWith({
        onInput: /* @__PURE__ */ __name((input) => split4(leftovers, input), "onInput"),
        onFailure: fail11,
        onDone: /* @__PURE__ */ __name(() => {
          if (isEmpty(leftovers)) {
            return void_6;
          }
          if (isNone2(pipe(leftovers, findFirst3(predicate)))) {
            return zipRight6(write(of2(leftovers)), void_6);
          }
          return zipRight6(split4(empty5(), leftovers), void_6);
        }, "onDone")
      }), "loop");
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty5()))));
    });
    splitOnChunk = /* @__PURE__ */ dual(2, (self2, delimiter) => {
      const next4 = /* @__PURE__ */ __name((leftover, delimiterIndex) => readWithCause({
        onInput: /* @__PURE__ */ __name((inputChunk) => {
          let buffer3;
          const [carry, delimiterCursor] = pipe(inputChunk, reduce2([pipe(leftover, getOrElse(() => empty5())), delimiterIndex], ([carry2, delimiterCursor2], a) => {
            const concatenated = pipe(carry2, append2(a));
            if (delimiterCursor2 < delimiter.length && equals(a, pipe(delimiter, unsafeGet4(delimiterCursor2)))) {
              if (delimiterCursor2 + 1 === delimiter.length) {
                if (buffer3 === void 0) {
                  buffer3 = [];
                }
                buffer3.push(pipe(concatenated, take(concatenated.length - delimiter.length)));
                return [empty5(), 0];
              }
              return [concatenated, delimiterCursor2 + 1];
            }
            return [concatenated, equals(a, pipe(delimiter, unsafeGet4(0))) ? 1 : 0];
          }));
          const output = buffer3 === void 0 ? empty5() : unsafeFromArray(buffer3);
          return flatMap13(write(output), () => next4(isNonEmpty2(carry) ? some2(carry) : none2(), delimiterCursor));
        }, "onInput"),
        onFailure: /* @__PURE__ */ __name((cause3) => match2(leftover, {
          onNone: /* @__PURE__ */ __name(() => failCause10(cause3), "onNone"),
          onSome: /* @__PURE__ */ __name((chunk4) => zipRight6(write(of2(chunk4)), failCause10(cause3)), "onSome")
        }), "onFailure"),
        onDone: /* @__PURE__ */ __name((done13) => match2(leftover, {
          onNone: /* @__PURE__ */ __name(() => succeed11(done13), "onNone"),
          onSome: /* @__PURE__ */ __name((chunk4) => zipRight6(write(of2(chunk4)), succeed11(done13)), "onSome")
        }), "onDone")
      }), "next");
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(next4(none2(), 0))));
    });
    splitLines2 = /* @__PURE__ */ __name((self2) => pipeThroughChannel(self2, splitLines()), "splitLines");
    succeed15 = /* @__PURE__ */ __name((value3) => fromChunk(of2(value3)), "succeed");
    sync10 = /* @__PURE__ */ __name((evaluate3) => suspend10(() => fromChunk(of2(evaluate3()))), "sync");
    suspend10 = /* @__PURE__ */ __name((stream2) => new StreamImpl(suspend6(() => toChannel2(stream2()))), "suspend");
    take7 = /* @__PURE__ */ dual(2, (self2, n) => {
      if (!Number.isInteger(n)) {
        return die10(new IllegalArgumentException2(`${n} must be an integer`));
      }
      const loop3 = /* @__PURE__ */ __name((n2) => readWith({
        onInput: /* @__PURE__ */ __name((input) => {
          const taken = pipe(input, take(Math.min(n2, Number.POSITIVE_INFINITY)));
          const leftover = Math.max(0, n2 - taken.length);
          const more = leftover > 0;
          if (more) {
            return pipe(write(taken), flatMap13(() => loop3(leftover)));
          }
          return write(taken);
        }, "onInput"),
        onFailure: fail11,
        onDone: succeed11
      }), "loop");
      return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(0 < n ? loop3(n) : void_6)));
    });
    takeRight2 = /* @__PURE__ */ dual(2, (self2, n) => {
      if (n <= 0) {
        return empty34;
      }
      return new StreamImpl(pipe(succeed9(new RingBuffer(n)), map18((queue) => {
        const reader = readWith({
          onInput: /* @__PURE__ */ __name((input) => {
            for (const element2 of input) {
              queue.put(element2);
            }
            return reader;
          }, "onInput"),
          onFailure: fail11,
          onDone: /* @__PURE__ */ __name(() => pipe(write(queue.toChunk()), zipRight6(void_6)), "onDone")
        });
        return pipe(toChannel2(self2), pipeTo(reader));
      }), unwrap));
    });
    takeUntil3 = /* @__PURE__ */ dual(2, (self2, predicate) => {
      const loop3 = readWith({
        onInput: /* @__PURE__ */ __name((input) => {
          const taken = pipe(input, takeWhile((a) => !predicate(a)));
          const last6 = pipe(input, drop2(taken.length), take(1));
          if (isEmpty(last6)) {
            return pipe(write(taken), flatMap13(() => loop3));
          }
          return write(pipe(taken, appendAll2(last6)));
        }, "onInput"),
        onFailure: fail11,
        onDone: succeed11
      });
      return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
    });
    takeUntilEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
      const loop3 = /* @__PURE__ */ __name((iterator2) => {
        const next4 = iterator2.next();
        if (next4.done) {
          return readWithCause({
            onInput: /* @__PURE__ */ __name((elem) => loop3(elem[Symbol.iterator]()), "onInput"),
            onFailure: failCause10,
            onDone: succeed11
          });
        }
        return pipe(predicate(next4.value), map18((bool) => bool ? write(of2(next4.value)) : pipe(write(of2(next4.value)), flatMap13(() => loop3(iterator2)))), unwrap);
      }, "loop");
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty5()[Symbol.iterator]()))));
    });
    takeWhile4 = /* @__PURE__ */ dual(2, (self2, predicate) => {
      const loop3 = readWith({
        onInput: /* @__PURE__ */ __name((input) => {
          const taken = pipe(input, takeWhile(predicate));
          const more = taken.length === input.length;
          if (more) {
            return pipe(write(taken), flatMap13(() => loop3));
          }
          return write(taken);
        }, "onInput"),
        onFailure: fail11,
        onDone: succeed11
      });
      return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
    });
    tap7 = /* @__PURE__ */ dual(2, (self2, f) => mapEffectSequential(self2, (a) => as6(f(a), a)));
    tapBoth3 = /* @__PURE__ */ dual(2, (self2, options) => pipe(self2, tapError5(options.onFailure), tap7(options.onSuccess)));
    tapError5 = /* @__PURE__ */ dual(2, (self2, f) => catchAll7(self2, (error50) => fromEffect7(zipRight5(f(error50), fail9(error50)))));
    tapErrorCause5 = /* @__PURE__ */ dual(2, (self2, f) => {
      const loop3 = readWithCause({
        onInput: /* @__PURE__ */ __name((chunk4) => flatMap13(write(chunk4), () => loop3), "onInput"),
        onFailure: /* @__PURE__ */ __name((cause3) => fromEffect4(zipRight5(f(cause3), failCause8(cause3))), "onFailure"),
        onDone: succeedNow
      });
      return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
    });
    tapSink = /* @__PURE__ */ dual(2, (self2, sink) => pipe(fromEffect7(all6([bounded5(1), make19()])), flatMap16(([queue, deferred]) => {
      const right3 = flattenTake(fromQueue2(queue, {
        maxChunkSize: 1
      }));
      const loop3 = readWithCause({
        onInput: /* @__PURE__ */ __name((chunk4) => pipe(fromEffect4(offer3(queue, chunk2(chunk4))), foldCauseChannel({
          onFailure: /* @__PURE__ */ __name(() => flatMap13(write(chunk4), () => identityChannel()), "onFailure"),
          onSuccess: /* @__PURE__ */ __name(() => flatMap13(write(chunk4), () => loop3), "onSuccess")
        })), "onInput"),
        onFailure: /* @__PURE__ */ __name((cause3) => pipe(fromEffect4(offer3(queue, failCause11(cause3))), foldCauseChannel({
          onFailure: /* @__PURE__ */ __name(() => failCause10(cause3), "onFailure"),
          onSuccess: /* @__PURE__ */ __name(() => failCause10(cause3), "onSuccess")
        })), "onFailure"),
        onDone: /* @__PURE__ */ __name(() => pipe(fromEffect4(offer3(queue, end4)), foldCauseChannel({
          onFailure: /* @__PURE__ */ __name(() => void_6, "onFailure"),
          onSuccess: /* @__PURE__ */ __name(() => void_6, "onSuccess")
        })), "onDone")
      });
      return pipe(new StreamImpl(pipe(pipeTo(toChannel2(self2), loop3), ensuring4(zipRight5(forkDaemon2(offer3(queue, end4)), _await(deferred))))), merge9(execute(pipe(run4(right3, sink), ensuring3(zipRight5(shutdown4(queue), succeed2(deferred, void 0)))))));
    })));
    throttle = /* @__PURE__ */ dual(2, (self2, options) => throttleEffect(self2, {
      ...options,
      cost: /* @__PURE__ */ __name((chunk4) => succeed9(options.cost(chunk4)), "cost")
    }));
    throttleEffect = /* @__PURE__ */ dual(2, (self2, options) => {
      if (options.strategy === "enforce") {
        return throttleEnforceEffect(self2, options.cost, options.units, options.duration, options.burst ?? 0);
      }
      return throttleShapeEffect(self2, options.cost, options.units, options.duration, options.burst ?? 0);
    });
    throttleEnforceEffect = /* @__PURE__ */ __name((self2, cost, units, duration6, burst) => {
      const loop3 = /* @__PURE__ */ __name((tokens, timestampMillis) => readWithCause({
        onInput: /* @__PURE__ */ __name((input) => pipe(cost(input), zip5(currentTimeMillis2), map18(([weight, currentTimeMillis3]) => {
          const elapsed3 = currentTimeMillis3 - timestampMillis;
          const cycles = elapsed3 / toMillis(duration6);
          const sum3 = tokens + cycles * units;
          const max6 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
          const available = sum3 < 0 ? max6 : Math.min(sum3, max6);
          if (weight <= available) {
            return pipe(write(input), flatMap13(() => loop3(available - weight, currentTimeMillis3)));
          }
          return loop3(tokens, timestampMillis);
        }), unwrap), "onInput"),
        onFailure: failCause10,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      }), "loop");
      const throttled = pipe(currentTimeMillis2, map18((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap);
      return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(throttled)));
    }, "throttleEnforceEffect");
    throttleShapeEffect = /* @__PURE__ */ __name((self2, costFn, units, duration6, burst) => {
      const loop3 = /* @__PURE__ */ __name((tokens, timestampMillis) => readWithCause({
        onInput: /* @__PURE__ */ __name((input) => pipe(costFn(input), zip5(currentTimeMillis2), map18(([weight, currentTimeMillis3]) => {
          const elapsed3 = currentTimeMillis3 - timestampMillis;
          const cycles = elapsed3 / toMillis(duration6);
          const sum3 = tokens + cycles * units;
          const max6 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
          const available = sum3 < 0 ? max6 : Math.min(sum3, max6);
          const remaining = available - weight;
          const waitCycles = remaining >= 0 ? 0 : -remaining / units;
          const delay3 = millis(Math.max(0, waitCycles * toMillis(duration6)));
          if (greaterThan3(delay3, zero2)) {
            return pipe(fromEffect4(sleep2(delay3)), zipRight6(write(input)), flatMap13(() => loop3(remaining, currentTimeMillis3)));
          }
          return flatMap13(write(input), () => loop3(remaining, currentTimeMillis3));
        }), unwrap), "onInput"),
        onFailure: failCause10,
        onDone: /* @__PURE__ */ __name(() => void_6, "onDone")
      }), "loop");
      const throttled = pipe(currentTimeMillis2, map18((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap);
      return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(throttled)));
    }, "throttleShapeEffect");
    tick = /* @__PURE__ */ __name((interval) => repeatWithSchedule(void 0, spaced2(interval)), "tick");
    timeout3 = /* @__PURE__ */ dual(2, (self2, duration6) => pipe(toPull2(self2), map18(timeoutFail2({
      onTimeout: /* @__PURE__ */ __name(() => none2(), "onTimeout"),
      duration: duration6
    })), fromPull2));
    timeoutFail3 = /* @__PURE__ */ dual(3, (self2, error50, duration6) => pipe(self2, timeoutTo3(duration6, failSync7(error50))));
    timeoutFailCause3 = /* @__PURE__ */ dual(3, (self2, cause3, duration6) => pipe(toPull2(self2), map18(timeoutFailCause2({
      onTimeout: /* @__PURE__ */ __name(() => map14(cause3(), some2), "onTimeout"),
      duration: duration6
    })), fromPull2));
    timeoutTo3 = /* @__PURE__ */ dual(3, (self2, duration6, that) => {
      const StreamTimeout = new RuntimeException2("Stream Timeout");
      return pipe(self2, timeoutFailCause3(() => die4(StreamTimeout), duration6), catchSomeCause3((cause3) => isDieType2(cause3) && isRuntimeException2(cause3.defect) && cause3.defect.message !== void 0 && cause3.defect.message === "Stream Timeout" ? some2(that) : none2()));
    });
    pubsubFromOptions = /* @__PURE__ */ __name((options) => {
      if (typeof options === "number") {
        return bounded4(options);
      } else if (options.capacity === "unbounded") {
        return unbounded4({
          replay: options.replay
        });
      }
      switch (options.strategy) {
        case "dropping":
          return dropping3(options);
        case "sliding":
          return sliding3(options);
        default:
          return bounded4(options);
      }
    }, "pubsubFromOptions");
    toPubSub2 = /* @__PURE__ */ dual(2, (self2, capacity7) => pipe(acquireRelease2(pubsubFromOptions(capacity7), (pubsub) => shutdown3(pubsub)), tap4((pubsub) => pipe(self2, runIntoPubSubScoped(pubsub), forkScoped2))));
    toPull2 = /* @__PURE__ */ __name((self2) => map18(toPull(toChannel2(self2)), (pull) => pipe(pull, mapError3(some2), flatMap11(match({
      onLeft: /* @__PURE__ */ __name(() => fail9(none2()), "onLeft"),
      onRight: succeed9
    })))), "toPull");
    toQueue2 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => tap4(acquireRelease2(options?.strategy === "unbounded" ? unbounded5() : options?.strategy === "dropping" ? dropping4(options.capacity ?? 2) : options?.strategy === "sliding" ? sliding4(options.capacity ?? 2) : bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueScoped(self2, queue))));
    toQueueOfElements = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => tap4(acquireRelease2(bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueElementsScoped(self2, queue))));
    toReadableStream = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => toReadableStreamRuntime(self2, defaultRuntime2, options));
    toReadableStreamEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => map18(runtime4(), (runtime5) => toReadableStreamRuntime(self2, runtime5, options)));
    toReadableStreamRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, runtime5, options) => {
      const runFork4 = runFork3(runtime5);
      let currentResolve = void 0;
      let fiber = void 0;
      const latch = unsafeMakeLatch2(false);
      return new ReadableStream({
        start(controller) {
          fiber = runFork4(runForEachChunk(self2, (chunk4) => {
            if (chunk4.length === 0) return _void;
            return latch.whenOpen(sync5(() => {
              latch.unsafeClose();
              for (const item of chunk4) {
                controller.enqueue(item);
              }
              currentResolve();
              currentResolve = void 0;
            }));
          }));
          fiber.addObserver((exit5) => {
            try {
              if (exit5._tag === "Failure") {
                controller.error(squash(exit5.cause));
              } else {
                controller.close();
              }
            } catch {
            }
          });
        },
        pull() {
          return new Promise((resolve) => {
            currentResolve = resolve;
            runSync(latch.open);
          });
        },
        cancel() {
          if (!fiber) return;
          return runPromise(asVoid4(interrupt6(fiber)));
        }
      }, options?.strategy);
    });
    transduce = /* @__PURE__ */ dual(2, (self2, sink) => {
      const newChannel = suspend6(() => {
        const leftovers = {
          ref: empty5()
        };
        const upstreamDone = {
          ref: false
        };
        const buffer3 = suspend6(() => {
          const leftover = leftovers.ref;
          if (isEmpty(leftover)) {
            return readWith({
              onInput: /* @__PURE__ */ __name((input) => pipe(write(input), flatMap13(() => buffer3)), "onInput"),
              onFailure: fail11,
              onDone: succeedNow
            });
          }
          leftovers.ref = empty5();
          return pipe(writeChunk(leftover), flatMap13(() => buffer3));
        });
        const concatAndGet = /* @__PURE__ */ __name((chunk4) => {
          const leftover = leftovers.ref;
          const concatenated = appendAll2(leftover, filter3(chunk4, (chunk5) => chunk5.length !== 0));
          leftovers.ref = concatenated;
          return concatenated;
        }, "concatAndGet");
        const upstreamMarker = readWith({
          onInput: /* @__PURE__ */ __name((input) => flatMap13(write(input), () => upstreamMarker), "onInput"),
          onFailure: fail11,
          onDone: /* @__PURE__ */ __name((done13) => zipRight6(sync7(() => {
            upstreamDone.ref = true;
          }), succeedNow(done13)), "onDone")
        });
        const transducer = pipe(sink, toChannel, collectElements, flatMap13(([leftover, z2]) => pipe(succeed11([upstreamDone.ref, concatAndGet(leftover)]), flatMap13(([done13, newLeftovers]) => {
          const nextChannel = done13 && isEmpty(newLeftovers) ? void_6 : transducer;
          return pipe(write(of2(z2)), flatMap13(() => nextChannel));
        }))));
        return pipe(toChannel2(self2), pipeTo(upstreamMarker), pipeTo(buffer3), pipeToOrFail(transducer));
      });
      return new StreamImpl(newChannel);
    });
    toAsyncIterableRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, runtime5) => {
      const runFork4 = runFork3(runtime5);
      return {
        [Symbol.asyncIterator]() {
          let currentResolve = void 0;
          let currentReject = void 0;
          let fiber = void 0;
          const latch = unsafeMakeLatch2(false);
          let returned = false;
          return {
            next() {
              if (!fiber) {
                fiber = runFork4(runForEach(self2, (value3) => latch.whenOpen(sync5(() => {
                  latch.unsafeClose();
                  currentResolve({
                    done: false,
                    value: value3
                  });
                  currentResolve = currentReject = void 0;
                }))));
                fiber.addObserver((exit5) => {
                  if (returned) return;
                  fiber = runFork2(latch.whenOpen(sync5(() => {
                    if (exit5._tag === "Failure") {
                      currentReject(squash(exit5.cause));
                    } else {
                      currentResolve({
                        done: true,
                        value: void 0
                      });
                    }
                    currentResolve = currentReject = void 0;
                  })));
                });
              }
              return new Promise((resolve, reject) => {
                currentResolve = resolve;
                currentReject = reject;
                latch.unsafeOpen();
              });
            },
            return() {
              returned = true;
              if (!fiber) return Promise.resolve({
                done: true,
                value: void 0
              });
              return runPromise(as6(interrupt6(fiber), {
                done: true,
                value: void 0
              }));
            }
          };
        }
      };
    });
    toAsyncIterable = /* @__PURE__ */ __name((self2) => toAsyncIterableRuntime(self2, defaultRuntime2), "toAsyncIterable");
    toAsyncIterableEffect = /* @__PURE__ */ __name((self2) => map18(runtime4(), (runtime5) => toAsyncIterableRuntime(self2, runtime5)), "toAsyncIterableEffect");
    unfold4 = /* @__PURE__ */ __name((s, f) => unfoldChunk(s, (s2) => pipe(f(s2), map2(([a, s3]) => [of2(a), s3]))), "unfold");
    unfoldChunk = /* @__PURE__ */ __name((s, f) => {
      const loop3 = /* @__PURE__ */ __name((s2) => match2(f(s2), {
        onNone: /* @__PURE__ */ __name(() => void_6, "onNone"),
        onSome: /* @__PURE__ */ __name(([chunk4, s3]) => flatMap13(write(chunk4), () => loop3(s3)), "onSome")
      }), "loop");
      return new StreamImpl(suspend6(() => loop3(s)));
    }, "unfoldChunk");
    unfoldChunkEffect = /* @__PURE__ */ __name((s, f) => suspend10(() => {
      const loop3 = /* @__PURE__ */ __name((s2) => unwrap(map18(f(s2), match2({
        onNone: /* @__PURE__ */ __name(() => void_6, "onNone"),
        onSome: /* @__PURE__ */ __name(([chunk4, s3]) => flatMap13(write(chunk4), () => loop3(s3)), "onSome")
      }))), "loop");
      return new StreamImpl(loop3(s));
    }), "unfoldChunkEffect");
    unfoldEffect = /* @__PURE__ */ __name((s, f) => unfoldChunkEffect(s, (s2) => pipe(f(s2), map18(map2(([a, s3]) => [of2(a), s3])))), "unfoldEffect");
    void_8 = /* @__PURE__ */ succeed15(void 0);
    unwrap2 = /* @__PURE__ */ __name((effect4) => flatten14(fromEffect7(effect4)), "unwrap");
    unwrapScoped4 = /* @__PURE__ */ __name((effect4) => flatten14(scoped5(effect4)), "unwrapScoped");
    unwrapScopedWith3 = /* @__PURE__ */ __name((f) => flatten14(scopedWith4((scope5) => f(scope5))), "unwrapScopedWith");
    updateService4 = /* @__PURE__ */ dual(3, (self2, tag2, f) => pipe(self2, mapInputContext6((context10) => pipe(context10, add2(tag2, f(pipe(context10, unsafeGet3(tag2))))))));
    when3 = /* @__PURE__ */ dual(2, (self2, test) => pipe(self2, whenEffect3(sync5(test))));
    whenCase = /* @__PURE__ */ __name((evaluate3, pf) => whenCaseEffect(pf)(sync5(evaluate3)), "whenCase");
    whenCaseEffect = /* @__PURE__ */ dual(2, (self2, pf) => pipe(fromEffect7(self2), flatMap16((a) => pipe(pf(a), getOrElse(() => empty34)))));
    whenEffect3 = /* @__PURE__ */ dual(2, (self2, effect4) => pipe(fromEffect7(effect4), flatMap16((bool) => bool ? self2 : empty34)));
    withSpan6 = /* @__PURE__ */ __name(function() {
      const dataFirst = typeof arguments[0] !== "string";
      const name = dataFirst ? arguments[1] : arguments[0];
      const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
      if (dataFirst) {
        const self2 = arguments[0];
        return new StreamImpl(withSpan5(toChannel2(self2), name, options));
      }
      return (self2) => new StreamImpl(withSpan5(toChannel2(self2), name, options));
    }, "withSpan");
    zip7 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, zipWith12(that, (a, a2) => [a, a2])));
    zipFlatten = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, zipWith12(that, (a, a2) => [...a, a2])));
    zipAll = /* @__PURE__ */ dual(2, (self2, options) => zipAllWith(self2, {
      other: options.other,
      onSelf: /* @__PURE__ */ __name((a) => [a, options.defaultOther], "onSelf"),
      onOther: /* @__PURE__ */ __name((a2) => [options.defaultSelf, a2], "onOther"),
      onBoth: /* @__PURE__ */ __name((a, a2) => [a, a2], "onBoth")
    }));
    zipAllLeft = /* @__PURE__ */ dual(3, (self2, other, defaultSelf) => zipAllWith(self2, {
      other,
      onSelf: identity,
      onOther: /* @__PURE__ */ __name(() => defaultSelf, "onOther"),
      onBoth: /* @__PURE__ */ __name((a) => a, "onBoth")
    }));
    zipAllRight = /* @__PURE__ */ dual(3, (self2, other, defaultRight) => zipAllWith(self2, {
      other,
      onSelf: /* @__PURE__ */ __name(() => defaultRight, "onSelf"),
      onOther: identity,
      onBoth: /* @__PURE__ */ __name((_, a2) => a2, "onBoth")
    }));
    zipAllSortedByKey = /* @__PURE__ */ dual(2, (self2, options) => zipAllSortedByKeyWith(self2, {
      other: options.other,
      onSelf: /* @__PURE__ */ __name((a) => [a, options.defaultOther], "onSelf"),
      onOther: /* @__PURE__ */ __name((a2) => [options.defaultSelf, a2], "onOther"),
      onBoth: /* @__PURE__ */ __name((a, a2) => [a, a2], "onBoth"),
      order: options.order
    }));
    zipAllSortedByKeyLeft = /* @__PURE__ */ dual(2, (self2, options) => zipAllSortedByKeyWith(self2, {
      other: options.other,
      onSelf: identity,
      onOther: /* @__PURE__ */ __name(() => options.defaultSelf, "onOther"),
      onBoth: /* @__PURE__ */ __name((a) => a, "onBoth"),
      order: options.order
    }));
    zipAllSortedByKeyRight = /* @__PURE__ */ dual(2, (self2, options) => zipAllSortedByKeyWith(self2, {
      other: options.other,
      onSelf: /* @__PURE__ */ __name(() => options.defaultOther, "onSelf"),
      onOther: identity,
      onBoth: /* @__PURE__ */ __name((_, a2) => a2, "onBoth"),
      order: options.order
    }));
    zipAllSortedByKeyWith = /* @__PURE__ */ dual(2, (self2, options) => {
      const pull = /* @__PURE__ */ __name((state, pullLeft, pullRight) => {
        switch (state._tag) {
          case OP_DRAIN_LEFT: {
            return pipe(pullLeft, match13({
              onFailure: fail4,
              onSuccess: /* @__PURE__ */ __name((leftChunk) => succeed3([map5(leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft]), "onSuccess")
            }));
          }
          case OP_DRAIN_RIGHT: {
            return pipe(pullRight, match13({
              onFailure: fail4,
              onSuccess: /* @__PURE__ */ __name((rightChunk) => succeed3([map5(rightChunk, ([k, a2]) => [k, options.onOther(a2)]), DrainRight]), "onSuccess")
            }));
          }
          case OP_PULL_BOTH: {
            return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
              concurrent: true
            }), matchEffect2({
              onFailure: /* @__PURE__ */ __name((error50) => succeed9(fail4(some2(error50))), "onFailure"),
              onSuccess: /* @__PURE__ */ __name(([leftOption, rightOption]) => {
                if (isSome2(leftOption) && isSome2(rightOption)) {
                  if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                    return pull(PullBoth, pullLeft, pullRight);
                  }
                  if (isEmpty(leftOption.value)) {
                    return pull(PullLeft(rightOption.value), pullLeft, pullRight);
                  }
                  if (isEmpty(rightOption.value)) {
                    return pull(PullRight(leftOption.value), pullLeft, pullRight);
                  }
                  return succeed9(succeed3(merge13(leftOption.value, rightOption.value)));
                }
                if (isSome2(leftOption) && isNone2(rightOption)) {
                  if (isEmpty(leftOption.value)) {
                    return pull(DrainLeft, pullLeft, pullRight);
                  }
                  return succeed9(succeed3([pipe(leftOption.value, map5(([k, a]) => [k, options.onSelf(a)])), DrainLeft]));
                }
                if (isNone2(leftOption) && isSome2(rightOption)) {
                  if (isEmpty(rightOption.value)) {
                    return pull(DrainRight, pullLeft, pullRight);
                  }
                  return succeed9(succeed3([pipe(rightOption.value, map5(([k, a2]) => [k, options.onOther(a2)])), DrainRight]));
                }
                return succeed9(fail4(none2()));
              }, "onSuccess")
            }));
          }
          case OP_PULL_LEFT: {
            return matchEffect2(pullLeft, {
              onFailure: match2({
                onNone: /* @__PURE__ */ __name(() => succeed9(succeed3([pipe(state.rightChunk, map5(([k, a2]) => [k, options.onOther(a2)])), DrainRight])), "onNone"),
                onSome: /* @__PURE__ */ __name((error50) => succeed9(fail4(some2(error50))), "onSome")
              }),
              onSuccess: /* @__PURE__ */ __name((leftChunk) => isEmpty(leftChunk) ? pull(PullLeft(state.rightChunk), pullLeft, pullRight) : succeed9(succeed3(merge13(leftChunk, state.rightChunk))), "onSuccess")
            });
          }
          case OP_PULL_RIGHT: {
            return matchEffect2(pullRight, {
              onFailure: match2({
                onNone: /* @__PURE__ */ __name(() => succeed9(succeed3([map5(state.leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])), "onNone"),
                onSome: /* @__PURE__ */ __name((error50) => succeed9(fail4(some2(error50))), "onSome")
              }),
              onSuccess: /* @__PURE__ */ __name((rightChunk) => isEmpty(rightChunk) ? pull(PullRight(state.leftChunk), pullLeft, pullRight) : succeed9(succeed3(merge13(state.leftChunk, rightChunk))), "onSuccess")
            });
          }
        }
      }, "pull");
      const merge13 = /* @__PURE__ */ __name((leftChunk, rightChunk) => {
        const hasNext = /* @__PURE__ */ __name((chunk4, index2) => index2 < chunk4.length - 1, "hasNext");
        const builder = [];
        let state = void 0;
        let leftIndex = 0;
        let rightIndex = 0;
        let leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
        let rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
        let k1 = leftTuple[0];
        let a = leftTuple[1];
        let k2 = rightTuple[0];
        let a2 = rightTuple[1];
        let loop3 = true;
        while (loop3) {
          const compare2 = options.order(k1, k2);
          if (compare2 === 0) {
            builder.push([k1, options.onBoth(a, a2)]);
            if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
              leftIndex = leftIndex + 1;
              rightIndex = rightIndex + 1;
              leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
              rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
              k1 = leftTuple[0];
              a = leftTuple[1];
              k2 = rightTuple[0];
              a2 = rightTuple[1];
            } else if (hasNext(leftChunk, leftIndex)) {
              state = PullRight(pipe(leftChunk, drop2(leftIndex + 1)));
              loop3 = false;
            } else if (hasNext(rightChunk, rightIndex)) {
              state = PullLeft(pipe(rightChunk, drop2(rightIndex + 1)));
              loop3 = false;
            } else {
              state = PullBoth;
              loop3 = false;
            }
          } else if (compare2 < 0) {
            builder.push([k1, options.onSelf(a)]);
            if (hasNext(leftChunk, leftIndex)) {
              leftIndex = leftIndex + 1;
              leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
              k1 = leftTuple[0];
              a = leftTuple[1];
            } else {
              const rightBuilder = [];
              rightBuilder.push(rightTuple);
              while (hasNext(rightChunk, rightIndex)) {
                rightIndex = rightIndex + 1;
                rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
                rightBuilder.push(rightTuple);
              }
              state = PullLeft(unsafeFromArray(rightBuilder));
              loop3 = false;
            }
          } else {
            builder.push([k2, options.onOther(a2)]);
            if (hasNext(rightChunk, rightIndex)) {
              rightIndex = rightIndex + 1;
              rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
              k2 = rightTuple[0];
              a2 = rightTuple[1];
            } else {
              const leftBuilder = [];
              leftBuilder.push(leftTuple);
              while (hasNext(leftChunk, leftIndex)) {
                leftIndex = leftIndex + 1;
                leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
                leftBuilder.push(leftTuple);
              }
              state = PullRight(unsafeFromArray(leftBuilder));
              loop3 = false;
            }
          }
        }
        return [unsafeFromArray(builder), state];
      }, "merge");
      return combineChunks(self2, options.other, PullBoth, pull);
    });
    zipAllWith = /* @__PURE__ */ dual(2, (self2, options) => {
      const pull = /* @__PURE__ */ __name((state, pullLeft, pullRight) => {
        switch (state._tag) {
          case OP_DRAIN_LEFT: {
            return matchEffect2(pullLeft, {
              onFailure: /* @__PURE__ */ __name((error50) => succeed9(fail4(error50)), "onFailure"),
              onSuccess: /* @__PURE__ */ __name((leftChunk) => succeed9(succeed3([map5(leftChunk, options.onSelf), DrainLeft])), "onSuccess")
            });
          }
          case OP_DRAIN_RIGHT: {
            return matchEffect2(pullRight, {
              onFailure: /* @__PURE__ */ __name((error50) => succeed9(fail4(error50)), "onFailure"),
              onSuccess: /* @__PURE__ */ __name((rightChunk) => succeed9(succeed3([map5(rightChunk, options.onOther), DrainRight])), "onSuccess")
            });
          }
          case OP_PULL_BOTH: {
            return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
              concurrent: true
            }), matchEffect2({
              onFailure: /* @__PURE__ */ __name((error50) => succeed9(fail4(some2(error50))), "onFailure"),
              onSuccess: /* @__PURE__ */ __name(([leftOption, rightOption]) => {
                if (isSome2(leftOption) && isSome2(rightOption)) {
                  if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                    return pull(PullBoth, pullLeft, pullRight);
                  }
                  if (isEmpty(leftOption.value)) {
                    return pull(PullLeft(rightOption.value), pullLeft, pullRight);
                  }
                  if (isEmpty(rightOption.value)) {
                    return pull(PullRight(leftOption.value), pullLeft, pullRight);
                  }
                  return succeed9(succeed3(zip10(leftOption.value, rightOption.value, options.onBoth)));
                }
                if (isSome2(leftOption) && isNone2(rightOption)) {
                  return succeed9(succeed3([map5(leftOption.value, options.onSelf), DrainLeft]));
                }
                if (isNone2(leftOption) && isSome2(rightOption)) {
                  return succeed9(succeed3([map5(rightOption.value, options.onOther), DrainRight]));
                }
                return succeed9(fail4(none2()));
              }, "onSuccess")
            }));
          }
          case OP_PULL_LEFT: {
            return matchEffect2(pullLeft, {
              onFailure: match2({
                onNone: /* @__PURE__ */ __name(() => succeed9(succeed3([map5(state.rightChunk, options.onOther), DrainRight])), "onNone"),
                onSome: /* @__PURE__ */ __name((error50) => succeed9(fail4(some2(error50))), "onSome")
              }),
              onSuccess: /* @__PURE__ */ __name((leftChunk) => {
                if (isEmpty(leftChunk)) {
                  return pull(PullLeft(state.rightChunk), pullLeft, pullRight);
                }
                if (isEmpty(state.rightChunk)) {
                  return pull(PullRight(leftChunk), pullLeft, pullRight);
                }
                return succeed9(succeed3(zip10(leftChunk, state.rightChunk, options.onBoth)));
              }, "onSuccess")
            });
          }
          case OP_PULL_RIGHT: {
            return matchEffect2(pullRight, {
              onFailure: match2({
                onNone: /* @__PURE__ */ __name(() => succeed9(succeed3([map5(state.leftChunk, options.onSelf), DrainLeft])), "onNone"),
                onSome: /* @__PURE__ */ __name((error50) => succeed9(fail4(some2(error50))), "onSome")
              }),
              onSuccess: /* @__PURE__ */ __name((rightChunk) => {
                if (isEmpty(rightChunk)) {
                  return pull(PullRight(state.leftChunk), pullLeft, pullRight);
                }
                if (isEmpty(state.leftChunk)) {
                  return pull(PullLeft(rightChunk), pullLeft, pullRight);
                }
                return succeed9(succeed3(zip10(state.leftChunk, rightChunk, options.onBoth)));
              }, "onSuccess")
            });
          }
        }
      }, "pull");
      const zip10 = /* @__PURE__ */ __name((leftChunk, rightChunk, f) => {
        const [output, either8] = zipChunks(leftChunk, rightChunk, f);
        switch (either8._tag) {
          case "Left": {
            if (isEmpty(either8.left)) {
              return [output, PullBoth];
            }
            return [output, PullRight(either8.left)];
          }
          case "Right": {
            if (isEmpty(either8.right)) {
              return [output, PullBoth];
            }
            return [output, PullLeft(either8.right)];
          }
        }
      }, "zip");
      return combineChunks(self2, options.other, PullBoth, pull);
    });
    zipLatest = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipLatestWith(right3, (a, a2) => [a, a2])));
    zipLatestAll = /* @__PURE__ */ __name((...streams) => {
      if (streams.length === 0) {
        return empty34;
      } else if (streams.length === 1) {
        return map24(streams[0], (x) => [x]);
      }
      const [head7, ...tail] = streams;
      return zipLatestWith(head7, zipLatestAll(...tail), (first3, second) => [first3, ...second]);
    }, "zipLatestAll");
    zipLatestWith = /* @__PURE__ */ dual(3, (left3, right3, f) => {
      const pullNonEmpty = /* @__PURE__ */ __name((pull) => pipe(pull, flatMap11((chunk4) => isEmpty(chunk4) ? pullNonEmpty(pull) : succeed9(chunk4))), "pullNonEmpty");
      return pipe(toPull2(left3), map18(pullNonEmpty), zip5(pipe(toPull2(right3), map18(pullNonEmpty))), flatMap11(([left4, right4]) => pipe(fromEffectOption(raceWith2(left4, right4, {
        onSelfDone: /* @__PURE__ */ __name((leftDone, rightFiber) => pipe(suspend4(() => leftDone), zipWith7(join3(rightFiber), (l, r) => [l, r, true])), "onSelfDone"),
        onOtherDone: /* @__PURE__ */ __name((rightDone, leftFiber) => pipe(suspend4(() => rightDone), zipWith7(join3(leftFiber), (l, r) => [r, l, false])), "onOtherDone")
      })), flatMap16(([l, r, leftFirst]) => pipe(fromEffect7(make29([unsafeLast(l), unsafeLast(r)])), flatMap16((latest) => pipe(fromChunk(leftFirst ? pipe(r, map5((a2) => f(unsafeLast(l), a2))) : pipe(l, map5((a) => f(a, unsafeLast(r))))), concat2(pipe(repeatEffectOption(left4), mergeEither(repeatEffectOption(right4)), mapEffectSequential(match({
        onLeft: /* @__PURE__ */ __name((leftChunk) => modify4(latest, ([_, rightLatest]) => [pipe(leftChunk, map5((a) => f(a, rightLatest))), [unsafeLast(leftChunk), rightLatest]]), "onLeft"),
        onRight: /* @__PURE__ */ __name((rightChunk) => modify4(latest, ([leftLatest, _]) => [pipe(rightChunk, map5((a2) => f(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]]), "onRight")
      })), flatMap16(fromChunk))))))), toPull2)), fromPull2);
    });
    zipLeft7 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
      if (left4.length > right4.length) {
        return [pipe(left4, take(right4.length)), left2(pipe(left4, take(right4.length)))];
      }
      return [left4, right2(pipe(right4, drop2(left4.length)))];
    })));
    zipRight10 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
      if (left4.length > right4.length) {
        return [right4, left2(pipe(left4, take(right4.length)))];
      }
      return [pipe(right4, take(left4.length)), right2(pipe(right4, drop2(left4.length)))];
    })));
    zipWith12 = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, zipWithChunks(right3, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))));
    zipWithChunks = /* @__PURE__ */ dual(3, (self2, that, f) => {
      const pull = /* @__PURE__ */ __name((state, pullLeft, pullRight) => {
        switch (state._tag) {
          case OP_PULL_BOTH2: {
            return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
              concurrent: true
            }), matchEffect2({
              onFailure: /* @__PURE__ */ __name((error50) => succeed9(fail4(some2(error50))), "onFailure"),
              onSuccess: /* @__PURE__ */ __name(([leftOption, rightOption]) => {
                if (isSome2(leftOption) && isSome2(rightOption)) {
                  if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                    return pull(PullBoth2, pullLeft, pullRight);
                  }
                  if (isEmpty(leftOption.value)) {
                    return pull(PullLeft2(rightOption.value), pullLeft, pullRight);
                  }
                  if (isEmpty(rightOption.value)) {
                    return pull(PullRight2(leftOption.value), pullLeft, pullRight);
                  }
                  return succeed9(succeed3(zip10(leftOption.value, rightOption.value)));
                }
                return succeed9(fail4(none2()));
              }, "onSuccess")
            }));
          }
          case OP_PULL_LEFT2: {
            return matchEffect2(pullLeft, {
              onFailure: /* @__PURE__ */ __name((error50) => succeed9(fail4(error50)), "onFailure"),
              onSuccess: /* @__PURE__ */ __name((leftChunk) => {
                if (isEmpty(leftChunk)) {
                  return pull(PullLeft2(state.rightChunk), pullLeft, pullRight);
                }
                if (isEmpty(state.rightChunk)) {
                  return pull(PullRight2(leftChunk), pullLeft, pullRight);
                }
                return succeed9(succeed3(zip10(leftChunk, state.rightChunk)));
              }, "onSuccess")
            });
          }
          case OP_PULL_RIGHT2: {
            return matchEffect2(pullRight, {
              onFailure: /* @__PURE__ */ __name((error50) => succeed9(fail4(error50)), "onFailure"),
              onSuccess: /* @__PURE__ */ __name((rightChunk) => {
                if (isEmpty(rightChunk)) {
                  return pull(PullRight2(state.leftChunk), pullLeft, pullRight);
                }
                if (isEmpty(state.leftChunk)) {
                  return pull(PullLeft2(rightChunk), pullLeft, pullRight);
                }
                return succeed9(succeed3(zip10(state.leftChunk, rightChunk)));
              }, "onSuccess")
            });
          }
        }
      }, "pull");
      const zip10 = /* @__PURE__ */ __name((leftChunk, rightChunk) => {
        const [output, either8] = f(leftChunk, rightChunk);
        switch (either8._tag) {
          case "Left": {
            if (isEmpty(either8.left)) {
              return [output, PullBoth2];
            }
            return [output, PullRight2(either8.left)];
          }
          case "Right": {
            if (isEmpty(either8.right)) {
              return [output, PullBoth2];
            }
            return [output, PullLeft2(either8.right)];
          }
        }
      }, "zip");
      return pipe(self2, combineChunks(that, PullBoth2, pull));
    });
    zipWithIndex = /* @__PURE__ */ __name((self2) => pipe(self2, mapAccum5(0, (index2, a) => [index2 + 1, [a, index2]])), "zipWithIndex");
    zipWithNext = /* @__PURE__ */ __name((self2) => {
      const process4 = /* @__PURE__ */ __name((last6) => readWithCause({
        onInput: /* @__PURE__ */ __name((input) => {
          const [newLast, chunk4] = mapAccum2(input, last6, (prev, curr) => [some2(curr), pipe(prev, map2((a) => [a, curr]))]);
          const output = filterMap3(chunk4, (option5) => isSome2(option5) ? some2([option5.value[0], some2(option5.value[1])]) : none2());
          return flatMap13(write(output), () => process4(newLast));
        }, "onInput"),
        onFailure: failCause10,
        onDone: /* @__PURE__ */ __name(() => match2(last6, {
          onNone: /* @__PURE__ */ __name(() => void_6, "onNone"),
          onSome: /* @__PURE__ */ __name((value3) => zipRight6(write(of2([value3, none2()])), void_6), "onSome")
        }), "onDone")
      }), "process");
      return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(process4(none2()))));
    }, "zipWithNext");
    zipWithPrevious = /* @__PURE__ */ __name((self2) => pipe(self2, mapAccum5(none2(), (prev, curr) => [some2(curr), [prev, curr]])), "zipWithPrevious");
    zipWithPreviousAndNext = /* @__PURE__ */ __name((self2) => pipe(zipWithNext(zipWithPrevious(self2)), map24(([[prev, curr], next4]) => [prev, curr, pipe(next4, map2((tuple4) => tuple4[1]))])), "zipWithPreviousAndNext");
    zipChunks = /* @__PURE__ */ __name((left3, right3, f) => {
      if (left3.length > right3.length) {
        return [pipe(left3, take(right3.length), zipWith3(right3, f)), left2(pipe(left3, drop2(right3.length)))];
      }
      return [pipe(left3, zipWith3(pipe(right3, take(left3.length)), f)), right2(pipe(right3, drop2(left3.length)))];
    }, "zipChunks");
    Do4 = /* @__PURE__ */ succeed15({});
    bind5 = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self2, tag2, f, options) => flatMap16(self2, (k) => map24(f(k), (a) => ({
      ...k,
      [tag2]: a
    })), options));
    bindTo5 = /* @__PURE__ */ bindTo(map24);
    let_5 = /* @__PURE__ */ let_(map24);
    decodeText = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, encoding = "utf-8") => suspend10(() => {
      const decoder2 = new TextDecoder(encoding);
      return map24(self2, (s) => decoder2.decode(s, {
        stream: true
      }));
    }));
    encodeText = /* @__PURE__ */ __name((self2) => suspend10(() => {
      const encoder2 = new TextEncoder();
      return map24(self2, (s) => encoder2.encode(s));
    }), "encodeText");
    fromEventListener = /* @__PURE__ */ __name((target, type, options) => asyncPush((emit3) => acquireRelease2(sync5(() => target.addEventListener(type, emit3.single, options)), () => sync5(() => target.removeEventListener(type, emit3.single, options))), {
      bufferSize: typeof options === "object" ? options.bufferSize : void 0
    }), "fromEventListener");
  }
});

// node_modules/effect/dist/esm/Channel.js
var init_Channel = __esm({
  "node_modules/effect/dist/esm/Channel.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/ChildExecutorDecision.js
var init_ChildExecutorDecision = __esm({
  "node_modules/effect/dist/esm/ChildExecutorDecision.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/ConfigError.js
var InvalidData2;
var init_ConfigError = __esm({
  "node_modules/effect/dist/esm/ConfigError.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_configError2();
    InvalidData2 = InvalidData;
  }
});

// node_modules/effect/dist/esm/internal/redacted.js
var RedactedSymbolKey, redactedRegistry, RedactedTypeId, proto12, isRedacted, make53, value;
var init_redacted = __esm({
  "node_modules/effect/dist/esm/internal/redacted.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_GlobalValue();
    init_Hash();
    init_Inspectable();
    init_Pipeable();
    init_Predicate();
    RedactedSymbolKey = "effect/Redacted";
    redactedRegistry = /* @__PURE__ */ globalValue("effect/Redacted/redactedRegistry", () => /* @__PURE__ */ new WeakMap());
    RedactedTypeId = /* @__PURE__ */ Symbol.for(RedactedSymbolKey);
    proto12 = {
      [RedactedTypeId]: {
        _A: /* @__PURE__ */ __name((_) => _, "_A")
      },
      pipe() {
        return pipeArguments(this, arguments);
      },
      toString() {
        return "<redacted>";
      },
      toJSON() {
        return "<redacted>";
      },
      [NodeInspectSymbol]() {
        return "<redacted>";
      },
      [symbol]() {
        return pipe(hash(RedactedSymbolKey), combine(hash(redactedRegistry.get(this))), cached(this));
      },
      [symbol2](that) {
        return isRedacted(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
      }
    };
    isRedacted = /* @__PURE__ */ __name((u) => hasProperty(u, RedactedTypeId), "isRedacted");
    make53 = /* @__PURE__ */ __name((value3) => {
      const redacted2 = Object.create(proto12);
      redactedRegistry.set(redacted2, value3);
      return redacted2;
    }, "make");
    value = /* @__PURE__ */ __name((self2) => {
      if (redactedRegistry.has(self2)) {
        return redactedRegistry.get(self2);
      } else {
        throw new Error("Unable to get redacted value");
      }
    }, "value");
  }
});

// node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey, ConfigTypeId, configVariance, proto13, mapOrFail, nested2, primitive, string3;
var init_config3 = __esm({
  "node_modules/effect/dist/esm/internal/config.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Either();
    init_Function();
    init_defaultServices();
    init_effectable();
    init_config2();
    ConfigSymbolKey = "effect/Config";
    ConfigTypeId = /* @__PURE__ */ Symbol.for(ConfigSymbolKey);
    configVariance = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    proto13 = {
      ...CommitPrototype,
      [ConfigTypeId]: configVariance,
      commit() {
        return config2(this);
      }
    };
    mapOrFail = /* @__PURE__ */ dual(2, (self2, f) => {
      const mapOrFail3 = Object.create(proto13);
      mapOrFail3._tag = OP_MAP_OR_FAIL;
      mapOrFail3.original = self2;
      mapOrFail3.mapOrFail = f;
      return mapOrFail3;
    });
    nested2 = /* @__PURE__ */ dual(2, (self2, name) => {
      const nested3 = Object.create(proto13);
      nested3._tag = OP_NESTED;
      nested3.name = name;
      nested3.config = self2;
      return nested3;
    });
    primitive = /* @__PURE__ */ __name((description, parse5) => {
      const primitive2 = Object.create(proto13);
      primitive2._tag = OP_PRIMITIVE;
      primitive2.description = description;
      primitive2.parse = parse5;
      return primitive2;
    }, "primitive");
    string3 = /* @__PURE__ */ __name((name) => {
      const config5 = primitive("a text property", right2);
      return name === void 0 ? config5 : nested2(config5, name);
    }, "string");
  }
});

// node_modules/effect/dist/esm/Config.js
var mapOrFail2, string4;
var init_Config = __esm({
  "node_modules/effect/dist/esm/Config.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_config3();
    mapOrFail2 = mapOrFail;
    string4 = string3;
  }
});

// node_modules/effect/dist/esm/ConfigProvider.js
var init_ConfigProvider = __esm({
  "node_modules/effect/dist/esm/ConfigProvider.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/ConfigProviderPathPatch.js
var init_ConfigProviderPathPatch = __esm({
  "node_modules/effect/dist/esm/ConfigProviderPathPatch.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Console.js
var init_Console = __esm({
  "node_modules/effect/dist/esm/Console.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/DateTime.js
var isDateTime2, isTimeZoneOffset2, isTimeZoneNamed2, isUtc2, isZoned2, Equivalence5, unsafeFromDate2, unsafeMake12, unsafeMakeZoned2, makeZonedFromString2, zoneUnsafeMakeNamed2, zoneMakeOffset2, zoneFromString2, zoneToString2, toDateUtc2, toEpochMillis2, formatIso2, formatIsoZoned2;
var init_DateTime = __esm({
  "node_modules/effect/dist/esm/DateTime.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_dateTime();
    isDateTime2 = isDateTime;
    isTimeZoneOffset2 = isTimeZoneOffset;
    isTimeZoneNamed2 = isTimeZoneNamed;
    isUtc2 = isUtc;
    isZoned2 = isZoned;
    Equivalence5 = Equivalence3;
    unsafeFromDate2 = unsafeFromDate;
    unsafeMake12 = unsafeMake10;
    unsafeMakeZoned2 = unsafeMakeZoned;
    makeZonedFromString2 = makeZonedFromString;
    zoneUnsafeMakeNamed2 = zoneUnsafeMakeNamed;
    zoneMakeOffset2 = zoneMakeOffset;
    zoneFromString2 = zoneFromString;
    zoneToString2 = zoneToString;
    toDateUtc2 = toDateUtc;
    toEpochMillis2 = toEpochMillis;
    formatIso2 = formatIso;
    formatIsoZoned2 = formatIsoZoned;
  }
});

// node_modules/effect/dist/esm/DefaultServices.js
var init_DefaultServices = __esm({
  "node_modules/effect/dist/esm/DefaultServices.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/internal/encoding/common.js
var DecodeExceptionTypeId, DecodeException, EncodeExceptionTypeId, EncodeException, encoder, decoder;
var init_common = __esm({
  "node_modules/effect/dist/esm/internal/encoding/common.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Predicate();
    DecodeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Decode");
    DecodeException = /* @__PURE__ */ __name((input, message) => {
      const out = {
        _tag: "DecodeException",
        [DecodeExceptionTypeId]: DecodeExceptionTypeId,
        input
      };
      if (isString(message)) {
        out.message = message;
      }
      return out;
    }, "DecodeException");
    EncodeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Encode");
    EncodeException = /* @__PURE__ */ __name((input, message) => {
      const out = {
        _tag: "EncodeException",
        [EncodeExceptionTypeId]: EncodeExceptionTypeId,
        input
      };
      if (isString(message)) {
        out.message = message;
      }
      return out;
    }, "EncodeException");
    encoder = /* @__PURE__ */ new TextEncoder();
    decoder = /* @__PURE__ */ new TextDecoder();
  }
});

// node_modules/effect/dist/esm/internal/encoding/base64.js
function getBase64Code(charCode) {
  if (charCode >= base64codes.length) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  const code = base64codes[charCode];
  if (code === 255) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  return code;
}
var encode, decode2, stripCrlf, base64abc, base64codes;
var init_base642 = __esm({
  "node_modules/effect/dist/esm/internal/encoding/base64.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Either();
    init_common();
    encode = /* @__PURE__ */ __name((bytes) => {
      const length4 = bytes.length;
      let result = "";
      let i;
      for (i = 2; i < length4; i += 3) {
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
        result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
        result += base64abc[bytes[i] & 63];
      }
      if (i === length4 + 1) {
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[(bytes[i - 2] & 3) << 4];
        result += "==";
      }
      if (i === length4) {
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
        result += base64abc[(bytes[i - 1] & 15) << 2];
        result += "=";
      }
      return result;
    }, "encode");
    decode2 = /* @__PURE__ */ __name((str) => {
      const stripped = stripCrlf(str);
      const length4 = stripped.length;
      if (length4 % 4 !== 0) {
        return left2(DecodeException(stripped, `Length must be a multiple of 4, but is ${length4}`));
      }
      const index2 = stripped.indexOf("=");
      if (index2 !== -1 && (index2 < length4 - 2 || index2 === length4 - 2 && stripped[length4 - 1] !== "=")) {
        return left2(DecodeException(stripped, "Found a '=' character, but it is not at the end"));
      }
      try {
        const missingOctets = stripped.endsWith("==") ? 2 : stripped.endsWith("=") ? 1 : 0;
        const result = new Uint8Array(3 * (length4 / 4) - missingOctets);
        for (let i = 0, j = 0; i < length4; i += 4, j += 3) {
          const buffer3 = getBase64Code(stripped.charCodeAt(i)) << 18 | getBase64Code(stripped.charCodeAt(i + 1)) << 12 | getBase64Code(stripped.charCodeAt(i + 2)) << 6 | getBase64Code(stripped.charCodeAt(i + 3));
          result[j] = buffer3 >> 16;
          result[j + 1] = buffer3 >> 8 & 255;
          result[j + 2] = buffer3 & 255;
        }
        return right2(result);
      } catch (e) {
        return left2(DecodeException(stripped, e instanceof Error ? e.message : "Invalid input"));
      }
    }, "decode");
    stripCrlf = /* @__PURE__ */ __name((str) => str.replace(/[\n\r]/g, ""), "stripCrlf");
    __name(getBase64Code, "getBase64Code");
    base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
    base64codes = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];
  }
});

// node_modules/effect/dist/esm/internal/encoding/base64Url.js
var encode2, decode3;
var init_base64Url = __esm({
  "node_modules/effect/dist/esm/internal/encoding/base64Url.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Either();
    init_base642();
    init_common();
    encode2 = /* @__PURE__ */ __name((data) => encode(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_"), "encode");
    decode3 = /* @__PURE__ */ __name((str) => {
      const stripped = stripCrlf(str);
      const length4 = stripped.length;
      if (length4 % 4 === 1) {
        return left2(DecodeException(stripped, `Length should be a multiple of 4, but is ${length4}`));
      }
      if (!/^[-_A-Z0-9]*?={0,2}$/i.test(stripped)) {
        return left2(DecodeException(stripped, "Invalid input"));
      }
      let sanitized = length4 % 4 === 2 ? `${stripped}==` : length4 % 4 === 3 ? `${stripped}=` : stripped;
      sanitized = sanitized.replace(/-/g, "+").replace(/_/g, "/");
      return decode2(sanitized);
    }, "decode");
  }
});

// node_modules/effect/dist/esm/internal/encoding/hex.js
var encode3, decode4, bytesToHex, fromHexChar;
var init_hex = __esm({
  "node_modules/effect/dist/esm/internal/encoding/hex.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Either();
    init_common();
    encode3 = /* @__PURE__ */ __name((bytes) => {
      let result = "";
      for (let i = 0; i < bytes.length; ++i) {
        result += bytesToHex[bytes[i]];
      }
      return result;
    }, "encode");
    decode4 = /* @__PURE__ */ __name((str) => {
      const bytes = new TextEncoder().encode(str);
      if (bytes.length % 2 !== 0) {
        return left2(DecodeException(str, `Length must be a multiple of 2, but is ${bytes.length}`));
      }
      try {
        const length4 = bytes.length / 2;
        const result = new Uint8Array(length4);
        for (let i = 0; i < length4; i++) {
          const a = fromHexChar(bytes[i * 2]);
          const b = fromHexChar(bytes[i * 2 + 1]);
          result[i] = a << 4 | b;
        }
        return right2(result);
      } catch (e) {
        return left2(DecodeException(str, e instanceof Error ? e.message : "Invalid input"));
      }
    }, "decode");
    bytesToHex = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
    fromHexChar = /* @__PURE__ */ __name((byte) => {
      if (48 <= byte && byte <= 57) {
        return byte - 48;
      }
      if (97 <= byte && byte <= 102) {
        return byte - 97 + 10;
      }
      if (65 <= byte && byte <= 70) {
        return byte - 65 + 10;
      }
      throw new TypeError("Invalid input");
    }, "fromHexChar");
  }
});

// node_modules/effect/dist/esm/Encoding.js
var encodeBase64, decodeBase64, decodeBase64String, encodeBase64Url, decodeBase64Url, decodeBase64UrlString, encodeHex, decodeHex, decodeHexString, encodeUriComponent, decodeUriComponent, DecodeException2, EncodeException2;
var init_Encoding = __esm({
  "node_modules/effect/dist/esm/Encoding.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Either();
    init_base642();
    init_base64Url();
    init_common();
    init_hex();
    encodeBase64 = /* @__PURE__ */ __name((input) => typeof input === "string" ? encode(encoder.encode(input)) : encode(input), "encodeBase64");
    decodeBase64 = /* @__PURE__ */ __name((str) => decode2(str), "decodeBase64");
    decodeBase64String = /* @__PURE__ */ __name((str) => map(decodeBase64(str), (_) => decoder.decode(_)), "decodeBase64String");
    encodeBase64Url = /* @__PURE__ */ __name((input) => typeof input === "string" ? encode2(encoder.encode(input)) : encode2(input), "encodeBase64Url");
    decodeBase64Url = /* @__PURE__ */ __name((str) => decode3(str), "decodeBase64Url");
    decodeBase64UrlString = /* @__PURE__ */ __name((str) => map(decodeBase64Url(str), (_) => decoder.decode(_)), "decodeBase64UrlString");
    encodeHex = /* @__PURE__ */ __name((input) => typeof input === "string" ? encode3(encoder.encode(input)) : encode3(input), "encodeHex");
    decodeHex = /* @__PURE__ */ __name((str) => decode4(str), "decodeHex");
    decodeHexString = /* @__PURE__ */ __name((str) => map(decodeHex(str), (_) => decoder.decode(_)), "decodeHexString");
    encodeUriComponent = /* @__PURE__ */ __name((str) => try_({
      try: /* @__PURE__ */ __name(() => encodeURIComponent(str), "try"),
      catch: /* @__PURE__ */ __name((e) => EncodeException2(str, e instanceof Error ? e.message : "Invalid input"), "catch")
    }), "encodeUriComponent");
    decodeUriComponent = /* @__PURE__ */ __name((str) => try_({
      try: /* @__PURE__ */ __name(() => decodeURIComponent(str), "try"),
      catch: /* @__PURE__ */ __name((e) => DecodeException2(str, e instanceof Error ? e.message : "Invalid input"), "catch")
    }), "decodeUriComponent");
    DecodeException2 = DecodeException;
    EncodeException2 = EncodeException;
  }
});

// node_modules/effect/dist/esm/ExecutionPlan.js
var TypeId22, Proto3, makeProto;
var init_ExecutionPlan = __esm({
  "node_modules/effect/dist/esm/ExecutionPlan.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Effect();
    init_executionPlan();
    init_Layer();
    init_Pipeable();
    TypeId22 = TypeId20;
    Proto3 = {
      [TypeId22]: TypeId22,
      get withRequirements() {
        const self2 = this;
        return contextWith2((context10) => makeProto(self2.steps.map((step4) => ({
          ...step4,
          provide: isLayer2(step4.provide) ? provide3(step4.provide, succeedContext2(context10)) : step4.provide
        }))));
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    makeProto = /* @__PURE__ */ __name((steps) => {
      const self2 = Object.create(Proto3);
      self2.steps = steps;
      return self2;
    }, "makeProto");
  }
});

// node_modules/effect/dist/esm/FiberHandle.js
var TypeId23, Proto4;
var init_FiberHandle = __esm({
  "node_modules/effect/dist/esm/FiberHandle.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Inspectable();
    init_Pipeable();
    TypeId23 = /* @__PURE__ */ Symbol.for("effect/FiberHandle");
    Proto4 = {
      [TypeId23]: TypeId23,
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "FiberHandle",
          state: this.state
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
  }
});

// node_modules/effect/dist/esm/FiberMap.js
var TypeId24, Proto5;
var init_FiberMap = __esm({
  "node_modules/effect/dist/esm/FiberMap.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Inspectable();
    init_Iterable();
    init_Pipeable();
    TypeId24 = /* @__PURE__ */ Symbol.for("effect/FiberMap");
    Proto5 = {
      [TypeId24]: TypeId24,
      [Symbol.iterator]() {
        if (this.state._tag === "Closed") {
          return empty();
        }
        return this.state.backing[Symbol.iterator]();
      },
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "FiberMap",
          state: this.state
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
  }
});

// node_modules/effect/dist/esm/FiberSet.js
var TypeId25, Proto6;
var init_FiberSet = __esm({
  "node_modules/effect/dist/esm/FiberSet.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Inspectable();
    init_Iterable();
    init_Pipeable();
    TypeId25 = /* @__PURE__ */ Symbol.for("effect/FiberSet");
    Proto6 = {
      [TypeId25]: TypeId25,
      [Symbol.iterator]() {
        if (this.state._tag === "Closed") {
          return empty();
        }
        return this.state.backing[Symbol.iterator]();
      },
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "FiberMap",
          state: this.state
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
  }
});

// node_modules/effect/dist/esm/Graph.js
var TypeId26, ProtoGraph, isGraph;
var init_Graph = __esm({
  "node_modules/effect/dist/esm/Graph.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Hash();
    init_Inspectable();
    init_Pipeable();
    TypeId26 = "~effect/Graph";
    ProtoGraph = {
      [TypeId26]: TypeId26,
      [Symbol.iterator]() {
        return this.nodes[Symbol.iterator]();
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      [symbol2](that) {
        if (isGraph(that)) {
          if (this.nodes.size !== that.nodes.size || this.edges.size !== that.edges.size || this.type !== that.type) {
            return false;
          }
          for (const [nodeIndex, nodeData] of this.nodes) {
            if (!that.nodes.has(nodeIndex)) {
              return false;
            }
            const otherNodeData = that.nodes.get(nodeIndex);
            if (!equals(nodeData, otherNodeData)) {
              return false;
            }
          }
          for (const [edgeIndex, edgeData] of this.edges) {
            if (!that.edges.has(edgeIndex)) {
              return false;
            }
            const otherEdge = that.edges.get(edgeIndex);
            if (!equals(edgeData, otherEdge)) {
              return false;
            }
          }
          return true;
        }
        return false;
      },
      [symbol]() {
        let hash4 = string("Graph");
        hash4 = hash4 ^ string(this.type);
        hash4 = hash4 ^ number2(this.nodes.size);
        hash4 = hash4 ^ number2(this.edges.size);
        for (const [nodeIndex, nodeData] of this.nodes) {
          hash4 = hash4 ^ hash(nodeIndex) + hash(nodeData);
        }
        for (const [edgeIndex, edgeData] of this.edges) {
          hash4 = hash4 ^ hash(edgeIndex) + hash(edgeData);
        }
        return hash4;
      },
      toJSON() {
        return {
          _id: "Graph",
          nodeCount: this.nodes.size,
          edgeCount: this.edges.size,
          type: this.type
        };
      },
      toString() {
        return format(this);
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    isGraph = /* @__PURE__ */ __name((u) => typeof u === "object" && u !== null && TypeId26 in u, "isGraph");
  }
});

// node_modules/effect/dist/esm/internal/groupBy.js
var GroupBySymbolKey, GroupByTypeId, groupByVariance, isGroupBy, evaluate2, make55, groupBy, mapEffectOptions, bindEffect, mapDequeue, MapDequeue, groupByKey, groupByIterable;
var init_groupBy = __esm({
  "node_modules/effect/dist/esm/internal/groupBy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Cause();
    init_Chunk();
    init_Deferred();
    init_Effect();
    init_Effectable();
    init_Exit();
    init_Function();
    init_Option();
    init_Pipeable();
    init_Predicate();
    init_Queue();
    init_Ref();
    init_Scope();
    init_channel2();
    init_channelExecutor();
    init_core_stream();
    init_stream();
    init_take();
    GroupBySymbolKey = "effect/GroupBy";
    GroupByTypeId = /* @__PURE__ */ Symbol.for(GroupBySymbolKey);
    groupByVariance = {
      /* c8 ignore next */
      _R: /* @__PURE__ */ __name((_) => _, "_R"),
      /* c8 ignore next */
      _E: /* @__PURE__ */ __name((_) => _, "_E"),
      /* c8 ignore next */
      _K: /* @__PURE__ */ __name((_) => _, "_K"),
      /* c8 ignore next */
      _V: /* @__PURE__ */ __name((_) => _, "_V")
    };
    isGroupBy = /* @__PURE__ */ __name((u) => hasProperty(u, GroupByTypeId), "isGroupBy");
    evaluate2 = /* @__PURE__ */ dual((args2) => isGroupBy(args2[0]), (self2, f, options) => flatMap16(self2.grouped, ([key, queue]) => f(key, flattenTake(fromQueue2(queue, {
      shutdown: true
    }))), {
      concurrency: "unbounded",
      bufferSize: options?.bufferSize ?? 16
    }));
    make55 = /* @__PURE__ */ __name((grouped3) => ({
      [GroupByTypeId]: groupByVariance,
      pipe() {
        return pipeArguments(this, arguments);
      },
      grouped: grouped3
    }), "make");
    groupBy = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, f, options) => make55(unwrapScoped4(gen4(function* () {
      const decider = yield* make19();
      const output = yield* acquireRelease2(bounded5(options?.bufferSize ?? 16), (queue) => shutdown4(queue));
      const ref2 = yield* make29(/* @__PURE__ */ new Map());
      const add7 = yield* pipe(mapEffectSequential(self2, f), distributedWithDynamicCallback(options?.bufferSize ?? 16, ([key, value3]) => flatMap11(_await(decider), (f2) => f2(key, value3)), (exit5) => offer3(output, exit5)));
      yield* succeed2(decider, (key, _) => pipe(get12(ref2), map18((map31) => fromNullable(map31.get(key))), flatMap11(match2({
        onNone: /* @__PURE__ */ __name(() => flatMap11(add7, ([index2, queue]) => zipRight5(update3(ref2, (map31) => map31.set(key, index2)), pipe(offer3(output, succeed3([key, mapDequeue(queue, (exit5) => new TakeImpl(pipe(exit5, map12((tuple4) => of2(tuple4[1])))))])), as6((n) => n === index2)))), "onNone"),
        onSome: /* @__PURE__ */ __name((index2) => succeed9((n) => n === index2), "onSome")
      }))));
      return flattenExitOption(fromQueue2(output, {
        shutdown: true
      }));
    }))));
    mapEffectOptions = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f, options) => {
      if (options?.key) {
        return evaluate2(groupByKey(self2, options.key, {
          bufferSize: options.bufferSize
        }), (_, s) => mapEffectSequential(s, f));
      }
      return matchConcurrency(options?.concurrency, () => mapEffectSequential(self2, f), (n) => options?.unordered ? flatMap16(self2, (a) => fromEffect7(f(a)), {
        concurrency: n
      }) : mapEffectPar(self2, n, f));
    });
    bindEffect = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self2, tag2, f, options) => mapEffectOptions(self2, (k) => map18(f(k), (a) => ({
      ...k,
      [tag2]: a
    })), options));
    mapDequeue = /* @__PURE__ */ __name((dequeue, f) => new MapDequeue(dequeue, f), "mapDequeue");
    MapDequeue = class extends Class2 {
      static {
        __name(this, "MapDequeue");
      }
      dequeue;
      f;
      [DequeueTypeId2] = {
        _Out: /* @__PURE__ */ __name((_) => _, "_Out")
      };
      constructor(dequeue, f) {
        super();
        this.dequeue = dequeue;
        this.f = f;
      }
      capacity() {
        return capacity4(this.dequeue);
      }
      get size() {
        return size12(this.dequeue);
      }
      unsafeSize() {
        return this.dequeue.unsafeSize();
      }
      get awaitShutdown() {
        return awaitShutdown3(this.dequeue);
      }
      isActive() {
        return this.dequeue.isActive();
      }
      get isShutdown() {
        return isShutdown3(this.dequeue);
      }
      get shutdown() {
        return shutdown4(this.dequeue);
      }
      get isFull() {
        return isFull3(this.dequeue);
      }
      get isEmpty() {
        return isEmpty12(this.dequeue);
      }
      get take() {
        return pipe(take3(this.dequeue), map18((a) => this.f(a)));
      }
      get takeAll() {
        return pipe(takeAll2(this.dequeue), map18(map5((a) => this.f(a))));
      }
      takeUpTo(max6) {
        return pipe(takeUpTo2(this.dequeue, max6), map18(map5((a) => this.f(a))));
      }
      takeBetween(min4, max6) {
        return pipe(takeBetween2(this.dequeue, min4, max6), map18(map5((a) => this.f(a))));
      }
      takeN(n) {
        return pipe(takeN2(this.dequeue, n), map18(map5((a) => this.f(a))));
      }
      poll() {
        return pipe(poll6(this.dequeue), map18(map2((a) => this.f(a))));
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
      commit() {
        return this.take;
      }
    };
    groupByKey = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f, options) => {
      const loop3 = /* @__PURE__ */ __name((map31, outerQueue) => readWithCause({
        onInput: /* @__PURE__ */ __name((input) => flatMap13(fromEffect4(forEach9(groupByIterable(input, f), ([key, values4]) => {
          const innerQueue = map31.get(key);
          if (innerQueue === void 0) {
            return pipe(bounded5(options?.bufferSize ?? 16), flatMap11((innerQueue2) => pipe(sync5(() => {
              map31.set(key, innerQueue2);
            }), zipRight5(offer3(outerQueue, of5([key, innerQueue2]))), zipRight5(pipe(offer3(innerQueue2, chunk2(values4)), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2()))))));
          }
          return catchSomeCause2(offer3(innerQueue, chunk2(values4)), (cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2());
        }, {
          discard: true
        })), () => loop3(map31, outerQueue)), "onInput"),
        onFailure: /* @__PURE__ */ __name((cause3) => fromEffect4(offer3(outerQueue, failCause11(cause3))), "onFailure"),
        onDone: /* @__PURE__ */ __name(() => fromEffect4(pipe(forEach9(map31.entries(), ([_, innerQueue]) => pipe(offer3(innerQueue, end4), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2())), {
          discard: true
        }), zipRight5(offer3(outerQueue, end4)))), "onDone")
      }), "loop");
      return make55(unwrapScopedWith3((scope5) => gen4(function* () {
        const map31 = /* @__PURE__ */ new Map();
        const queue = yield* unbounded5();
        yield* addFinalizer2(scope5, shutdown4(queue));
        return yield* toChannel2(self2).pipe(pipeTo(loop3(map31, queue)), drain, runIn(scope5), forkIn2(scope5), as6(flattenTake(fromQueue2(queue, {
          shutdown: true
        }))));
      })));
    });
    groupByIterable = /* @__PURE__ */ dual(2, (iterable, f) => {
      const builder = [];
      const iterator2 = iterable[Symbol.iterator]();
      const map31 = /* @__PURE__ */ new Map();
      let next4;
      while ((next4 = iterator2.next()) && !next4.done) {
        const value3 = next4.value;
        const key = f(value3);
        if (map31.has(key)) {
          const innerBuilder = map31.get(key);
          innerBuilder.push(value3);
        } else {
          const innerBuilder = [value3];
          builder.push([key, innerBuilder]);
          map31.set(key, innerBuilder);
        }
      }
      return unsafeFromArray(builder.map((tuple4) => [tuple4[0], unsafeFromArray(tuple4[1])]));
    });
  }
});

// node_modules/effect/dist/esm/GroupBy.js
var init_GroupBy = __esm({
  "node_modules/effect/dist/esm/GroupBy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/HKT.js
var init_HKT = __esm({
  "node_modules/effect/dist/esm/HKT.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/PrimaryKey.js
var init_PrimaryKey = __esm({
  "node_modules/effect/dist/esm/PrimaryKey.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/HashRing.js
var TypeId27, Proto7;
var init_HashRing = __esm({
  "node_modules/effect/dist/esm/HashRing.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Inspectable();
    init_Iterable();
    init_Pipeable();
    TypeId27 = "~effect/cluster/HashRing";
    Proto7 = {
      [TypeId27]: TypeId27,
      [Symbol.iterator]() {
        return map3(this.nodes.values(), ([n]) => n)[Symbol.iterator]();
      },
      pipe() {
        return pipeArguments(this, arguments);
      },
      ...BaseProto,
      toJSON() {
        return {
          _id: "HashRing",
          baseWeight: this.baseWeight,
          nodes: this.ring.map(([, n]) => this.nodes.get(n)[0])
        };
      }
    };
  }
});

// node_modules/effect/dist/esm/ParseResult.js
function sortByIndex(es) {
  return es.sort(compare).map((t) => t[1]);
}
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(orElse(() => getTitleAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), orElse(() => getIdentifierAnnotation(ast)), getOrElse(() => `{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue2) {
  if (issue2.message !== void 0) {
    return issue2.message;
  }
  const expected = isRefinement(issue2.ast) ? getRefinementExpected(issue2.ast) : String(issue2.ast);
  return `Expected ${expected}, actual ${formatUnknown(issue2.actual)}`;
}
var Pointer, Unexpected, Missing, Composite2, Refinement2, Transformation2, Type2, Forbidden, ParseErrorTypeId2, ParseError2, parseError, succeed17, fail17, _try, fromOption3, isEither4, flatMap17, map26, mapError7, mapBoth8, orElse10, mergeInternalOptions, getEither, getSync, getOption3, getEffect, decodeUnknownSync, decodeUnknownOption, decodeUnknownEither, decodeUnknown, encodeUnknownSync, encodeUnknownOption, encodeUnknownEither, encodeUnknown, decodeSync, decodeOption, validateSync, validateOption, validateEither, validate4, is, asserts, encodeSync, encodeOption, decodeMemoMap, encodeMemoMap, goMemo, getConcurrency, getBatching, go, fromRefinement, getLiterals, getSearchTree, dropRightRefinement, handleForbidden, compare, getFinalTransformation, makeTree, TreeFormatter, drawTree, draw, formatTransformationKind, formatRefinementKind, getAnnotated, Either_void, getCurrentMessage, createParseIssueGuard, isComposite2, isRefinement2, isTransformation2, getMessage, getParseIssueTitleAnnotation2, formatTypeMessage, getParseIssueTitle, formatForbiddenMessage, formatUnexpectedMessage, formatMissingMessage, formatTree, makeArrayFormatterIssue, ArrayFormatter, getArrayFormatterIssues;
var init_ParseResult = __esm({
  "node_modules/effect/dist/esm/ParseResult.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Cause();
    init_Data();
    init_Effect();
    init_Either();
    init_Exit();
    init_Function();
    init_GlobalValue();
    init_Inspectable();
    init_util();
    init_Option();
    init_Predicate();
    init_Scheduler();
    init_SchemaAST();
    Pointer = class {
      static {
        __name(this, "Pointer");
      }
      path;
      actual;
      issue;
      /**
       * @since 3.10.0
       */
      _tag = "Pointer";
      constructor(path, actual, issue2) {
        this.path = path;
        this.actual = actual;
        this.issue = issue2;
      }
    };
    Unexpected = class {
      static {
        __name(this, "Unexpected");
      }
      actual;
      message;
      /**
       * @since 3.10.0
       */
      _tag = "Unexpected";
      constructor(actual, message) {
        this.actual = actual;
        this.message = message;
      }
    };
    Missing = class {
      static {
        __name(this, "Missing");
      }
      ast;
      message;
      /**
       * @since 3.10.0
       */
      _tag = "Missing";
      /**
       * @since 3.10.0
       */
      actual = void 0;
      constructor(ast, message) {
        this.ast = ast;
        this.message = message;
      }
    };
    Composite2 = class {
      static {
        __name(this, "Composite");
      }
      ast;
      actual;
      issues;
      output;
      /**
       * @since 3.10.0
       */
      _tag = "Composite";
      constructor(ast, actual, issues, output) {
        this.ast = ast;
        this.actual = actual;
        this.issues = issues;
        this.output = output;
      }
    };
    Refinement2 = class {
      static {
        __name(this, "Refinement");
      }
      ast;
      actual;
      kind;
      issue;
      /**
       * @since 3.10.0
       */
      _tag = "Refinement";
      constructor(ast, actual, kind, issue2) {
        this.ast = ast;
        this.actual = actual;
        this.kind = kind;
        this.issue = issue2;
      }
    };
    Transformation2 = class {
      static {
        __name(this, "Transformation");
      }
      ast;
      actual;
      kind;
      issue;
      /**
       * @since 3.10.0
       */
      _tag = "Transformation";
      constructor(ast, actual, kind, issue2) {
        this.ast = ast;
        this.actual = actual;
        this.kind = kind;
        this.issue = issue2;
      }
    };
    Type2 = class {
      static {
        __name(this, "Type");
      }
      ast;
      actual;
      message;
      /**
       * @since 3.10.0
       */
      _tag = "Type";
      constructor(ast, actual, message) {
        this.ast = ast;
        this.actual = actual;
        this.message = message;
      }
    };
    Forbidden = class {
      static {
        __name(this, "Forbidden");
      }
      ast;
      actual;
      message;
      /**
       * @since 3.10.0
       */
      _tag = "Forbidden";
      constructor(ast, actual, message) {
        this.ast = ast;
        this.actual = actual;
        this.message = message;
      }
    };
    ParseErrorTypeId2 = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
    ParseError2 = class extends (/* @__PURE__ */ TaggedError("ParseError")) {
      static {
        __name(this, "ParseError");
      }
      /**
       * @since 3.10.0
       */
      [ParseErrorTypeId2] = ParseErrorTypeId2;
      get message() {
        return this.toString();
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return TreeFormatter.formatIssueSync(this.issue);
      }
      /**
       * @since 3.10.0
       */
      toJSON() {
        return {
          _id: "ParseError",
          message: this.toString()
        };
      }
      /**
       * @since 3.10.0
       */
      [NodeInspectSymbol]() {
        return this.toJSON();
      }
    };
    parseError = /* @__PURE__ */ __name((issue2) => new ParseError2({
      issue: issue2
    }), "parseError");
    succeed17 = right2;
    fail17 = left2;
    _try = try_;
    fromOption3 = fromOption2;
    isEither4 = isEither2;
    flatMap17 = /* @__PURE__ */ dual(2, (self2, f) => {
      return isEither4(self2) ? match(self2, {
        onLeft: left2,
        onRight: f
      }) : flatMap11(self2, f);
    });
    map26 = /* @__PURE__ */ dual(2, (self2, f) => {
      return isEither4(self2) ? map(self2, f) : map18(self2, f);
    });
    mapError7 = /* @__PURE__ */ dual(2, (self2, f) => {
      return isEither4(self2) ? mapLeft(self2, f) : mapError3(self2, f);
    });
    mapBoth8 = /* @__PURE__ */ dual(2, (self2, options) => {
      return isEither4(self2) ? mapBoth(self2, {
        onLeft: options.onFailure,
        onRight: options.onSuccess
      }) : mapBoth5(self2, options);
    });
    orElse10 = /* @__PURE__ */ dual(2, (self2, f) => {
      return isEither4(self2) ? match(self2, {
        onLeft: f,
        onRight: right2
      }) : catchAll3(self2, f);
    });
    mergeInternalOptions = /* @__PURE__ */ __name((options, overrideOptions) => {
      if (overrideOptions === void 0 || isNumber(overrideOptions)) {
        return options;
      }
      if (options === void 0) {
        return overrideOptions;
      }
      return {
        ...options,
        ...overrideOptions
      };
    }, "mergeInternalOptions");
    getEither = /* @__PURE__ */ __name((ast, isDecoding, options) => {
      const parser = goMemo(ast, isDecoding);
      return (u, overrideOptions) => parser(u, mergeInternalOptions(options, overrideOptions));
    }, "getEither");
    getSync = /* @__PURE__ */ __name((ast, isDecoding, options) => {
      const parser = getEither(ast, isDecoding, options);
      return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
    }, "getSync");
    getOption3 = /* @__PURE__ */ __name((ast, isDecoding, options) => {
      const parser = getEither(ast, isDecoding, options);
      return (input, overrideOptions) => getRight2(parser(input, overrideOptions));
    }, "getOption");
    getEffect = /* @__PURE__ */ __name((ast, isDecoding, options) => {
      const parser = goMemo(ast, isDecoding);
      return (input, overrideOptions) => parser(input, {
        ...mergeInternalOptions(options, overrideOptions),
        isEffectAllowed: true
      });
    }, "getEffect");
    decodeUnknownSync = /* @__PURE__ */ __name((schema, options) => getSync(schema.ast, true, options), "decodeUnknownSync");
    decodeUnknownOption = /* @__PURE__ */ __name((schema, options) => getOption3(schema.ast, true, options), "decodeUnknownOption");
    decodeUnknownEither = /* @__PURE__ */ __name((schema, options) => getEither(schema.ast, true, options), "decodeUnknownEither");
    decodeUnknown = /* @__PURE__ */ __name((schema, options) => getEffect(schema.ast, true, options), "decodeUnknown");
    encodeUnknownSync = /* @__PURE__ */ __name((schema, options) => getSync(schema.ast, false, options), "encodeUnknownSync");
    encodeUnknownOption = /* @__PURE__ */ __name((schema, options) => getOption3(schema.ast, false, options), "encodeUnknownOption");
    encodeUnknownEither = /* @__PURE__ */ __name((schema, options) => getEither(schema.ast, false, options), "encodeUnknownEither");
    encodeUnknown = /* @__PURE__ */ __name((schema, options) => getEffect(schema.ast, false, options), "encodeUnknown");
    decodeSync = decodeUnknownSync;
    decodeOption = decodeUnknownOption;
    validateSync = /* @__PURE__ */ __name((schema, options) => getSync(typeAST(schema.ast), true, options), "validateSync");
    validateOption = /* @__PURE__ */ __name((schema, options) => getOption3(typeAST(schema.ast), true, options), "validateOption");
    validateEither = /* @__PURE__ */ __name((schema, options) => getEither(typeAST(schema.ast), true, options), "validateEither");
    validate4 = /* @__PURE__ */ __name((schema, options) => getEffect(typeAST(schema.ast), true, options), "validate");
    is = /* @__PURE__ */ __name((schema, options) => {
      const parser = goMemo(typeAST(schema.ast), true);
      return (u, overrideOptions) => isRight2(parser(u, {
        exact: true,
        ...mergeInternalOptions(options, overrideOptions)
      }));
    }, "is");
    asserts = /* @__PURE__ */ __name((schema, options) => {
      const parser = goMemo(typeAST(schema.ast), true);
      return (u, overrideOptions) => {
        const result = parser(u, {
          exact: true,
          ...mergeInternalOptions(options, overrideOptions)
        });
        if (isLeft2(result)) {
          throw parseError(result.left);
        }
      };
    }, "asserts");
    encodeSync = encodeUnknownSync;
    encodeOption = encodeUnknownOption;
    decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
    encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
    goMemo = /* @__PURE__ */ __name((ast, isDecoding) => {
      const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
      const memo2 = memoMap.get(ast);
      if (memo2) {
        return memo2;
      }
      const raw = go(ast, isDecoding);
      const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
      const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
      const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
      const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options) => handleForbidden(orElse10(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
      memoMap.set(ast, parser);
      return parser;
    }, "goMemo");
    getConcurrency = /* @__PURE__ */ __name((ast) => getOrUndefined(getConcurrencyAnnotation(ast)), "getConcurrency");
    getBatching = /* @__PURE__ */ __name((ast) => getOrUndefined(getBatchingAnnotation(ast)), "getBatching");
    go = /* @__PURE__ */ __name((ast, isDecoding) => {
      switch (ast._tag) {
        case "Refinement": {
          if (isDecoding) {
            const from2 = goMemo(ast.from, true);
            return (i, options) => {
              options = options ?? defaultParseOption;
              const allErrors = options?.errors === "all";
              const result = flatMap17(orElse10(from2(i, options), (ef) => {
                const issue2 = new Refinement2(ast, i, "From", ef);
                if (allErrors && hasStableFilter(ast) && isComposite2(ef)) {
                  return match2(ast.filter(i, options, ast), {
                    onNone: /* @__PURE__ */ __name(() => left2(issue2), "onNone"),
                    onSome: /* @__PURE__ */ __name((ep) => left2(new Composite2(ast, i, [issue2, new Refinement2(ast, i, "Predicate", ep)])), "onSome")
                  });
                }
                return left2(issue2);
              }), (a) => match2(ast.filter(a, options, ast), {
                onNone: /* @__PURE__ */ __name(() => right2(a), "onNone"),
                onSome: /* @__PURE__ */ __name((ep) => left2(new Refinement2(ast, i, "Predicate", ep)), "onSome")
              }));
              return handleForbidden(result, ast, i, options);
            };
          } else {
            const from2 = goMemo(typeAST(ast), true);
            const to = goMemo(dropRightRefinement(ast.from), false);
            return (i, options) => handleForbidden(flatMap17(from2(i, options), (a) => to(a, options)), ast, i, options);
          }
        }
        case "Transformation": {
          const transform4 = getFinalTransformation(ast.transformation, isDecoding);
          const from2 = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
          const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
          return (i, options) => handleForbidden(flatMap17(mapError7(from2(i, options), (e) => new Transformation2(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap17(mapError7(transform4(a, options ?? defaultParseOption, ast, i), (e) => new Transformation2(ast, i, "Transformation", e)), (i2) => mapError7(to(i2, options), (e) => new Transformation2(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
        }
        case "Declaration": {
          const parse5 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
          return (i, options) => handleForbidden(parse5(i, options ?? defaultParseOption, ast), ast, i, options);
        }
        case "Literal":
          return fromRefinement(ast, (u) => u === ast.literal);
        case "UniqueSymbol":
          return fromRefinement(ast, (u) => u === ast.symbol);
        case "UndefinedKeyword":
          return fromRefinement(ast, isUndefined);
        case "NeverKeyword":
          return fromRefinement(ast, isNever);
        case "UnknownKeyword":
        case "AnyKeyword":
        case "VoidKeyword":
          return right2;
        case "StringKeyword":
          return fromRefinement(ast, isString);
        case "NumberKeyword":
          return fromRefinement(ast, isNumber);
        case "BooleanKeyword":
          return fromRefinement(ast, isBoolean);
        case "BigIntKeyword":
          return fromRefinement(ast, isBigInt);
        case "SymbolKeyword":
          return fromRefinement(ast, isSymbol);
        case "ObjectKeyword":
          return fromRefinement(ast, isObject);
        case "Enums":
          return fromRefinement(ast, (u) => ast.enums.some(([_, value3]) => value3 === u));
        case "TemplateLiteral": {
          const regex = getTemplateLiteralRegExp(ast);
          return fromRefinement(ast, (u) => isString(u) && regex.test(u));
        }
        case "TupleType": {
          const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
          const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
          let requiredTypes = ast.elements.filter((e) => !e.isOptional);
          if (ast.rest.length > 0) {
            requiredTypes = requiredTypes.concat(ast.rest.slice(1));
          }
          const requiredLen = requiredTypes.length;
          const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
          const concurrency = getConcurrency(ast);
          const batching = getBatching(ast);
          return (input, options) => {
            if (!isArray(input)) {
              return left2(new Type2(ast, input));
            }
            const allErrors = options?.errors === "all";
            const es = [];
            let stepKey = 0;
            const output = [];
            const len = input.length;
            for (let i2 = len; i2 <= requiredLen - 1; i2++) {
              const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
            if (ast.rest.length === 0) {
              for (let i2 = ast.elements.length; i2 <= len - 1; i2++) {
                const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              }
            }
            let i = 0;
            let queue = void 0;
            for (; i < elements.length; i++) {
              if (len < i + 1) {
                if (ast.elements[i].isOptional) {
                  continue;
                }
              } else {
                const parser = elements[i];
                const te = parser(input[i], options);
                if (isEither4(te)) {
                  if (isLeft2(te)) {
                    const e = new Pointer(i, input, te.left);
                    if (allErrors) {
                      es.push([stepKey++, e]);
                      continue;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output)));
                    }
                  }
                  output.push([stepKey++, te.right]);
                } else {
                  const nk = stepKey++;
                  const index2 = i;
                  if (!queue) {
                    queue = [];
                  }
                  queue.push(({
                    es: es2,
                    output: output2
                  }) => flatMap11(either4(te), (t) => {
                    if (isLeft2(t)) {
                      const e = new Pointer(index2, input, t.left);
                      if (allErrors) {
                        es2.push([nk, e]);
                        return _void;
                      } else {
                        return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                      }
                    }
                    output2.push([nk, t.right]);
                    return _void;
                  }));
                }
              }
            }
            if (isNonEmptyReadonlyArray(rest)) {
              const [head7, ...tail] = rest;
              for (; i < len - tail.length; i++) {
                const te = head7(input[i], options);
                if (isEither4(te)) {
                  if (isLeft2(te)) {
                    const e = new Pointer(i, input, te.left);
                    if (allErrors) {
                      es.push([stepKey++, e]);
                      continue;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output)));
                    }
                  } else {
                    output.push([stepKey++, te.right]);
                  }
                } else {
                  const nk = stepKey++;
                  const index2 = i;
                  if (!queue) {
                    queue = [];
                  }
                  queue.push(({
                    es: es2,
                    output: output2
                  }) => flatMap11(either4(te), (t) => {
                    if (isLeft2(t)) {
                      const e = new Pointer(index2, input, t.left);
                      if (allErrors) {
                        es2.push([nk, e]);
                        return _void;
                      } else {
                        return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                      }
                    } else {
                      output2.push([nk, t.right]);
                      return _void;
                    }
                  }));
                }
              }
              for (let j = 0; j < tail.length; j++) {
                i += j;
                if (len < i + 1) {
                  continue;
                } else {
                  const te = tail[j](input[i], options);
                  if (isEither4(te)) {
                    if (isLeft2(te)) {
                      const e = new Pointer(i, input, te.left);
                      if (allErrors) {
                        es.push([stepKey++, e]);
                        continue;
                      } else {
                        return left2(new Composite2(ast, input, e, sortByIndex(output)));
                      }
                    }
                    output.push([stepKey++, te.right]);
                  } else {
                    const nk = stepKey++;
                    const index2 = i;
                    if (!queue) {
                      queue = [];
                    }
                    queue.push(({
                      es: es2,
                      output: output2
                    }) => flatMap11(either4(te), (t) => {
                      if (isLeft2(t)) {
                        const e = new Pointer(index2, input, t.left);
                        if (allErrors) {
                          es2.push([nk, e]);
                          return _void;
                        } else {
                          return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                        }
                      }
                      output2.push([nk, t.right]);
                      return _void;
                    }));
                  }
                }
              }
            }
            const computeResult = /* @__PURE__ */ __name(({
              es: es2,
              output: output2
            }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2)), "computeResult");
            if (queue && queue.length > 0) {
              const cqueue = queue;
              return suspend4(() => {
                const state = {
                  es: copy(es),
                  output: copy(output)
                };
                return flatMap11(forEach9(cqueue, (f) => f(state), {
                  concurrency,
                  batching,
                  discard: true
                }), () => computeResult(state));
              });
            }
            return computeResult({
              output,
              es
            });
          };
        }
        case "TypeLiteral": {
          if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
            return fromRefinement(ast, isNotNullable);
          }
          const propertySignatures = [];
          const expectedKeysMap = {};
          const expectedKeys = [];
          for (const ps of ast.propertySignatures) {
            propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
            expectedKeysMap[ps.name] = null;
            expectedKeys.push(ps.name);
          }
          const indexSignatures = ast.indexSignatures.map((is3) => [goMemo(is3.parameter, isDecoding), goMemo(is3.type, isDecoding), is3.parameter]);
          const expectedAST = Union.make(ast.indexSignatures.map((is3) => is3.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
          const expected = goMemo(expectedAST, isDecoding);
          const concurrency = getConcurrency(ast);
          const batching = getBatching(ast);
          return (input, options) => {
            if (!isRecord(input)) {
              return left2(new Type2(ast, input));
            }
            const allErrors = options?.errors === "all";
            const es = [];
            let stepKey = 0;
            const onExcessPropertyError = options?.onExcessProperty === "error";
            const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
            const output = {};
            let inputKeys;
            if (onExcessPropertyError || onExcessPropertyPreserve) {
              inputKeys = Reflect.ownKeys(input);
              for (const key of inputKeys) {
                const te = expected(key, options);
                if (isEither4(te) && isLeft2(te)) {
                  if (onExcessPropertyError) {
                    const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                    if (allErrors) {
                      es.push([stepKey++, e]);
                      continue;
                    } else {
                      return left2(new Composite2(ast, input, e, output));
                    }
                  } else {
                    output[key] = input[key];
                  }
                }
              }
            }
            let queue = void 0;
            const isExact = options?.exact === true;
            for (let i = 0; i < propertySignatures.length; i++) {
              const ps = propertySignatures[i][1];
              const name = ps.name;
              const hasKey = Object.prototype.hasOwnProperty.call(input, name);
              if (!hasKey) {
                if (ps.isOptional) {
                  continue;
                } else if (isExact) {
                  const e = new Pointer(name, input, new Missing(ps));
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                }
              }
              const parser = propertySignatures[i][0];
              const te = parser(input[name], options);
              if (isEither4(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                }
                output[name] = te.right;
              } else {
                const nk = stepKey++;
                const index2 = name;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap11(either4(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index2, input, hasKey ? t.left : new Missing(ps));
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, output2));
                    }
                  }
                  output2[index2] = t.right;
                  return _void;
                }));
              }
            }
            for (let i = 0; i < indexSignatures.length; i++) {
              const indexSignature = indexSignatures[i];
              const parameter = indexSignature[0];
              const type = indexSignature[1];
              const keys5 = getKeysForIndexSignature(input, indexSignature[2]);
              for (const key of keys5) {
                const keu = parameter(key, options);
                if (isEither4(keu) && isRight2(keu)) {
                  const vpr = type(input[key], options);
                  if (isEither4(vpr)) {
                    if (isLeft2(vpr)) {
                      const e = new Pointer(key, input, vpr.left);
                      if (allErrors) {
                        es.push([stepKey++, e]);
                        continue;
                      } else {
                        return left2(new Composite2(ast, input, e, output));
                      }
                    } else {
                      if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                        output[key] = vpr.right;
                      }
                    }
                  } else {
                    const nk = stepKey++;
                    const index2 = key;
                    if (!queue) {
                      queue = [];
                    }
                    queue.push(({
                      es: es2,
                      output: output2
                    }) => flatMap11(either4(vpr), (tv) => {
                      if (isLeft2(tv)) {
                        const e = new Pointer(index2, input, tv.left);
                        if (allErrors) {
                          es2.push([nk, e]);
                          return _void;
                        } else {
                          return left2(new Composite2(ast, input, e, output2));
                        }
                      } else {
                        if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                          output2[key] = tv.right;
                        }
                        return _void;
                      }
                    }));
                  }
                }
              }
            }
            const computeResult = /* @__PURE__ */ __name(({
              es: es2,
              output: output2
            }) => {
              if (isNonEmptyArray2(es2)) {
                return left2(new Composite2(ast, input, sortByIndex(es2), output2));
              }
              if (options?.propertyOrder === "original") {
                const keys5 = inputKeys || Reflect.ownKeys(input);
                for (const name of expectedKeys) {
                  if (keys5.indexOf(name) === -1) {
                    keys5.push(name);
                  }
                }
                const out = {};
                for (const key of keys5) {
                  if (Object.prototype.hasOwnProperty.call(output2, key)) {
                    out[key] = output2[key];
                  }
                }
                return right2(out);
              }
              return right2(output2);
            }, "computeResult");
            if (queue && queue.length > 0) {
              const cqueue = queue;
              return suspend4(() => {
                const state = {
                  es: copy(es),
                  output: Object.assign({}, output)
                };
                return flatMap11(forEach9(cqueue, (f) => f(state), {
                  concurrency,
                  batching,
                  discard: true
                }), () => computeResult(state));
              });
            }
            return computeResult({
              es,
              output
            });
          };
        }
        case "Union": {
          const searchTree = getSearchTree(ast.types, isDecoding);
          const ownKeys = Reflect.ownKeys(searchTree.keys);
          const ownKeysLen = ownKeys.length;
          const astTypesLen = ast.types.length;
          const map31 = /* @__PURE__ */ new Map();
          for (let i = 0; i < astTypesLen; i++) {
            map31.set(ast.types[i], goMemo(ast.types[i], isDecoding));
          }
          const concurrency = getConcurrency(ast) ?? 1;
          const batching = getBatching(ast);
          return (input, options) => {
            const es = [];
            let stepKey = 0;
            let candidates = [];
            if (ownKeysLen > 0) {
              if (isRecordOrArray(input)) {
                for (let i = 0; i < ownKeysLen; i++) {
                  const name = ownKeys[i];
                  const buckets = searchTree.keys[name].buckets;
                  if (Object.prototype.hasOwnProperty.call(input, name)) {
                    const literal3 = String(input[name]);
                    if (Object.prototype.hasOwnProperty.call(buckets, literal3)) {
                      candidates = candidates.concat(buckets[literal3]);
                    } else {
                      const {
                        candidates: candidates2,
                        literals
                      } = searchTree.keys[name];
                      const literalsUnion = Union.make(literals);
                      const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates2);
                      es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Type2(literalsUnion, input[name])))]);
                    }
                  } else {
                    const {
                      candidates: candidates2,
                      literals
                    } = searchTree.keys[name];
                    const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
                    const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                    es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
                  }
                }
              } else {
                const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
                es.push([stepKey++, new Type2(errorAst, input)]);
              }
            }
            if (searchTree.otherwise.length > 0) {
              candidates = candidates.concat(searchTree.otherwise);
            }
            let queue = void 0;
            for (let i = 0; i < candidates.length; i++) {
              const candidate = candidates[i];
              const pr = map31.get(candidate)(input, options);
              if (isEither4(pr) && (!queue || queue.length === 0)) {
                if (isRight2(pr)) {
                  return pr;
                } else {
                  es.push([stepKey++, pr.left]);
                }
              } else {
                const nk = stepKey++;
                if (!queue) {
                  queue = [];
                }
                queue.push((state) => suspend4(() => {
                  if ("finalResult" in state) {
                    return _void;
                  } else {
                    return flatMap11(either4(pr), (t) => {
                      if (isRight2(t)) {
                        state.finalResult = t;
                      } else {
                        state.es.push([nk, t.left]);
                      }
                      return _void;
                    });
                  }
                }));
              }
            }
            const computeResult = /* @__PURE__ */ __name((es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : (
              // this should never happen
              left2(new Type2(ast, input))
            ), "computeResult");
            if (queue && queue.length > 0) {
              const cqueue = queue;
              return suspend4(() => {
                const state = {
                  es: copy(es)
                };
                return flatMap11(forEach9(cqueue, (f) => f(state), {
                  concurrency,
                  batching,
                  discard: true
                }), () => {
                  if ("finalResult" in state) {
                    return state.finalResult;
                  }
                  return computeResult(state.es);
                });
              });
            }
            return computeResult(es);
          };
        }
        case "Suspend": {
          const get18 = memoizeThunk(() => goMemo(ast.f(), isDecoding));
          return (a, options) => get18()(a, options);
        }
      }
    }, "go");
    fromRefinement = /* @__PURE__ */ __name((ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u)), "fromRefinement");
    getLiterals = /* @__PURE__ */ __name((ast, isDecoding) => {
      switch (ast._tag) {
        case "Declaration": {
          const annotation = getSurrogateAnnotation(ast);
          if (isSome2(annotation)) {
            return getLiterals(annotation.value, isDecoding);
          }
          break;
        }
        case "TypeLiteral": {
          const out = [];
          for (let i = 0; i < ast.propertySignatures.length; i++) {
            const propertySignature2 = ast.propertySignatures[i];
            const type = isDecoding ? encodedAST(propertySignature2.type) : typeAST(propertySignature2.type);
            if (isLiteral(type) && !propertySignature2.isOptional) {
              out.push([propertySignature2.name, type]);
            }
          }
          return out;
        }
        case "TupleType": {
          const out = [];
          for (let i = 0; i < ast.elements.length; i++) {
            const element2 = ast.elements[i];
            const type = isDecoding ? encodedAST(element2.type) : typeAST(element2.type);
            if (isLiteral(type) && !element2.isOptional) {
              out.push([i, type]);
            }
          }
          return out;
        }
        case "Refinement":
          return getLiterals(ast.from, isDecoding);
        case "Suspend":
          return getLiterals(ast.f(), isDecoding);
        case "Transformation":
          return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
      }
      return [];
    }, "getLiterals");
    getSearchTree = /* @__PURE__ */ __name((members, isDecoding) => {
      const keys5 = {};
      const otherwise = [];
      const candidates = [];
      for (let i = 0; i < members.length; i++) {
        const member = members[i];
        const tags = getLiterals(member, isDecoding);
        if (tags.length > 0) {
          candidates.push(member);
          for (let j = 0; j < tags.length; j++) {
            const [key, literal3] = tags[j];
            const hash4 = String(literal3.literal);
            keys5[key] = keys5[key] || {
              buckets: {},
              literals: [],
              candidates: []
            };
            const buckets = keys5[key].buckets;
            if (Object.prototype.hasOwnProperty.call(buckets, hash4)) {
              if (j < tags.length - 1) {
                continue;
              }
              buckets[hash4].push(member);
              keys5[key].literals.push(literal3);
              keys5[key].candidates.push(member);
            } else {
              buckets[hash4] = [member];
              keys5[key].literals.push(literal3);
              keys5[key].candidates.push(member);
              break;
            }
          }
        } else {
          otherwise.push(member);
        }
      }
      return {
        keys: keys5,
        otherwise,
        candidates
      };
    }, "getSearchTree");
    dropRightRefinement = /* @__PURE__ */ __name((ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast, "dropRightRefinement");
    handleForbidden = /* @__PURE__ */ __name((effect4, ast, actual, options) => {
      if (options?.isEffectAllowed === true) {
        return effect4;
      }
      if (isEither4(effect4)) {
        return effect4;
      }
      const scheduler2 = new SyncScheduler();
      const fiber = runFork2(effect4, {
        scheduler: scheduler2
      });
      scheduler2.flush();
      const exit5 = fiber.unsafePoll();
      if (exit5) {
        if (isSuccess(exit5)) {
          return right2(exit5.value);
        }
        const cause3 = exit5.cause;
        if (isFailType2(cause3)) {
          return left2(cause3.error);
        }
        return left2(new Forbidden(ast, actual, pretty2(cause3)));
      }
      return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
    }, "handleForbidden");
    compare = /* @__PURE__ */ __name(([a], [b]) => a > b ? 1 : a < b ? -1 : 0, "compare");
    __name(sortByIndex, "sortByIndex");
    getFinalTransformation = /* @__PURE__ */ __name((transformation, isDecoding) => {
      switch (transformation._tag) {
        case "FinalTransformation":
          return isDecoding ? transformation.decode : transformation.encode;
        case "ComposeTransformation":
          return right2;
        case "TypeLiteralTransformation":
          return (input) => {
            let out = right2(input);
            for (const pst of transformation.propertySignatureTransformations) {
              const [from2, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
              const transformation2 = isDecoding ? pst.decode : pst.encode;
              const f = /* @__PURE__ */ __name((input2) => {
                const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from2) ? some2(input2[from2]) : none2());
                delete input2[from2];
                if (isSome2(o)) {
                  input2[to] = o.value;
                }
                return input2;
              }, "f");
              out = map26(out, f);
            }
            return out;
          };
      }
    }, "getFinalTransformation");
    makeTree = /* @__PURE__ */ __name((value3, forest = []) => ({
      value: value3,
      forest
    }), "makeTree");
    TreeFormatter = {
      formatIssue: /* @__PURE__ */ __name((issue2) => map26(formatTree(issue2), drawTree), "formatIssue"),
      formatIssueSync: /* @__PURE__ */ __name((issue2) => {
        const e = TreeFormatter.formatIssue(issue2);
        return isEither4(e) ? getOrThrow(e) : runSync(e);
      }, "formatIssueSync"),
      formatError: /* @__PURE__ */ __name((error50) => TreeFormatter.formatIssue(error50.issue), "formatError"),
      formatErrorSync: /* @__PURE__ */ __name((error50) => TreeFormatter.formatIssueSync(error50.issue), "formatErrorSync")
    };
    drawTree = /* @__PURE__ */ __name((tree) => tree.value + draw("\n", tree.forest), "drawTree");
    draw = /* @__PURE__ */ __name((indentation, forest) => {
      let r = "";
      const len = forest.length;
      let tree;
      for (let i = 0; i < len; i++) {
        tree = forest[i];
        const isLast = i === len - 1;
        r += indentation + (isLast ? "\u2514" : "\u251C") + "\u2500 " + tree.value;
        r += draw(indentation + (len > 1 && !isLast ? "\u2502  " : "   "), tree.forest);
      }
      return r;
    }, "draw");
    formatTransformationKind = /* @__PURE__ */ __name((kind) => {
      switch (kind) {
        case "Encoded":
          return "Encoded side transformation failure";
        case "Transformation":
          return "Transformation process failure";
        case "Type":
          return "Type side transformation failure";
      }
    }, "formatTransformationKind");
    formatRefinementKind = /* @__PURE__ */ __name((kind) => {
      switch (kind) {
        case "From":
          return "From side refinement failure";
        case "Predicate":
          return "Predicate refinement failure";
      }
    }, "formatRefinementKind");
    getAnnotated = /* @__PURE__ */ __name((issue2) => "ast" in issue2 ? some2(issue2.ast) : none2(), "getAnnotated");
    Either_void = /* @__PURE__ */ right2(void 0);
    getCurrentMessage = /* @__PURE__ */ __name((issue2) => getAnnotated(issue2).pipe(flatMap(getMessageAnnotation), match2({
      onNone: /* @__PURE__ */ __name(() => Either_void, "onNone"),
      onSome: /* @__PURE__ */ __name((messageAnnotation) => {
        const union13 = messageAnnotation(issue2);
        if (isString(union13)) {
          return right2({
            message: union13,
            override: false
          });
        }
        if (isEffect2(union13)) {
          return map18(union13, (message) => ({
            message,
            override: false
          }));
        }
        if (isString(union13.message)) {
          return right2({
            message: union13.message,
            override: union13.override
          });
        }
        return map18(union13.message, (message) => ({
          message,
          override: union13.override
        }));
      }, "onSome")
    })), "getCurrentMessage");
    createParseIssueGuard = /* @__PURE__ */ __name((tag2) => (issue2) => issue2._tag === tag2, "createParseIssueGuard");
    isComposite2 = /* @__PURE__ */ createParseIssueGuard("Composite");
    isRefinement2 = /* @__PURE__ */ createParseIssueGuard("Refinement");
    isTransformation2 = /* @__PURE__ */ createParseIssueGuard("Transformation");
    getMessage = /* @__PURE__ */ __name((issue2) => flatMap17(getCurrentMessage(issue2), (currentMessage) => {
      if (currentMessage !== void 0) {
        const useInnerMessage = !currentMessage.override && (isComposite2(issue2) || isRefinement2(issue2) && issue2.kind === "From" || isTransformation2(issue2) && issue2.kind !== "Transformation");
        return useInnerMessage ? isTransformation2(issue2) || isRefinement2(issue2) ? getMessage(issue2.issue) : Either_void : right2(currentMessage.message);
      }
      return Either_void;
    }), "getMessage");
    getParseIssueTitleAnnotation2 = /* @__PURE__ */ __name((issue2) => getAnnotated(issue2).pipe(flatMap(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue2)), getOrUndefined), "getParseIssueTitleAnnotation");
    __name(getRefinementExpected, "getRefinementExpected");
    __name(getDefaultTypeMessage, "getDefaultTypeMessage");
    formatTypeMessage = /* @__PURE__ */ __name((issue2) => map26(getMessage(issue2), (message) => message ?? getParseIssueTitleAnnotation2(issue2) ?? getDefaultTypeMessage(issue2)), "formatTypeMessage");
    getParseIssueTitle = /* @__PURE__ */ __name((issue2) => getParseIssueTitleAnnotation2(issue2) ?? String(issue2.ast), "getParseIssueTitle");
    formatForbiddenMessage = /* @__PURE__ */ __name((issue2) => issue2.message ?? "is forbidden", "formatForbiddenMessage");
    formatUnexpectedMessage = /* @__PURE__ */ __name((issue2) => issue2.message ?? "is unexpected", "formatUnexpectedMessage");
    formatMissingMessage = /* @__PURE__ */ __name((issue2) => {
      const missingMessageAnnotation = getMissingMessageAnnotation(issue2.ast);
      if (isSome2(missingMessageAnnotation)) {
        const annotation = missingMessageAnnotation.value();
        return isString(annotation) ? right2(annotation) : annotation;
      }
      return right2(issue2.message ?? "is missing");
    }, "formatMissingMessage");
    formatTree = /* @__PURE__ */ __name((issue2) => {
      switch (issue2._tag) {
        case "Type":
          return map26(formatTypeMessage(issue2), makeTree);
        case "Forbidden":
          return right2(makeTree(getParseIssueTitle(issue2), [makeTree(formatForbiddenMessage(issue2))]));
        case "Unexpected":
          return right2(makeTree(formatUnexpectedMessage(issue2)));
        case "Missing":
          return map26(formatMissingMessage(issue2), makeTree);
        case "Transformation":
          return flatMap17(getMessage(issue2), (message) => {
            if (message !== void 0) {
              return right2(makeTree(message));
            }
            return map26(formatTree(issue2.issue), (tree) => makeTree(getParseIssueTitle(issue2), [makeTree(formatTransformationKind(issue2.kind), [tree])]));
          });
        case "Refinement":
          return flatMap17(getMessage(issue2), (message) => {
            if (message !== void 0) {
              return right2(makeTree(message));
            }
            return map26(formatTree(issue2.issue), (tree) => makeTree(getParseIssueTitle(issue2), [makeTree(formatRefinementKind(issue2.kind), [tree])]));
          });
        case "Pointer":
          return map26(formatTree(issue2.issue), (tree) => makeTree(formatPath(issue2.path), [tree]));
        case "Composite":
          return flatMap17(getMessage(issue2), (message) => {
            if (message !== void 0) {
              return right2(makeTree(message));
            }
            const parseIssueTitle = getParseIssueTitle(issue2);
            return isNonEmpty(issue2.issues) ? map26(forEach9(issue2.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map26(formatTree(issue2.issues), (tree) => makeTree(parseIssueTitle, [tree]));
          });
      }
    }, "formatTree");
    makeArrayFormatterIssue = /* @__PURE__ */ __name((_tag, path, message) => ({
      _tag,
      path,
      message
    }), "makeArrayFormatterIssue");
    ArrayFormatter = {
      formatIssue: /* @__PURE__ */ __name((issue2) => getArrayFormatterIssues(issue2, void 0, []), "formatIssue"),
      formatIssueSync: /* @__PURE__ */ __name((issue2) => {
        const e = ArrayFormatter.formatIssue(issue2);
        return isEither4(e) ? getOrThrow(e) : runSync(e);
      }, "formatIssueSync"),
      formatError: /* @__PURE__ */ __name((error50) => ArrayFormatter.formatIssue(error50.issue), "formatError"),
      formatErrorSync: /* @__PURE__ */ __name((error50) => ArrayFormatter.formatIssueSync(error50.issue), "formatErrorSync")
    };
    getArrayFormatterIssues = /* @__PURE__ */ __name((issue2, parentTag, path) => {
      const _tag = issue2._tag;
      switch (_tag) {
        case "Type":
          return map26(formatTypeMessage(issue2), (message) => [makeArrayFormatterIssue(parentTag ?? _tag, path, message)]);
        case "Forbidden":
          return right2([makeArrayFormatterIssue(_tag, path, formatForbiddenMessage(issue2))]);
        case "Unexpected":
          return right2([makeArrayFormatterIssue(_tag, path, formatUnexpectedMessage(issue2))]);
        case "Missing":
          return map26(formatMissingMessage(issue2), (message) => [makeArrayFormatterIssue(_tag, path, message)]);
        case "Pointer":
          return getArrayFormatterIssues(issue2.issue, void 0, path.concat(issue2.path));
        case "Composite":
          return flatMap17(getMessage(issue2), (message) => {
            if (message !== void 0) {
              return right2([makeArrayFormatterIssue(_tag, path, message)]);
            }
            return isNonEmpty(issue2.issues) ? map26(forEach9(issue2.issues, (issue3) => getArrayFormatterIssues(issue3, void 0, path)), flatten2) : getArrayFormatterIssues(issue2.issues, void 0, path);
          });
        case "Refinement":
          return flatMap17(getMessage(issue2), (message) => {
            if (message !== void 0) {
              return right2([makeArrayFormatterIssue(_tag, path, message)]);
            }
            return getArrayFormatterIssues(issue2.issue, issue2.kind === "Predicate" ? _tag : void 0, path);
          });
        case "Transformation":
          return flatMap17(getMessage(issue2), (message) => {
            if (message !== void 0) {
              return right2([makeArrayFormatterIssue(_tag, path, message)]);
            }
            return getArrayFormatterIssues(issue2.issue, issue2.kind === "Transformation" ? _tag : void 0, path);
          });
      }
    }, "getArrayFormatterIssues");
  }
});

// node_modules/effect/dist/esm/JSONSchema.js
var init_JSONSchema = __esm({
  "node_modules/effect/dist/esm/JSONSchema.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/KeyedPool.js
var init_KeyedPool = __esm({
  "node_modules/effect/dist/esm/KeyedPool.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/RcMap.js
var init_RcMap = __esm({
  "node_modules/effect/dist/esm/RcMap.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/LayerMap.js
var init_LayerMap = __esm({
  "node_modules/effect/dist/esm/LayerMap.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Logger.js
var init_Logger = __esm({
  "node_modules/effect/dist/esm/Logger.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Mailbox.js
var init_Mailbox = __esm({
  "node_modules/effect/dist/esm/Mailbox.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/ManagedRuntime.js
var init_ManagedRuntime = __esm({
  "node_modules/effect/dist/esm/ManagedRuntime.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Match.js
var init_Match = __esm({
  "node_modules/effect/dist/esm/Match.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/MergeState.js
var init_MergeState = __esm({
  "node_modules/effect/dist/esm/MergeState.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/MergeStrategy.js
var init_MergeStrategy = __esm({
  "node_modules/effect/dist/esm/MergeStrategy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Metric.js
var init_Metric = __esm({
  "node_modules/effect/dist/esm/Metric.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/MetricBoundaries.js
var init_MetricBoundaries = __esm({
  "node_modules/effect/dist/esm/MetricBoundaries.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/MetricHook.js
var init_MetricHook = __esm({
  "node_modules/effect/dist/esm/MetricHook.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/MetricKey.js
var init_MetricKey = __esm({
  "node_modules/effect/dist/esm/MetricKey.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/MetricKeyType.js
var init_MetricKeyType = __esm({
  "node_modules/effect/dist/esm/MetricKeyType.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/MetricLabel.js
var init_MetricLabel = __esm({
  "node_modules/effect/dist/esm/MetricLabel.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/MetricPair.js
var init_MetricPair = __esm({
  "node_modules/effect/dist/esm/MetricPair.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/MetricPolling.js
var init_MetricPolling = __esm({
  "node_modules/effect/dist/esm/MetricPolling.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/MetricRegistry.js
var init_MetricRegistry = __esm({
  "node_modules/effect/dist/esm/MetricRegistry.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/MetricState.js
var init_MetricState = __esm({
  "node_modules/effect/dist/esm/MetricState.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/ModuleVersion.js
var init_ModuleVersion = __esm({
  "node_modules/effect/dist/esm/ModuleVersion.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/MutableHashSet.js
var TypeId28, MutableHashSetProto;
var init_MutableHashSet = __esm({
  "node_modules/effect/dist/esm/MutableHashSet.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Inspectable();
    init_Pipeable();
    TypeId28 = /* @__PURE__ */ Symbol.for("effect/MutableHashSet");
    MutableHashSetProto = {
      [TypeId28]: TypeId28,
      [Symbol.iterator]() {
        return Array.from(this.keyMap).map(([_]) => _)[Symbol.iterator]();
      },
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "MutableHashSet",
          values: Array.from(this).map(toJSON)
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
  }
});

// node_modules/effect/dist/esm/NonEmptyIterable.js
var init_NonEmptyIterable = __esm({
  "node_modules/effect/dist/esm/NonEmptyIterable.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Ordering.js
var init_Ordering = __esm({
  "node_modules/effect/dist/esm/Ordering.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/PartitionedSemaphore.js
var init_PartitionedSemaphore = __esm({
  "node_modules/effect/dist/esm/PartitionedSemaphore.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Pool.js
var init_Pool = __esm({
  "node_modules/effect/dist/esm/Pool.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Pretty.js
var init_Pretty = __esm({
  "node_modules/effect/dist/esm/Pretty.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/RateLimiter.js
var init_RateLimiter = __esm({
  "node_modules/effect/dist/esm/RateLimiter.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Redacted.js
var isRedacted2, make56, value2, getEquivalence7;
var init_Redacted = __esm({
  "node_modules/effect/dist/esm/Redacted.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equivalence();
    init_redacted();
    isRedacted2 = isRedacted;
    make56 = make53;
    value2 = value;
    getEquivalence7 = /* @__PURE__ */ __name((isEquivalent) => make((x, y) => isEquivalent(value2(x), value2(y))), "getEquivalence");
  }
});

// node_modules/effect/dist/esm/Reloadable.js
var init_Reloadable = __esm({
  "node_modules/effect/dist/esm/Reloadable.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/RequestBlock.js
var init_RequestBlock = __esm({
  "node_modules/effect/dist/esm/RequestBlock.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/RequestResolver.js
var init_RequestResolver = __esm({
  "node_modules/effect/dist/esm/RequestResolver.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Resource.js
var init_Resource = __esm({
  "node_modules/effect/dist/esm/Resource.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/RuntimeFlags.js
var init_RuntimeFlags = __esm({
  "node_modules/effect/dist/esm/RuntimeFlags.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/STM.js
var init_STM = __esm({
  "node_modules/effect/dist/esm/STM.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Struct.js
var pick4, omit4;
var init_Struct = __esm({
  "node_modules/effect/dist/esm/Struct.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_Predicate();
    pick4 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys5) => {
      const out = {};
      for (const k of keys5) {
        if (k in s) {
          out[k] = s[k];
        }
      }
      return out;
    });
    omit4 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys5) => {
      const out = {
        ...s
      };
      for (const k of keys5) {
        delete out[k];
      }
      return out;
    });
  }
});

// node_modules/effect/dist/esm/Schema.js
var Schema_exports = {};
__export(Schema_exports, {
  Any: () => Any,
  Array: () => Array$,
  ArrayEnsure: () => ArrayEnsure,
  ArrayFormatterIssue: () => ArrayFormatterIssue,
  BetweenBigDecimalSchemaId: () => BetweenBigDecimalSchemaId,
  BetweenBigIntSchemaId: () => BetweenBigIntSchemaId,
  BetweenDateSchemaId: () => BetweenDateSchemaId,
  BetweenDurationSchemaId: () => BetweenDurationSchemaId,
  BetweenSchemaId: () => BetweenSchemaId2,
  BigDecimal: () => BigDecimal,
  BigDecimalFromNumber: () => BigDecimalFromNumber,
  BigDecimalFromSelf: () => BigDecimalFromSelf,
  BigInt: () => BigInt$,
  BigIntFromNumber: () => BigIntFromNumber,
  BigIntFromSelf: () => BigIntFromSelf,
  Boolean: () => Boolean$,
  BooleanFromString: () => BooleanFromString,
  BooleanFromUnknown: () => BooleanFromUnknown,
  BrandSchemaId: () => BrandSchemaId,
  Capitalize: () => Capitalize,
  Capitalized: () => Capitalized,
  CapitalizedSchemaId: () => CapitalizedSchemaId,
  Cause: () => Cause,
  CauseFromSelf: () => CauseFromSelf,
  Char: () => Char,
  Chunk: () => Chunk,
  ChunkFromSelf: () => ChunkFromSelf,
  Class: () => Class6,
  Config: () => Config,
  Data: () => Data,
  DataFromSelf: () => DataFromSelf,
  Date: () => Date$,
  DateFromNumber: () => DateFromNumber,
  DateFromSelf: () => DateFromSelf,
  DateFromSelfSchemaId: () => DateFromSelfSchemaId2,
  DateFromString: () => DateFromString,
  DateTimeUtc: () => DateTimeUtc,
  DateTimeUtcFromDate: () => DateTimeUtcFromDate,
  DateTimeUtcFromNumber: () => DateTimeUtcFromNumber,
  DateTimeUtcFromSelf: () => DateTimeUtcFromSelf,
  DateTimeZoned: () => DateTimeZoned,
  DateTimeZonedFromSelf: () => DateTimeZonedFromSelf,
  Defect: () => Defect,
  Duration: () => Duration,
  DurationFromMillis: () => DurationFromMillis,
  DurationFromNanos: () => DurationFromNanos,
  DurationFromSelf: () => DurationFromSelf,
  Either: () => Either2,
  EitherFromSelf: () => EitherFromSelf,
  EitherFromUnion: () => EitherFromUnion,
  EndsWithSchemaId: () => EndsWithSchemaId,
  Enums: () => Enums2,
  Exit: () => Exit,
  ExitFromSelf: () => ExitFromSelf,
  FiberId: () => FiberId,
  FiberIdFromSelf: () => FiberIdFromSelf,
  Finite: () => Finite,
  FiniteSchemaId: () => FiniteSchemaId2,
  FromPropertySignature: () => FromPropertySignature,
  GreaterThanBigDecimalSchemaId: () => GreaterThanBigDecimalSchemaId,
  GreaterThanBigIntSchemaId: () => GreaterThanBigIntSchemaId,
  GreaterThanDateSchemaId: () => GreaterThanDateSchemaId,
  GreaterThanDurationSchemaId: () => GreaterThanDurationSchemaId,
  GreaterThanOrEqualToBigDecimalSchemaId: () => GreaterThanOrEqualToBigDecimalSchemaId,
  GreaterThanOrEqualToBigIntSchemaId: () => GreaterThanOrEqualToBigIntSchemaId2,
  GreaterThanOrEqualToDateSchemaId: () => GreaterThanOrEqualToDateSchemaId,
  GreaterThanOrEqualToDurationSchemaId: () => GreaterThanOrEqualToDurationSchemaId,
  GreaterThanOrEqualToSchemaId: () => GreaterThanOrEqualToSchemaId2,
  GreaterThanSchemaId: () => GreaterThanSchemaId2,
  HashMap: () => HashMap,
  HashMapFromSelf: () => HashMapFromSelf,
  HashSet: () => HashSet,
  HashSetFromSelf: () => HashSetFromSelf,
  IncludesSchemaId: () => IncludesSchemaId,
  InstanceOfSchemaId: () => InstanceOfSchemaId,
  Int: () => Int,
  IntSchemaId: () => IntSchemaId2,
  ItemsCountSchemaId: () => ItemsCountSchemaId2,
  JsonNumber: () => JsonNumber,
  JsonNumberSchemaId: () => JsonNumberSchemaId2,
  LengthSchemaId: () => LengthSchemaId2,
  LessThanBigDecimalSchemaId: () => LessThanBigDecimalSchemaId,
  LessThanBigIntSchemaId: () => LessThanBigIntSchemaId2,
  LessThanDateSchemaId: () => LessThanDateSchemaId,
  LessThanDurationSchemaId: () => LessThanDurationSchemaId,
  LessThanOrEqualToBigDecimalSchemaId: () => LessThanOrEqualToBigDecimalSchemaId,
  LessThanOrEqualToBigIntSchemaId: () => LessThanOrEqualToBigIntSchemaId2,
  LessThanOrEqualToDateSchemaId: () => LessThanOrEqualToDateSchemaId,
  LessThanOrEqualToDurationSchemaId: () => LessThanOrEqualToDurationSchemaId,
  LessThanOrEqualToSchemaId: () => LessThanOrEqualToSchemaId2,
  LessThanSchemaId: () => LessThanSchemaId2,
  List: () => List,
  ListFromSelf: () => ListFromSelf,
  Literal: () => Literal2,
  Lowercase: () => Lowercase,
  Lowercased: () => Lowercased,
  LowercasedSchemaId: () => LowercasedSchemaId,
  Map: () => map27,
  MapFromRecord: () => MapFromRecord,
  MapFromSelf: () => MapFromSelf,
  MaxItemsSchemaId: () => MaxItemsSchemaId2,
  MaxLengthSchemaId: () => MaxLengthSchemaId2,
  MinItemsSchemaId: () => MinItemsSchemaId2,
  MinLengthSchemaId: () => MinLengthSchemaId2,
  MultipleOfSchemaId: () => MultipleOfSchemaId,
  Negative: () => Negative,
  NegativeBigDecimalFromSelf: () => NegativeBigDecimalFromSelf,
  NegativeBigDecimalSchemaId: () => NegativeBigDecimalSchemaId,
  NegativeBigInt: () => NegativeBigInt,
  NegativeBigIntFromSelf: () => NegativeBigIntFromSelf,
  Never: () => Never,
  NonEmptyArray: () => NonEmptyArray,
  NonEmptyArrayEnsure: () => NonEmptyArrayEnsure,
  NonEmptyChunk: () => NonEmptyChunk,
  NonEmptyChunkFromSelf: () => NonEmptyChunkFromSelf,
  NonEmptyString: () => NonEmptyString,
  NonEmptyTrimmedString: () => NonEmptyTrimmedString,
  NonNaN: () => NonNaN,
  NonNaNSchemaId: () => NonNaNSchemaId2,
  NonNegative: () => NonNegative,
  NonNegativeBigDecimalFromSelf: () => NonNegativeBigDecimalFromSelf,
  NonNegativeBigDecimalSchemaId: () => NonNegativeBigDecimalSchemaId,
  NonNegativeBigInt: () => NonNegativeBigInt,
  NonNegativeBigIntFromSelf: () => NonNegativeBigIntFromSelf,
  NonNegativeInt: () => NonNegativeInt,
  NonPositive: () => NonPositive,
  NonPositiveBigDecimalFromSelf: () => NonPositiveBigDecimalFromSelf,
  NonPositiveBigDecimalSchemaId: () => NonPositiveBigDecimalSchemaId,
  NonPositiveBigInt: () => NonPositiveBigInt,
  NonPositiveBigIntFromSelf: () => NonPositiveBigIntFromSelf,
  Not: () => Not,
  Null: () => Null,
  NullOr: () => NullOr,
  NullishOr: () => NullishOr,
  Number: () => Number$,
  NumberFromString: () => NumberFromString,
  Object: () => Object$,
  Option: () => Option,
  OptionFromNonEmptyTrimmedString: () => OptionFromNonEmptyTrimmedString,
  OptionFromNullOr: () => OptionFromNullOr,
  OptionFromNullishOr: () => OptionFromNullishOr,
  OptionFromSelf: () => OptionFromSelf,
  OptionFromUndefinedOr: () => OptionFromUndefinedOr,
  PatternSchemaId: () => PatternSchemaId,
  Positive: () => Positive,
  PositiveBigDecimalFromSelf: () => PositiveBigDecimalFromSelf,
  PositiveBigDecimalSchemaId: () => PositiveBigDecimalSchemaId,
  PositiveBigInt: () => PositiveBigInt,
  PositiveBigIntFromSelf: () => PositiveBigIntFromSelf,
  PropertyKey: () => PropertyKey$,
  PropertySignatureDeclaration: () => PropertySignatureDeclaration,
  PropertySignatureTransformation: () => PropertySignatureTransformation2,
  PropertySignatureTypeId: () => PropertySignatureTypeId,
  ReadonlyMap: () => ReadonlyMap,
  ReadonlyMapFromRecord: () => ReadonlyMapFromRecord,
  ReadonlyMapFromSelf: () => ReadonlyMapFromSelf,
  ReadonlySet: () => ReadonlySet,
  ReadonlySetFromSelf: () => ReadonlySetFromSelf,
  Record: () => Record,
  Redacted: () => Redacted,
  RedactedFromSelf: () => RedactedFromSelf,
  RefineSchemaId: () => RefineSchemaId,
  Set: () => set8,
  SetFromSelf: () => SetFromSelf,
  SortedSet: () => SortedSet,
  SortedSetFromSelf: () => SortedSetFromSelf,
  StartsWithSchemaId: () => StartsWithSchemaId,
  String: () => String$,
  StringFromBase64: () => StringFromBase64,
  StringFromBase64Url: () => StringFromBase64Url,
  StringFromHex: () => StringFromHex,
  StringFromUriComponent: () => StringFromUriComponent,
  Struct: () => Struct,
  Symbol: () => Symbol$,
  SymbolFromSelf: () => SymbolFromSelf,
  TaggedClass: () => TaggedClass2,
  TaggedError: () => TaggedError2,
  TaggedRequest: () => TaggedRequest,
  TaggedStruct: () => TaggedStruct,
  TemplateLiteral: () => TemplateLiteral2,
  TemplateLiteralParser: () => TemplateLiteralParser,
  TimeZone: () => TimeZone,
  TimeZoneFromSelf: () => TimeZoneFromSelf,
  TimeZoneNamed: () => TimeZoneNamed,
  TimeZoneNamedFromSelf: () => TimeZoneNamedFromSelf,
  TimeZoneOffset: () => TimeZoneOffset,
  TimeZoneOffsetFromSelf: () => TimeZoneOffsetFromSelf,
  ToPropertySignature: () => ToPropertySignature,
  Trim: () => Trim,
  Trimmed: () => Trimmed,
  TrimmedSchemaId: () => TrimmedSchemaId,
  Tuple: () => Tuple,
  TypeId: () => TypeId29,
  ULID: () => ULID,
  ULIDSchemaId: () => ULIDSchemaId,
  URL: () => URL$,
  URLFromSelf: () => URLFromSelf,
  UUID: () => UUID,
  UUIDSchemaId: () => UUIDSchemaId,
  Uint8: () => Uint8,
  Uint8Array: () => Uint8Array$,
  Uint8ArrayFromBase64: () => Uint8ArrayFromBase64,
  Uint8ArrayFromBase64Url: () => Uint8ArrayFromBase64Url,
  Uint8ArrayFromHex: () => Uint8ArrayFromHex,
  Uint8ArrayFromSelf: () => Uint8ArrayFromSelf,
  Uncapitalize: () => Uncapitalize,
  Uncapitalized: () => Uncapitalized,
  UncapitalizedSchemaId: () => UncapitalizedSchemaId,
  Undefined: () => Undefined,
  UndefinedOr: () => UndefinedOr,
  Union: () => Union2,
  UniqueSymbolFromSelf: () => UniqueSymbolFromSelf,
  Unknown: () => Unknown,
  Uppercase: () => Uppercase,
  Uppercased: () => Uppercased,
  UppercasedSchemaId: () => UppercasedSchemaId,
  ValidDateFromSelf: () => ValidDateFromSelf,
  ValidDateSchemaId: () => ValidDateSchemaId,
  Void: () => Void,
  annotations: () => annotations2,
  asSchema: () => asSchema,
  asSerializable: () => asSerializable,
  asSerializableWithResult: () => asSerializableWithResult,
  asWithResult: () => asWithResult,
  asserts: () => asserts,
  attachPropertySignature: () => attachPropertySignature,
  between: () => between5,
  betweenBigDecimal: () => betweenBigDecimal,
  betweenBigInt: () => betweenBigInt,
  betweenDate: () => betweenDate,
  betweenDuration: () => betweenDuration,
  brand: () => brand,
  capitalized: () => capitalized,
  clamp: () => clamp8,
  clampBigDecimal: () => clampBigDecimal,
  clampBigInt: () => clampBigInt,
  clampDuration: () => clampDuration,
  compose: () => compose4,
  declare: () => declare,
  decode: () => decode5,
  decodeEither: () => decodeEither,
  decodeOption: () => decodeOption,
  decodePromise: () => decodePromise,
  decodeSync: () => decodeSync,
  decodeUnknown: () => decodeUnknown2,
  decodeUnknownEither: () => decodeUnknownEither2,
  decodeUnknownOption: () => decodeUnknownOption,
  decodeUnknownPromise: () => decodeUnknownPromise,
  decodeUnknownSync: () => decodeUnknownSync,
  deserialize: () => deserialize,
  deserializeExit: () => deserializeExit,
  deserializeFailure: () => deserializeFailure,
  deserializeSuccess: () => deserializeSuccess,
  element: () => element,
  encode: () => encode4,
  encodeEither: () => encodeEither,
  encodeOption: () => encodeOption,
  encodePromise: () => encodePromise,
  encodeSync: () => encodeSync,
  encodeUnknown: () => encodeUnknown2,
  encodeUnknownEither: () => encodeUnknownEither2,
  encodeUnknownOption: () => encodeUnknownOption,
  encodeUnknownPromise: () => encodeUnknownPromise,
  encodeUnknownSync: () => encodeUnknownSync,
  encodedBoundSchema: () => encodedBoundSchema,
  encodedSchema: () => encodedSchema,
  endsWith: () => endsWith,
  equivalence: () => equivalence2,
  exitSchema: () => exitSchema,
  extend: () => extend3,
  failureSchema: () => failureSchema,
  filter: () => filter11,
  filterEffect: () => filterEffect2,
  finite: () => finite,
  format: () => format6,
  fromBrand: () => fromBrand,
  fromKey: () => fromKey,
  getClassTag: () => getClassTag,
  getNumberIndexedAccess: () => getNumberIndexedAccess2,
  greaterThan: () => greaterThan6,
  greaterThanBigDecimal: () => greaterThanBigDecimal,
  greaterThanBigInt: () => greaterThanBigInt,
  greaterThanDate: () => greaterThanDate,
  greaterThanDuration: () => greaterThanDuration,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo5,
  greaterThanOrEqualToBigDecimal: () => greaterThanOrEqualToBigDecimal,
  greaterThanOrEqualToBigInt: () => greaterThanOrEqualToBigInt,
  greaterThanOrEqualToDate: () => greaterThanOrEqualToDate,
  greaterThanOrEqualToDuration: () => greaterThanOrEqualToDuration,
  head: () => head6,
  headNonEmpty: () => headNonEmpty3,
  headOrElse: () => headOrElse,
  includes: () => includes,
  instanceOf: () => instanceOf,
  int: () => int,
  is: () => is,
  isPropertySignature: () => isPropertySignature,
  isSchema: () => isSchema,
  itemsCount: () => itemsCount,
  keyof: () => keyof2,
  length: () => length3,
  lessThan: () => lessThan9,
  lessThanBigDecimal: () => lessThanBigDecimal,
  lessThanBigInt: () => lessThanBigInt,
  lessThanDate: () => lessThanDate,
  lessThanDuration: () => lessThanDuration,
  lessThanOrEqualTo: () => lessThanOrEqualTo5,
  lessThanOrEqualToBigDecimal: () => lessThanOrEqualToBigDecimal,
  lessThanOrEqualToBigInt: () => lessThanOrEqualToBigInt,
  lessThanOrEqualToDate: () => lessThanOrEqualToDate,
  lessThanOrEqualToDuration: () => lessThanOrEqualToDuration,
  lowercased: () => lowercased,
  make: () => make57,
  makePropertySignature: () => makePropertySignature,
  maxItems: () => maxItems,
  maxLength: () => maxLength,
  minItems: () => minItems,
  minLength: () => minLength,
  multipleOf: () => multipleOf,
  mutable: () => mutable2,
  negative: () => negative,
  negativeBigDecimal: () => negativeBigDecimal,
  negativeBigInt: () => negativeBigInt,
  nonEmptyString: () => nonEmptyString2,
  nonNaN: () => nonNaN,
  nonNegative: () => nonNegative,
  nonNegativeBigDecimal: () => nonNegativeBigDecimal,
  nonNegativeBigInt: () => nonNegativeBigInt,
  nonPositive: () => nonPositive,
  nonPositiveBigDecimal: () => nonPositiveBigDecimal,
  nonPositiveBigInt: () => nonPositiveBigInt,
  omit: () => omit5,
  optional: () => optional,
  optionalElement: () => optionalElement,
  optionalToOptional: () => optionalToOptional,
  optionalToRequired: () => optionalToRequired,
  optionalWith: () => optionalWith,
  parseJson: () => parseJson,
  parseNumber: () => parseNumber,
  partial: () => partial2,
  partialWith: () => partialWith,
  pattern: () => pattern,
  pick: () => pick5,
  pickLiteral: () => pickLiteral,
  pluck: () => pluck,
  positive: () => positive,
  positiveBigDecimal: () => positiveBigDecimal,
  positiveBigInt: () => positiveBigInt,
  propertySignature: () => propertySignature,
  rename: () => rename2,
  required: () => required2,
  requiredToOptional: () => requiredToOptional,
  serializableSchema: () => serializableSchema,
  serialize: () => serialize,
  serializeExit: () => serializeExit,
  serializeFailure: () => serializeFailure,
  serializeSuccess: () => serializeSuccess,
  split: () => split2,
  standardSchemaV1: () => standardSchemaV1,
  startsWith: () => startsWith,
  successSchema: () => successSchema,
  suspend: () => suspend12,
  symbolSerializable: () => symbolSerializable,
  symbolWithResult: () => symbolWithResult,
  tag: () => tag,
  transform: () => transform2,
  transformLiteral: () => transformLiteral,
  transformLiterals: () => transformLiterals,
  transformOrFail: () => transformOrFail,
  trimmed: () => trimmed,
  typeSchema: () => typeSchema,
  uncapitalized: () => uncapitalized,
  uppercased: () => uppercased,
  validDate: () => validDate,
  validate: () => validate5,
  validateEither: () => validateEither2,
  validateOption: () => validateOption,
  validatePromise: () => validatePromise,
  validateSync: () => validateSync,
  withConstructorDefault: () => withConstructorDefault,
  withDecodingDefault: () => withDecodingDefault,
  withDefaults: () => withDefaults
});
function make57(ast) {
  return class SchemaClass {
    static {
      __name(this, "SchemaClass");
    }
    [TypeId29] = variance7;
    static ast = ast;
    static annotations(annotations3) {
      return make57(mergeSchemaAnnotations(this.ast, annotations3));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
    static Type;
    static Encoded;
    static Context;
    static [TypeId29] = variance7;
  };
}
function asSchema(schema) {
  return schema;
}
function getDefaultLiteralAST(literals) {
  return isMembers(literals) ? Union.make(mapMembers(literals, (literal3) => new Literal(literal3))) : new Literal(literals[0]);
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
  return class LiteralClass extends make57(ast) {
    static {
      __name(this, "LiteralClass");
    }
    static annotations(annotations3) {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static literals = [...literals];
  };
}
function Literal2(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
function getTemplateLiteralParserCoercedElement(encoded, schema) {
  const ast = encoded.ast;
  switch (ast._tag) {
    case "Literal": {
      const literal3 = ast.literal;
      if (!isString(literal3)) {
        const s = String(literal3);
        return transform2(Literal2(s), schema, {
          strict: true,
          decode: /* @__PURE__ */ __name(() => literal3, "decode"),
          encode: /* @__PURE__ */ __name(() => s, "encode")
        });
      }
      break;
    }
    case "NumberKeyword":
      return compose4(NumberFromString, schema);
    case "Union": {
      const members = [];
      let hasCoercions = false;
      for (const member of ast.types) {
        const schema2 = make57(member);
        const encoded2 = encodedSchema(schema2);
        const coerced = getTemplateLiteralParserCoercedElement(encoded2, schema2);
        if (coerced) {
          hasCoercions = true;
        }
        members.push(coerced ?? schema2);
      }
      return hasCoercions ? compose4(Union2(...members), schema) : schema;
    }
  }
}
function makeDeclareClass(typeParameters, ast) {
  return class DeclareClass extends make57(ast) {
    static {
      __name(this, "DeclareClass");
    }
    static annotations(annotations3) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static typeParameters = [...typeParameters];
  };
}
function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
  return class UnionClass extends make57(ast) {
    static {
      __name(this, "UnionClass");
    }
    static annotations(annotations3) {
      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static members = [...members];
  };
}
function Union2(...members) {
  return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
  return class TupleTypeClass extends make57(ast) {
    static {
      __name(this, "TupleTypeClass");
    }
    static annotations(annotations3) {
      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static elements = [...elements];
    static rest = [...rest];
  };
}
function Tuple(...args2) {
  return Array.isArray(args2[0]) ? makeTupleTypeClass(args2[0], args2.slice(1)) : makeTupleTypeClass(args2, []);
}
function makeArrayClass(value3, ast) {
  return class ArrayClass extends makeTupleTypeClass([], [value3], ast) {
    static {
      __name(this, "ArrayClass");
    }
    static annotations(annotations3) {
      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static value = value3;
  };
}
function makeNonEmptyArrayClass(value3, ast) {
  return class NonEmptyArrayClass extends makeTupleTypeClass([value3], [value3], ast) {
    static {
      __name(this, "NonEmptyArrayClass");
    }
    static annotations(annotations3) {
      return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static value = value3;
  };
}
function ArrayEnsure(value3) {
  return transform2(Union2(value3, Array$(value3)), Array$(typeSchema(asSchema(value3))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => ensure(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => a.length === 1 ? a[0] : a, "encode")
  });
}
function NonEmptyArrayEnsure(value3) {
  return transform2(Union2(value3, NonEmptyArray(value3)), NonEmptyArray(typeSchema(asSchema(value3))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => isNonEmptyReadonlyArray(i) ? i : of(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => a.length === 1 ? a[0] : a, "encode")
  });
}
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
  return class TypeLiteralClass extends make57(ast) {
    static {
      __name(this, "TypeLiteralClass");
    }
    static annotations(annotations3) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static fields = {
      ...fields
    };
    static records = [...records];
    static make = /* @__PURE__ */ __name((props, options) => {
      const propsWithDefaults = lazilyMergeDefaults(fields, {
        ...props
      });
      return getDisableValidationMakeOption(options) ? propsWithDefaults : validateSync(this)(propsWithDefaults);
    }, "make");
    static pick(...keys5) {
      return Struct(pick4(fields, ...keys5));
    }
    static omit(...keys5) {
      return Struct(omit4(fields, ...keys5));
    }
  };
}
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
function makeRecordClass(key, value3, ast) {
  return class RecordClass extends makeTypeLiteralClass({}, [{
    key,
    value: value3
  }], ast) {
    static {
      __name(this, "RecordClass");
    }
    static annotations(annotations3) {
      return makeRecordClass(key, value3, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static key = key;
    static value = value3;
  };
}
function makeBrandClass(from2, ast) {
  return class BrandClass extends make57(ast) {
    static {
      __name(this, "BrandClass");
    }
    static annotations(annotations3) {
      return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static make = /* @__PURE__ */ __name((a, options) => {
      return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
    }, "make");
    static from = from2;
  };
}
function makeRefineClass(from2, filter14, ast) {
  return class RefineClass extends make57(ast) {
    static {
      __name(this, "RefineClass");
    }
    static annotations(annotations3) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static [RefineSchemaId] = from2;
    static from = from2;
    static filter = filter14;
    static make = /* @__PURE__ */ __name((a, options) => {
      return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
    }, "make");
  };
}
function filter11(predicate, annotations3) {
  return (self2) => {
    function filter14(input, options, ast2) {
      return toFilterParseIssue(predicate(input, options, ast2), ast2, input);
    }
    __name(filter14, "filter");
    const ast = new Refinement(self2.ast, filter14, toASTAnnotations(annotations3));
    return makeRefineClass(self2, filter14, ast);
  };
}
function makeTransformationClass(from2, to, ast) {
  return class TransformationClass extends make57(ast) {
    static {
      __name(this, "TransformationClass");
    }
    static annotations(annotations3) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static from = from2;
    static to = to;
  };
}
function transformLiteral(from2, to) {
  return transform2(Literal2(from2), Literal2(to), {
    strict: true,
    decode: /* @__PURE__ */ __name(() => to, "decode"),
    encode: /* @__PURE__ */ __name(() => from2, "encode")
  });
}
function transformLiterals(...pairs) {
  return Union2(...pairs.map(([from2, to]) => transformLiteral(from2, to)));
}
function parseNumber(self2) {
  return transformOrFail(self2, Number$, {
    strict: false,
    decode: /* @__PURE__ */ __name((i, _, ast) => fromOption3(parse(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a number`)), "decode"),
    encode: /* @__PURE__ */ __name((a) => succeed17(String(a)), "encode")
  });
}
function Redacted(value3) {
  return transform2(value3, RedactedFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => make56(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => value2(a), "encode")
  });
}
function head6(self2) {
  return transform2(self2, OptionFromSelf(getNumberIndexedAccess2(typeSchema(self2))), {
    strict: false,
    decode: /* @__PURE__ */ __name((i) => head(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => match2(a, {
      onNone: /* @__PURE__ */ __name(() => [], "onNone"),
      onSome: of
    }), "encode")
  });
}
function headNonEmpty3(self2) {
  return transform2(self2, getNumberIndexedAccess2(typeSchema(self2)), {
    strict: false,
    decode: /* @__PURE__ */ __name((i) => headNonEmpty(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => of(a), "encode")
  });
}
function Option(value3) {
  const value_ = asSchema(value3);
  const out = transform2(optionEncoded(value_), OptionFromSelf(typeSchema(value_)), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => optionDecode(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => match2(a, {
      onNone: /* @__PURE__ */ __name(() => makeNoneEncoded, "onNone"),
      onSome: makeSomeEncoded
    }), "encode")
  });
  return out;
}
function OptionFromNullOr(value3) {
  return transform2(NullOr(value3), OptionFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => fromNullable(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => getOrNull(a), "encode")
  });
}
function OptionFromNullishOr(value3, onNoneEncoding) {
  return transform2(NullishOr(value3), OptionFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => fromNullable(i), "decode"),
    encode: onNoneEncoding === null ? (a) => getOrNull(a) : (a) => getOrUndefined(a)
  });
}
function OptionFromUndefinedOr(value3) {
  return transform2(UndefinedOr(value3), OptionFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => fromNullable(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => getOrUndefined(a), "encode")
  });
}
function ReadonlyMap({
  key,
  value: value3
}) {
  return transform2(Array$(Tuple(key, value3)), ReadonlyMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value3))
  }), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => new Map(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.from(a.entries()), "encode")
  });
}
function map27({
  key,
  value: value3
}) {
  return transform2(Array$(Tuple(key, value3)), MapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value3))
  }), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => new Map(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.from(a.entries()), "encode")
  });
}
function ReadonlySet(value3) {
  return transform2(Array$(value3), ReadonlySetFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => new Set(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.from(a), "encode")
  });
}
function set8(value3) {
  return transform2(Array$(value3), SetFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => new Set(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.from(a), "encode")
  });
}
function Chunk(value3) {
  return transform2(Array$(value3), ChunkFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => i.length === 0 ? empty5() : fromIterable3(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => toReadonlyArray(a), "encode")
  });
}
function NonEmptyChunk(value3) {
  return transform2(NonEmptyArray(value3), NonEmptyChunkFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => unsafeFromNonEmptyArray(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => toReadonlyArray(a), "encode")
  });
}
function getDisableValidationMakeOption(options) {
  return isBoolean(options) ? options : options?.disableValidation ?? false;
}
function causeDecode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return empty28;
    case "Fail":
      return fail5(cause3.error);
    case "Die":
      return die4(cause3.defect);
    case "Interrupt":
      return interrupt5(fiberIdDecode(cause3.fiberId));
    case "Sequential":
      return sequential4(causeDecode(cause3.left), causeDecode(cause3.right));
    case "Parallel":
      return parallel4(causeDecode(cause3.left), causeDecode(cause3.right));
  }
}
function causeEncode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause3.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause3.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause3.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
  }
}
function HashSet(value3) {
  return transform2(Array$(value3), HashSetFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => fromIterable6(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.from(a), "encode")
  });
}
function List(value3) {
  return transform2(Array$(value3), ListFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => fromIterable8(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.from(a), "encode")
  });
}
function SortedSet(value3, ordA) {
  const to = typeSchema(asSchema(value3));
  return transform2(Array$(value3), SortedSetFromSelf(to, ordA, ordA), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => fromIterable12(i, ordA), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.from(values3(a)), "encode")
  });
}
var TypeId29, variance7, makeStandardResult, makeStandardFailureResult, makeStandardFailureFromParseIssue, standardSchemaV1, builtInAnnotations, toASTAnnotations, mergeSchemaAnnotations, format6, encodedSchema, encodedBoundSchema, typeSchema, encodeUnknown2, encodeUnknownEither2, encodeUnknownPromise, encode4, encodeEither, encodePromise, decodeUnknown2, decodeUnknownEither2, decodeUnknownPromise, decode5, decodeEither, decodePromise, validate5, validateEither2, validatePromise, isSchema, pickLiteral, UniqueSymbolFromSelf, getDefaultEnumsAST, makeEnumsClass, Enums2, TemplateLiteral2, TemplateLiteralParser, declareConstructor, declarePrimitive, declare, BrandSchemaId, fromBrand, InstanceOfSchemaId, instanceOf, Undefined, Void, Null, Never, Unknown, Any, BigIntFromSelf, SymbolFromSelf, String$, Number$, Boolean$, Object$, getDefaultUnionAST, NullOr, UndefinedOr, NullishOr, keyof2, element, optionalElement, ElementImpl, getDefaultTupleTypeAST, Array$, NonEmptyArray, formatPropertySignatureToken, PropertySignatureDeclaration, FromPropertySignature, ToPropertySignature, formatPropertyKey2, PropertySignatureTransformation2, mergeSignatureAnnotations, PropertySignatureTypeId, isPropertySignature, PropertySignatureImpl, makePropertySignature, PropertySignatureWithFromImpl, propertySignature, withConstructorDefault, applyDefaultValue, pruneUndefined2, withDecodingDefault, withDefaults, fromKey, optionalToRequired, requiredToOptional, optionalToOptional, optionalPropertySignatureAST, optional, optionalWith, preserveMissingMessageAnnotation, getDefaultTypeLiteralAST, lazilyMergeDefaults, tag, TaggedStruct, Record, pick5, omit5, pluck, brand, partial2, partialWith, required2, mutable2, intersectTypeLiterals, preserveRefinementAnnotations, addRefinementToMembers, extendAST, getTypes, intersectUnionMembers, extend3, compose4, suspend12, RefineSchemaId, fromFilterPredicateReturnTypeItem, toFilterParseIssue, filterEffect2, transformOrFail, transform2, attachPropertySignature, annotations2, rename2, TrimmedSchemaId, trimmed, MaxLengthSchemaId2, maxLength, MinLengthSchemaId2, minLength, LengthSchemaId2, length3, PatternSchemaId, pattern, StartsWithSchemaId, startsWith, EndsWithSchemaId, endsWith, IncludesSchemaId, includes, LowercasedSchemaId, lowercased, Lowercased, UppercasedSchemaId, uppercased, Uppercased, CapitalizedSchemaId, capitalized, Capitalized, UncapitalizedSchemaId, uncapitalized, Uncapitalized, Char, nonEmptyString2, Lowercase, Uppercase, Capitalize, Uncapitalize, Trimmed, NonEmptyTrimmedString, Trim, split2, getErrorMessage2, getParseJsonTransformation, parseJson, NonEmptyString, UUIDSchemaId, uuidRegexp, UUID, ULIDSchemaId, ulidRegexp, ULID, URLFromSelf, URL$, FiniteSchemaId2, finite, GreaterThanSchemaId2, greaterThan6, GreaterThanOrEqualToSchemaId2, greaterThanOrEqualTo5, MultipleOfSchemaId, multipleOf, IntSchemaId2, int, LessThanSchemaId2, lessThan9, LessThanOrEqualToSchemaId2, lessThanOrEqualTo5, BetweenSchemaId2, between5, NonNaNSchemaId2, nonNaN, positive, negative, nonPositive, nonNegative, clamp8, NumberFromString, Finite, Int, NonNaN, Positive, Negative, NonPositive, NonNegative, JsonNumberSchemaId2, JsonNumber, Not, encodeSymbol2, decodeSymbol, Symbol$, GreaterThanBigIntSchemaId, greaterThanBigInt, GreaterThanOrEqualToBigIntSchemaId2, greaterThanOrEqualToBigInt, LessThanBigIntSchemaId2, lessThanBigInt, LessThanOrEqualToBigIntSchemaId2, lessThanOrEqualToBigInt, BetweenBigIntSchemaId, betweenBigInt, positiveBigInt, negativeBigInt, nonNegativeBigInt, nonPositiveBigInt, clampBigInt, BigInt$, PositiveBigIntFromSelf, PositiveBigInt, NegativeBigIntFromSelf, NegativeBigInt, NonPositiveBigIntFromSelf, NonPositiveBigInt, NonNegativeBigIntFromSelf, NonNegativeBigInt, BigIntFromNumber, redactedArbitrary, toComposite, redactedParse, RedactedFromSelf, DurationFromSelf, DurationFromNanos, NonNegativeInt, DurationFromMillis, DurationValueMillis, DurationValueNanos, DurationValueInfinity, durationValueInfinity, DurationValue, FiniteHRTime, InfiniteHRTime, HRTime, isDurationValue, Duration, clampDuration, LessThanDurationSchemaId, lessThanDuration, LessThanOrEqualToDurationSchemaId, lessThanOrEqualToDuration, GreaterThanDurationSchemaId, greaterThanDuration, GreaterThanOrEqualToDurationSchemaId, greaterThanOrEqualToDuration, BetweenDurationSchemaId, betweenDuration, Uint8ArrayFromSelf, Uint8, Uint8Array$, makeUint8ArrayTransformation, Uint8ArrayFromBase64, Uint8ArrayFromBase64Url, Uint8ArrayFromHex, makeEncodingTransformation, StringFromBase64, StringFromBase64Url, StringFromHex, StringFromUriComponent, MinItemsSchemaId2, minItems, MaxItemsSchemaId2, maxItems, ItemsCountSchemaId2, itemsCount, getNumberIndexedAccess2, headOrElse, ValidDateSchemaId, validDate, LessThanDateSchemaId, lessThanDate, LessThanOrEqualToDateSchemaId, lessThanOrEqualToDate, GreaterThanDateSchemaId, greaterThanDate, GreaterThanOrEqualToDateSchemaId, greaterThanOrEqualToDate, BetweenDateSchemaId, betweenDate, DateFromSelfSchemaId2, DateFromSelf, ValidDateFromSelf, DateFromString, Date$, DateFromNumber, DateTimeUtcFromSelf, decodeDateTimeUtc, DateTimeUtcFromNumber, DateTimeUtcFromDate, DateTimeUtc, timeZoneOffsetArbitrary, TimeZoneOffsetFromSelf, TimeZoneOffset, timeZoneNamedArbitrary, TimeZoneNamedFromSelf, TimeZoneNamed, TimeZoneFromSelf, TimeZone, timeZoneArbitrary, DateTimeZonedFromSelf, DateTimeZoned, OptionNoneEncoded, optionSomeEncoded, optionEncoded, optionDecode, optionArbitrary, optionPretty, optionParse, OptionFromSelf_, OptionFromSelf, makeNoneEncoded, makeSomeEncoded, OptionFromNonEmptyTrimmedString, rightEncoded, leftEncoded, eitherEncoded, eitherDecode, eitherArbitrary, eitherPretty, eitherParse, EitherFromSelf, makeLeftEncoded, makeRightEncoded, Either2, EitherFromUnion, mapArbitrary, readonlyMapPretty, readonlyMapEquivalence, readonlyMapParse, mapFromSelf_, ReadonlyMapFromSelf, MapFromSelf, ReadonlyMapFromRecord, MapFromRecord, setArbitrary, readonlySetPretty, readonlySetEquivalence, readonlySetParse, setFromSelf_, ReadonlySetFromSelf, SetFromSelf, bigDecimalPretty, bigDecimalArbitrary, BigDecimalFromSelf, BigDecimal, BigDecimalFromNumber, GreaterThanBigDecimalSchemaId, greaterThanBigDecimal, GreaterThanOrEqualToBigDecimalSchemaId, greaterThanOrEqualToBigDecimal, LessThanBigDecimalSchemaId, lessThanBigDecimal, LessThanOrEqualToBigDecimalSchemaId, lessThanOrEqualToBigDecimal, PositiveBigDecimalSchemaId, positiveBigDecimal, PositiveBigDecimalFromSelf, NonNegativeBigDecimalSchemaId, nonNegativeBigDecimal, NonNegativeBigDecimalFromSelf, NegativeBigDecimalSchemaId, negativeBigDecimal, NegativeBigDecimalFromSelf, NonPositiveBigDecimalSchemaId, nonPositiveBigDecimal, NonPositiveBigDecimalFromSelf, BetweenBigDecimalSchemaId, betweenBigDecimal, clampBigDecimal, chunkArbitrary, chunkPretty, chunkParse, ChunkFromSelf, nonEmptyChunkArbitrary, nonEmptyChunkPretty, nonEmptyChunkParse, NonEmptyChunkFromSelf, decodeData, dataArbitrary, dataPretty, dataParse, DataFromSelf, Data, isField, isFields, getFields, getSchemaFromFieldsOr, getFieldsFromFieldsOr, Class6, getClassTag, TaggedClass2, TaggedError2, extendFields, astCache, getClassAnnotations, makeClass, FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded, FiberIdEncoded, fiberIdArbitrary, fiberIdPretty, FiberIdFromSelf, fiberIdDecode, fiberIdEncode, FiberId, causeDieEncoded, CauseEmptyEncoded, causeFailEncoded, CauseInterruptEncoded, causeEncodedId, causeEncoded, causeArbitrary, causePretty, causeParse, CauseFromSelf, Cause, Defect, exitFailureEncoded, exitSuccessEncoded, exitEncoded, exitDecode, exitArbitrary, exitPretty, exitParse, ExitFromSelf, Exit, hashSetArbitrary, hashSetPretty, hashSetEquivalence, hashSetParse, HashSetFromSelf, hashMapArbitrary, hashMapPretty, hashMapEquivalence, hashMapParse, HashMapFromSelf, HashMap, listArbitrary, listPretty, listEquivalence, listParse, ListFromSelf, sortedSetArbitrary, sortedSetPretty, sortedSetParse, SortedSetFromSelf, BooleanFromUnknown, BooleanFromString, Config, symbolSerializable, asSerializable, serializableSchema, serialize, deserialize, symbolWithResult, asWithResult, failureSchema, successSchema, exitSchemaCache, exitSchema, serializeFailure, deserializeFailure, serializeSuccess, deserializeSuccess, serializeExit, deserializeExit, asSerializableWithResult, TaggedRequest, equivalence2, getEquivalenceAnnotation, go2, SymbolStruct, SymbolFromStruct, PropertyKey$, ArrayFormatterIssue;
var init_Schema = __esm({
  "node_modules/effect/dist/esm/Schema.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_BigDecimal();
    init_BigInt();
    init_Boolean();
    init_Cause();
    init_Chunk();
    init_Config();
    init_ConfigError();
    init_Data();
    init_DateTime();
    init_Duration();
    init_Effect();
    init_Either();
    init_Encoding();
    init_Equal();
    init_Equivalence();
    init_Exit();
    init_FastCheck();
    init_FiberId();
    init_Function();
    init_GlobalValue();
    init_HashMap();
    init_HashSet();
    init_Inspectable();
    init_cause2();
    init_errors2();
    init_schemaId();
    init_util();
    init_List();
    init_Number();
    init_Option();
    init_ParseResult();
    init_Pipeable();
    init_Predicate();
    init_Redacted();
    init_Request();
    init_Scheduler();
    init_SchemaAST();
    init_SortedSet();
    init_String();
    init_Struct();
    init_ParseResult();
    TypeId29 = /* @__PURE__ */ Symbol.for("effect/Schema");
    __name(make57, "make");
    variance7 = {
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A"),
      /* c8 ignore next */
      _I: /* @__PURE__ */ __name((_) => _, "_I"),
      /* c8 ignore next */
      _R: /* @__PURE__ */ __name((_) => _, "_R")
    };
    makeStandardResult = /* @__PURE__ */ __name((exit5) => isSuccess(exit5) ? exit5.value : makeStandardFailureResult(pretty2(exit5.cause)), "makeStandardResult");
    makeStandardFailureResult = /* @__PURE__ */ __name((message) => ({
      issues: [{
        message
      }]
    }), "makeStandardFailureResult");
    makeStandardFailureFromParseIssue = /* @__PURE__ */ __name((issue2) => map18(ArrayFormatter.formatIssue(issue2), (issues) => ({
      issues: issues.map((issue3) => ({
        path: issue3.path,
        message: issue3.message
      }))
    })), "makeStandardFailureFromParseIssue");
    standardSchemaV1 = /* @__PURE__ */ __name((schema, overrideOptions) => {
      const decodeUnknown3 = decodeUnknown(schema, {
        errors: "all"
      });
      return class StandardSchemaV1Class extends make57(schema.ast) {
        static {
          __name(this, "StandardSchemaV1Class");
        }
        static "~standard" = {
          version: 1,
          vendor: "effect",
          validate(value3) {
            const scheduler2 = new SyncScheduler();
            const fiber = runFork2(matchEffect2(decodeUnknown3(value3, overrideOptions), {
              onFailure: makeStandardFailureFromParseIssue,
              onSuccess: /* @__PURE__ */ __name((value4) => succeed9({
                value: value4
              }), "onSuccess")
            }), {
              scheduler: scheduler2
            });
            scheduler2.flush();
            const exit5 = fiber.unsafePoll();
            if (exit5) {
              return makeStandardResult(exit5);
            }
            return new Promise((resolve) => {
              fiber.addObserver((exit6) => {
                resolve(makeStandardResult(exit6));
              });
            });
          }
        };
      };
    }, "standardSchemaV1");
    builtInAnnotations = {
      typeConstructor: TypeConstructorAnnotationId,
      schemaId: SchemaIdAnnotationId,
      message: MessageAnnotationId,
      missingMessage: MissingMessageAnnotationId,
      identifier: IdentifierAnnotationId,
      title: TitleAnnotationId,
      description: DescriptionAnnotationId,
      examples: ExamplesAnnotationId,
      default: DefaultAnnotationId,
      documentation: DocumentationAnnotationId,
      jsonSchema: JSONSchemaAnnotationId,
      arbitrary: ArbitraryAnnotationId,
      pretty: PrettyAnnotationId,
      equivalence: EquivalenceAnnotationId,
      concurrency: ConcurrencyAnnotationId,
      batching: BatchingAnnotationId,
      parseIssueTitle: ParseIssueTitleAnnotationId,
      parseOptions: ParseOptionsAnnotationId,
      decodingFallback: DecodingFallbackAnnotationId
    };
    toASTAnnotations = /* @__PURE__ */ __name((annotations3) => {
      if (!annotations3) {
        return {};
      }
      const out = {
        ...annotations3
      };
      for (const key in builtInAnnotations) {
        if (key in annotations3) {
          const id2 = builtInAnnotations[key];
          out[id2] = annotations3[key];
          delete out[key];
        }
      }
      return out;
    }, "toASTAnnotations");
    mergeSchemaAnnotations = /* @__PURE__ */ __name((ast, annotations3) => annotations(ast, toASTAnnotations(annotations3)), "mergeSchemaAnnotations");
    __name(asSchema, "asSchema");
    format6 = /* @__PURE__ */ __name((schema) => String(schema.ast), "format");
    encodedSchema = /* @__PURE__ */ __name((schema) => make57(encodedAST(schema.ast)), "encodedSchema");
    encodedBoundSchema = /* @__PURE__ */ __name((schema) => make57(encodedBoundAST(schema.ast)), "encodedBoundSchema");
    typeSchema = /* @__PURE__ */ __name((schema) => make57(typeAST(schema.ast)), "typeSchema");
    encodeUnknown2 = /* @__PURE__ */ __name((schema, options) => {
      const encodeUnknown3 = encodeUnknown(schema, options);
      return (u, overrideOptions) => mapError7(encodeUnknown3(u, overrideOptions), parseError);
    }, "encodeUnknown");
    encodeUnknownEither2 = /* @__PURE__ */ __name((schema, options) => {
      const encodeUnknownEither3 = encodeUnknownEither(schema, options);
      return (u, overrideOptions) => mapLeft(encodeUnknownEither3(u, overrideOptions), parseError);
    }, "encodeUnknownEither");
    encodeUnknownPromise = /* @__PURE__ */ __name((schema, options) => {
      const parser = encodeUnknown2(schema, options);
      return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
    }, "encodeUnknownPromise");
    encode4 = encodeUnknown2;
    encodeEither = encodeUnknownEither2;
    encodePromise = encodeUnknownPromise;
    decodeUnknown2 = /* @__PURE__ */ __name((schema, options) => {
      const decodeUnknown3 = decodeUnknown(schema, options);
      return (u, overrideOptions) => mapError7(decodeUnknown3(u, overrideOptions), parseError);
    }, "decodeUnknown");
    decodeUnknownEither2 = /* @__PURE__ */ __name((schema, options) => {
      const decodeUnknownEither3 = decodeUnknownEither(schema, options);
      return (u, overrideOptions) => mapLeft(decodeUnknownEither3(u, overrideOptions), parseError);
    }, "decodeUnknownEither");
    decodeUnknownPromise = /* @__PURE__ */ __name((schema, options) => {
      const parser = decodeUnknown2(schema, options);
      return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
    }, "decodeUnknownPromise");
    decode5 = decodeUnknown2;
    decodeEither = decodeUnknownEither2;
    decodePromise = decodeUnknownPromise;
    validate5 = /* @__PURE__ */ __name((schema, options) => {
      const validate6 = validate4(schema, options);
      return (u, overrideOptions) => mapError7(validate6(u, overrideOptions), parseError);
    }, "validate");
    validateEither2 = /* @__PURE__ */ __name((schema, options) => {
      const validateEither3 = validateEither(schema, options);
      return (u, overrideOptions) => mapLeft(validateEither3(u, overrideOptions), parseError);
    }, "validateEither");
    validatePromise = /* @__PURE__ */ __name((schema, options) => {
      const parser = validate5(schema, options);
      return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
    }, "validatePromise");
    isSchema = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId29) && isObject(u[TypeId29]), "isSchema");
    __name(getDefaultLiteralAST, "getDefaultLiteralAST");
    __name(makeLiteralClass, "makeLiteralClass");
    __name(Literal2, "Literal");
    pickLiteral = /* @__PURE__ */ __name((...literals) => (_schema) => Literal2(...literals), "pickLiteral");
    UniqueSymbolFromSelf = /* @__PURE__ */ __name((symbol4) => make57(new UniqueSymbol(symbol4)), "UniqueSymbolFromSelf");
    getDefaultEnumsAST = /* @__PURE__ */ __name((enums) => new Enums(Object.keys(enums).filter((key) => typeof enums[enums[key]] !== "number").map((key) => [key, enums[key]])), "getDefaultEnumsAST");
    makeEnumsClass = /* @__PURE__ */ __name((enums, ast = getDefaultEnumsAST(enums)) => class EnumsClass extends make57(ast) {
      static {
        __name(this, "EnumsClass");
      }
      static annotations(annotations3) {
        return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations3));
      }
      static enums = {
        ...enums
      };
    }, "makeEnumsClass");
    Enums2 = /* @__PURE__ */ __name((enums) => makeEnumsClass(enums), "Enums");
    TemplateLiteral2 = /* @__PURE__ */ __name((...[head7, ...tail]) => {
      const spans = [];
      let h = "";
      let ts = tail;
      if (isSchema(head7)) {
        if (isLiteral(head7.ast)) {
          h = String(head7.ast.literal);
        } else {
          ts = [head7, ...ts];
        }
      } else {
        h = String(head7);
      }
      for (let i = 0; i < ts.length; i++) {
        const item = ts[i];
        if (isSchema(item)) {
          if (i < ts.length - 1) {
            const next4 = ts[i + 1];
            if (isSchema(next4)) {
              if (isLiteral(next4.ast)) {
                spans.push(new TemplateLiteralSpan(item.ast, String(next4.ast.literal)));
                i++;
                continue;
              }
            } else {
              spans.push(new TemplateLiteralSpan(item.ast, String(next4)));
              i++;
              continue;
            }
          }
          spans.push(new TemplateLiteralSpan(item.ast, ""));
        } else {
          spans.push(new TemplateLiteralSpan(new Literal(item), ""));
        }
      }
      if (isNonEmptyArray2(spans)) {
        return make57(new TemplateLiteral(h, spans));
      } else {
        return make57(new TemplateLiteral("", [new TemplateLiteralSpan(new Literal(h), "")]));
      }
    }, "TemplateLiteral");
    __name(getTemplateLiteralParserCoercedElement, "getTemplateLiteralParserCoercedElement");
    TemplateLiteralParser = /* @__PURE__ */ __name((...params) => {
      const encodedSchemas = [];
      const elements = [];
      const schemas = [];
      let coerced = false;
      for (let i = 0; i < params.length; i++) {
        const param = params[i];
        const schema = isSchema(param) ? param : Literal2(param);
        schemas.push(schema);
        const encoded = encodedSchema(schema);
        encodedSchemas.push(encoded);
        const element2 = getTemplateLiteralParserCoercedElement(encoded, schema);
        if (element2) {
          elements.push(element2);
          coerced = true;
        } else {
          elements.push(schema);
        }
      }
      const from2 = TemplateLiteral2(...encodedSchemas);
      const re = getTemplateLiteralCapturingRegExp(from2.ast);
      let to = Tuple(...elements);
      if (coerced) {
        to = to.annotations({
          [AutoTitleAnnotationId]: format6(Tuple(...schemas))
        });
      }
      return class TemplateLiteralParserClass extends transformOrFail(from2, to, {
        strict: false,
        decode: /* @__PURE__ */ __name((i, _, ast) => {
          const match20 = re.exec(i);
          return match20 ? succeed17(match20.slice(1, params.length + 1)) : fail17(new Type2(ast, i, `${re.source}: no match for ${JSON.stringify(i)}`));
        }, "decode"),
        encode: /* @__PURE__ */ __name((tuple4) => succeed17(tuple4.join("")), "encode")
      }) {
        static {
          __name(this, "TemplateLiteralParserClass");
        }
        static params = params.slice();
      };
    }, "TemplateLiteralParser");
    declareConstructor = /* @__PURE__ */ __name((typeParameters, options, annotations3) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options.decode(...typeParameters2.map(make57)), (...typeParameters2) => options.encode(...typeParameters2.map(make57)), toASTAnnotations(annotations3))), "declareConstructor");
    declarePrimitive = /* @__PURE__ */ __name((is3, annotations3) => {
      const decodeUnknown3 = /* @__PURE__ */ __name(() => (input, _, ast) => is3(input) ? succeed17(input) : fail17(new Type2(ast, input)), "decodeUnknown");
      const encodeUnknown3 = decodeUnknown3;
      return makeDeclareClass([], new Declaration([], decodeUnknown3, encodeUnknown3, toASTAnnotations(annotations3)));
    }, "declarePrimitive");
    __name(makeDeclareClass, "makeDeclareClass");
    declare = /* @__PURE__ */ __name(function() {
      if (Array.isArray(arguments[0])) {
        const typeParameters = arguments[0];
        const options = arguments[1];
        const annotations4 = arguments[2];
        return declareConstructor(typeParameters, options, annotations4);
      }
      const is3 = arguments[0];
      const annotations3 = arguments[1];
      return declarePrimitive(is3, annotations3);
    }, "declare");
    BrandSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Brand");
    fromBrand = /* @__PURE__ */ __name((constructor, annotations3) => (self2) => {
      const out = makeBrandClass(self2, new Refinement(self2.ast, /* @__PURE__ */ __name(function predicate(a, _, ast) {
        const either8 = constructor.either(a);
        return isLeft2(either8) ? some2(new Type2(ast, a, either8.left.map((v) => v.message).join(", "))) : none2();
      }, "predicate"), toASTAnnotations({
        schemaId: BrandSchemaId,
        [BrandSchemaId]: {
          constructor
        },
        ...annotations3
      })));
      return out;
    }, "fromBrand");
    InstanceOfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/InstanceOf");
    instanceOf = /* @__PURE__ */ __name((constructor, annotations3) => declare((u) => u instanceof constructor, {
      title: constructor.name,
      description: `an instance of ${constructor.name}`,
      pretty: /* @__PURE__ */ __name(() => String, "pretty"),
      schemaId: InstanceOfSchemaId,
      [InstanceOfSchemaId]: {
        constructor
      },
      ...annotations3
    }), "instanceOf");
    Undefined = class extends (/* @__PURE__ */ make57(undefinedKeyword)) {
      static {
        __name(this, "Undefined");
      }
    };
    Void = class extends (/* @__PURE__ */ make57(voidKeyword)) {
      static {
        __name(this, "Void");
      }
    };
    Null = class extends (/* @__PURE__ */ make57($null)) {
      static {
        __name(this, "Null");
      }
    };
    Never = class extends (/* @__PURE__ */ make57(neverKeyword)) {
      static {
        __name(this, "Never");
      }
    };
    Unknown = class extends (/* @__PURE__ */ make57(unknownKeyword)) {
      static {
        __name(this, "Unknown");
      }
    };
    Any = class extends (/* @__PURE__ */ make57(anyKeyword)) {
      static {
        __name(this, "Any");
      }
    };
    BigIntFromSelf = class extends (/* @__PURE__ */ make57(bigIntKeyword)) {
      static {
        __name(this, "BigIntFromSelf");
      }
    };
    SymbolFromSelf = class extends (/* @__PURE__ */ make57(symbolKeyword)) {
      static {
        __name(this, "SymbolFromSelf");
      }
    };
    String$ = class extends (/* @__PURE__ */ make57(stringKeyword)) {
      static {
        __name(this, "String$");
      }
    };
    Number$ = class extends (/* @__PURE__ */ make57(numberKeyword)) {
      static {
        __name(this, "Number$");
      }
    };
    Boolean$ = class extends (/* @__PURE__ */ make57(booleanKeyword)) {
      static {
        __name(this, "Boolean$");
      }
    };
    Object$ = class extends (/* @__PURE__ */ make57(objectKeyword)) {
      static {
        __name(this, "Object$");
      }
    };
    getDefaultUnionAST = /* @__PURE__ */ __name((members) => Union.make(members.map((m) => m.ast)), "getDefaultUnionAST");
    __name(makeUnionClass, "makeUnionClass");
    __name(Union2, "Union");
    NullOr = /* @__PURE__ */ __name((self2) => Union2(self2, Null), "NullOr");
    UndefinedOr = /* @__PURE__ */ __name((self2) => Union2(self2, Undefined), "UndefinedOr");
    NullishOr = /* @__PURE__ */ __name((self2) => Union2(self2, Null, Undefined), "NullishOr");
    keyof2 = /* @__PURE__ */ __name((self2) => make57(keyof(self2.ast)), "keyof");
    element = /* @__PURE__ */ __name((self2) => new ElementImpl(new OptionalType(self2.ast, false), self2), "element");
    optionalElement = /* @__PURE__ */ __name((self2) => new ElementImpl(new OptionalType(self2.ast, true), self2), "optionalElement");
    ElementImpl = class _ElementImpl {
      static {
        __name(this, "ElementImpl");
      }
      ast;
      from;
      [TypeId29];
      _Token;
      constructor(ast, from2) {
        this.ast = ast;
        this.from = from2;
      }
      annotations(annotations3) {
        return new _ElementImpl(new OptionalType(this.ast.type, this.ast.isOptional, {
          ...this.ast.annotations,
          ...toASTAnnotations(annotations3)
        }), this.from);
      }
      toString() {
        return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`;
      }
    };
    getDefaultTupleTypeAST = /* @__PURE__ */ __name((elements, rest) => new TupleType(elements.map((el) => isSchema(el) ? new OptionalType(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type(el.ast) : el.ast), true), "getDefaultTupleTypeAST");
    __name(makeTupleTypeClass, "makeTupleTypeClass");
    __name(Tuple, "Tuple");
    __name(makeArrayClass, "makeArrayClass");
    Array$ = /* @__PURE__ */ __name((value3) => makeArrayClass(value3), "Array$");
    __name(makeNonEmptyArrayClass, "makeNonEmptyArrayClass");
    NonEmptyArray = /* @__PURE__ */ __name((value3) => makeNonEmptyArrayClass(value3), "NonEmptyArray");
    __name(ArrayEnsure, "ArrayEnsure");
    __name(NonEmptyArrayEnsure, "NonEmptyArrayEnsure");
    formatPropertySignatureToken = /* @__PURE__ */ __name((isOptional) => isOptional ? '"?:"' : '":"', "formatPropertySignatureToken");
    PropertySignatureDeclaration = class extends OptionalType {
      static {
        __name(this, "PropertySignatureDeclaration");
      }
      isReadonly;
      defaultValue;
      /**
       * @since 3.10.0
       */
      _tag = "PropertySignatureDeclaration";
      constructor(type, isOptional, isReadonly, annotations3, defaultValue) {
        super(type, isOptional, annotations3);
        this.isReadonly = isReadonly;
        this.defaultValue = defaultValue;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        const token = formatPropertySignatureToken(this.isOptional);
        const type = String(this.type);
        return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
      }
    };
    FromPropertySignature = class extends OptionalType {
      static {
        __name(this, "FromPropertySignature");
      }
      isReadonly;
      fromKey;
      constructor(type, isOptional, isReadonly, annotations3, fromKey2) {
        super(type, isOptional, annotations3);
        this.isReadonly = isReadonly;
        this.fromKey = fromKey2;
      }
    };
    ToPropertySignature = class extends OptionalType {
      static {
        __name(this, "ToPropertySignature");
      }
      isReadonly;
      defaultValue;
      constructor(type, isOptional, isReadonly, annotations3, defaultValue) {
        super(type, isOptional, annotations3);
        this.isReadonly = isReadonly;
        this.defaultValue = defaultValue;
      }
    };
    formatPropertyKey2 = /* @__PURE__ */ __name((p) => {
      if (p === void 0) {
        return "never";
      }
      if (isString(p)) {
        return JSON.stringify(p);
      }
      return String(p);
    }, "formatPropertyKey");
    PropertySignatureTransformation2 = class {
      static {
        __name(this, "PropertySignatureTransformation");
      }
      from;
      to;
      decode;
      encode;
      /**
       * @since 3.10.0
       */
      _tag = "PropertySignatureTransformation";
      constructor(from2, to, decode8, encode7) {
        this.from = from2;
        this.to = to;
        this.decode = decode8;
        this.encode = encode7;
      }
      /**
       * @since 3.10.0
       */
      toString() {
        return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey2(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
      }
    };
    mergeSignatureAnnotations = /* @__PURE__ */ __name((ast, annotations3) => {
      switch (ast._tag) {
        case "PropertySignatureDeclaration": {
          return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
            ...ast.annotations,
            ...annotations3
          }, ast.defaultValue);
        }
        case "PropertySignatureTransformation": {
          return new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
            ...ast.to.annotations,
            ...annotations3
          }, ast.to.defaultValue), ast.decode, ast.encode);
        }
      }
    }, "mergeSignatureAnnotations");
    PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("effect/PropertySignature");
    isPropertySignature = /* @__PURE__ */ __name((u) => hasProperty(u, PropertySignatureTypeId), "isPropertySignature");
    PropertySignatureImpl = class _PropertySignatureImpl {
      static {
        __name(this, "PropertySignatureImpl");
      }
      ast;
      [TypeId29];
      [PropertySignatureTypeId] = null;
      _TypeToken;
      _Key;
      _EncodedToken;
      _HasDefault;
      constructor(ast) {
        this.ast = ast;
      }
      pipe() {
        return pipeArguments(this, arguments);
      }
      annotations(annotations3) {
        return new _PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations3)));
      }
      toString() {
        return String(this.ast);
      }
    };
    makePropertySignature = /* @__PURE__ */ __name((ast) => new PropertySignatureImpl(ast), "makePropertySignature");
    PropertySignatureWithFromImpl = class _PropertySignatureWithFromImpl extends PropertySignatureImpl {
      static {
        __name(this, "PropertySignatureWithFromImpl");
      }
      from;
      constructor(ast, from2) {
        super(ast);
        this.from = from2;
      }
      annotations(annotations3) {
        return new _PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations3)), this.from);
      }
    };
    propertySignature = /* @__PURE__ */ __name((self2) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self2.ast, false, true, {}, void 0), self2), "propertySignature");
    withConstructorDefault = /* @__PURE__ */ dual(2, (self2, defaultValue) => {
      const ast = self2.ast;
      switch (ast._tag) {
        case "PropertySignatureDeclaration":
          return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
        case "PropertySignatureTransformation":
          return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
      }
    });
    applyDefaultValue = /* @__PURE__ */ __name((o, defaultValue) => match2(o, {
      onNone: /* @__PURE__ */ __name(() => some2(defaultValue()), "onNone"),
      onSome: /* @__PURE__ */ __name((value3) => some2(value3 === void 0 ? defaultValue() : value3), "onSome")
    }), "applyDefaultValue");
    pruneUndefined2 = /* @__PURE__ */ __name((ast) => pruneUndefined(ast, pruneUndefined2, (ast2) => {
      const pruned = pruneUndefined2(ast2.to);
      if (pruned) {
        return new Transformation(ast2.from, pruned, ast2.transformation);
      }
    }), "pruneUndefined");
    withDecodingDefault = /* @__PURE__ */ dual(2, (self2, defaultValue) => {
      const ast = self2.ast;
      switch (ast._tag) {
        case "PropertySignatureDeclaration": {
          const to = typeAST(ast.type);
          return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations), new ToPropertySignature(pruneUndefined2(to) ?? to, false, true, {}, ast.defaultValue), (o) => applyDefaultValue(o, defaultValue), identity));
        }
        case "PropertySignatureTransformation": {
          const to = ast.to.type;
          return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(pruneUndefined2(to) ?? to, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue), (o) => applyDefaultValue(ast.decode(o), defaultValue), ast.encode));
        }
      }
    });
    withDefaults = /* @__PURE__ */ dual(2, (self2, defaults) => self2.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)));
    fromKey = /* @__PURE__ */ dual(2, (self2, key) => {
      const ast = self2.ast;
      switch (ast._tag) {
        case "PropertySignatureDeclaration": {
          return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature(typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue), identity, identity));
        }
        case "PropertySignatureTransformation":
          return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
      }
    });
    optionalToRequired = /* @__PURE__ */ __name((from2, to, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from2.ast, true, true, {}, void 0), new ToPropertySignature(to.ast, false, true, {}, void 0), (o) => some2(options.decode(o)), flatMap(options.encode))), "optionalToRequired");
    requiredToOptional = /* @__PURE__ */ __name((from2, to, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from2.ast, false, true, {}, void 0), new ToPropertySignature(to.ast, true, true, {}, void 0), flatMap(options.decode), (o) => some2(options.encode(o)))), "requiredToOptional");
    optionalToOptional = /* @__PURE__ */ __name((from2, to, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from2.ast, true, true, {}, void 0), new ToPropertySignature(to.ast, true, true, {}, void 0), options.decode, options.encode)), "optionalToOptional");
    optionalPropertySignatureAST = /* @__PURE__ */ __name((self2, options) => {
      const isExact = options?.exact;
      const defaultValue = options?.default;
      const isNullable2 = options?.nullable;
      const asOption = options?.as == "Option";
      const asOptionEncode = options?.onNoneEncoding ? orElse(options.onNoneEncoding) : identity;
      if (isExact) {
        if (defaultValue) {
          if (isNullable2) {
            return withConstructorDefault(optionalToRequired(NullOr(self2), typeSchema(self2), {
              decode: match2({
                onNone: defaultValue,
                onSome: /* @__PURE__ */ __name((a) => a === null ? defaultValue() : a, "onSome")
              }),
              encode: some2
            }), defaultValue).ast;
          } else {
            return withConstructorDefault(optionalToRequired(self2, typeSchema(self2), {
              decode: match2({
                onNone: defaultValue,
                onSome: identity
              }),
              encode: some2
            }), defaultValue).ast;
          }
        } else if (asOption) {
          const to = OptionFromSelf_(typeSchema(self2));
          if (isNullable2) {
            return optionalToRequired(NullOr(self2), to, {
              decode: filter(isNotNull),
              encode: asOptionEncode
            }).ast;
          } else {
            return optionalToRequired(self2, to, {
              decode: identity,
              encode: identity
            }).ast;
          }
        } else {
          if (isNullable2) {
            return optionalToOptional(NullOr(self2), typeSchema(self2), {
              decode: filter(isNotNull),
              encode: identity
            }).ast;
          } else {
            return new PropertySignatureDeclaration(self2.ast, true, true, {}, void 0);
          }
        }
      } else {
        if (defaultValue) {
          if (isNullable2) {
            return withConstructorDefault(optionalToRequired(NullishOr(self2), typeSchema(self2), {
              decode: match2({
                onNone: defaultValue,
                onSome: /* @__PURE__ */ __name((a) => a == null ? defaultValue() : a, "onSome")
              }),
              encode: some2
            }), defaultValue).ast;
          } else {
            return withConstructorDefault(optionalToRequired(UndefinedOr(self2), typeSchema(self2), {
              decode: match2({
                onNone: defaultValue,
                onSome: /* @__PURE__ */ __name((a) => a === void 0 ? defaultValue() : a, "onSome")
              }),
              encode: some2
            }), defaultValue).ast;
          }
        } else if (asOption) {
          const to = OptionFromSelf_(typeSchema(self2));
          if (isNullable2) {
            return optionalToRequired(NullishOr(self2), to, {
              decode: filter((a) => a != null),
              encode: asOptionEncode
            }).ast;
          } else {
            return optionalToRequired(UndefinedOr(self2), to, {
              decode: filter(isNotUndefined),
              encode: asOptionEncode
            }).ast;
          }
        } else {
          if (isNullable2) {
            return optionalToOptional(NullishOr(self2), UndefinedOr(typeSchema(self2)), {
              decode: filter(isNotNull),
              encode: identity
            }).ast;
          } else {
            return new PropertySignatureDeclaration(UndefinedOr(self2).ast, true, true, {}, void 0);
          }
        }
      }
    }, "optionalPropertySignatureAST");
    optional = /* @__PURE__ */ __name((self2) => {
      const ast = self2.ast === undefinedKeyword || self2.ast === neverKeyword ? undefinedKeyword : UndefinedOr(self2).ast;
      return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, void 0), self2);
    }, "optional");
    optionalWith = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (self2, options) => {
      return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self2, options), self2);
    });
    preserveMissingMessageAnnotation = /* @__PURE__ */ pickAnnotations([MissingMessageAnnotationId]);
    getDefaultTypeLiteralAST = /* @__PURE__ */ __name((fields, records) => {
      const ownKeys = Reflect.ownKeys(fields);
      const pss = [];
      if (ownKeys.length > 0) {
        const from2 = [];
        const to = [];
        const transformations = [];
        for (let i = 0; i < ownKeys.length; i++) {
          const key = ownKeys[i];
          const field = fields[key];
          if (isPropertySignature(field)) {
            const ast = field.ast;
            switch (ast._tag) {
              case "PropertySignatureDeclaration": {
                const type = ast.type;
                const isOptional = ast.isOptional;
                const toAnnotations = ast.annotations;
                from2.push(new PropertySignature(key, type, isOptional, true, preserveMissingMessageAnnotation(ast)));
                to.push(new PropertySignature(key, typeAST(type), isOptional, true, toAnnotations));
                pss.push(new PropertySignature(key, type, isOptional, true, toAnnotations));
                break;
              }
              case "PropertySignatureTransformation": {
                const fromKey2 = ast.from.fromKey ?? key;
                from2.push(new PropertySignature(fromKey2, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
                to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
                transformations.push(new PropertySignatureTransformation(fromKey2, key, ast.decode, ast.encode));
                break;
              }
            }
          } else {
            from2.push(new PropertySignature(key, field.ast, false, true));
            to.push(new PropertySignature(key, typeAST(field.ast), false, true));
            pss.push(new PropertySignature(key, field.ast, false, true));
          }
        }
        if (isNonEmptyReadonlyArray(transformations)) {
          const issFrom = [];
          const issTo = [];
          for (const r of records) {
            const {
              indexSignatures,
              propertySignatures
            } = record2(r.key.ast, r.value.ast);
            propertySignatures.forEach((ps) => {
              from2.push(ps);
              to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
            });
            indexSignatures.forEach((is3) => {
              issFrom.push(is3);
              issTo.push(new IndexSignature(is3.parameter, typeAST(is3.type), is3.isReadonly));
            });
          }
          return new Transformation(new TypeLiteral(from2, issFrom, {
            [AutoTitleAnnotationId]: "Struct (Encoded side)"
          }), new TypeLiteral(to, issTo, {
            [AutoTitleAnnotationId]: "Struct (Type side)"
          }), new TypeLiteralTransformation(transformations));
        }
      }
      const iss = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record2(r.key.ast, r.value.ast);
        propertySignatures.forEach((ps) => pss.push(ps));
        indexSignatures.forEach((is3) => iss.push(is3));
      }
      return new TypeLiteral(pss, iss);
    }, "getDefaultTypeLiteralAST");
    lazilyMergeDefaults = /* @__PURE__ */ __name((fields, out) => {
      const ownKeys = Reflect.ownKeys(fields);
      for (const key of ownKeys) {
        const field = fields[key];
        if (out[key] === void 0 && isPropertySignature(field)) {
          const ast = field.ast;
          const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
          if (defaultValue !== void 0) {
            out[key] = defaultValue();
          }
        }
      }
      return out;
    }, "lazilyMergeDefaults");
    __name(makeTypeLiteralClass, "makeTypeLiteralClass");
    __name(Struct, "Struct");
    tag = /* @__PURE__ */ __name((tag2) => Literal2(tag2).pipe(propertySignature, withConstructorDefault(() => tag2)), "tag");
    TaggedStruct = /* @__PURE__ */ __name((value3, fields) => Struct({
      _tag: tag(value3),
      ...fields
    }), "TaggedStruct");
    __name(makeRecordClass, "makeRecordClass");
    Record = /* @__PURE__ */ __name((options) => makeRecordClass(options.key, options.value), "Record");
    pick5 = /* @__PURE__ */ __name((...keys5) => (self2) => make57(pick(self2.ast, keys5)), "pick");
    omit5 = /* @__PURE__ */ __name((...keys5) => (self2) => make57(omit(self2.ast, keys5)), "omit");
    pluck = /* @__PURE__ */ dual(2, (schema, key) => {
      const ps = getPropertyKeyIndexedAccess(typeAST(schema.ast), key);
      const value3 = make57(ps.isOptional ? orUndefined(ps.type) : ps.type);
      const out = transform2(schema.pipe(pick5(key)), value3, {
        strict: true,
        decode: /* @__PURE__ */ __name((i) => i[key], "decode"),
        encode: /* @__PURE__ */ __name((a) => ps.isOptional && a === void 0 ? {} : {
          [key]: a
        }, "encode")
      });
      return out;
    });
    __name(makeBrandClass, "makeBrandClass");
    brand = /* @__PURE__ */ __name((brand2, annotations3) => (self2) => {
      const annotation = match2(getBrandAnnotation(self2.ast), {
        onNone: /* @__PURE__ */ __name(() => [brand2], "onNone"),
        onSome: /* @__PURE__ */ __name((brands) => [...brands, brand2], "onSome")
      });
      const ast = annotations(self2.ast, toASTAnnotations({
        [BrandAnnotationId]: annotation,
        ...annotations3
      }));
      return makeBrandClass(self2, ast);
    }, "brand");
    partial2 = /* @__PURE__ */ __name((self2) => make57(partial(self2.ast)), "partial");
    partialWith = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (self2, options) => make57(partial(self2.ast, options)));
    required2 = /* @__PURE__ */ __name((self2) => make57(required(self2.ast)), "required");
    mutable2 = /* @__PURE__ */ __name((schema) => make57(mutable(schema.ast)), "mutable");
    intersectTypeLiterals = /* @__PURE__ */ __name((x, y, path) => {
      if (isTypeLiteral(x) && isTypeLiteral(y)) {
        const propertySignatures = [...x.propertySignatures];
        for (const ps of y.propertySignatures) {
          const name = ps.name;
          const i = propertySignatures.findIndex((ps2) => ps2.name === name);
          if (i === -1) {
            propertySignatures.push(ps);
          } else {
            const {
              isOptional,
              type
            } = propertySignatures[i];
            propertySignatures[i] = new PropertySignature(name, extendAST(type, ps.type, path.concat(name)), isOptional, true);
          }
        }
        return new TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
      }
      throw new Error(getSchemaExtendErrorMessage(x, y, path));
    }, "intersectTypeLiterals");
    preserveRefinementAnnotations = /* @__PURE__ */ omitAnnotations([IdentifierAnnotationId]);
    addRefinementToMembers = /* @__PURE__ */ __name((refinement, asts) => asts.map((ast) => new Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement))), "addRefinementToMembers");
    extendAST = /* @__PURE__ */ __name((x, y, path) => Union.make(intersectUnionMembers([x], [y], path)), "extendAST");
    getTypes = /* @__PURE__ */ __name((ast) => isUnion(ast) ? ast.types : [ast], "getTypes");
    intersectUnionMembers = /* @__PURE__ */ __name((xs, ys, path) => flatMap2(xs, (x) => flatMap2(ys, (y) => {
      switch (y._tag) {
        case "Literal": {
          if (isString(y.literal) && isStringKeyword(x) || isNumber(y.literal) && isNumberKeyword(x) || isBoolean(y.literal) && isBooleanKeyword(x)) {
            return [y];
          }
          break;
        }
        case "StringKeyword": {
          if (y === stringKeyword) {
            if (isStringKeyword(x) || isLiteral(x) && isString(x.literal)) {
              return [x];
            } else if (isRefinement(x)) {
              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
            }
          } else if (x === stringKeyword) {
            return [y];
          }
          break;
        }
        case "NumberKeyword": {
          if (y === numberKeyword) {
            if (isNumberKeyword(x) || isLiteral(x) && isNumber(x.literal)) {
              return [x];
            } else if (isRefinement(x)) {
              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
            }
          } else if (x === numberKeyword) {
            return [y];
          }
          break;
        }
        case "BooleanKeyword": {
          if (y === booleanKeyword) {
            if (isBooleanKeyword(x) || isLiteral(x) && isBoolean(x.literal)) {
              return [x];
            } else if (isRefinement(x)) {
              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
            }
          } else if (x === booleanKeyword) {
            return [y];
          }
          break;
        }
        case "Union":
          return intersectUnionMembers(getTypes(x), y.types, path);
        case "Suspend":
          return [new Suspend(() => extendAST(x, y.f(), path))];
        case "Refinement":
          return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path));
        case "TypeLiteral": {
          switch (x._tag) {
            case "Union":
              return intersectUnionMembers(x.types, [y], path);
            case "Suspend":
              return [new Suspend(() => extendAST(x.f(), y, path))];
            case "Refinement":
              return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
            case "TypeLiteral":
              return [intersectTypeLiterals(x, y, path)];
            case "Transformation": {
              const transformation = x.transformation;
              const from2 = intersectTypeLiterals(x.from, y, path);
              const to = intersectTypeLiterals(x.to, typeAST(y), path);
              switch (transformation._tag) {
                case "TypeLiteralTransformation":
                  return [new Transformation(from2, to, new TypeLiteralTransformation(transformation.propertySignatureTransformations))];
                case "ComposeTransformation":
                  return [new Transformation(from2, to, composeTransformation)];
                case "FinalTransformation":
                  return [new Transformation(from2, to, new FinalTransformation((fromA, options, ast, fromI) => map26(transformation.decode(fromA, options, ast, fromI), (partial4) => ({
                    ...fromA,
                    ...partial4
                  })), (toI, options, ast, toA) => map26(transformation.encode(toI, options, ast, toA), (partial4) => ({
                    ...toI,
                    ...partial4
                  }))))];
              }
            }
          }
          break;
        }
        case "Transformation": {
          if (isTransformation(x)) {
            if (isTypeLiteralTransformation(y.transformation) && isTypeLiteralTransformation(x.transformation)) {
              return [new Transformation(intersectTypeLiterals(x.from, y.from, path), intersectTypeLiterals(x.to, y.to, path), new TypeLiteralTransformation(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
            }
          } else {
            return intersectUnionMembers([y], [x], path);
          }
          break;
        }
      }
      throw new Error(getSchemaExtendErrorMessage(x, y, path));
    })), "intersectUnionMembers");
    extend3 = /* @__PURE__ */ dual(2, (self2, that) => make57(extendAST(self2.ast, that.ast, [])));
    compose4 = /* @__PURE__ */ dual((args2) => isSchema(args2[1]), (from2, to) => makeTransformationClass(from2, to, compose(from2.ast, to.ast)));
    suspend12 = /* @__PURE__ */ __name((f) => make57(new Suspend(() => f().ast)), "suspend");
    RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
    __name(makeRefineClass, "makeRefineClass");
    fromFilterPredicateReturnTypeItem = /* @__PURE__ */ __name((item, ast, input) => {
      if (isBoolean(item)) {
        return item ? none2() : some2(new Type2(ast, input));
      }
      if (isString(item)) {
        return some2(new Type2(ast, input, item));
      }
      if (item !== void 0) {
        if ("_tag" in item) {
          return some2(item);
        }
        const issue2 = new Type2(ast, input, item.message);
        return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue2) : issue2);
      }
      return none2();
    }, "fromFilterPredicateReturnTypeItem");
    toFilterParseIssue = /* @__PURE__ */ __name((out, ast, input) => {
      if (isSingle(out)) {
        return fromFilterPredicateReturnTypeItem(out, ast, input);
      }
      if (isNonEmptyReadonlyArray(out)) {
        const issues = filterMap2(out, (issue2) => fromFilterPredicateReturnTypeItem(issue2, ast, input));
        if (isNonEmptyReadonlyArray(issues)) {
          return some2(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
        }
      }
      return none2();
    }, "toFilterParseIssue");
    __name(filter11, "filter");
    filterEffect2 = /* @__PURE__ */ dual(2, (self2, f) => transformOrFail(self2, typeSchema(self2), {
      strict: true,
      decode: /* @__PURE__ */ __name((i, options, ast) => flatMap17(f(i, options, ast), (filterReturnType) => match2(toFilterParseIssue(filterReturnType, ast, i), {
        onNone: /* @__PURE__ */ __name(() => succeed17(i), "onNone"),
        onSome: fail17
      })), "decode"),
      encode: /* @__PURE__ */ __name((a) => succeed17(a), "encode")
    }));
    __name(makeTransformationClass, "makeTransformationClass");
    transformOrFail = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from2, to, options) => makeTransformationClass(from2, to, new Transformation(from2.ast, to.ast, new FinalTransformation(options.decode, options.encode))));
    transform2 = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from2, to, options) => transformOrFail(from2, to, {
      strict: true,
      decode: /* @__PURE__ */ __name((fromA, _options, _ast, toA) => succeed17(options.decode(fromA, toA)), "decode"),
      encode: /* @__PURE__ */ __name((toI, _options, _ast, toA) => succeed17(options.encode(toI, toA)), "encode")
    }));
    __name(transformLiteral, "transformLiteral");
    __name(transformLiterals, "transformLiterals");
    attachPropertySignature = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (schema, key, value3, annotations3) => {
      const ast = extend3(typeSchema(schema), Struct({
        [key]: isSymbol(value3) ? UniqueSymbolFromSelf(value3) : Literal2(value3)
      })).ast;
      return make57(new Transformation(schema.ast, annotations3 ? mergeSchemaAnnotations(ast, annotations3) : ast, new TypeLiteralTransformation([new PropertySignatureTransformation(key, key, () => some2(value3), () => none2())])));
    });
    annotations2 = /* @__PURE__ */ dual(2, (self2, annotations3) => self2.annotations(annotations3));
    rename2 = /* @__PURE__ */ dual(2, (self2, mapping) => make57(rename(self2.ast, mapping)));
    TrimmedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Trimmed");
    trimmed = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter11((a) => a === a.trim(), {
      schemaId: TrimmedSchemaId,
      title: "trimmed",
      description: "a string with no leading or trailing whitespace",
      jsonSchema: {
        pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$"
      },
      ...annotations3
    })), "trimmed");
    MaxLengthSchemaId2 = MaxLengthSchemaId;
    maxLength = /* @__PURE__ */ __name((maxLength2, annotations3) => (self2) => self2.pipe(filter11((a) => a.length <= maxLength2, {
      schemaId: MaxLengthSchemaId2,
      title: `maxLength(${maxLength2})`,
      description: `a string at most ${maxLength2} character(s) long`,
      jsonSchema: {
        maxLength: maxLength2
      },
      ...annotations3
    })), "maxLength");
    MinLengthSchemaId2 = MinLengthSchemaId;
    minLength = /* @__PURE__ */ __name((minLength2, annotations3) => (self2) => self2.pipe(filter11((a) => a.length >= minLength2, {
      schemaId: MinLengthSchemaId2,
      title: `minLength(${minLength2})`,
      description: `a string at least ${minLength2} character(s) long`,
      jsonSchema: {
        minLength: minLength2
      },
      ...annotations3
    })), "minLength");
    LengthSchemaId2 = LengthSchemaId;
    length3 = /* @__PURE__ */ __name((length4, annotations3) => (self2) => {
      const minLength2 = isObject(length4) ? Math.max(0, Math.floor(length4.min)) : Math.max(0, Math.floor(length4));
      const maxLength2 = isObject(length4) ? Math.max(minLength2, Math.floor(length4.max)) : minLength2;
      if (minLength2 !== maxLength2) {
        return self2.pipe(filter11((a) => a.length >= minLength2 && a.length <= maxLength2, {
          schemaId: LengthSchemaId2,
          title: `length({ min: ${minLength2}, max: ${maxLength2})`,
          description: `a string at least ${minLength2} character(s) and at most ${maxLength2} character(s) long`,
          jsonSchema: {
            minLength: minLength2,
            maxLength: maxLength2
          },
          ...annotations3
        }));
      }
      return self2.pipe(filter11((a) => a.length === minLength2, {
        schemaId: LengthSchemaId2,
        title: `length(${minLength2})`,
        description: minLength2 === 1 ? `a single character` : `a string ${minLength2} character(s) long`,
        jsonSchema: {
          minLength: minLength2,
          maxLength: minLength2
        },
        ...annotations3
      }));
    }, "length");
    PatternSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Pattern");
    pattern = /* @__PURE__ */ __name((regex, annotations3) => (self2) => {
      const source2 = regex.source;
      return self2.pipe(filter11((a) => {
        regex.lastIndex = 0;
        return regex.test(a);
      }, {
        schemaId: PatternSchemaId,
        [PatternSchemaId]: {
          regex
        },
        // title: `pattern(/${source}/)`, // avoiding this because it can be very long
        description: `a string matching the pattern ${source2}`,
        jsonSchema: {
          pattern: source2
        },
        ...annotations3
      }));
    }, "pattern");
    StartsWithSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/StartsWith");
    startsWith = /* @__PURE__ */ __name((startsWith2, annotations3) => (self2) => {
      const formatted = JSON.stringify(startsWith2);
      return self2.pipe(filter11((a) => a.startsWith(startsWith2), {
        schemaId: StartsWithSchemaId,
        [StartsWithSchemaId]: {
          startsWith: startsWith2
        },
        title: `startsWith(${formatted})`,
        description: `a string starting with ${formatted}`,
        jsonSchema: {
          pattern: `^${startsWith2}`
        },
        ...annotations3
      }));
    }, "startsWith");
    EndsWithSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/EndsWith");
    endsWith = /* @__PURE__ */ __name((endsWith2, annotations3) => (self2) => {
      const formatted = JSON.stringify(endsWith2);
      return self2.pipe(filter11((a) => a.endsWith(endsWith2), {
        schemaId: EndsWithSchemaId,
        [EndsWithSchemaId]: {
          endsWith: endsWith2
        },
        title: `endsWith(${formatted})`,
        description: `a string ending with ${formatted}`,
        jsonSchema: {
          pattern: `^.*${endsWith2}$`
        },
        ...annotations3
      }));
    }, "endsWith");
    IncludesSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Includes");
    includes = /* @__PURE__ */ __name((searchString, annotations3) => (self2) => {
      const formatted = JSON.stringify(searchString);
      return self2.pipe(filter11((a) => a.includes(searchString), {
        schemaId: IncludesSchemaId,
        [IncludesSchemaId]: {
          includes: searchString
        },
        title: `includes(${formatted})`,
        description: `a string including ${formatted}`,
        jsonSchema: {
          pattern: `.*${searchString}.*`
        },
        ...annotations3
      }));
    }, "includes");
    LowercasedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Lowercased");
    lowercased = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter11((a) => a === a.toLowerCase(), {
      schemaId: LowercasedSchemaId,
      title: "lowercased",
      description: "a lowercase string",
      jsonSchema: {
        pattern: "^[^A-Z]*$"
      },
      ...annotations3
    })), "lowercased");
    Lowercased = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ lowercased({
      identifier: "Lowercased"
    }))) {
      static {
        __name(this, "Lowercased");
      }
    };
    UppercasedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Uppercased");
    uppercased = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter11((a) => a === a.toUpperCase(), {
      schemaId: UppercasedSchemaId,
      title: "uppercased",
      description: "an uppercase string",
      jsonSchema: {
        pattern: "^[^a-z]*$"
      },
      ...annotations3
    })), "uppercased");
    Uppercased = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ uppercased({
      identifier: "Uppercased"
    }))) {
      static {
        __name(this, "Uppercased");
      }
    };
    CapitalizedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Capitalized");
    capitalized = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter11((a) => a[0]?.toUpperCase() === a[0], {
      schemaId: CapitalizedSchemaId,
      title: "capitalized",
      description: "a capitalized string",
      jsonSchema: {
        pattern: "^[^a-z]?.*$"
      },
      ...annotations3
    })), "capitalized");
    Capitalized = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ capitalized({
      identifier: "Capitalized"
    }))) {
      static {
        __name(this, "Capitalized");
      }
    };
    UncapitalizedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Uncapitalized");
    uncapitalized = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter11((a) => a[0]?.toLowerCase() === a[0], {
      schemaId: UncapitalizedSchemaId,
      title: "uncapitalized",
      description: "a uncapitalized string",
      jsonSchema: {
        pattern: "^[^A-Z]?.*$"
      },
      ...annotations3
    })), "uncapitalized");
    Uncapitalized = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ uncapitalized({
      identifier: "Uncapitalized"
    }))) {
      static {
        __name(this, "Uncapitalized");
      }
    };
    Char = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ length3(1, {
      identifier: "Char"
    }))) {
      static {
        __name(this, "Char");
      }
    };
    nonEmptyString2 = /* @__PURE__ */ __name((annotations3) => minLength(1, {
      title: "nonEmptyString",
      description: "a non empty string",
      ...annotations3
    }), "nonEmptyString");
    Lowercase = class extends (/* @__PURE__ */ transform2(String$.annotations({
      description: "a string that will be converted to lowercase"
    }), Lowercased, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => i.toLowerCase(), "decode"),
      encode: identity
    }).annotations({
      identifier: "Lowercase"
    })) {
      static {
        __name(this, "Lowercase");
      }
    };
    Uppercase = class extends (/* @__PURE__ */ transform2(String$.annotations({
      description: "a string that will be converted to uppercase"
    }), Uppercased, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => i.toUpperCase(), "decode"),
      encode: identity
    }).annotations({
      identifier: "Uppercase"
    })) {
      static {
        __name(this, "Uppercase");
      }
    };
    Capitalize = class extends (/* @__PURE__ */ transform2(String$.annotations({
      description: "a string that will be converted to a capitalized format"
    }), Capitalized, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => capitalize(i), "decode"),
      encode: identity
    }).annotations({
      identifier: "Capitalize"
    })) {
      static {
        __name(this, "Capitalize");
      }
    };
    Uncapitalize = class extends (/* @__PURE__ */ transform2(String$.annotations({
      description: "a string that will be converted to an uncapitalized format"
    }), Uncapitalized, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => uncapitalize(i), "decode"),
      encode: identity
    }).annotations({
      identifier: "Uncapitalize"
    })) {
      static {
        __name(this, "Uncapitalize");
      }
    };
    Trimmed = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ trimmed({
      identifier: "Trimmed"
    }))) {
      static {
        __name(this, "Trimmed");
      }
    };
    NonEmptyTrimmedString = class extends (/* @__PURE__ */ Trimmed.pipe(/* @__PURE__ */ nonEmptyString2({
      identifier: "NonEmptyTrimmedString"
    }))) {
      static {
        __name(this, "NonEmptyTrimmedString");
      }
    };
    Trim = class extends (/* @__PURE__ */ transform2(String$.annotations({
      description: "a string that will be trimmed"
    }), Trimmed, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => i.trim(), "decode"),
      encode: identity
    }).annotations({
      identifier: "Trim"
    })) {
      static {
        __name(this, "Trim");
      }
    };
    split2 = /* @__PURE__ */ __name((separator) => transform2(String$.annotations({
      description: "a string that will be split"
    }), Array$(String$), {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => i.split(separator), "decode"),
      encode: /* @__PURE__ */ __name((a) => a.join(separator), "encode")
    }), "split");
    getErrorMessage2 = /* @__PURE__ */ __name((e) => e instanceof Error ? e.message : String(e), "getErrorMessage");
    getParseJsonTransformation = /* @__PURE__ */ __name((options) => transformOrFail(String$.annotations({
      description: "a string to be decoded into JSON"
    }), Unknown, {
      strict: true,
      decode: /* @__PURE__ */ __name((i, _, ast) => _try({
        try: /* @__PURE__ */ __name(() => JSON.parse(i, options?.reviver), "try"),
        catch: /* @__PURE__ */ __name((e) => new Type2(ast, i, getErrorMessage2(e)), "catch")
      }), "decode"),
      encode: /* @__PURE__ */ __name((a, _, ast) => _try({
        try: /* @__PURE__ */ __name(() => JSON.stringify(a, options?.replacer, options?.space), "try"),
        catch: /* @__PURE__ */ __name((e) => new Type2(ast, a, getErrorMessage2(e)), "catch")
      }), "encode")
    }).annotations({
      title: "parseJson",
      schemaId: ParseJsonSchemaId
    }), "getParseJsonTransformation");
    parseJson = /* @__PURE__ */ __name((schemaOrOptions, o) => isSchema(schemaOrOptions) ? compose4(parseJson(o), schemaOrOptions) : getParseJsonTransformation(schemaOrOptions), "parseJson");
    NonEmptyString = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ nonEmptyString2({
      identifier: "NonEmptyString"
    }))) {
      static {
        __name(this, "NonEmptyString");
      }
    };
    UUIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/UUID");
    uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
    UUID = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(uuidRegexp, {
      schemaId: UUIDSchemaId,
      identifier: "UUID",
      jsonSchema: {
        format: "uuid",
        pattern: uuidRegexp.source
      },
      description: "a Universally Unique Identifier",
      arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.uuid(), "arbitrary")
    }))) {
      static {
        __name(this, "UUID");
      }
    };
    ULIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ULID");
    ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;
    ULID = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(ulidRegexp, {
      schemaId: ULIDSchemaId,
      identifier: "ULID",
      description: "a Universally Unique Lexicographically Sortable Identifier",
      arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.ulid(), "arbitrary")
    }))) {
      static {
        __name(this, "ULID");
      }
    };
    URLFromSelf = class extends (/* @__PURE__ */ instanceOf(URL, {
      typeConstructor: {
        _tag: "URL"
      },
      identifier: "URLFromSelf",
      arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.webUrl().map((s) => new URL(s)), "arbitrary"),
      pretty: /* @__PURE__ */ __name(() => (url3) => url3.toString(), "pretty")
    })) {
      static {
        __name(this, "URLFromSelf");
      }
    };
    URL$ = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
      description: "a string to be decoded into a URL"
    }), URLFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i, _, ast) => _try({
        try: /* @__PURE__ */ __name(() => new URL(i), "try"),
        catch: /* @__PURE__ */ __name((e) => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a URL. ${getErrorMessage2(e)}`), "catch")
      }), "decode"),
      encode: /* @__PURE__ */ __name((a) => succeed17(a.toString()), "encode")
    }).annotations({
      identifier: "URL",
      pretty: /* @__PURE__ */ __name(() => (url3) => url3.toString(), "pretty")
    })) {
      static {
        __name(this, "URL$");
      }
    };
    FiniteSchemaId2 = FiniteSchemaId;
    finite = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter11(Number.isFinite, {
      schemaId: FiniteSchemaId2,
      title: "finite",
      description: "a finite number",
      jsonSchema: {},
      ...annotations3
    })), "finite");
    GreaterThanSchemaId2 = GreaterThanSchemaId;
    greaterThan6 = /* @__PURE__ */ __name((exclusiveMinimum, annotations3) => (self2) => self2.pipe(filter11((a) => a > exclusiveMinimum, {
      schemaId: GreaterThanSchemaId2,
      title: `greaterThan(${exclusiveMinimum})`,
      description: exclusiveMinimum === 0 ? "a positive number" : `a number greater than ${exclusiveMinimum}`,
      jsonSchema: {
        exclusiveMinimum
      },
      ...annotations3
    })), "greaterThan");
    GreaterThanOrEqualToSchemaId2 = GreaterThanOrEqualToSchemaId;
    greaterThanOrEqualTo5 = /* @__PURE__ */ __name((minimum, annotations3) => (self2) => self2.pipe(filter11((a) => a >= minimum, {
      schemaId: GreaterThanOrEqualToSchemaId2,
      title: `greaterThanOrEqualTo(${minimum})`,
      description: minimum === 0 ? "a non-negative number" : `a number greater than or equal to ${minimum}`,
      jsonSchema: {
        minimum
      },
      ...annotations3
    })), "greaterThanOrEqualTo");
    MultipleOfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MultipleOf");
    multipleOf = /* @__PURE__ */ __name((divisor, annotations3) => (self2) => {
      const positiveDivisor = Math.abs(divisor);
      return self2.pipe(filter11((a) => remainder(a, divisor) === 0, {
        schemaId: MultipleOfSchemaId,
        title: `multipleOf(${positiveDivisor})`,
        description: `a number divisible by ${positiveDivisor}`,
        jsonSchema: {
          multipleOf: positiveDivisor
        },
        ...annotations3
      }));
    }, "multipleOf");
    IntSchemaId2 = IntSchemaId;
    int = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter11((a) => Number.isSafeInteger(a), {
      schemaId: IntSchemaId2,
      title: "int",
      description: "an integer",
      jsonSchema: {
        type: "integer"
      },
      ...annotations3
    })), "int");
    LessThanSchemaId2 = LessThanSchemaId;
    lessThan9 = /* @__PURE__ */ __name((exclusiveMaximum, annotations3) => (self2) => self2.pipe(filter11((a) => a < exclusiveMaximum, {
      schemaId: LessThanSchemaId2,
      title: `lessThan(${exclusiveMaximum})`,
      description: exclusiveMaximum === 0 ? "a negative number" : `a number less than ${exclusiveMaximum}`,
      jsonSchema: {
        exclusiveMaximum
      },
      ...annotations3
    })), "lessThan");
    LessThanOrEqualToSchemaId2 = LessThanOrEqualToSchemaId;
    lessThanOrEqualTo5 = /* @__PURE__ */ __name((maximum, annotations3) => (self2) => self2.pipe(filter11((a) => a <= maximum, {
      schemaId: LessThanOrEqualToSchemaId2,
      title: `lessThanOrEqualTo(${maximum})`,
      description: maximum === 0 ? "a non-positive number" : `a number less than or equal to ${maximum}`,
      jsonSchema: {
        maximum
      },
      ...annotations3
    })), "lessThanOrEqualTo");
    BetweenSchemaId2 = BetweenSchemaId;
    between5 = /* @__PURE__ */ __name((minimum, maximum, annotations3) => (self2) => self2.pipe(filter11((a) => a >= minimum && a <= maximum, {
      schemaId: BetweenSchemaId2,
      title: `between(${minimum}, ${maximum})`,
      description: `a number between ${minimum} and ${maximum}`,
      jsonSchema: {
        minimum,
        maximum
      },
      ...annotations3
    })), "between");
    NonNaNSchemaId2 = NonNaNSchemaId;
    nonNaN = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter11((a) => !Number.isNaN(a), {
      schemaId: NonNaNSchemaId2,
      title: "nonNaN",
      description: "a number excluding NaN",
      ...annotations3
    })), "nonNaN");
    positive = /* @__PURE__ */ __name((annotations3) => greaterThan6(0, {
      title: "positive",
      ...annotations3
    }), "positive");
    negative = /* @__PURE__ */ __name((annotations3) => lessThan9(0, {
      title: "negative",
      ...annotations3
    }), "negative");
    nonPositive = /* @__PURE__ */ __name((annotations3) => lessThanOrEqualTo5(0, {
      title: "nonPositive",
      ...annotations3
    }), "nonPositive");
    nonNegative = /* @__PURE__ */ __name((annotations3) => greaterThanOrEqualTo5(0, {
      title: "nonNegative",
      ...annotations3
    }), "nonNegative");
    clamp8 = /* @__PURE__ */ __name((minimum, maximum) => (self2) => {
      return transform2(self2, typeSchema(self2).pipe(between5(minimum, maximum)), {
        strict: false,
        decode: /* @__PURE__ */ __name((i) => clamp3(i, {
          minimum,
          maximum
        }), "decode"),
        encode: identity
      });
    }, "clamp");
    __name(parseNumber, "parseNumber");
    NumberFromString = class extends (/* @__PURE__ */ parseNumber(String$.annotations({
      description: "a string to be decoded into a number"
    })).annotations({
      identifier: "NumberFromString"
    })) {
      static {
        __name(this, "NumberFromString");
      }
    };
    Finite = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ finite({
      identifier: "Finite"
    }))) {
      static {
        __name(this, "Finite");
      }
    };
    Int = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ int({
      identifier: "Int"
    }))) {
      static {
        __name(this, "Int");
      }
    };
    NonNaN = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonNaN({
      identifier: "NonNaN"
    }))) {
      static {
        __name(this, "NonNaN");
      }
    };
    Positive = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ positive({
      identifier: "Positive"
    }))) {
      static {
        __name(this, "Positive");
      }
    };
    Negative = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ negative({
      identifier: "Negative"
    }))) {
      static {
        __name(this, "Negative");
      }
    };
    NonPositive = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonPositive({
      identifier: "NonPositive"
    }))) {
      static {
        __name(this, "NonPositive");
      }
    };
    NonNegative = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonNegative({
      identifier: "NonNegative"
    }))) {
      static {
        __name(this, "NonNegative");
      }
    };
    JsonNumberSchemaId2 = JsonNumberSchemaId;
    JsonNumber = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ finite({
      schemaId: JsonNumberSchemaId2,
      identifier: "JsonNumber"
    }))) {
      static {
        __name(this, "JsonNumber");
      }
    };
    Not = class extends (/* @__PURE__ */ transform2(/* @__PURE__ */ Boolean$.annotations({
      description: "a boolean that will be negated"
    }), Boolean$, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => not(i), "decode"),
      encode: /* @__PURE__ */ __name((a) => not(a), "encode")
    })) {
      static {
        __name(this, "Not");
      }
    };
    encodeSymbol2 = /* @__PURE__ */ __name((sym, ast) => {
      const key = Symbol.keyFor(sym);
      return key === void 0 ? fail17(new Type2(ast, sym, `Unable to encode a unique symbol ${String(sym)} into a string`)) : succeed17(key);
    }, "encodeSymbol");
    decodeSymbol = /* @__PURE__ */ __name((s) => succeed17(Symbol.for(s)), "decodeSymbol");
    Symbol$ = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
      description: "a string to be decoded into a globally shared symbol"
    }), SymbolFromSelf, {
      strict: false,
      decode: /* @__PURE__ */ __name((i) => decodeSymbol(i), "decode"),
      encode: /* @__PURE__ */ __name((a, _, ast) => encodeSymbol2(a, ast), "encode")
    }).annotations({
      identifier: "Symbol"
    })) {
      static {
        __name(this, "Symbol$");
      }
    };
    GreaterThanBigIntSchemaId = GreaterThanBigintSchemaId;
    greaterThanBigInt = /* @__PURE__ */ __name((min4, annotations3) => (self2) => self2.pipe(filter11((a) => a > min4, {
      schemaId: GreaterThanBigIntSchemaId,
      [GreaterThanBigIntSchemaId]: {
        min: min4
      },
      title: `greaterThanBigInt(${min4})`,
      description: min4 === 0n ? "a positive bigint" : `a bigint greater than ${min4}n`,
      ...annotations3
    })), "greaterThanBigInt");
    GreaterThanOrEqualToBigIntSchemaId2 = GreaterThanOrEqualToBigIntSchemaId;
    greaterThanOrEqualToBigInt = /* @__PURE__ */ __name((min4, annotations3) => (self2) => self2.pipe(filter11((a) => a >= min4, {
      schemaId: GreaterThanOrEqualToBigIntSchemaId2,
      [GreaterThanOrEqualToBigIntSchemaId2]: {
        min: min4
      },
      title: `greaterThanOrEqualToBigInt(${min4})`,
      description: min4 === 0n ? "a non-negative bigint" : `a bigint greater than or equal to ${min4}n`,
      ...annotations3
    })), "greaterThanOrEqualToBigInt");
    LessThanBigIntSchemaId2 = LessThanBigIntSchemaId;
    lessThanBigInt = /* @__PURE__ */ __name((max6, annotations3) => (self2) => self2.pipe(filter11((a) => a < max6, {
      schemaId: LessThanBigIntSchemaId2,
      [LessThanBigIntSchemaId2]: {
        max: max6
      },
      title: `lessThanBigInt(${max6})`,
      description: max6 === 0n ? "a negative bigint" : `a bigint less than ${max6}n`,
      ...annotations3
    })), "lessThanBigInt");
    LessThanOrEqualToBigIntSchemaId2 = LessThanOrEqualToBigIntSchemaId;
    lessThanOrEqualToBigInt = /* @__PURE__ */ __name((max6, annotations3) => (self2) => self2.pipe(filter11((a) => a <= max6, {
      schemaId: LessThanOrEqualToBigIntSchemaId2,
      [LessThanOrEqualToBigIntSchemaId2]: {
        max: max6
      },
      title: `lessThanOrEqualToBigInt(${max6})`,
      description: max6 === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max6}n`,
      ...annotations3
    })), "lessThanOrEqualToBigInt");
    BetweenBigIntSchemaId = BetweenBigintSchemaId;
    betweenBigInt = /* @__PURE__ */ __name((min4, max6, annotations3) => (self2) => self2.pipe(filter11((a) => a >= min4 && a <= max6, {
      schemaId: BetweenBigIntSchemaId,
      [BetweenBigIntSchemaId]: {
        min: min4,
        max: max6
      },
      title: `betweenBigInt(${min4}, ${max6})`,
      description: `a bigint between ${min4}n and ${max6}n`,
      ...annotations3
    })), "betweenBigInt");
    positiveBigInt = /* @__PURE__ */ __name((annotations3) => greaterThanBigInt(0n, {
      title: "positiveBigInt",
      ...annotations3
    }), "positiveBigInt");
    negativeBigInt = /* @__PURE__ */ __name((annotations3) => lessThanBigInt(0n, {
      title: "negativeBigInt",
      ...annotations3
    }), "negativeBigInt");
    nonNegativeBigInt = /* @__PURE__ */ __name((annotations3) => greaterThanOrEqualToBigInt(0n, {
      title: "nonNegativeBigInt",
      ...annotations3
    }), "nonNegativeBigInt");
    nonPositiveBigInt = /* @__PURE__ */ __name((annotations3) => lessThanOrEqualToBigInt(0n, {
      title: "nonPositiveBigInt",
      ...annotations3
    }), "nonPositiveBigInt");
    clampBigInt = /* @__PURE__ */ __name((minimum, maximum) => (self2) => transform2(self2, self2.pipe(typeSchema, betweenBigInt(minimum, maximum)), {
      strict: false,
      decode: /* @__PURE__ */ __name((i) => clamp5(i, {
        minimum,
        maximum
      }), "decode"),
      encode: identity
    }), "clampBigInt");
    BigInt$ = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
      description: "a string to be decoded into a bigint"
    }), BigIntFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i, _, ast) => fromOption3(fromString2(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a bigint`)), "decode"),
      encode: /* @__PURE__ */ __name((a) => succeed17(String(a)), "encode")
    }).annotations({
      identifier: "BigInt"
    })) {
      static {
        __name(this, "BigInt$");
      }
    };
    PositiveBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ positiveBigInt({
      identifier: "PositiveBigintFromSelf"
    }));
    PositiveBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ positiveBigInt({
      identifier: "PositiveBigint"
    }));
    NegativeBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ negativeBigInt({
      identifier: "NegativeBigintFromSelf"
    }));
    NegativeBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ negativeBigInt({
      identifier: "NegativeBigint"
    }));
    NonPositiveBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ nonPositiveBigInt({
      identifier: "NonPositiveBigintFromSelf"
    }));
    NonPositiveBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ nonPositiveBigInt({
      identifier: "NonPositiveBigint"
    }));
    NonNegativeBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ nonNegativeBigInt({
      identifier: "NonNegativeBigintFromSelf"
    }));
    NonNegativeBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ nonNegativeBigInt({
      identifier: "NonNegativeBigint"
    }));
    BigIntFromNumber = class extends (/* @__PURE__ */ transformOrFail(Number$.annotations({
      description: "a number to be decoded into a bigint"
    }), BigIntFromSelf.pipe(betweenBigInt(BigInt(Number.MIN_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER))), {
      strict: true,
      decode: /* @__PURE__ */ __name((i, _, ast) => fromOption3(fromNumber(i), () => new Type2(ast, i, `Unable to decode ${i} into a bigint`)), "decode"),
      encode: /* @__PURE__ */ __name((a, _, ast) => fromOption3(toNumber(a), () => new Type2(ast, a, `Unable to encode ${a}n into a number`)), "encode")
    }).annotations({
      identifier: "BigIntFromNumber"
    })) {
      static {
        __name(this, "BigIntFromNumber");
      }
    };
    redactedArbitrary = /* @__PURE__ */ __name((value3) => (fc) => value3(fc).map(make56), "redactedArbitrary");
    toComposite = /* @__PURE__ */ __name((eff, onSuccess, ast, actual) => mapBoth8(eff, {
      onFailure: /* @__PURE__ */ __name((e) => new Composite2(ast, actual, e), "onFailure"),
      onSuccess
    }), "toComposite");
    redactedParse = /* @__PURE__ */ __name((decodeUnknown3) => (u, options, ast) => isRedacted2(u) ? toComposite(decodeUnknown3(value2(u), options), make56, ast, u) : fail17(new Type2(ast, u)), "redactedParse");
    RedactedFromSelf = /* @__PURE__ */ __name((value3) => declare([value3], {
      decode: /* @__PURE__ */ __name((value4) => redactedParse(decodeUnknown(value4)), "decode"),
      encode: /* @__PURE__ */ __name((value4) => redactedParse(encodeUnknown(value4)), "encode")
    }, {
      typeConstructor: {
        _tag: "effect/Redacted"
      },
      description: "Redacted(<redacted>)",
      pretty: /* @__PURE__ */ __name(() => () => "Redacted(<redacted>)", "pretty"),
      arbitrary: redactedArbitrary,
      equivalence: getEquivalence7
    }), "RedactedFromSelf");
    __name(Redacted, "Redacted");
    DurationFromSelf = class extends (/* @__PURE__ */ declare(isDuration, {
      typeConstructor: {
        _tag: "effect/Duration"
      },
      identifier: "DurationFromSelf",
      pretty: /* @__PURE__ */ __name(() => String, "pretty"),
      arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.oneof(fc.constant(infinity), fc.bigInt({
        min: 0n
      }).map((_) => nanos(_)), fc.maxSafeNat().map((_) => millis(_))), "arbitrary"),
      equivalence: /* @__PURE__ */ __name(() => Equivalence2, "equivalence")
    })) {
      static {
        __name(this, "DurationFromSelf");
      }
    };
    DurationFromNanos = class extends (/* @__PURE__ */ transformOrFail(NonNegativeBigIntFromSelf.annotations({
      description: "a bigint to be decoded into a Duration"
    }), DurationFromSelf.pipe(filter11((duration6) => isFinite2(duration6), {
      description: "a finite duration"
    })), {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => succeed17(nanos(i)), "decode"),
      encode: /* @__PURE__ */ __name((a, _, ast) => match2(toNanos(a), {
        onNone: /* @__PURE__ */ __name(() => fail17(new Type2(ast, a, `Unable to encode ${a} into a bigint`)), "onNone"),
        onSome: /* @__PURE__ */ __name((nanos2) => succeed17(nanos2), "onSome")
      }), "encode")
    }).annotations({
      identifier: "DurationFromNanos"
    })) {
      static {
        __name(this, "DurationFromNanos");
      }
    };
    NonNegativeInt = /* @__PURE__ */ NonNegative.pipe(int()).annotations({
      identifier: "NonNegativeInt"
    });
    DurationFromMillis = class extends (/* @__PURE__ */ transform2(NonNegative.annotations({
      description: "a non-negative number to be decoded into a Duration"
    }), DurationFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => millis(i), "decode"),
      encode: /* @__PURE__ */ __name((a) => toMillis(a), "encode")
    }).annotations({
      identifier: "DurationFromMillis"
    })) {
      static {
        __name(this, "DurationFromMillis");
      }
    };
    DurationValueMillis = /* @__PURE__ */ TaggedStruct("Millis", {
      millis: NonNegativeInt
    });
    DurationValueNanos = /* @__PURE__ */ TaggedStruct("Nanos", {
      nanos: BigInt$
    });
    DurationValueInfinity = /* @__PURE__ */ TaggedStruct("Infinity", {});
    durationValueInfinity = /* @__PURE__ */ DurationValueInfinity.make({});
    DurationValue = /* @__PURE__ */ Union2(DurationValueMillis, DurationValueNanos, DurationValueInfinity).annotations({
      identifier: "DurationValue",
      description: "an JSON-compatible tagged union to be decoded into a Duration"
    });
    FiniteHRTime = /* @__PURE__ */ Tuple(element(NonNegativeInt).annotations({
      title: "seconds"
    }), element(NonNegativeInt).annotations({
      title: "nanos"
    })).annotations({
      identifier: "FiniteHRTime"
    });
    InfiniteHRTime = /* @__PURE__ */ Tuple(Literal2(-1), Literal2(0)).annotations({
      identifier: "InfiniteHRTime"
    });
    HRTime = /* @__PURE__ */ Union2(FiniteHRTime, InfiniteHRTime).annotations({
      identifier: "HRTime",
      description: "a tuple of seconds and nanos to be decoded into a Duration"
    });
    isDurationValue = /* @__PURE__ */ __name((u) => typeof u === "object", "isDurationValue");
    Duration = class extends (/* @__PURE__ */ transform2(Union2(DurationValue, HRTime), DurationFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => {
        if (isDurationValue(i)) {
          switch (i._tag) {
            case "Millis":
              return millis(i.millis);
            case "Nanos":
              return nanos(i.nanos);
            case "Infinity":
              return infinity;
          }
        }
        const [seconds2, nanos2] = i;
        return seconds2 === -1 ? infinity : nanos(BigInt(seconds2) * BigInt(1e9) + BigInt(nanos2));
      }, "decode"),
      encode: /* @__PURE__ */ __name((a) => {
        switch (a.value._tag) {
          case "Millis":
            return DurationValueMillis.make({
              millis: a.value.millis
            });
          case "Nanos":
            return DurationValueNanos.make({
              nanos: a.value.nanos
            });
          case "Infinity":
            return durationValueInfinity;
        }
      }, "encode")
    }).annotations({
      identifier: "Duration"
    })) {
      static {
        __name(this, "Duration");
      }
    };
    clampDuration = /* @__PURE__ */ __name((minimum, maximum) => (self2) => transform2(self2, self2.pipe(typeSchema, betweenDuration(minimum, maximum)), {
      strict: false,
      decode: /* @__PURE__ */ __name((i) => clamp6(i, {
        minimum,
        maximum
      }), "decode"),
      encode: identity
    }), "clampDuration");
    LessThanDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanDuration");
    lessThanDuration = /* @__PURE__ */ __name((max6, annotations3) => (self2) => self2.pipe(filter11((a) => lessThan3(a, max6), {
      schemaId: LessThanDurationSchemaId,
      [LessThanDurationSchemaId]: {
        max: max6
      },
      title: `lessThanDuration(${max6})`,
      description: `a Duration less than ${decode(max6)}`,
      ...annotations3
    })), "lessThanDuration");
    LessThanOrEqualToDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/LessThanOrEqualToDuration");
    lessThanOrEqualToDuration = /* @__PURE__ */ __name((max6, annotations3) => (self2) => self2.pipe(filter11((a) => lessThanOrEqualTo3(a, max6), {
      schemaId: LessThanDurationSchemaId,
      [LessThanDurationSchemaId]: {
        max: max6
      },
      title: `lessThanOrEqualToDuration(${max6})`,
      description: `a Duration less than or equal to ${decode(max6)}`,
      ...annotations3
    })), "lessThanOrEqualToDuration");
    GreaterThanDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanDuration");
    greaterThanDuration = /* @__PURE__ */ __name((min4, annotations3) => (self2) => self2.pipe(filter11((a) => greaterThan3(a, min4), {
      schemaId: GreaterThanDurationSchemaId,
      [GreaterThanDurationSchemaId]: {
        min: min4
      },
      title: `greaterThanDuration(${min4})`,
      description: `a Duration greater than ${decode(min4)}`,
      ...annotations3
    })), "greaterThanDuration");
    GreaterThanOrEqualToDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/GreaterThanOrEqualToDuration");
    greaterThanOrEqualToDuration = /* @__PURE__ */ __name((min4, annotations3) => (self2) => self2.pipe(filter11((a) => greaterThanOrEqualTo3(a, min4), {
      schemaId: GreaterThanOrEqualToDurationSchemaId,
      [GreaterThanOrEqualToDurationSchemaId]: {
        min: min4
      },
      title: `greaterThanOrEqualToDuration(${min4})`,
      description: `a Duration greater than or equal to ${decode(min4)}`,
      ...annotations3
    })), "greaterThanOrEqualToDuration");
    BetweenDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenDuration");
    betweenDuration = /* @__PURE__ */ __name((minimum, maximum, annotations3) => (self2) => self2.pipe(filter11((a) => between3(a, {
      minimum,
      maximum
    }), {
      schemaId: BetweenDurationSchemaId,
      [BetweenDurationSchemaId]: {
        maximum,
        minimum
      },
      title: `betweenDuration(${minimum}, ${maximum})`,
      description: `a Duration between ${decode(minimum)} and ${decode(maximum)}`,
      ...annotations3
    })), "betweenDuration");
    Uint8ArrayFromSelf = class extends (/* @__PURE__ */ declare(isUint8Array, {
      typeConstructor: {
        _tag: "Uint8Array"
      },
      identifier: "Uint8ArrayFromSelf",
      pretty: /* @__PURE__ */ __name(() => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`, "pretty"),
      arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.uint8Array(), "arbitrary"),
      equivalence: /* @__PURE__ */ __name(() => getEquivalence3(equals), "equivalence")
    })) {
      static {
        __name(this, "Uint8ArrayFromSelf");
      }
    };
    Uint8 = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ between5(0, 255, {
      identifier: "Uint8",
      description: "a 8-bit unsigned integer"
    }))) {
      static {
        __name(this, "Uint8");
      }
    };
    Uint8Array$ = class extends (/* @__PURE__ */ transform2(Array$(Uint8).annotations({
      description: "an array of 8-bit unsigned integers to be decoded into a Uint8Array"
    }), Uint8ArrayFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => Uint8Array.from(i), "decode"),
      encode: /* @__PURE__ */ __name((a) => Array.from(a), "encode")
    }).annotations({
      identifier: "Uint8Array"
    })) {
      static {
        __name(this, "Uint8Array$");
      }
    };
    makeUint8ArrayTransformation = /* @__PURE__ */ __name((id2, decode8, encode7) => transformOrFail(String$.annotations({
      description: "a string to be decoded into a Uint8Array"
    }), Uint8ArrayFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i, _, ast) => mapLeft(decode8(i), (decodeException) => new Type2(ast, i, decodeException.message)), "decode"),
      encode: /* @__PURE__ */ __name((a) => succeed17(encode7(a)), "encode")
    }).annotations({
      identifier: id2
    }), "makeUint8ArrayTransformation");
    Uint8ArrayFromBase64 = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromBase64", decodeBase64, encodeBase64);
    Uint8ArrayFromBase64Url = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromBase64Url", decodeBase64Url, encodeBase64Url);
    Uint8ArrayFromHex = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromHex", decodeHex, encodeHex);
    makeEncodingTransformation = /* @__PURE__ */ __name((id2, decode8, encode7) => transformOrFail(String$.annotations({
      description: `A string that is interpreted as being ${id2}-encoded and will be decoded into a UTF-8 string`
    }), String$, {
      strict: true,
      decode: /* @__PURE__ */ __name((i, _, ast) => mapLeft(decode8(i), (decodeException) => new Type2(ast, i, decodeException.message)), "decode"),
      encode: /* @__PURE__ */ __name((a) => succeed17(encode7(a)), "encode")
    }).annotations({
      identifier: `StringFrom${id2}`
    }), "makeEncodingTransformation");
    StringFromBase64 = /* @__PURE__ */ makeEncodingTransformation("Base64", decodeBase64String, encodeBase64);
    StringFromBase64Url = /* @__PURE__ */ makeEncodingTransformation("Base64Url", decodeBase64UrlString, encodeBase64Url);
    StringFromHex = /* @__PURE__ */ makeEncodingTransformation("Hex", decodeHexString, encodeHex);
    StringFromUriComponent = /* @__PURE__ */ transformOrFail(String$.annotations({
      description: `A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string`
    }), String$, {
      strict: true,
      decode: /* @__PURE__ */ __name((i, _, ast) => mapLeft(decodeUriComponent(i), (decodeException) => new Type2(ast, i, decodeException.message)), "decode"),
      encode: /* @__PURE__ */ __name((a, _, ast) => mapLeft(encodeUriComponent(a), (encodeException) => new Type2(ast, a, encodeException.message)), "encode")
    }).annotations({
      identifier: `StringFromUriComponent`
    });
    MinItemsSchemaId2 = MinItemsSchemaId;
    minItems = /* @__PURE__ */ __name((n, annotations3) => (self2) => {
      const minItems2 = Math.floor(n);
      if (minItems2 < 1) {
        throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
      }
      return self2.pipe(filter11((a) => a.length >= minItems2, {
        schemaId: MinItemsSchemaId2,
        title: `minItems(${minItems2})`,
        description: `an array of at least ${minItems2} item(s)`,
        jsonSchema: {
          minItems: minItems2
        },
        [StableFilterAnnotationId]: true,
        ...annotations3
      }));
    }, "minItems");
    MaxItemsSchemaId2 = MaxItemsSchemaId;
    maxItems = /* @__PURE__ */ __name((n, annotations3) => (self2) => {
      const maxItems2 = Math.floor(n);
      if (maxItems2 < 1) {
        throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
      }
      return self2.pipe(filter11((a) => a.length <= maxItems2, {
        schemaId: MaxItemsSchemaId2,
        title: `maxItems(${maxItems2})`,
        description: `an array of at most ${maxItems2} item(s)`,
        jsonSchema: {
          maxItems: maxItems2
        },
        [StableFilterAnnotationId]: true,
        ...annotations3
      }));
    }, "maxItems");
    ItemsCountSchemaId2 = ItemsCountSchemaId;
    itemsCount = /* @__PURE__ */ __name((n, annotations3) => (self2) => {
      const itemsCount2 = Math.floor(n);
      if (itemsCount2 < 0) {
        throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 0, actual ${n}`));
      }
      return self2.pipe(filter11((a) => a.length === itemsCount2, {
        schemaId: ItemsCountSchemaId2,
        title: `itemsCount(${itemsCount2})`,
        description: `an array of exactly ${itemsCount2} item(s)`,
        jsonSchema: {
          minItems: itemsCount2,
          maxItems: itemsCount2
        },
        [StableFilterAnnotationId]: true,
        ...annotations3
      }));
    }, "itemsCount");
    getNumberIndexedAccess2 = /* @__PURE__ */ __name((self2) => make57(getNumberIndexedAccess(self2.ast)), "getNumberIndexedAccess");
    __name(head6, "head");
    __name(headNonEmpty3, "headNonEmpty");
    headOrElse = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (self2, fallback) => transformOrFail(self2, getNumberIndexedAccess2(typeSchema(self2)), {
      strict: true,
      decode: /* @__PURE__ */ __name((i, _, ast) => i.length > 0 ? succeed17(i[0]) : fallback ? succeed17(fallback()) : fail17(new Type2(ast, i, "Unable to retrieve the first element of an empty array")), "decode"),
      encode: /* @__PURE__ */ __name((a) => succeed17(of(a)), "encode")
    }));
    ValidDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ValidDate");
    validDate = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter11((a) => !Number.isNaN(a.getTime()), {
      schemaId: ValidDateSchemaId,
      [ValidDateSchemaId]: {
        noInvalidDate: true
      },
      title: "validDate",
      description: "a valid Date",
      ...annotations3
    })), "validDate");
    LessThanDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanDate");
    lessThanDate = /* @__PURE__ */ __name((max6, annotations3) => (self2) => self2.pipe(filter11((a) => a < max6, {
      schemaId: LessThanDateSchemaId,
      [LessThanDateSchemaId]: {
        max: max6
      },
      title: `lessThanDate(${formatDate(max6)})`,
      description: `a date before ${formatDate(max6)}`,
      ...annotations3
    })), "lessThanDate");
    LessThanOrEqualToDateSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/LessThanOrEqualToDate");
    lessThanOrEqualToDate = /* @__PURE__ */ __name((max6, annotations3) => (self2) => self2.pipe(filter11((a) => a <= max6, {
      schemaId: LessThanOrEqualToDateSchemaId,
      [LessThanOrEqualToDateSchemaId]: {
        max: max6
      },
      title: `lessThanOrEqualToDate(${formatDate(max6)})`,
      description: `a date before or equal to ${formatDate(max6)}`,
      ...annotations3
    })), "lessThanOrEqualToDate");
    GreaterThanDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanDate");
    greaterThanDate = /* @__PURE__ */ __name((min4, annotations3) => (self2) => self2.pipe(filter11((a) => a > min4, {
      schemaId: GreaterThanDateSchemaId,
      [GreaterThanDateSchemaId]: {
        min: min4
      },
      title: `greaterThanDate(${formatDate(min4)})`,
      description: `a date after ${formatDate(min4)}`,
      ...annotations3
    })), "greaterThanDate");
    GreaterThanOrEqualToDateSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/GreaterThanOrEqualToDate");
    greaterThanOrEqualToDate = /* @__PURE__ */ __name((min4, annotations3) => (self2) => self2.pipe(filter11((a) => a >= min4, {
      schemaId: GreaterThanOrEqualToDateSchemaId,
      [GreaterThanOrEqualToDateSchemaId]: {
        min: min4
      },
      title: `greaterThanOrEqualToDate(${formatDate(min4)})`,
      description: `a date after or equal to ${formatDate(min4)}`,
      ...annotations3
    })), "greaterThanOrEqualToDate");
    BetweenDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenDate");
    betweenDate = /* @__PURE__ */ __name((min4, max6, annotations3) => (self2) => self2.pipe(filter11((a) => a <= max6 && a >= min4, {
      schemaId: BetweenDateSchemaId,
      [BetweenDateSchemaId]: {
        max: max6,
        min: min4
      },
      title: `betweenDate(${formatDate(min4)}, ${formatDate(max6)})`,
      description: `a date between ${formatDate(min4)} and ${formatDate(max6)}`,
      ...annotations3
    })), "betweenDate");
    DateFromSelfSchemaId2 = DateFromSelfSchemaId;
    DateFromSelf = class extends (/* @__PURE__ */ declare(isDate, {
      typeConstructor: {
        _tag: "Date"
      },
      identifier: "DateFromSelf",
      schemaId: DateFromSelfSchemaId2,
      [DateFromSelfSchemaId2]: {
        noInvalidDate: false
      },
      description: "a potentially invalid Date instance",
      pretty: /* @__PURE__ */ __name(() => (date7) => `new Date(${JSON.stringify(date7)})`, "pretty"),
      arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.date({
        noInvalidDate: false
      }), "arbitrary"),
      equivalence: /* @__PURE__ */ __name(() => Date2, "equivalence")
    })) {
      static {
        __name(this, "DateFromSelf");
      }
    };
    ValidDateFromSelf = class extends (/* @__PURE__ */ DateFromSelf.pipe(/* @__PURE__ */ validDate({
      identifier: "ValidDateFromSelf",
      description: "a valid Date instance"
    }))) {
      static {
        __name(this, "ValidDateFromSelf");
      }
    };
    DateFromString = class extends (/* @__PURE__ */ transform2(String$.annotations({
      description: "a string to be decoded into a Date"
    }), DateFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => new Date(i), "decode"),
      encode: /* @__PURE__ */ __name((a) => formatDate(a), "encode")
    }).annotations({
      identifier: "DateFromString"
    })) {
      static {
        __name(this, "DateFromString");
      }
    };
    Date$ = class extends (/* @__PURE__ */ DateFromString.pipe(/* @__PURE__ */ validDate({
      identifier: "Date"
    }))) {
      static {
        __name(this, "Date$");
      }
    };
    DateFromNumber = class extends (/* @__PURE__ */ transform2(Number$.annotations({
      description: "a number to be decoded into a Date"
    }), DateFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => new Date(i), "decode"),
      encode: /* @__PURE__ */ __name((a) => a.getTime(), "encode")
    }).annotations({
      identifier: "DateFromNumber"
    })) {
      static {
        __name(this, "DateFromNumber");
      }
    };
    DateTimeUtcFromSelf = class extends (/* @__PURE__ */ declare((u) => isDateTime2(u) && isUtc2(u), {
      typeConstructor: {
        _tag: "effect/DateTime.Utc"
      },
      identifier: "DateTimeUtcFromSelf",
      description: "a DateTime.Utc instance",
      pretty: /* @__PURE__ */ __name(() => (dateTime) => dateTime.toString(), "pretty"),
      arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.date({
        noInvalidDate: true
      }).map((date7) => unsafeFromDate2(date7)), "arbitrary"),
      equivalence: /* @__PURE__ */ __name(() => Equivalence5, "equivalence")
    })) {
      static {
        __name(this, "DateTimeUtcFromSelf");
      }
    };
    decodeDateTimeUtc = /* @__PURE__ */ __name((input, ast) => _try({
      try: /* @__PURE__ */ __name(() => unsafeMake12(input), "try"),
      catch: /* @__PURE__ */ __name(() => new Type2(ast, input, `Unable to decode ${formatUnknown(input)} into a DateTime.Utc`), "catch")
    }), "decodeDateTimeUtc");
    DateTimeUtcFromNumber = class extends (/* @__PURE__ */ transformOrFail(Number$.annotations({
      description: "a number to be decoded into a DateTime.Utc"
    }), DateTimeUtcFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i, _, ast) => decodeDateTimeUtc(i, ast), "decode"),
      encode: /* @__PURE__ */ __name((a) => succeed17(toEpochMillis2(a)), "encode")
    }).annotations({
      identifier: "DateTimeUtcFromNumber"
    })) {
      static {
        __name(this, "DateTimeUtcFromNumber");
      }
    };
    DateTimeUtcFromDate = class extends (/* @__PURE__ */ transformOrFail(DateFromSelf.annotations({
      description: "a Date to be decoded into a DateTime.Utc"
    }), DateTimeUtcFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i, _, ast) => decodeDateTimeUtc(i, ast), "decode"),
      encode: /* @__PURE__ */ __name((a) => succeed17(toDateUtc2(a)), "encode")
    }).annotations({
      identifier: "DateTimeUtcFromDate"
    })) {
      static {
        __name(this, "DateTimeUtcFromDate");
      }
    };
    DateTimeUtc = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
      description: "a string to be decoded into a DateTime.Utc"
    }), DateTimeUtcFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i, _, ast) => decodeDateTimeUtc(i, ast), "decode"),
      encode: /* @__PURE__ */ __name((a) => succeed17(formatIso2(a)), "encode")
    }).annotations({
      identifier: "DateTimeUtc"
    })) {
      static {
        __name(this, "DateTimeUtc");
      }
    };
    timeZoneOffsetArbitrary = /* @__PURE__ */ __name(() => (fc) => fc.integer({
      min: -12 * 60 * 60 * 1e3,
      max: 14 * 60 * 60 * 1e3
    }).map(zoneMakeOffset2), "timeZoneOffsetArbitrary");
    TimeZoneOffsetFromSelf = class extends (/* @__PURE__ */ declare(isTimeZoneOffset2, {
      typeConstructor: {
        _tag: "effect/DateTime.TimeZone.Offset"
      },
      identifier: "TimeZoneOffsetFromSelf",
      description: "a TimeZone.Offset instance",
      pretty: /* @__PURE__ */ __name(() => (zone) => zone.toString(), "pretty"),
      arbitrary: timeZoneOffsetArbitrary
    })) {
      static {
        __name(this, "TimeZoneOffsetFromSelf");
      }
    };
    TimeZoneOffset = class extends (/* @__PURE__ */ transform2(Number$.annotations({
      description: "a number to be decoded into a TimeZone.Offset"
    }), TimeZoneOffsetFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => zoneMakeOffset2(i), "decode"),
      encode: /* @__PURE__ */ __name((a) => a.offset, "encode")
    }).annotations({
      identifier: "TimeZoneOffset"
    })) {
      static {
        __name(this, "TimeZoneOffset");
      }
    };
    timeZoneNamedArbitrary = /* @__PURE__ */ __name(() => (fc) => fc.constantFrom(...Intl.supportedValuesOf("timeZone")).map(zoneUnsafeMakeNamed2), "timeZoneNamedArbitrary");
    TimeZoneNamedFromSelf = class extends (/* @__PURE__ */ declare(isTimeZoneNamed2, {
      typeConstructor: {
        _tag: "effect/DateTime.TimeZone.Named"
      },
      identifier: "TimeZoneNamedFromSelf",
      description: "a TimeZone.Named instance",
      pretty: /* @__PURE__ */ __name(() => (zone) => zone.toString(), "pretty"),
      arbitrary: timeZoneNamedArbitrary
    })) {
      static {
        __name(this, "TimeZoneNamedFromSelf");
      }
    };
    TimeZoneNamed = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
      description: "a string to be decoded into a TimeZone.Named"
    }), TimeZoneNamedFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i, _, ast) => _try({
        try: /* @__PURE__ */ __name(() => zoneUnsafeMakeNamed2(i), "try"),
        catch: /* @__PURE__ */ __name(() => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone.Named`), "catch")
      }), "decode"),
      encode: /* @__PURE__ */ __name((a) => succeed17(a.id), "encode")
    }).annotations({
      identifier: "TimeZoneNamed"
    })) {
      static {
        __name(this, "TimeZoneNamed");
      }
    };
    TimeZoneFromSelf = class extends (/* @__PURE__ */ Union2(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf)) {
      static {
        __name(this, "TimeZoneFromSelf");
      }
    };
    TimeZone = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
      description: "a string to be decoded into a TimeZone"
    }), TimeZoneFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i, _, ast) => match2(zoneFromString2(i), {
        onNone: /* @__PURE__ */ __name(() => fail17(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone`)), "onNone"),
        onSome: succeed17
      }), "decode"),
      encode: /* @__PURE__ */ __name((a) => succeed17(zoneToString2(a)), "encode")
    }).annotations({
      identifier: "TimeZone"
    })) {
      static {
        __name(this, "TimeZone");
      }
    };
    timeZoneArbitrary = /* @__PURE__ */ __name((fc) => fc.oneof(timeZoneOffsetArbitrary()(fc), timeZoneNamedArbitrary()(fc)), "timeZoneArbitrary");
    DateTimeZonedFromSelf = class extends (/* @__PURE__ */ declare((u) => isDateTime2(u) && isZoned2(u), {
      typeConstructor: {
        _tag: "effect/DateTime.Zoned"
      },
      identifier: "DateTimeZonedFromSelf",
      description: "a DateTime.Zoned instance",
      pretty: /* @__PURE__ */ __name(() => (dateTime) => dateTime.toString(), "pretty"),
      arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.tuple(fc.integer({
        // time zone db supports +/- 1000 years or so
        min: -31536e9,
        max: 31536e9
      }), timeZoneArbitrary(fc)).map(([millis2, timeZone]) => unsafeMakeZoned2(millis2, {
        timeZone
      })), "arbitrary"),
      equivalence: /* @__PURE__ */ __name(() => Equivalence5, "equivalence")
    })) {
      static {
        __name(this, "DateTimeZonedFromSelf");
      }
    };
    DateTimeZoned = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
      description: "a string to be decoded into a DateTime.Zoned"
    }), DateTimeZonedFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i, _, ast) => match2(makeZonedFromString2(i), {
        onNone: /* @__PURE__ */ __name(() => fail17(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a DateTime.Zoned`)), "onNone"),
        onSome: succeed17
      }), "decode"),
      encode: /* @__PURE__ */ __name((a) => succeed17(formatIsoZoned2(a)), "encode")
    }).annotations({
      identifier: "DateTimeZoned"
    })) {
      static {
        __name(this, "DateTimeZoned");
      }
    };
    OptionNoneEncoded = /* @__PURE__ */ Struct({
      _tag: Literal2("None")
    }).annotations({
      description: "NoneEncoded"
    });
    optionSomeEncoded = /* @__PURE__ */ __name((value3) => Struct({
      _tag: Literal2("Some"),
      value: value3
    }).annotations({
      description: `SomeEncoded<${format6(value3)}>`
    }), "optionSomeEncoded");
    optionEncoded = /* @__PURE__ */ __name((value3) => Union2(OptionNoneEncoded, optionSomeEncoded(value3)).annotations({
      description: `OptionEncoded<${format6(value3)}>`
    }), "optionEncoded");
    optionDecode = /* @__PURE__ */ __name((input) => input._tag === "None" ? none2() : some2(input.value), "optionDecode");
    optionArbitrary = /* @__PURE__ */ __name((value3, ctx) => (fc) => fc.oneof(ctx, fc.record({
      _tag: fc.constant("None")
    }), fc.record({
      _tag: fc.constant("Some"),
      value: value3(fc)
    })).map(optionDecode), "optionArbitrary");
    optionPretty = /* @__PURE__ */ __name((value3) => match2({
      onNone: /* @__PURE__ */ __name(() => "none()", "onNone"),
      onSome: /* @__PURE__ */ __name((a) => `some(${value3(a)})`, "onSome")
    }), "optionPretty");
    optionParse = /* @__PURE__ */ __name((decodeUnknown3) => (u, options, ast) => isOption2(u) ? isNone2(u) ? succeed17(none2()) : toComposite(decodeUnknown3(u.value, options), some2, ast, u) : fail17(new Type2(ast, u)), "optionParse");
    OptionFromSelf_ = /* @__PURE__ */ __name((value3) => {
      return declare([value3], {
        decode: /* @__PURE__ */ __name((value4) => optionParse(decodeUnknown(value4)), "decode"),
        encode: /* @__PURE__ */ __name((value4) => optionParse(encodeUnknown(value4)), "encode")
      }, {
        typeConstructor: {
          _tag: "effect/Option"
        },
        pretty: optionPretty,
        arbitrary: optionArbitrary,
        equivalence: getEquivalence2
      });
    }, "OptionFromSelf_");
    OptionFromSelf = /* @__PURE__ */ __name((value3) => {
      return OptionFromSelf_(value3).annotations({
        description: `Option<${format6(value3)}>`
      });
    }, "OptionFromSelf");
    makeNoneEncoded = {
      _tag: "None"
    };
    makeSomeEncoded = /* @__PURE__ */ __name((value3) => ({
      _tag: "Some",
      value: value3
    }), "makeSomeEncoded");
    __name(Option, "Option");
    __name(OptionFromNullOr, "OptionFromNullOr");
    __name(OptionFromNullishOr, "OptionFromNullishOr");
    __name(OptionFromUndefinedOr, "OptionFromUndefinedOr");
    OptionFromNonEmptyTrimmedString = class extends (/* @__PURE__ */ transform2(String$, /* @__PURE__ */ OptionFromSelf(NonEmptyTrimmedString), {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => filter(some2(i.trim()), isNonEmpty6), "decode"),
      encode: /* @__PURE__ */ __name((a) => getOrElse(a, () => ""), "encode")
    })) {
      static {
        __name(this, "OptionFromNonEmptyTrimmedString");
      }
    };
    rightEncoded = /* @__PURE__ */ __name((right3) => Struct({
      _tag: Literal2("Right"),
      right: right3
    }).annotations({
      description: `RightEncoded<${format6(right3)}>`
    }), "rightEncoded");
    leftEncoded = /* @__PURE__ */ __name((left3) => Struct({
      _tag: Literal2("Left"),
      left: left3
    }).annotations({
      description: `LeftEncoded<${format6(left3)}>`
    }), "leftEncoded");
    eitherEncoded = /* @__PURE__ */ __name((right3, left3) => Union2(rightEncoded(right3), leftEncoded(left3)).annotations({
      description: `EitherEncoded<${format6(left3)}, ${format6(right3)}>`
    }), "eitherEncoded");
    eitherDecode = /* @__PURE__ */ __name((input) => input._tag === "Left" ? left2(input.left) : right2(input.right), "eitherDecode");
    eitherArbitrary = /* @__PURE__ */ __name((right3, left3) => (fc) => fc.oneof(fc.record({
      _tag: fc.constant("Left"),
      left: left3(fc)
    }), fc.record({
      _tag: fc.constant("Right"),
      right: right3(fc)
    })).map(eitherDecode), "eitherArbitrary");
    eitherPretty = /* @__PURE__ */ __name((right3, left3) => match({
      onLeft: /* @__PURE__ */ __name((e) => `left(${left3(e)})`, "onLeft"),
      onRight: /* @__PURE__ */ __name((a) => `right(${right3(a)})`, "onRight")
    }), "eitherPretty");
    eitherParse = /* @__PURE__ */ __name((parseRight, decodeUnknownLeft) => (u, options, ast) => isEither2(u) ? match(u, {
      onLeft: /* @__PURE__ */ __name((left3) => toComposite(decodeUnknownLeft(left3, options), left2, ast, u), "onLeft"),
      onRight: /* @__PURE__ */ __name((right3) => toComposite(parseRight(right3, options), right2, ast, u), "onRight")
    }) : fail17(new Type2(ast, u)), "eitherParse");
    EitherFromSelf = /* @__PURE__ */ __name(({
      left: left3,
      right: right3
    }) => {
      return declare([right3, left3], {
        decode: /* @__PURE__ */ __name((right4, left4) => eitherParse(decodeUnknown(right4), decodeUnknown(left4)), "decode"),
        encode: /* @__PURE__ */ __name((right4, left4) => eitherParse(encodeUnknown(right4), encodeUnknown(left4)), "encode")
      }, {
        typeConstructor: {
          _tag: "effect/Either"
        },
        description: `Either<${format6(right3)}, ${format6(left3)}>`,
        pretty: eitherPretty,
        arbitrary: eitherArbitrary,
        equivalence: /* @__PURE__ */ __name((right4, left4) => getEquivalence({
          left: left4,
          right: right4
        }), "equivalence")
      });
    }, "EitherFromSelf");
    makeLeftEncoded = /* @__PURE__ */ __name((left3) => ({
      _tag: "Left",
      left: left3
    }), "makeLeftEncoded");
    makeRightEncoded = /* @__PURE__ */ __name((right3) => ({
      _tag: "Right",
      right: right3
    }), "makeRightEncoded");
    Either2 = /* @__PURE__ */ __name(({
      left: left3,
      right: right3
    }) => {
      const right_ = asSchema(right3);
      const left_ = asSchema(left3);
      const out = transform2(eitherEncoded(right_, left_), EitherFromSelf({
        left: typeSchema(left_),
        right: typeSchema(right_)
      }), {
        strict: true,
        decode: /* @__PURE__ */ __name((i) => eitherDecode(i), "decode"),
        encode: /* @__PURE__ */ __name((a) => match(a, {
          onLeft: makeLeftEncoded,
          onRight: makeRightEncoded
        }), "encode")
      });
      return out;
    }, "Either");
    EitherFromUnion = /* @__PURE__ */ __name(({
      left: left3,
      right: right3
    }) => {
      const right_ = asSchema(right3);
      const left_ = asSchema(left3);
      const toright = typeSchema(right_);
      const toleft = typeSchema(left_);
      const fromRight = transform2(right_, rightEncoded(toright), {
        strict: true,
        decode: /* @__PURE__ */ __name((i) => makeRightEncoded(i), "decode"),
        encode: /* @__PURE__ */ __name((a) => a.right, "encode")
      });
      const fromLeft = transform2(left_, leftEncoded(toleft), {
        strict: true,
        decode: /* @__PURE__ */ __name((i) => makeLeftEncoded(i), "decode"),
        encode: /* @__PURE__ */ __name((a) => a.left, "encode")
      });
      const out = transform2(Union2(fromRight, fromLeft), EitherFromSelf({
        left: toleft,
        right: toright
      }), {
        strict: true,
        decode: /* @__PURE__ */ __name((i) => i._tag === "Left" ? left2(i.left) : right2(i.right), "decode"),
        encode: /* @__PURE__ */ __name((a) => match(a, {
          onLeft: makeLeftEncoded,
          onRight: makeRightEncoded
        }), "encode")
      });
      return out;
    }, "EitherFromUnion");
    mapArbitrary = /* @__PURE__ */ __name((key, value3, ctx) => {
      return (fc) => {
        const items = fc.array(fc.tuple(key(fc), value3(fc)));
        return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as12) => new Map(as12));
      };
    }, "mapArbitrary");
    readonlyMapPretty = /* @__PURE__ */ __name((key, value3) => (map31) => `new Map([${Array.from(map31.entries()).map(([k, v]) => `[${key(k)}, ${value3(v)}]`).join(", ")}])`, "readonlyMapPretty");
    readonlyMapEquivalence = /* @__PURE__ */ __name((key, value3) => {
      const arrayEquivalence = getEquivalence3(make(([ka, va], [kb, vb]) => key(ka, kb) && value3(va, vb)));
      return make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())));
    }, "readonlyMapEquivalence");
    readonlyMapParse = /* @__PURE__ */ __name((decodeUnknown3) => (u, options, ast) => isMap(u) ? toComposite(decodeUnknown3(Array.from(u.entries()), options), (as12) => new Map(as12), ast, u) : fail17(new Type2(ast, u)), "readonlyMapParse");
    mapFromSelf_ = /* @__PURE__ */ __name((key, value3, description) => declare([key, value3], {
      decode: /* @__PURE__ */ __name((Key2, Value2) => readonlyMapParse(decodeUnknown(Array$(Tuple(Key2, Value2)))), "decode"),
      encode: /* @__PURE__ */ __name((Key2, Value2) => readonlyMapParse(encodeUnknown(Array$(Tuple(Key2, Value2)))), "encode")
    }, {
      typeConstructor: {
        _tag: "ReadonlyMap"
      },
      description,
      pretty: readonlyMapPretty,
      arbitrary: mapArbitrary,
      equivalence: readonlyMapEquivalence
    }), "mapFromSelf_");
    ReadonlyMapFromSelf = /* @__PURE__ */ __name(({
      key,
      value: value3
    }) => mapFromSelf_(key, value3, `ReadonlyMap<${format6(key)}, ${format6(value3)}>`), "ReadonlyMapFromSelf");
    MapFromSelf = /* @__PURE__ */ __name(({
      key,
      value: value3
    }) => mapFromSelf_(key, value3, `Map<${format6(key)}, ${format6(value3)}>`), "MapFromSelf");
    __name(ReadonlyMap, "ReadonlyMap");
    __name(map27, "map");
    ReadonlyMapFromRecord = /* @__PURE__ */ __name(({
      key,
      value: value3
    }) => transform2(Record({
      key: encodedBoundSchema(key),
      value: value3
    }).annotations({
      description: "a record to be decoded into a ReadonlyMap"
    }), ReadonlyMapFromSelf({
      key,
      value: typeSchema(value3)
    }), {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => new Map(Object.entries(i)), "decode"),
      encode: /* @__PURE__ */ __name((a) => Object.fromEntries(a), "encode")
    }), "ReadonlyMapFromRecord");
    MapFromRecord = /* @__PURE__ */ __name(({
      key,
      value: value3
    }) => transform2(Record({
      key: encodedBoundSchema(key),
      value: value3
    }).annotations({
      description: "a record to be decoded into a Map"
    }), MapFromSelf({
      key,
      value: typeSchema(value3)
    }), {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => new Map(Object.entries(i)), "decode"),
      encode: /* @__PURE__ */ __name((a) => Object.fromEntries(a), "encode")
    }), "MapFromRecord");
    setArbitrary = /* @__PURE__ */ __name((item, ctx) => (fc) => {
      const items = fc.array(item(fc));
      return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as12) => new Set(as12));
    }, "setArbitrary");
    readonlySetPretty = /* @__PURE__ */ __name((item) => (set10) => `new Set([${Array.from(set10.values()).map((a) => item(a)).join(", ")}])`, "readonlySetPretty");
    readonlySetEquivalence = /* @__PURE__ */ __name((item) => {
      const arrayEquivalence = getEquivalence3(item);
      return make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())));
    }, "readonlySetEquivalence");
    readonlySetParse = /* @__PURE__ */ __name((decodeUnknown3) => (u, options, ast) => isSet(u) ? toComposite(decodeUnknown3(Array.from(u.values()), options), (as12) => new Set(as12), ast, u) : fail17(new Type2(ast, u)), "readonlySetParse");
    setFromSelf_ = /* @__PURE__ */ __name((value3, description) => declare([value3], {
      decode: /* @__PURE__ */ __name((item) => readonlySetParse(decodeUnknown(Array$(item))), "decode"),
      encode: /* @__PURE__ */ __name((item) => readonlySetParse(encodeUnknown(Array$(item))), "encode")
    }, {
      typeConstructor: {
        _tag: "ReadonlySet"
      },
      description,
      pretty: readonlySetPretty,
      arbitrary: setArbitrary,
      equivalence: readonlySetEquivalence
    }), "setFromSelf_");
    ReadonlySetFromSelf = /* @__PURE__ */ __name((value3) => setFromSelf_(value3, `ReadonlySet<${format6(value3)}>`), "ReadonlySetFromSelf");
    SetFromSelf = /* @__PURE__ */ __name((value3) => setFromSelf_(value3, `Set<${format6(value3)}>`), "SetFromSelf");
    __name(ReadonlySet, "ReadonlySet");
    __name(set8, "set");
    bigDecimalPretty = /* @__PURE__ */ __name(() => (val) => `BigDecimal(${format2(normalize(val))})`, "bigDecimalPretty");
    bigDecimalArbitrary = /* @__PURE__ */ __name(() => (fc) => fc.tuple(fc.bigInt(), fc.integer({
      min: -18,
      max: 18
    })).map(([value3, scale2]) => make4(value3, scale2)), "bigDecimalArbitrary");
    BigDecimalFromSelf = class extends (/* @__PURE__ */ declare(isBigDecimal, {
      typeConstructor: {
        _tag: "effect/BigDecimal"
      },
      identifier: "BigDecimalFromSelf",
      pretty: bigDecimalPretty,
      arbitrary: bigDecimalArbitrary,
      equivalence: /* @__PURE__ */ __name(() => Equivalence, "equivalence")
    })) {
      static {
        __name(this, "BigDecimalFromSelf");
      }
    };
    BigDecimal = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
      description: "a string to be decoded into a BigDecimal"
    }), BigDecimalFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i, _, ast) => fromString(i).pipe(match2({
        onNone: /* @__PURE__ */ __name(() => fail17(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a BigDecimal`)), "onNone"),
        onSome: /* @__PURE__ */ __name((val) => succeed17(normalize(val)), "onSome")
      })), "decode"),
      encode: /* @__PURE__ */ __name((a) => succeed17(format2(normalize(a))), "encode")
    }).annotations({
      identifier: "BigDecimal"
    })) {
      static {
        __name(this, "BigDecimal");
      }
    };
    BigDecimalFromNumber = class extends (/* @__PURE__ */ transform2(Number$.annotations({
      description: "a number to be decoded into a BigDecimal"
    }), BigDecimalFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => unsafeFromNumber(i), "decode"),
      encode: /* @__PURE__ */ __name((a) => unsafeToNumber(a), "encode")
    }).annotations({
      identifier: "BigDecimalFromNumber"
    })) {
      static {
        __name(this, "BigDecimalFromNumber");
      }
    };
    GreaterThanBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanBigDecimal");
    greaterThanBigDecimal = /* @__PURE__ */ __name((min4, annotations3) => (self2) => {
      const formatted = format2(min4);
      return self2.pipe(filter11((a) => greaterThan2(a, min4), {
        schemaId: GreaterThanBigDecimalSchemaId,
        [GreaterThanBigDecimalSchemaId]: {
          min: min4
        },
        title: `greaterThanBigDecimal(${formatted})`,
        description: `a BigDecimal greater than ${formatted}`,
        ...annotations3
      }));
    }, "greaterThanBigDecimal");
    GreaterThanOrEqualToBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/GreaterThanOrEqualToBigDecimal");
    greaterThanOrEqualToBigDecimal = /* @__PURE__ */ __name((min4, annotations3) => (self2) => {
      const formatted = format2(min4);
      return self2.pipe(filter11((a) => greaterThanOrEqualTo2(a, min4), {
        schemaId: GreaterThanOrEqualToBigDecimalSchemaId,
        [GreaterThanOrEqualToBigDecimalSchemaId]: {
          min: min4
        },
        title: `greaterThanOrEqualToBigDecimal(${formatted})`,
        description: `a BigDecimal greater than or equal to ${formatted}`,
        ...annotations3
      }));
    }, "greaterThanOrEqualToBigDecimal");
    LessThanBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanBigDecimal");
    lessThanBigDecimal = /* @__PURE__ */ __name((max6, annotations3) => (self2) => {
      const formatted = format2(max6);
      return self2.pipe(filter11((a) => lessThan2(a, max6), {
        schemaId: LessThanBigDecimalSchemaId,
        [LessThanBigDecimalSchemaId]: {
          max: max6
        },
        title: `lessThanBigDecimal(${formatted})`,
        description: `a BigDecimal less than ${formatted}`,
        ...annotations3
      }));
    }, "lessThanBigDecimal");
    LessThanOrEqualToBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/LessThanOrEqualToBigDecimal");
    lessThanOrEqualToBigDecimal = /* @__PURE__ */ __name((max6, annotations3) => (self2) => {
      const formatted = format2(max6);
      return self2.pipe(filter11((a) => lessThanOrEqualTo2(a, max6), {
        schemaId: LessThanOrEqualToBigDecimalSchemaId,
        [LessThanOrEqualToBigDecimalSchemaId]: {
          max: max6
        },
        title: `lessThanOrEqualToBigDecimal(${formatted})`,
        description: `a BigDecimal less than or equal to ${formatted}`,
        ...annotations3
      }));
    }, "lessThanOrEqualToBigDecimal");
    PositiveBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/PositiveBigDecimal");
    positiveBigDecimal = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter11((a) => isPositive(a), {
      schemaId: PositiveBigDecimalSchemaId,
      title: "positiveBigDecimal",
      description: `a positive BigDecimal`,
      ...annotations3
    })), "positiveBigDecimal");
    PositiveBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ positiveBigDecimal({
      identifier: "PositiveBigDecimalFromSelf"
    }));
    NonNegativeBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/NonNegativeBigDecimal");
    nonNegativeBigDecimal = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter11((a) => a.value >= 0n, {
      schemaId: NonNegativeBigDecimalSchemaId,
      title: "nonNegativeBigDecimal",
      description: `a non-negative BigDecimal`,
      ...annotations3
    })), "nonNegativeBigDecimal");
    NonNegativeBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ nonNegativeBigDecimal({
      identifier: "NonNegativeBigDecimalFromSelf"
    }));
    NegativeBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/NegativeBigDecimal");
    negativeBigDecimal = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter11((a) => isNegative(a), {
      schemaId: NegativeBigDecimalSchemaId,
      title: "negativeBigDecimal",
      description: `a negative BigDecimal`,
      ...annotations3
    })), "negativeBigDecimal");
    NegativeBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ negativeBigDecimal({
      identifier: "NegativeBigDecimalFromSelf"
    }));
    NonPositiveBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/NonPositiveBigDecimal");
    nonPositiveBigDecimal = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter11((a) => a.value <= 0n, {
      schemaId: NonPositiveBigDecimalSchemaId,
      title: "nonPositiveBigDecimal",
      description: `a non-positive BigDecimal`,
      ...annotations3
    })), "nonPositiveBigDecimal");
    NonPositiveBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ nonPositiveBigDecimal({
      identifier: "NonPositiveBigDecimalFromSelf"
    }));
    BetweenBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenBigDecimal");
    betweenBigDecimal = /* @__PURE__ */ __name((minimum, maximum, annotations3) => (self2) => {
      const formattedMinimum = format2(minimum);
      const formattedMaximum = format2(maximum);
      return self2.pipe(filter11((a) => between2(a, {
        minimum,
        maximum
      }), {
        schemaId: BetweenBigDecimalSchemaId,
        [BetweenBigDecimalSchemaId]: {
          maximum,
          minimum
        },
        title: `betweenBigDecimal(${formattedMinimum}, ${formattedMaximum})`,
        description: `a BigDecimal between ${formattedMinimum} and ${formattedMaximum}`,
        ...annotations3
      }));
    }, "betweenBigDecimal");
    clampBigDecimal = /* @__PURE__ */ __name((minimum, maximum) => (self2) => transform2(self2, self2.pipe(typeSchema, betweenBigDecimal(minimum, maximum)), {
      strict: false,
      decode: /* @__PURE__ */ __name((i) => clamp4(i, {
        minimum,
        maximum
      }), "decode"),
      encode: identity
    }), "clampBigDecimal");
    chunkArbitrary = /* @__PURE__ */ __name((item, ctx) => (fc) => {
      const items = fc.array(item(fc));
      return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable3);
    }, "chunkArbitrary");
    chunkPretty = /* @__PURE__ */ __name((item) => (c) => `Chunk(${toReadonlyArray(c).map(item).join(", ")})`, "chunkPretty");
    chunkParse = /* @__PURE__ */ __name((decodeUnknown3) => (u, options, ast) => isChunk(u) ? isEmpty(u) ? succeed17(empty5()) : toComposite(decodeUnknown3(toReadonlyArray(u), options), fromIterable3, ast, u) : fail17(new Type2(ast, u)), "chunkParse");
    ChunkFromSelf = /* @__PURE__ */ __name((value3) => {
      return declare([value3], {
        decode: /* @__PURE__ */ __name((item) => chunkParse(decodeUnknown(Array$(item))), "decode"),
        encode: /* @__PURE__ */ __name((item) => chunkParse(encodeUnknown(Array$(item))), "encode")
      }, {
        typeConstructor: {
          _tag: "effect/Chunk"
        },
        description: `Chunk<${format6(value3)}>`,
        pretty: chunkPretty,
        arbitrary: chunkArbitrary,
        equivalence: getEquivalence4
      });
    }, "ChunkFromSelf");
    __name(Chunk, "Chunk");
    nonEmptyChunkArbitrary = /* @__PURE__ */ __name((item) => (fc) => array3(item(fc), {
      minLength: 1
    }).map((as12) => unsafeFromNonEmptyArray(as12)), "nonEmptyChunkArbitrary");
    nonEmptyChunkPretty = /* @__PURE__ */ __name((item) => (c) => `NonEmptyChunk(${toReadonlyArray(c).map(item).join(", ")})`, "nonEmptyChunkPretty");
    nonEmptyChunkParse = /* @__PURE__ */ __name((decodeUnknown3) => (u, options, ast) => isChunk(u) && isNonEmpty2(u) ? toComposite(decodeUnknown3(toReadonlyArray(u), options), unsafeFromNonEmptyArray, ast, u) : fail17(new Type2(ast, u)), "nonEmptyChunkParse");
    NonEmptyChunkFromSelf = /* @__PURE__ */ __name((value3) => {
      return declare([value3], {
        decode: /* @__PURE__ */ __name((item) => nonEmptyChunkParse(decodeUnknown(NonEmptyArray(item))), "decode"),
        encode: /* @__PURE__ */ __name((item) => nonEmptyChunkParse(encodeUnknown(NonEmptyArray(item))), "encode")
      }, {
        typeConstructor: {
          _tag: "effect/Chunk.NonEmptyChunk"
        },
        description: `NonEmptyChunk<${format6(value3)}>`,
        pretty: nonEmptyChunkPretty,
        arbitrary: nonEmptyChunkArbitrary,
        equivalence: getEquivalence4
      });
    }, "NonEmptyChunkFromSelf");
    __name(NonEmptyChunk, "NonEmptyChunk");
    decodeData = /* @__PURE__ */ __name((a) => Array.isArray(a) ? array4(a) : struct2(a), "decodeData");
    dataArbitrary = /* @__PURE__ */ __name((item) => (fc) => item(fc).map(decodeData), "dataArbitrary");
    dataPretty = /* @__PURE__ */ __name((item) => (d) => `Data(${item(d)})`, "dataPretty");
    dataParse = /* @__PURE__ */ __name((decodeUnknown3) => (u, options, ast) => isEqual(u) ? toComposite(decodeUnknown3(u, options), decodeData, ast, u) : fail17(new Type2(ast, u)), "dataParse");
    DataFromSelf = /* @__PURE__ */ __name((value3) => {
      return declare([value3], {
        decode: /* @__PURE__ */ __name((item) => dataParse(decodeUnknown(item)), "decode"),
        encode: /* @__PURE__ */ __name((item) => dataParse(encodeUnknown(item)), "encode")
      }, {
        description: `Data<${format6(value3)}>`,
        pretty: dataPretty,
        arbitrary: dataArbitrary
      });
    }, "DataFromSelf");
    Data = /* @__PURE__ */ __name((value3) => {
      return transform2(value3, DataFromSelf(typeSchema(value3)), {
        strict: false,
        decode: /* @__PURE__ */ __name((i) => decodeData(i), "decode"),
        encode: /* @__PURE__ */ __name((a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a), "encode")
      });
    }, "Data");
    isField = /* @__PURE__ */ __name((u) => isSchema(u) || isPropertySignature(u), "isField");
    isFields = /* @__PURE__ */ __name((fields) => Reflect.ownKeys(fields).every((key) => isField(fields[key])), "isFields");
    getFields = /* @__PURE__ */ __name((hasFields) => "fields" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId]), "getFields");
    getSchemaFromFieldsOr = /* @__PURE__ */ __name((fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr)), "getSchemaFromFieldsOr");
    getFieldsFromFieldsOr = /* @__PURE__ */ __name((fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr), "getFieldsFromFieldsOr");
    Class6 = /* @__PURE__ */ __name((identifier2) => (fieldsOr, annotations3) => makeClass({
      kind: "Class",
      identifier: identifier2,
      schema: getSchemaFromFieldsOr(fieldsOr),
      fields: getFieldsFromFieldsOr(fieldsOr),
      Base: Class4,
      annotations: annotations3
    }), "Class");
    getClassTag = /* @__PURE__ */ __name((tag2) => withConstructorDefault(propertySignature(Literal2(tag2)), () => tag2), "getClassTag");
    TaggedClass2 = /* @__PURE__ */ __name((identifier2) => (tag2, fieldsOr, annotations3) => {
      const fields = getFieldsFromFieldsOr(fieldsOr);
      const schema = getSchemaFromFieldsOr(fieldsOr);
      const newFields = {
        _tag: getClassTag(tag2)
      };
      const taggedFields = extendFields(newFields, fields);
      return class TaggedClass extends makeClass({
        kind: "TaggedClass",
        identifier: identifier2 ?? tag2,
        schema: extend3(schema, Struct(newFields)),
        fields: taggedFields,
        Base: Class4,
        annotations: annotations3
      }) {
        static {
          __name(this, "TaggedClass");
        }
        static _tag = tag2;
      };
    }, "TaggedClass");
    TaggedError2 = /* @__PURE__ */ __name((identifier2) => (tag2, fieldsOr, annotations3) => {
      class Base3 extends Error3 {
        static {
          __name(this, "Base");
        }
      }
      ;
      Base3.prototype.name = tag2;
      const fields = getFieldsFromFieldsOr(fieldsOr);
      const schema = getSchemaFromFieldsOr(fieldsOr);
      const newFields = {
        _tag: getClassTag(tag2)
      };
      const taggedFields = extendFields(newFields, fields);
      const hasMessageField = "message" in taggedFields;
      class TaggedErrorClass extends makeClass({
        kind: "TaggedError",
        identifier: identifier2 ?? tag2,
        schema: extend3(schema, Struct(newFields)),
        fields: taggedFields,
        Base: Base3,
        annotations: annotations3,
        disableToString: true
      }) {
        static {
          __name(this, "TaggedErrorClass");
        }
        static _tag = tag2;
      }
      if (!hasMessageField) {
        Object.defineProperty(TaggedErrorClass.prototype, "message", {
          get() {
            return `{ ${Reflect.ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} }`;
          },
          enumerable: false,
          // mirrors the built-in Error.prototype.message, whose descriptor is also non-enumerable
          configurable: true
        });
      }
      return TaggedErrorClass;
    }, "TaggedError");
    extendFields = /* @__PURE__ */ __name((a, b) => {
      const out = {
        ...a
      };
      for (const key of Reflect.ownKeys(b)) {
        if (key in a) {
          throw new Error(getASTDuplicatePropertySignatureErrorMessage(key));
        }
        out[key] = b[key];
      }
      return out;
    }, "extendFields");
    __name(getDisableValidationMakeOption, "getDisableValidationMakeOption");
    astCache = /* @__PURE__ */ globalValue("effect/Schema/astCache", () => /* @__PURE__ */ new WeakMap());
    getClassAnnotations = /* @__PURE__ */ __name((annotations3) => {
      if (annotations3 === void 0) {
        return [];
      } else if (Array.isArray(annotations3)) {
        return annotations3;
      } else {
        return [annotations3];
      }
    }, "getClassAnnotations");
    makeClass = /* @__PURE__ */ __name(({
      Base: Base3,
      annotations: annotations3,
      disableToString,
      fields,
      identifier: identifier2,
      kind,
      schema
    }) => {
      const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier2}`);
      const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations3);
      const typeSchema_ = typeSchema(schema);
      const declarationSurrogate = typeSchema_.annotations({
        identifier: identifier2,
        ...typeAnnotations
      });
      const typeSide = typeSchema_.annotations({
        [AutoTitleAnnotationId]: `${identifier2} (Type side)`,
        ...typeAnnotations
      });
      const constructorSchema = schema.annotations({
        [AutoTitleAnnotationId]: `${identifier2} (Constructor)`,
        ...typeAnnotations
      });
      const encodedSide = schema.annotations({
        [AutoTitleAnnotationId]: `${identifier2} (Encoded side)`,
        ...encodedAnnotations
      });
      const transformationSurrogate = schema.annotations({
        ...encodedAnnotations,
        ...typeAnnotations,
        ...transformationAnnotations
      });
      const fallbackInstanceOf = /* @__PURE__ */ __name((u) => hasProperty(u, classSymbol) && is(typeSide)(u), "fallbackInstanceOf");
      const klass = class extends Base3 {
        static {
          __name(this, "klass");
        }
        constructor(props = {}, options = false) {
          props = {
            ...props
          };
          if (kind !== "Class") {
            delete props["_tag"];
          }
          props = lazilyMergeDefaults(fields, props);
          if (!getDisableValidationMakeOption(options)) {
            props = validateSync(constructorSchema)(props);
          }
          super(props, true);
        }
        // ----------------
        // Schema interface
        // ----------------
        static [TypeId29] = variance7;
        static get ast() {
          let out = astCache.get(this);
          if (out) {
            return out;
          }
          const declaration = declare([schema], {
            decode: /* @__PURE__ */ __name(() => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed17(input) : fail17(new Type2(ast, input)), "decode"),
            encode: /* @__PURE__ */ __name(() => (input, options) => input instanceof this ? succeed17(input) : map26(encodeUnknown(typeSide)(input, options), (props) => new this(props, true)), "encode")
          }, {
            identifier: identifier2,
            pretty: /* @__PURE__ */ __name((pretty4) => (self2) => `${identifier2}(${pretty4(self2)})`, "pretty"),
            // @ts-expect-error
            arbitrary: /* @__PURE__ */ __name((arb) => (fc) => arb(fc).map((props) => new this(props)), "arbitrary"),
            equivalence: identity,
            [SurrogateAnnotationId]: declarationSurrogate.ast,
            ...typeAnnotations
          });
          out = transform2(encodedSide, declaration, {
            strict: true,
            decode: /* @__PURE__ */ __name((i) => new this(i, true), "decode"),
            encode: identity
          }).annotations({
            [SurrogateAnnotationId]: transformationSurrogate.ast,
            ...transformationAnnotations
          }).ast;
          astCache.set(this, out);
          return out;
        }
        static pipe() {
          return pipeArguments(this, arguments);
        }
        static annotations(annotations4) {
          return make57(this.ast).annotations(annotations4);
        }
        static toString() {
          return `(${String(encodedSide)} <-> ${identifier2})`;
        }
        // ----------------
        // Class interface
        // ----------------
        static make(...args2) {
          return new this(...args2);
        }
        static fields = {
          ...fields
        };
        static identifier = identifier2;
        static extend(identifier3) {
          return (newFieldsOr, annotations4) => {
            const newFields = getFieldsFromFieldsOr(newFieldsOr);
            const newSchema = getSchemaFromFieldsOr(newFieldsOr);
            const extendedFields = extendFields(fields, newFields);
            return makeClass({
              kind,
              identifier: identifier3,
              schema: extend3(schema, newSchema),
              fields: extendedFields,
              Base: this,
              annotations: annotations4
            });
          };
        }
        static transformOrFail(identifier3) {
          return (newFieldsOr, options, annotations4) => {
            const transformedFields = extendFields(fields, newFieldsOr);
            return makeClass({
              kind,
              identifier: identifier3,
              schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options),
              fields: transformedFields,
              Base: this,
              annotations: annotations4
            });
          };
        }
        static transformOrFailFrom(identifier3) {
          return (newFields, options, annotations4) => {
            const transformedFields = extendFields(fields, newFields);
            return makeClass({
              kind,
              identifier: identifier3,
              schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options),
              fields: transformedFields,
              Base: this,
              annotations: annotations4
            });
          };
        }
        // ----------------
        // other
        // ----------------
        get [classSymbol]() {
          return classSymbol;
        }
      };
      if (disableToString !== true) {
        Object.defineProperty(klass.prototype, "toString", {
          value() {
            return `${identifier2}({ ${Reflect.ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} })`;
          },
          configurable: true,
          writable: true
        });
      }
      return klass;
    }, "makeClass");
    FiberIdNoneEncoded = /* @__PURE__ */ Struct({
      _tag: Literal2("None")
    }).annotations({
      identifier: "FiberIdNoneEncoded"
    });
    FiberIdRuntimeEncoded = /* @__PURE__ */ Struct({
      _tag: Literal2("Runtime"),
      id: Int,
      startTimeMillis: Int
    }).annotations({
      identifier: "FiberIdRuntimeEncoded"
    });
    FiberIdCompositeEncoded = /* @__PURE__ */ Struct({
      _tag: Literal2("Composite"),
      left: suspend12(() => FiberIdEncoded),
      right: suspend12(() => FiberIdEncoded)
    }).annotations({
      identifier: "FiberIdCompositeEncoded"
    });
    FiberIdEncoded = /* @__PURE__ */ Union2(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
      identifier: "FiberIdEncoded"
    });
    fiberIdArbitrary = /* @__PURE__ */ __name((fc) => fc.letrec((tie) => ({
      None: fc.record({
        _tag: fc.constant("None")
      }),
      Runtime: fc.record({
        _tag: fc.constant("Runtime"),
        id: fc.integer(),
        startTimeMillis: fc.integer()
      }),
      Composite: fc.record({
        _tag: fc.constant("Composite"),
        left: tie("FiberId"),
        right: tie("FiberId")
      }),
      FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
    })).FiberId.map(fiberIdDecode), "fiberIdArbitrary");
    fiberIdPretty = /* @__PURE__ */ __name((fiberId3) => {
      switch (fiberId3._tag) {
        case "None":
          return "FiberId.none";
        case "Runtime":
          return `FiberId.runtime(${fiberId3.id}, ${fiberId3.startTimeMillis})`;
        case "Composite":
          return `FiberId.composite(${fiberIdPretty(fiberId3.right)}, ${fiberIdPretty(fiberId3.left)})`;
      }
    }, "fiberIdPretty");
    FiberIdFromSelf = class extends (/* @__PURE__ */ declare(isFiberId2, {
      typeConstructor: {
        _tag: "effect/FiberId"
      },
      identifier: "FiberIdFromSelf",
      pretty: /* @__PURE__ */ __name(() => fiberIdPretty, "pretty"),
      arbitrary: /* @__PURE__ */ __name(() => fiberIdArbitrary, "arbitrary")
    })) {
      static {
        __name(this, "FiberIdFromSelf");
      }
    };
    fiberIdDecode = /* @__PURE__ */ __name((input) => {
      switch (input._tag) {
        case "None":
          return none4;
        case "Runtime":
          return runtime2(input.id, input.startTimeMillis);
        case "Composite":
          return composite2(fiberIdDecode(input.left), fiberIdDecode(input.right));
      }
    }, "fiberIdDecode");
    fiberIdEncode = /* @__PURE__ */ __name((input) => {
      switch (input._tag) {
        case "None":
          return {
            _tag: "None"
          };
        case "Runtime":
          return {
            _tag: "Runtime",
            id: input.id,
            startTimeMillis: input.startTimeMillis
          };
        case "Composite":
          return {
            _tag: "Composite",
            left: fiberIdEncode(input.left),
            right: fiberIdEncode(input.right)
          };
      }
    }, "fiberIdEncode");
    FiberId = class extends (/* @__PURE__ */ transform2(FiberIdEncoded, FiberIdFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => fiberIdDecode(i), "decode"),
      encode: /* @__PURE__ */ __name((a) => fiberIdEncode(a), "encode")
    }).annotations({
      identifier: "FiberId"
    })) {
      static {
        __name(this, "FiberId");
      }
    };
    causeDieEncoded = /* @__PURE__ */ __name((defect) => Struct({
      _tag: Literal2("Die"),
      defect
    }), "causeDieEncoded");
    CauseEmptyEncoded = /* @__PURE__ */ Struct({
      _tag: /* @__PURE__ */ Literal2("Empty")
    });
    causeFailEncoded = /* @__PURE__ */ __name((error50) => Struct({
      _tag: Literal2("Fail"),
      error: error50
    }), "causeFailEncoded");
    CauseInterruptEncoded = /* @__PURE__ */ Struct({
      _tag: /* @__PURE__ */ Literal2("Interrupt"),
      fiberId: FiberIdEncoded
    });
    causeEncodedId = 0;
    causeEncoded = /* @__PURE__ */ __name((error50, defect) => {
      const error_ = asSchema(error50);
      const defect_ = asSchema(defect);
      const suspended3 = suspend12(() => out);
      const out = Union2(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
        _tag: Literal2("Sequential"),
        left: suspended3,
        right: suspended3
      }), Struct({
        _tag: Literal2("Parallel"),
        left: suspended3,
        right: suspended3
      })).annotations({
        title: `CauseEncoded<${format6(error50)}>`,
        [JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
      });
      return out;
    }, "causeEncoded");
    causeArbitrary = /* @__PURE__ */ __name((error50, defect) => (fc) => fc.letrec((tie) => ({
      Empty: fc.record({
        _tag: fc.constant("Empty")
      }),
      Fail: fc.record({
        _tag: fc.constant("Fail"),
        error: error50(fc)
      }),
      Die: fc.record({
        _tag: fc.constant("Die"),
        defect: defect(fc)
      }),
      Interrupt: fc.record({
        _tag: fc.constant("Interrupt"),
        fiberId: fiberIdArbitrary(fc)
      }),
      Sequential: fc.record({
        _tag: fc.constant("Sequential"),
        left: tie("Cause"),
        right: tie("Cause")
      }),
      Parallel: fc.record({
        _tag: fc.constant("Parallel"),
        left: tie("Cause"),
        right: tie("Cause")
      }),
      Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
    })).Cause.map(causeDecode), "causeArbitrary");
    causePretty = /* @__PURE__ */ __name((error50) => (cause3) => {
      const f = /* @__PURE__ */ __name((cause4) => {
        switch (cause4._tag) {
          case "Empty":
            return "Cause.empty";
          case "Fail":
            return `Cause.fail(${error50(cause4.error)})`;
          case "Die":
            return `Cause.die(${pretty2(cause4)})`;
          case "Interrupt":
            return `Cause.interrupt(${fiberIdPretty(cause4.fiberId)})`;
          case "Sequential":
            return `Cause.sequential(${f(cause4.left)}, ${f(cause4.right)})`;
          case "Parallel":
            return `Cause.parallel(${f(cause4.left)}, ${f(cause4.right)})`;
        }
      }, "f");
      return f(cause3);
    }, "causePretty");
    causeParse = /* @__PURE__ */ __name((decodeUnknown3) => (u, options, ast) => isCause2(u) ? toComposite(decodeUnknown3(causeEncode(u), options), causeDecode, ast, u) : fail17(new Type2(ast, u)), "causeParse");
    CauseFromSelf = /* @__PURE__ */ __name(({
      defect,
      error: error50
    }) => {
      return declare([error50, defect], {
        decode: /* @__PURE__ */ __name((error51, defect2) => causeParse(decodeUnknown(causeEncoded(error51, defect2))), "decode"),
        encode: /* @__PURE__ */ __name((error51, defect2) => causeParse(encodeUnknown(causeEncoded(error51, defect2))), "encode")
      }, {
        typeConstructor: {
          _tag: "effect/Cause"
        },
        title: `Cause<${error50.ast}>`,
        pretty: causePretty,
        arbitrary: causeArbitrary
      });
    }, "CauseFromSelf");
    __name(causeDecode, "causeDecode");
    __name(causeEncode, "causeEncode");
    Cause = /* @__PURE__ */ __name(({
      defect,
      error: error50
    }) => {
      const error_ = asSchema(error50);
      const defect_ = asSchema(defect);
      const out = transform2(causeEncoded(error_, defect_), CauseFromSelf({
        error: typeSchema(error_),
        defect: typeSchema(defect_)
      }), {
        strict: false,
        decode: /* @__PURE__ */ __name((i) => causeDecode(i), "decode"),
        encode: /* @__PURE__ */ __name((a) => causeEncode(a), "encode")
      });
      return out;
    }, "Cause");
    Defect = class extends (/* @__PURE__ */ transform2(Unknown, Unknown, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => {
        if (isObject(i) && "message" in i && typeof i.message === "string") {
          const err = new Error(i.message, {
            cause: i
          });
          if ("name" in i && typeof i.name === "string") {
            err.name = i.name;
          }
          err.stack = "stack" in i && typeof i.stack === "string" ? i.stack : "";
          return err;
        }
        return prettyErrorMessage(i);
      }, "decode"),
      encode: /* @__PURE__ */ __name((a) => {
        if (a instanceof Error) {
          return {
            name: a.name,
            message: a.message
            // no stack because of security reasons
          };
        }
        return prettyErrorMessage(a);
      }, "encode")
    }).annotations({
      identifier: "Defect"
    })) {
      static {
        __name(this, "Defect");
      }
    };
    exitFailureEncoded = /* @__PURE__ */ __name((error50, defect) => Struct({
      _tag: Literal2("Failure"),
      cause: causeEncoded(error50, defect)
    }), "exitFailureEncoded");
    exitSuccessEncoded = /* @__PURE__ */ __name((value3) => Struct({
      _tag: Literal2("Success"),
      value: value3
    }), "exitSuccessEncoded");
    exitEncoded = /* @__PURE__ */ __name((value3, error50, defect) => {
      return Union2(exitFailureEncoded(error50, defect), exitSuccessEncoded(value3)).annotations({
        title: `ExitEncoded<${format6(value3)}, ${format6(error50)}, ${format6(defect)}>`
      });
    }, "exitEncoded");
    exitDecode = /* @__PURE__ */ __name((input) => {
      switch (input._tag) {
        case "Failure":
          return failCause3(causeDecode(input.cause));
        case "Success":
          return succeed3(input.value);
      }
    }, "exitDecode");
    exitArbitrary = /* @__PURE__ */ __name((value3, error50, defect) => (fc) => fc.oneof(fc.record({
      _tag: fc.constant("Failure"),
      cause: causeArbitrary(error50, defect)(fc)
    }), fc.record({
      _tag: fc.constant("Success"),
      value: value3(fc)
    })).map(exitDecode), "exitArbitrary");
    exitPretty = /* @__PURE__ */ __name((value3, error50) => (exit5) => exit5._tag === "Failure" ? `Exit.failCause(${causePretty(error50)(exit5.cause)})` : `Exit.succeed(${value3(exit5.value)})`, "exitPretty");
    exitParse = /* @__PURE__ */ __name((decodeUnknownValue, decodeUnknownCause) => (u, options, ast) => isExit(u) ? match6(u, {
      onFailure: /* @__PURE__ */ __name((cause3) => toComposite(decodeUnknownCause(cause3, options), failCause3, ast, u), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((value3) => toComposite(decodeUnknownValue(value3, options), succeed3, ast, u), "onSuccess")
    }) : fail17(new Type2(ast, u)), "exitParse");
    ExitFromSelf = /* @__PURE__ */ __name(({
      defect,
      failure,
      success: success2
    }) => declare([success2, failure, defect], {
      decode: /* @__PURE__ */ __name((success3, failure2, defect2) => exitParse(decodeUnknown(success3), decodeUnknown(CauseFromSelf({
        error: failure2,
        defect: defect2
      }))), "decode"),
      encode: /* @__PURE__ */ __name((success3, failure2, defect2) => exitParse(encodeUnknown(success3), encodeUnknown(CauseFromSelf({
        error: failure2,
        defect: defect2
      }))), "encode")
    }, {
      typeConstructor: {
        _tag: "effect/Exit"
      },
      title: `Exit<${success2.ast}, ${failure.ast}>`,
      pretty: exitPretty,
      arbitrary: exitArbitrary
    }), "ExitFromSelf");
    Exit = /* @__PURE__ */ __name(({
      defect,
      failure,
      success: success2
    }) => {
      const success_ = asSchema(success2);
      const failure_ = asSchema(failure);
      const defect_ = asSchema(defect);
      const out = transform2(exitEncoded(success_, failure_, defect_), ExitFromSelf({
        failure: typeSchema(failure_),
        success: typeSchema(success_),
        defect: typeSchema(defect_)
      }), {
        strict: false,
        decode: /* @__PURE__ */ __name((i) => exitDecode(i), "decode"),
        encode: /* @__PURE__ */ __name((a) => a._tag === "Failure" ? {
          _tag: "Failure",
          cause: a.cause
        } : {
          _tag: "Success",
          value: a.value
        }, "encode")
      });
      return out;
    }, "Exit");
    hashSetArbitrary = /* @__PURE__ */ __name((item, ctx) => (fc) => {
      const items = fc.array(item(fc));
      return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable6);
    }, "hashSetArbitrary");
    hashSetPretty = /* @__PURE__ */ __name((item) => (set10) => `HashSet(${Array.from(set10).map((a) => item(a)).join(", ")})`, "hashSetPretty");
    hashSetEquivalence = /* @__PURE__ */ __name((item) => {
      const arrayEquivalence = getEquivalence3(item);
      return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
    }, "hashSetEquivalence");
    hashSetParse = /* @__PURE__ */ __name((decodeUnknown3) => (u, options, ast) => isHashSet2(u) ? toComposite(decodeUnknown3(Array.from(u), options), fromIterable6, ast, u) : fail17(new Type2(ast, u)), "hashSetParse");
    HashSetFromSelf = /* @__PURE__ */ __name((value3) => {
      return declare([value3], {
        decode: /* @__PURE__ */ __name((item) => hashSetParse(decodeUnknown(Array$(item))), "decode"),
        encode: /* @__PURE__ */ __name((item) => hashSetParse(encodeUnknown(Array$(item))), "encode")
      }, {
        typeConstructor: {
          _tag: "effect/HashSet"
        },
        description: `HashSet<${format6(value3)}>`,
        pretty: hashSetPretty,
        arbitrary: hashSetArbitrary,
        equivalence: hashSetEquivalence
      });
    }, "HashSetFromSelf");
    __name(HashSet, "HashSet");
    hashMapArbitrary = /* @__PURE__ */ __name((key, value3, ctx) => (fc) => {
      const items = fc.array(fc.tuple(key(fc), value3(fc)));
      return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable7);
    }, "hashMapArbitrary");
    hashMapPretty = /* @__PURE__ */ __name((key, value3) => (map31) => `HashMap([${Array.from(map31).map(([k, v]) => `[${key(k)}, ${value3(v)}]`).join(", ")}])`, "hashMapPretty");
    hashMapEquivalence = /* @__PURE__ */ __name((key, value3) => {
      const arrayEquivalence = getEquivalence3(make(([ka, va], [kb, vb]) => key(ka, kb) && value3(va, vb)));
      return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
    }, "hashMapEquivalence");
    hashMapParse = /* @__PURE__ */ __name((decodeUnknown3) => (u, options, ast) => isHashMap2(u) ? toComposite(decodeUnknown3(Array.from(u), options), fromIterable7, ast, u) : fail17(new Type2(ast, u)), "hashMapParse");
    HashMapFromSelf = /* @__PURE__ */ __name(({
      key,
      value: value3
    }) => {
      return declare([key, value3], {
        decode: /* @__PURE__ */ __name((key2, value4) => hashMapParse(decodeUnknown(Array$(Tuple(key2, value4)))), "decode"),
        encode: /* @__PURE__ */ __name((key2, value4) => hashMapParse(encodeUnknown(Array$(Tuple(key2, value4)))), "encode")
      }, {
        typeConstructor: {
          _tag: "effect/HashMap"
        },
        description: `HashMap<${format6(key)}, ${format6(value3)}>`,
        pretty: hashMapPretty,
        arbitrary: hashMapArbitrary,
        equivalence: hashMapEquivalence
      });
    }, "HashMapFromSelf");
    HashMap = /* @__PURE__ */ __name(({
      key,
      value: value3
    }) => {
      return transform2(Array$(Tuple(key, value3)), HashMapFromSelf({
        key: typeSchema(asSchema(key)),
        value: typeSchema(asSchema(value3))
      }), {
        strict: true,
        decode: /* @__PURE__ */ __name((i) => fromIterable7(i), "decode"),
        encode: /* @__PURE__ */ __name((a) => Array.from(a), "encode")
      });
    }, "HashMap");
    listArbitrary = /* @__PURE__ */ __name((item, ctx) => (fc) => {
      const items = fc.array(item(fc));
      return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable8);
    }, "listArbitrary");
    listPretty = /* @__PURE__ */ __name((item) => (set10) => `List(${Array.from(set10).map((a) => item(a)).join(", ")})`, "listPretty");
    listEquivalence = /* @__PURE__ */ __name((item) => {
      const arrayEquivalence = getEquivalence3(item);
      return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
    }, "listEquivalence");
    listParse = /* @__PURE__ */ __name((decodeUnknown3) => (u, options, ast) => isList(u) ? toComposite(decodeUnknown3(Array.from(u), options), fromIterable8, ast, u) : fail17(new Type2(ast, u)), "listParse");
    ListFromSelf = /* @__PURE__ */ __name((value3) => {
      return declare([value3], {
        decode: /* @__PURE__ */ __name((item) => listParse(decodeUnknown(Array$(item))), "decode"),
        encode: /* @__PURE__ */ __name((item) => listParse(encodeUnknown(Array$(item))), "encode")
      }, {
        typeConstructor: {
          _tag: "effect/List"
        },
        description: `List<${format6(value3)}>`,
        pretty: listPretty,
        arbitrary: listArbitrary,
        equivalence: listEquivalence
      });
    }, "ListFromSelf");
    __name(List, "List");
    sortedSetArbitrary = /* @__PURE__ */ __name((item, ord, ctx) => (fc) => {
      const items = fc.array(item(fc));
      return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as12) => fromIterable12(as12, ord));
    }, "sortedSetArbitrary");
    sortedSetPretty = /* @__PURE__ */ __name((item) => (set10) => `new SortedSet([${Array.from(values3(set10)).map((a) => item(a)).join(", ")}])`, "sortedSetPretty");
    sortedSetParse = /* @__PURE__ */ __name((decodeUnknown3, ord) => (u, options, ast) => isSortedSet(u) ? toComposite(decodeUnknown3(Array.from(values3(u)), options), (as12) => fromIterable12(as12, ord), ast, u) : fail17(new Type2(ast, u)), "sortedSetParse");
    SortedSetFromSelf = /* @__PURE__ */ __name((value3, ordA, ordI) => {
      return declare([value3], {
        decode: /* @__PURE__ */ __name((item) => sortedSetParse(decodeUnknown(Array$(item)), ordA), "decode"),
        encode: /* @__PURE__ */ __name((item) => sortedSetParse(encodeUnknown(Array$(item)), ordI), "encode")
      }, {
        typeConstructor: {
          _tag: "effect/SortedSet"
        },
        description: `SortedSet<${format6(value3)}>`,
        pretty: sortedSetPretty,
        arbitrary: /* @__PURE__ */ __name((arb, ctx) => sortedSetArbitrary(arb, ordA, ctx), "arbitrary"),
        equivalence: /* @__PURE__ */ __name(() => getEquivalence6(), "equivalence")
      });
    }, "SortedSetFromSelf");
    __name(SortedSet, "SortedSet");
    BooleanFromUnknown = class extends (/* @__PURE__ */ transform2(Unknown, Boolean$, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => isTruthy(i), "decode"),
      encode: identity
    }).annotations({
      identifier: "BooleanFromUnknown"
    })) {
      static {
        __name(this, "BooleanFromUnknown");
      }
    };
    BooleanFromString = class extends (/* @__PURE__ */ transform2(Literal2("true", "false").annotations({
      description: "a string to be decoded into a boolean"
    }), Boolean$, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => i === "true", "decode"),
      encode: /* @__PURE__ */ __name((a) => a ? "true" : "false", "encode")
    }).annotations({
      identifier: "BooleanFromString"
    })) {
      static {
        __name(this, "BooleanFromString");
      }
    };
    Config = /* @__PURE__ */ __name((name, schema) => {
      const decodeUnknownEither3 = decodeUnknownEither(schema);
      return string4(name).pipe(mapOrFail2((s) => decodeUnknownEither3(s).pipe(mapLeft((error50) => InvalidData2([], TreeFormatter.formatIssueSync(error50))))));
    }, "Config");
    symbolSerializable = /* @__PURE__ */ Symbol.for("effect/Schema/Serializable/symbol");
    asSerializable = /* @__PURE__ */ __name((serializable) => serializable, "asSerializable");
    serializableSchema = /* @__PURE__ */ __name((self2) => self2[symbolSerializable], "serializableSchema");
    serialize = /* @__PURE__ */ __name((self2) => encodeUnknown2(self2[symbolSerializable])(self2), "serialize");
    deserialize = /* @__PURE__ */ dual(2, (self2, value3) => decodeUnknown2(self2[symbolSerializable])(value3));
    symbolWithResult = /* @__PURE__ */ Symbol.for("effect/Schema/Serializable/symbolResult");
    asWithResult = /* @__PURE__ */ __name((withExit) => withExit, "asWithResult");
    failureSchema = /* @__PURE__ */ __name((self2) => self2[symbolWithResult].failure, "failureSchema");
    successSchema = /* @__PURE__ */ __name((self2) => self2[symbolWithResult].success, "successSchema");
    exitSchemaCache = /* @__PURE__ */ globalValue("effect/Schema/Serializable/exitSchemaCache", () => /* @__PURE__ */ new WeakMap());
    exitSchema = /* @__PURE__ */ __name((self2) => {
      const proto14 = Object.getPrototypeOf(self2);
      if (!(symbolWithResult in proto14)) {
        return Exit({
          failure: failureSchema(self2),
          success: successSchema(self2),
          defect: Defect
        });
      }
      let schema = exitSchemaCache.get(proto14);
      if (schema === void 0) {
        schema = Exit({
          failure: failureSchema(self2),
          success: successSchema(self2),
          defect: Defect
        });
        exitSchemaCache.set(proto14, schema);
      }
      return schema;
    }, "exitSchema");
    serializeFailure = /* @__PURE__ */ dual(2, (self2, value3) => encode4(self2[symbolWithResult].failure)(value3));
    deserializeFailure = /* @__PURE__ */ dual(2, (self2, value3) => decodeUnknown2(self2[symbolWithResult].failure)(value3));
    serializeSuccess = /* @__PURE__ */ dual(2, (self2, value3) => encode4(self2[symbolWithResult].success)(value3));
    deserializeSuccess = /* @__PURE__ */ dual(2, (self2, value3) => decodeUnknown2(self2[symbolWithResult].success)(value3));
    serializeExit = /* @__PURE__ */ dual(2, (self2, value3) => encode4(exitSchema(self2))(value3));
    deserializeExit = /* @__PURE__ */ dual(2, (self2, value3) => decodeUnknown2(exitSchema(self2))(value3));
    asSerializableWithResult = /* @__PURE__ */ __name((procedure) => procedure, "asSerializableWithResult");
    TaggedRequest = /* @__PURE__ */ __name((identifier2) => (tag2, options, annotations3) => {
      const taggedFields = extendFields({
        _tag: getClassTag(tag2)
      }, options.payload);
      return class TaggedRequestClass extends makeClass({
        kind: "TaggedRequest",
        identifier: identifier2 ?? tag2,
        schema: Struct(taggedFields),
        fields: taggedFields,
        Base: Class5,
        annotations: annotations3
      }) {
        static {
          __name(this, "TaggedRequestClass");
        }
        static _tag = tag2;
        static success = options.success;
        static failure = options.failure;
        get [symbolSerializable]() {
          return this.constructor;
        }
        get [symbolWithResult]() {
          return {
            failure: options.failure,
            success: options.success
          };
        }
      };
    }, "TaggedRequest");
    equivalence2 = /* @__PURE__ */ __name((schema) => go2(schema.ast, []), "equivalence");
    getEquivalenceAnnotation = /* @__PURE__ */ getAnnotation(EquivalenceAnnotationId);
    go2 = /* @__PURE__ */ __name((ast, path) => {
      const hook = getEquivalenceAnnotation(ast);
      if (isSome2(hook)) {
        switch (ast._tag) {
          case "Declaration":
            return hook.value(...ast.typeParameters.map((tp) => go2(tp, path)));
          case "Refinement":
            return hook.value(go2(ast.from, path));
          default:
            return hook.value();
        }
      }
      switch (ast._tag) {
        case "NeverKeyword":
          throw new Error(getEquivalenceUnsupportedErrorMessage(ast, path));
        case "Transformation":
          return go2(ast.to, path);
        case "Declaration":
        case "Literal":
        case "StringKeyword":
        case "TemplateLiteral":
        case "UniqueSymbol":
        case "SymbolKeyword":
        case "UnknownKeyword":
        case "AnyKeyword":
        case "NumberKeyword":
        case "BooleanKeyword":
        case "BigIntKeyword":
        case "UndefinedKeyword":
        case "VoidKeyword":
        case "Enums":
        case "ObjectKeyword":
          return equals;
        case "Refinement":
          return go2(ast.from, path);
        case "Suspend": {
          const get18 = memoizeThunk(() => go2(ast.f(), path));
          return (a, b) => get18()(a, b);
        }
        case "TupleType": {
          const elements = ast.elements.map((element2, i) => go2(element2.type, path.concat(i)));
          const rest = ast.rest.map((annotatedAST) => go2(annotatedAST.type, path));
          return make((a, b) => {
            if (!Array.isArray(a) || !Array.isArray(b)) {
              return false;
            }
            const len = a.length;
            if (len !== b.length) {
              return false;
            }
            let i = 0;
            for (; i < Math.min(len, ast.elements.length); i++) {
              if (!elements[i](a[i], b[i])) {
                return false;
              }
            }
            if (isNonEmptyReadonlyArray(rest)) {
              const [head7, ...tail] = rest;
              for (; i < len - tail.length; i++) {
                if (!head7(a[i], b[i])) {
                  return false;
                }
              }
              for (let j = 0; j < tail.length; j++) {
                i += j;
                if (!tail[j](a[i], b[i])) {
                  return false;
                }
              }
            }
            return true;
          });
        }
        case "TypeLiteral": {
          if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
            return equals;
          }
          const propertySignatures = ast.propertySignatures.map((ps) => go2(ps.type, path.concat(ps.name)));
          const indexSignatures = ast.indexSignatures.map((is3) => go2(is3.type, path));
          return make((a, b) => {
            if (!isRecord(a) || !isRecord(b)) {
              return false;
            }
            const aStringKeys = Object.keys(a);
            const aSymbolKeys = Object.getOwnPropertySymbols(a);
            for (let i = 0; i < propertySignatures.length; i++) {
              const ps = ast.propertySignatures[i];
              const name = ps.name;
              const aHas = Object.prototype.hasOwnProperty.call(a, name);
              const bHas = Object.prototype.hasOwnProperty.call(b, name);
              if (ps.isOptional) {
                if (aHas !== bHas) {
                  return false;
                }
              }
              if (aHas && bHas && !propertySignatures[i](a[name], b[name])) {
                return false;
              }
            }
            let bSymbolKeys;
            let bStringKeys;
            for (let i = 0; i < indexSignatures.length; i++) {
              const is3 = ast.indexSignatures[i];
              const encodedParameter = getEncodedParameter(is3.parameter);
              const isSymbol2 = isSymbolKeyword(encodedParameter);
              if (isSymbol2) {
                bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b);
                if (aSymbolKeys.length !== bSymbolKeys.length) {
                  return false;
                }
              } else {
                bStringKeys = bStringKeys || Object.keys(b);
                if (aStringKeys.length !== bStringKeys.length) {
                  return false;
                }
              }
              const aKeys = isSymbol2 ? aSymbolKeys : aStringKeys;
              for (let j = 0; j < aKeys.length; j++) {
                const key = aKeys[j];
                if (!Object.prototype.hasOwnProperty.call(b, key) || !indexSignatures[i](a[key], b[key])) {
                  return false;
                }
              }
            }
            return true;
          });
        }
        case "Union": {
          const searchTree = getSearchTree(ast.types, true);
          const ownKeys = Reflect.ownKeys(searchTree.keys);
          const len = ownKeys.length;
          return make((a, b) => {
            let candidates = [];
            if (len > 0 && isRecordOrArray(a)) {
              for (let i = 0; i < len; i++) {
                const name = ownKeys[i];
                const buckets = searchTree.keys[name].buckets;
                if (Object.prototype.hasOwnProperty.call(a, name)) {
                  const literal3 = String(a[name]);
                  if (Object.prototype.hasOwnProperty.call(buckets, literal3)) {
                    candidates = candidates.concat(buckets[literal3]);
                  }
                }
              }
            }
            if (searchTree.otherwise.length > 0) {
              candidates = candidates.concat(searchTree.otherwise);
            }
            const tuples = candidates.map((ast2) => [go2(ast2, path), is({
              ast: ast2
            })]);
            for (let i = 0; i < tuples.length; i++) {
              const [equivalence3, is3] = tuples[i];
              if (is3(a) && is3(b)) {
                if (equivalence3(a, b)) {
                  return true;
                }
              }
            }
            return false;
          });
        }
      }
    }, "go");
    SymbolStruct = /* @__PURE__ */ TaggedStruct("symbol", {
      key: String$
    }).annotations({
      description: "an object to be decoded into a globally shared symbol"
    });
    SymbolFromStruct = /* @__PURE__ */ transformOrFail(SymbolStruct, SymbolFromSelf, {
      strict: true,
      decode: /* @__PURE__ */ __name((i) => decodeSymbol(i.key), "decode"),
      encode: /* @__PURE__ */ __name((a, _, ast) => map26(encodeSymbol2(a, ast), (key) => SymbolStruct.make({
        key
      })), "encode")
    });
    PropertyKey$ = class extends (/* @__PURE__ */ Union2(String$, Number$, SymbolFromStruct).annotations({
      identifier: "PropertyKey"
    })) {
      static {
        __name(this, "PropertyKey$");
      }
    };
    ArrayFormatterIssue = class extends (/* @__PURE__ */ Struct({
      _tag: propertySignature(Literal2("Pointer", "Unexpected", "Missing", "Composite", "Refinement", "Transformation", "Type", "Forbidden")).annotations({
        description: "The tag identifying the type of parse issue"
      }),
      path: propertySignature(Array$(PropertyKey$)).annotations({
        description: "The path to the property where the issue occurred"
      }),
      message: propertySignature(String$).annotations({
        description: "A descriptive message explaining the issue"
      })
    }).annotations({
      identifier: "ArrayFormatterIssue",
      description: "Represents an issue returned by the ArrayFormatter formatter"
    })) {
      static {
        __name(this, "ArrayFormatterIssue");
      }
    };
  }
});

// node_modules/effect/dist/esm/ScopedCache.js
var init_ScopedCache = __esm({
  "node_modules/effect/dist/esm/ScopedCache.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/ScopedRef.js
var init_ScopedRef = __esm({
  "node_modules/effect/dist/esm/ScopedRef.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Secret.js
var init_Secret = __esm({
  "node_modules/effect/dist/esm/Secret.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/SingleProducerAsyncInput.js
var init_SingleProducerAsyncInput = __esm({
  "node_modules/effect/dist/esm/SingleProducerAsyncInput.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Sink.js
var init_Sink = __esm({
  "node_modules/effect/dist/esm/Sink.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/SortedMap.js
var TypeId30, SortedMapProto, isSortedMap;
var init_SortedMap = __esm({
  "node_modules/effect/dist/esm/SortedMap.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Equal();
    init_Function();
    init_Hash();
    init_Inspectable();
    init_Pipeable();
    init_Predicate();
    TypeId30 = /* @__PURE__ */ Symbol.for("effect/SortedMap");
    SortedMapProto = {
      [TypeId30]: {
        _K: /* @__PURE__ */ __name((_) => _, "_K"),
        _V: /* @__PURE__ */ __name((_) => _, "_V")
      },
      [symbol]() {
        return pipe(hash(this.tree), combine(hash("effect/SortedMap")), cached(this));
      },
      [symbol2](that) {
        return isSortedMap(that) && equals(this.tree, that.tree);
      },
      [Symbol.iterator]() {
        return this.tree[Symbol.iterator]();
      },
      toString() {
        return format(this.toJSON());
      },
      toJSON() {
        return {
          _id: "SortedMap",
          values: Array.from(this).map(toJSON)
        };
      },
      [NodeInspectSymbol]() {
        return this.toJSON();
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
    isSortedMap = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId30), "isSortedMap");
  }
});

// node_modules/effect/dist/esm/Stream.js
var Stream_exports = {};
__export(Stream_exports, {
  DefaultChunkSize: () => DefaultChunkSize2,
  Do: () => Do5,
  StreamTypeId: () => StreamTypeId3,
  accumulate: () => accumulate2,
  accumulateChunks: () => accumulateChunks2,
  acquireRelease: () => acquireRelease4,
  aggregate: () => aggregate2,
  aggregateWithin: () => aggregateWithin2,
  aggregateWithinEither: () => aggregateWithinEither2,
  as: () => as11,
  async: () => _async2,
  asyncEffect: () => asyncEffect4,
  asyncPush: () => asyncPush2,
  asyncScoped: () => asyncScoped2,
  bind: () => bind6,
  bindEffect: () => bindEffect2,
  bindTo: () => bindTo6,
  branchAfter: () => branchAfter2,
  broadcast: () => broadcast2,
  broadcastDynamic: () => broadcastDynamic2,
  broadcastedQueues: () => broadcastedQueues2,
  broadcastedQueuesDynamic: () => broadcastedQueuesDynamic2,
  buffer: () => buffer2,
  bufferChunks: () => bufferChunks2,
  catchAll: () => catchAll8,
  catchAllCause: () => catchAllCause7,
  catchSome: () => catchSome4,
  catchSomeCause: () => catchSomeCause4,
  catchTag: () => catchTag4,
  catchTags: () => catchTags4,
  changes: () => changes2,
  changesWith: () => changesWith2,
  changesWithEffect: () => changesWithEffect2,
  chunks: () => chunks2,
  chunksWith: () => chunksWith2,
  combine: () => combine10,
  combineChunks: () => combineChunks2,
  concat: () => concat3,
  concatAll: () => concatAll3,
  context: () => context8,
  contextWith: () => contextWith4,
  contextWithEffect: () => contextWithEffect4,
  contextWithStream: () => contextWithStream2,
  cross: () => cross2,
  crossLeft: () => crossLeft2,
  crossRight: () => crossRight2,
  crossWith: () => crossWith2,
  debounce: () => debounce2,
  decodeText: () => decodeText2,
  die: () => die11,
  dieMessage: () => dieMessage5,
  dieSync: () => dieSync7,
  distributedWith: () => distributedWith2,
  distributedWithDynamic: () => distributedWithDynamic2,
  drain: () => drain4,
  drainFork: () => drainFork2,
  drop: () => drop4,
  dropRight: () => dropRight2,
  dropUntil: () => dropUntil4,
  dropUntilEffect: () => dropUntilEffect2,
  dropWhile: () => dropWhile5,
  dropWhileEffect: () => dropWhileEffect2,
  either: () => either7,
  empty: () => empty35,
  encodeText: () => encodeText2,
  ensuring: () => ensuring8,
  ensuringWith: () => ensuringWith3,
  execute: () => execute2,
  fail: () => fail18,
  failCause: () => failCause14,
  failCauseSync: () => failCauseSync7,
  failSync: () => failSync8,
  filter: () => filter12,
  filterEffect: () => filterEffect3,
  filterMap: () => filterMap8,
  filterMapEffect: () => filterMapEffect2,
  filterMapWhile: () => filterMapWhile4,
  filterMapWhileEffect: () => filterMapWhileEffect2,
  finalizer: () => finalizer2,
  find: () => find3,
  findEffect: () => findEffect2,
  flatMap: () => flatMap18,
  flatten: () => flatten15,
  flattenChunks: () => flattenChunks2,
  flattenEffect: () => flattenEffect2,
  flattenExitOption: () => flattenExitOption2,
  flattenIterables: () => flattenIterables2,
  flattenTake: () => flattenTake2,
  forever: () => forever6,
  fromAsyncIterable: () => fromAsyncIterable2,
  fromChannel: () => fromChannel3,
  fromChunk: () => fromChunk2,
  fromChunkPubSub: () => fromChunkPubSub2,
  fromChunkQueue: () => fromChunkQueue2,
  fromChunks: () => fromChunks2,
  fromEffect: () => fromEffect8,
  fromEffectOption: () => fromEffectOption2,
  fromEventListener: () => fromEventListener2,
  fromIterable: () => fromIterable15,
  fromIterableEffect: () => fromIterableEffect2,
  fromIteratorSucceed: () => fromIteratorSucceed2,
  fromPubSub: () => fromPubSub2,
  fromPull: () => fromPull3,
  fromQueue: () => fromQueue3,
  fromReadableStream: () => fromReadableStream2,
  fromReadableStreamByob: () => fromReadableStreamByob2,
  fromSchedule: () => fromSchedule2,
  fromTPubSub: () => fromTPubSub2,
  fromTQueue: () => fromTQueue2,
  groupAdjacentBy: () => groupAdjacentBy2,
  groupBy: () => groupBy2,
  groupByKey: () => groupByKey2,
  grouped: () => grouped2,
  groupedWithin: () => groupedWithin2,
  haltAfter: () => haltAfter2,
  haltWhen: () => haltWhen2,
  haltWhenDeferred: () => haltWhenDeferred2,
  identity: () => identity5,
  interleave: () => interleave2,
  interleaveWith: () => interleaveWith2,
  interruptAfter: () => interruptAfter2,
  interruptWhen: () => interruptWhen3,
  interruptWhenDeferred: () => interruptWhenDeferred3,
  intersperse: () => intersperse2,
  intersperseAffixes: () => intersperseAffixes2,
  iterate: () => iterate4,
  let: () => let_6,
  make: () => make58,
  map: () => map28,
  mapAccum: () => mapAccum6,
  mapAccumEffect: () => mapAccumEffect2,
  mapBoth: () => mapBoth9,
  mapChunks: () => mapChunks2,
  mapChunksEffect: () => mapChunksEffect2,
  mapConcat: () => mapConcat2,
  mapConcatChunk: () => mapConcatChunk2,
  mapConcatChunkEffect: () => mapConcatChunkEffect2,
  mapConcatEffect: () => mapConcatEffect2,
  mapEffect: () => mapEffect5,
  mapError: () => mapError8,
  mapErrorCause: () => mapErrorCause5,
  mapInputContext: () => mapInputContext7,
  merge: () => merge10,
  mergeAll: () => mergeAll9,
  mergeEither: () => mergeEither2,
  mergeLeft: () => mergeLeft2,
  mergeRight: () => mergeRight2,
  mergeWith: () => mergeWith4,
  mergeWithTag: () => mergeWithTag2,
  mkString: () => mkString3,
  never: () => never5,
  onDone: () => onDone2,
  onEnd: () => onEnd2,
  onError: () => onError4,
  onStart: () => onStart2,
  orDie: () => orDie6,
  orDieWith: () => orDieWith5,
  orElse: () => orElse11,
  orElseEither: () => orElseEither5,
  orElseFail: () => orElseFail4,
  orElseIfEmpty: () => orElseIfEmpty2,
  orElseIfEmptyChunk: () => orElseIfEmptyChunk2,
  orElseIfEmptyStream: () => orElseIfEmptyStream2,
  orElseSucceed: () => orElseSucceed4,
  paginate: () => paginate2,
  paginateChunk: () => paginateChunk2,
  paginateChunkEffect: () => paginateChunkEffect2,
  paginateEffect: () => paginateEffect2,
  partition: () => partition6,
  partitionEither: () => partitionEither2,
  peel: () => peel2,
  pipeThrough: () => pipeThrough2,
  pipeThroughChannel: () => pipeThroughChannel2,
  pipeThroughChannelOrFail: () => pipeThroughChannelOrFail2,
  prepend: () => prepend5,
  provideContext: () => provideContext7,
  provideLayer: () => provideLayer2,
  provideService: () => provideService7,
  provideServiceEffect: () => provideServiceEffect4,
  provideServiceStream: () => provideServiceStream2,
  provideSomeContext: () => provideSomeContext3,
  provideSomeLayer: () => provideSomeLayer3,
  race: () => race4,
  raceAll: () => raceAll4,
  range: () => range3,
  rechunk: () => rechunk2,
  refineOrDie: () => refineOrDie2,
  refineOrDieWith: () => refineOrDieWith2,
  repeat: () => repeat4,
  repeatEffect: () => repeatEffect2,
  repeatEffectChunk: () => repeatEffectChunk2,
  repeatEffectChunkOption: () => repeatEffectChunkOption2,
  repeatEffectOption: () => repeatEffectOption2,
  repeatEffectWithSchedule: () => repeatEffectWithSchedule2,
  repeatEither: () => repeatEither2,
  repeatElements: () => repeatElements2,
  repeatElementsWith: () => repeatElementsWith2,
  repeatValue: () => repeatValue2,
  repeatWith: () => repeatWith2,
  retry: () => retry7,
  run: () => run5,
  runCollect: () => runCollect2,
  runCount: () => runCount2,
  runDrain: () => runDrain3,
  runFold: () => runFold2,
  runFoldEffect: () => runFoldEffect2,
  runFoldScoped: () => runFoldScoped2,
  runFoldScopedEffect: () => runFoldScopedEffect2,
  runFoldWhile: () => runFoldWhile2,
  runFoldWhileEffect: () => runFoldWhileEffect2,
  runFoldWhileScoped: () => runFoldWhileScoped2,
  runFoldWhileScopedEffect: () => runFoldWhileScopedEffect2,
  runForEach: () => runForEach2,
  runForEachChunk: () => runForEachChunk2,
  runForEachChunkScoped: () => runForEachChunkScoped2,
  runForEachScoped: () => runForEachScoped2,
  runForEachWhile: () => runForEachWhile2,
  runForEachWhileScoped: () => runForEachWhileScoped2,
  runHead: () => runHead2,
  runIntoPubSub: () => runIntoPubSub2,
  runIntoPubSubScoped: () => runIntoPubSubScoped2,
  runIntoQueue: () => runIntoQueue2,
  runIntoQueueElementsScoped: () => runIntoQueueElementsScoped2,
  runIntoQueueScoped: () => runIntoQueueScoped2,
  runLast: () => runLast2,
  runScoped: () => runScoped3,
  runSum: () => runSum2,
  scan: () => scan2,
  scanEffect: () => scanEffect2,
  scanReduce: () => scanReduce2,
  scanReduceEffect: () => scanReduceEffect2,
  schedule: () => schedule3,
  scheduleWith: () => scheduleWith2,
  scoped: () => scoped6,
  scopedWith: () => scopedWith5,
  share: () => share2,
  sliding: () => sliding8,
  slidingSize: () => slidingSize2,
  some: () => some6,
  someOrElse: () => someOrElse2,
  someOrFail: () => someOrFail2,
  split: () => split3,
  splitLines: () => splitLines3,
  splitOnChunk: () => splitOnChunk2,
  succeed: () => succeed18,
  suspend: () => suspend13,
  sync: () => sync12,
  take: () => take8,
  takeRight: () => takeRight3,
  takeUntil: () => takeUntil4,
  takeUntilEffect: () => takeUntilEffect2,
  takeWhile: () => takeWhile5,
  tap: () => tap8,
  tapBoth: () => tapBoth4,
  tapError: () => tapError6,
  tapErrorCause: () => tapErrorCause6,
  tapSink: () => tapSink2,
  throttle: () => throttle2,
  throttleEffect: () => throttleEffect2,
  tick: () => tick2,
  timeout: () => timeout4,
  timeoutFail: () => timeoutFail4,
  timeoutFailCause: () => timeoutFailCause4,
  timeoutTo: () => timeoutTo4,
  toAsyncIterable: () => toAsyncIterable2,
  toAsyncIterableEffect: () => toAsyncIterableEffect2,
  toAsyncIterableRuntime: () => toAsyncIterableRuntime2,
  toChannel: () => toChannel3,
  toPubSub: () => toPubSub3,
  toPull: () => toPull3,
  toQueue: () => toQueue3,
  toQueueOfElements: () => toQueueOfElements2,
  toReadableStream: () => toReadableStream2,
  toReadableStreamEffect: () => toReadableStreamEffect2,
  toReadableStreamRuntime: () => toReadableStreamRuntime2,
  transduce: () => transduce2,
  unfold: () => unfold5,
  unfoldChunk: () => unfoldChunk2,
  unfoldChunkEffect: () => unfoldChunkEffect2,
  unfoldEffect: () => unfoldEffect2,
  unwrap: () => unwrap4,
  unwrapScoped: () => unwrapScoped5,
  unwrapScopedWith: () => unwrapScopedWith4,
  updateService: () => updateService5,
  void: () => void_9,
  when: () => when4,
  whenCase: () => whenCase2,
  whenCaseEffect: () => whenCaseEffect2,
  whenEffect: () => whenEffect4,
  withExecutionPlan: () => withExecutionPlan4,
  withSpan: () => withSpan7,
  zip: () => zip9,
  zipAll: () => zipAll2,
  zipAllLeft: () => zipAllLeft2,
  zipAllRight: () => zipAllRight2,
  zipAllSortedByKey: () => zipAllSortedByKey2,
  zipAllSortedByKeyLeft: () => zipAllSortedByKeyLeft2,
  zipAllSortedByKeyRight: () => zipAllSortedByKeyRight2,
  zipAllSortedByKeyWith: () => zipAllSortedByKeyWith2,
  zipAllWith: () => zipAllWith2,
  zipFlatten: () => zipFlatten2,
  zipLatest: () => zipLatest2,
  zipLatestAll: () => zipLatestAll2,
  zipLatestWith: () => zipLatestWith2,
  zipLeft: () => zipLeft8,
  zipRight: () => zipRight11,
  zipWith: () => zipWith14,
  zipWithChunks: () => zipWithChunks2,
  zipWithIndex: () => zipWithIndex2,
  zipWithNext: () => zipWithNext2,
  zipWithPrevious: () => zipWithPrevious2,
  zipWithPreviousAndNext: () => zipWithPreviousAndNext2
});
var StreamTypeId3, DefaultChunkSize2, accumulate2, accumulateChunks2, acquireRelease4, aggregate2, aggregateWithin2, aggregateWithinEither2, as11, _async2, asyncEffect4, asyncPush2, asyncScoped2, branchAfter2, broadcast2, share2, broadcastDynamic2, broadcastedQueues2, broadcastedQueuesDynamic2, buffer2, bufferChunks2, catchAll8, catchAllCause7, catchSome4, catchTag4, catchTags4, catchSomeCause4, changes2, changesWith2, changesWithEffect2, chunks2, chunksWith2, combine10, combineChunks2, concat3, concatAll3, cross2, crossLeft2, crossRight2, crossWith2, debounce2, die11, dieSync7, dieMessage5, distributedWith2, distributedWithDynamic2, drain4, drainFork2, drop4, dropRight2, dropUntil4, dropUntilEffect2, dropWhile5, dropWhileEffect2, either7, empty35, ensuring8, ensuringWith3, context8, contextWith4, contextWithEffect4, contextWithStream2, execute2, fail18, failSync8, failCause14, failCauseSync7, filter12, filterEffect3, filterMap8, filterMapEffect2, filterMapWhile4, filterMapWhileEffect2, finalizer2, find3, findEffect2, flatMap18, flatten15, flattenChunks2, flattenEffect2, flattenExitOption2, flattenIterables2, flattenTake2, forever6, fromAsyncIterable2, fromChannel3, toChannel3, fromChunk2, fromChunkPubSub2, fromChunkQueue2, fromChunks2, fromEffect8, fromEffectOption2, fromPubSub2, fromTPubSub2, fromIterable15, fromIterableEffect2, fromIteratorSucceed2, fromPull3, fromQueue3, fromTQueue2, fromReadableStream2, fromReadableStreamByob2, fromSchedule2, groupAdjacentBy2, groupBy2, groupByKey2, grouped2, groupedWithin2, haltAfter2, haltWhen2, haltWhenDeferred2, identity5, interleave2, interleaveWith2, intersperse2, intersperseAffixes2, interruptAfter2, interruptWhen3, interruptWhenDeferred3, iterate4, make58, map28, mapAccum6, mapAccumEffect2, mapBoth9, mapChunks2, mapChunksEffect2, mapConcat2, mapConcatChunk2, mapConcatChunkEffect2, mapConcatEffect2, mapEffect5, mapError8, mapErrorCause5, merge10, mergeAll9, mergeWithTag2, mergeWith4, mergeEither2, mergeLeft2, mergeRight2, mkString3, never5, onEnd2, onError4, onDone2, onStart2, orDie6, orDieWith5, orElse11, orElseEither5, orElseFail4, orElseIfEmpty2, orElseIfEmptyChunk2, orElseIfEmptyStream2, orElseSucceed4, paginate2, paginateChunk2, paginateChunkEffect2, paginateEffect2, partition6, partitionEither2, peel2, pipeThrough2, pipeThroughChannel2, pipeThroughChannelOrFail2, prepend5, provideContext7, provideSomeContext3, provideLayer2, provideService7, provideServiceEffect4, provideServiceStream2, mapInputContext7, provideSomeLayer3, race4, raceAll4, range3, rechunk2, refineOrDie2, refineOrDieWith2, repeat4, repeatEffect2, repeatEffectChunk2, repeatEffectChunkOption2, repeatEffectOption2, repeatEffectWithSchedule2, repeatEither2, repeatElements2, repeatElementsWith2, repeatValue2, repeatWith2, retry7, withExecutionPlan4, run5, runCollect2, runCount2, runDrain3, runFold2, runFoldEffect2, runFoldScoped2, runFoldScopedEffect2, runFoldWhile2, runFoldWhileEffect2, runFoldWhileScoped2, runFoldWhileScopedEffect2, runForEach2, runForEachChunk2, runForEachChunkScoped2, runForEachScoped2, runForEachWhile2, runForEachWhileScoped2, runHead2, runIntoPubSub2, runIntoPubSubScoped2, runIntoQueue2, runIntoQueueElementsScoped2, runIntoQueueScoped2, runLast2, runScoped3, runSum2, scan2, scanEffect2, scanReduce2, scanReduceEffect2, schedule3, scheduleWith2, scoped6, scopedWith5, sliding8, slidingSize2, some6, someOrElse2, someOrFail2, split3, splitOnChunk2, splitLines3, succeed18, sync12, suspend13, take8, takeRight3, takeUntil4, takeUntilEffect2, takeWhile5, tap8, tapBoth4, tapError6, tapErrorCause6, tapSink2, throttle2, throttleEffect2, tick2, timeout4, timeoutFail4, timeoutFailCause4, timeoutTo4, toPubSub3, toPull3, toQueue3, toQueueOfElements2, toReadableStream2, toReadableStreamEffect2, toReadableStreamRuntime2, toAsyncIterableRuntime2, toAsyncIterableEffect2, toAsyncIterable2, transduce2, unfold5, unfoldChunk2, unfoldChunkEffect2, unfoldEffect2, void_9, unwrap4, unwrapScoped5, unwrapScopedWith4, updateService5, when4, whenCase2, whenCaseEffect2, whenEffect4, withSpan7, zip9, zipFlatten2, zipAll2, zipAllLeft2, zipAllRight2, zipAllSortedByKey2, zipAllSortedByKeyLeft2, zipAllSortedByKeyRight2, zipAllSortedByKeyWith2, zipAllWith2, zipLatest2, zipLatestAll2, zipLatestWith2, zipLeft8, zipRight11, zipWith14, zipWithChunks2, zipWithNext2, zipWithPrevious2, zipWithPreviousAndNext2, zipWithIndex2, Do5, bind6, bindEffect2, bindTo6, let_6, decodeText2, encodeText2, fromEventListener2;
var init_Stream2 = __esm({
  "node_modules/effect/dist/esm/Stream.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_groupBy();
    init_stream();
    StreamTypeId3 = StreamTypeId2;
    DefaultChunkSize2 = DefaultChunkSize;
    accumulate2 = accumulate;
    accumulateChunks2 = accumulateChunks;
    acquireRelease4 = acquireRelease3;
    aggregate2 = aggregate;
    aggregateWithin2 = aggregateWithin;
    aggregateWithinEither2 = aggregateWithinEither;
    as11 = as10;
    _async2 = _async;
    asyncEffect4 = asyncEffect3;
    asyncPush2 = asyncPush;
    asyncScoped2 = asyncScoped;
    branchAfter2 = branchAfter;
    broadcast2 = broadcast;
    share2 = share;
    broadcastDynamic2 = broadcastDynamic;
    broadcastedQueues2 = broadcastedQueues;
    broadcastedQueuesDynamic2 = broadcastedQueuesDynamic;
    buffer2 = buffer;
    bufferChunks2 = bufferChunks;
    catchAll8 = catchAll7;
    catchAllCause7 = catchAllCause6;
    catchSome4 = catchSome3;
    catchTag4 = catchTag3;
    catchTags4 = catchTags3;
    catchSomeCause4 = catchSomeCause3;
    changes2 = changes;
    changesWith2 = changesWith;
    changesWithEffect2 = changesWithEffect;
    chunks2 = chunks;
    chunksWith2 = chunksWith;
    combine10 = combine9;
    combineChunks2 = combineChunks;
    concat3 = concat2;
    concatAll3 = concatAll2;
    cross2 = cross;
    crossLeft2 = crossLeft;
    crossRight2 = crossRight;
    crossWith2 = crossWith;
    debounce2 = debounce;
    die11 = die10;
    dieSync7 = dieSync6;
    dieMessage5 = dieMessage4;
    distributedWith2 = distributedWith;
    distributedWithDynamic2 = distributedWithDynamic;
    drain4 = drain3;
    drainFork2 = drainFork;
    drop4 = drop3;
    dropRight2 = dropRight;
    dropUntil4 = dropUntil3;
    dropUntilEffect2 = dropUntilEffect;
    dropWhile5 = dropWhile4;
    dropWhileEffect2 = dropWhileEffect;
    either7 = either6;
    empty35 = empty34;
    ensuring8 = ensuring7;
    ensuringWith3 = ensuringWith2;
    context8 = context7;
    contextWith4 = contextWith3;
    contextWithEffect4 = contextWithEffect3;
    contextWithStream2 = contextWithStream;
    execute2 = execute;
    fail18 = fail15;
    failSync8 = failSync7;
    failCause14 = failCause13;
    failCauseSync7 = failCauseSync6;
    filter12 = filter10;
    filterEffect3 = filterEffect;
    filterMap8 = filterMap7;
    filterMapEffect2 = filterMapEffect;
    filterMapWhile4 = filterMapWhile3;
    filterMapWhileEffect2 = filterMapWhileEffect;
    finalizer2 = finalizer;
    find3 = find2;
    findEffect2 = findEffect;
    flatMap18 = flatMap16;
    flatten15 = flatten14;
    flattenChunks2 = flattenChunks;
    flattenEffect2 = flattenEffect;
    flattenExitOption2 = flattenExitOption;
    flattenIterables2 = flattenIterables;
    flattenTake2 = flattenTake;
    forever6 = forever5;
    fromAsyncIterable2 = fromAsyncIterable;
    fromChannel3 = fromChannel2;
    toChannel3 = toChannel2;
    fromChunk2 = fromChunk;
    fromChunkPubSub2 = fromChunkPubSub;
    fromChunkQueue2 = fromChunkQueue;
    fromChunks2 = fromChunks;
    fromEffect8 = fromEffect7;
    fromEffectOption2 = fromEffectOption;
    fromPubSub2 = fromPubSub;
    fromTPubSub2 = fromTPubSub;
    fromIterable15 = fromIterable14;
    fromIterableEffect2 = fromIterableEffect;
    fromIteratorSucceed2 = fromIteratorSucceed;
    fromPull3 = fromPull2;
    fromQueue3 = fromQueue2;
    fromTQueue2 = fromTQueue;
    fromReadableStream2 = fromReadableStream;
    fromReadableStreamByob2 = fromReadableStreamByob;
    fromSchedule2 = fromSchedule;
    groupAdjacentBy2 = groupAdjacentBy;
    groupBy2 = groupBy;
    groupByKey2 = groupByKey;
    grouped2 = grouped;
    groupedWithin2 = groupedWithin;
    haltAfter2 = haltAfter;
    haltWhen2 = haltWhen;
    haltWhenDeferred2 = haltWhenDeferred;
    identity5 = identityStream;
    interleave2 = interleave;
    interleaveWith2 = interleaveWith;
    intersperse2 = intersperse;
    intersperseAffixes2 = intersperseAffixes;
    interruptAfter2 = interruptAfter;
    interruptWhen3 = interruptWhen2;
    interruptWhenDeferred3 = interruptWhenDeferred2;
    iterate4 = iterate3;
    make58 = make52;
    map28 = map24;
    mapAccum6 = mapAccum5;
    mapAccumEffect2 = mapAccumEffect;
    mapBoth9 = mapBoth7;
    mapChunks2 = mapChunks;
    mapChunksEffect2 = mapChunksEffect;
    mapConcat2 = mapConcat;
    mapConcatChunk2 = mapConcatChunk;
    mapConcatChunkEffect2 = mapConcatChunkEffect;
    mapConcatEffect2 = mapConcatEffect;
    mapEffect5 = mapEffectOptions;
    mapError8 = mapError6;
    mapErrorCause5 = mapErrorCause4;
    merge10 = merge9;
    mergeAll9 = mergeAll8;
    mergeWithTag2 = mergeWithTag;
    mergeWith4 = mergeWith3;
    mergeEither2 = mergeEither;
    mergeLeft2 = mergeLeft;
    mergeRight2 = mergeRight;
    mkString3 = mkString2;
    never5 = never4;
    onEnd2 = onEnd;
    onError4 = onError3;
    onDone2 = onDone;
    onStart2 = onStart;
    orDie6 = orDie5;
    orDieWith5 = orDieWith4;
    orElse11 = orElse8;
    orElseEither5 = orElseEither4;
    orElseFail4 = orElseFail3;
    orElseIfEmpty2 = orElseIfEmpty;
    orElseIfEmptyChunk2 = orElseIfEmptyChunk;
    orElseIfEmptyStream2 = orElseIfEmptyStream;
    orElseSucceed4 = orElseSucceed3;
    paginate2 = paginate;
    paginateChunk2 = paginateChunk;
    paginateChunkEffect2 = paginateChunkEffect;
    paginateEffect2 = paginateEffect;
    partition6 = partition5;
    partitionEither2 = partitionEither;
    peel2 = peel;
    pipeThrough2 = pipeThrough;
    pipeThroughChannel2 = pipeThroughChannel;
    pipeThroughChannelOrFail2 = pipeThroughChannelOrFail;
    prepend5 = prepend4;
    provideContext7 = provideContext6;
    provideSomeContext3 = provideSomeContext2;
    provideLayer2 = provideLayer;
    provideService7 = provideService6;
    provideServiceEffect4 = provideServiceEffect3;
    provideServiceStream2 = provideServiceStream;
    mapInputContext7 = mapInputContext6;
    provideSomeLayer3 = provideSomeLayer2;
    race4 = race3;
    raceAll4 = raceAll3;
    range3 = range2;
    rechunk2 = rechunk;
    refineOrDie2 = refineOrDie;
    refineOrDieWith2 = refineOrDieWith;
    repeat4 = repeat2;
    repeatEffect2 = repeatEffect;
    repeatEffectChunk2 = repeatEffectChunk;
    repeatEffectChunkOption2 = repeatEffectChunkOption;
    repeatEffectOption2 = repeatEffectOption;
    repeatEffectWithSchedule2 = repeatEffectWithSchedule;
    repeatEither2 = repeatEither;
    repeatElements2 = repeatElements;
    repeatElementsWith2 = repeatElementsWith;
    repeatValue2 = repeatValue;
    repeatWith2 = repeatWith;
    retry7 = retry6;
    withExecutionPlan4 = withExecutionPlan3;
    run5 = run4;
    runCollect2 = runCollect;
    runCount2 = runCount;
    runDrain3 = runDrain2;
    runFold2 = runFold;
    runFoldEffect2 = runFoldEffect;
    runFoldScoped2 = runFoldScoped;
    runFoldScopedEffect2 = runFoldScopedEffect;
    runFoldWhile2 = runFoldWhile;
    runFoldWhileEffect2 = runFoldWhileEffect;
    runFoldWhileScoped2 = runFoldWhileScoped;
    runFoldWhileScopedEffect2 = runFoldWhileScopedEffect;
    runForEach2 = runForEach;
    runForEachChunk2 = runForEachChunk;
    runForEachChunkScoped2 = runForEachChunkScoped;
    runForEachScoped2 = runForEachScoped;
    runForEachWhile2 = runForEachWhile;
    runForEachWhileScoped2 = runForEachWhileScoped;
    runHead2 = runHead;
    runIntoPubSub2 = runIntoPubSub;
    runIntoPubSubScoped2 = runIntoPubSubScoped;
    runIntoQueue2 = runIntoQueue;
    runIntoQueueElementsScoped2 = runIntoQueueElementsScoped;
    runIntoQueueScoped2 = runIntoQueueScoped;
    runLast2 = runLast;
    runScoped3 = runScoped2;
    runSum2 = runSum;
    scan2 = scan;
    scanEffect2 = scanEffect;
    scanReduce2 = scanReduce;
    scanReduceEffect2 = scanReduceEffect;
    schedule3 = schedule2;
    scheduleWith2 = scheduleWith;
    scoped6 = scoped5;
    scopedWith5 = scopedWith4;
    sliding8 = sliding7;
    slidingSize2 = slidingSize;
    some6 = some5;
    someOrElse2 = someOrElse;
    someOrFail2 = someOrFail;
    split3 = split;
    splitOnChunk2 = splitOnChunk;
    splitLines3 = splitLines2;
    succeed18 = succeed15;
    sync12 = sync10;
    suspend13 = suspend10;
    take8 = take7;
    takeRight3 = takeRight2;
    takeUntil4 = takeUntil3;
    takeUntilEffect2 = takeUntilEffect;
    takeWhile5 = takeWhile4;
    tap8 = tap7;
    tapBoth4 = tapBoth3;
    tapError6 = tapError5;
    tapErrorCause6 = tapErrorCause5;
    tapSink2 = tapSink;
    throttle2 = throttle;
    throttleEffect2 = throttleEffect;
    tick2 = tick;
    timeout4 = timeout3;
    timeoutFail4 = timeoutFail3;
    timeoutFailCause4 = timeoutFailCause3;
    timeoutTo4 = timeoutTo3;
    toPubSub3 = toPubSub2;
    toPull3 = toPull2;
    toQueue3 = toQueue2;
    toQueueOfElements2 = toQueueOfElements;
    toReadableStream2 = toReadableStream;
    toReadableStreamEffect2 = toReadableStreamEffect;
    toReadableStreamRuntime2 = toReadableStreamRuntime;
    toAsyncIterableRuntime2 = toAsyncIterableRuntime;
    toAsyncIterableEffect2 = toAsyncIterableEffect;
    toAsyncIterable2 = toAsyncIterable;
    transduce2 = transduce;
    unfold5 = unfold4;
    unfoldChunk2 = unfoldChunk;
    unfoldChunkEffect2 = unfoldChunkEffect;
    unfoldEffect2 = unfoldEffect;
    void_9 = void_8;
    unwrap4 = unwrap2;
    unwrapScoped5 = unwrapScoped4;
    unwrapScopedWith4 = unwrapScopedWith3;
    updateService5 = updateService4;
    when4 = when3;
    whenCase2 = whenCase;
    whenCaseEffect2 = whenCaseEffect;
    whenEffect4 = whenEffect3;
    withSpan7 = withSpan6;
    zip9 = zip7;
    zipFlatten2 = zipFlatten;
    zipAll2 = zipAll;
    zipAllLeft2 = zipAllLeft;
    zipAllRight2 = zipAllRight;
    zipAllSortedByKey2 = zipAllSortedByKey;
    zipAllSortedByKeyLeft2 = zipAllSortedByKeyLeft;
    zipAllSortedByKeyRight2 = zipAllSortedByKeyRight;
    zipAllSortedByKeyWith2 = zipAllSortedByKeyWith;
    zipAllWith2 = zipAllWith;
    zipLatest2 = zipLatest;
    zipLatestAll2 = zipLatestAll;
    zipLatestWith2 = zipLatestWith;
    zipLeft8 = zipLeft7;
    zipRight11 = zipRight10;
    zipWith14 = zipWith12;
    zipWithChunks2 = zipWithChunks;
    zipWithNext2 = zipWithNext;
    zipWithPrevious2 = zipWithPrevious;
    zipWithPreviousAndNext2 = zipWithPreviousAndNext;
    zipWithIndex2 = zipWithIndex;
    Do5 = Do4;
    bind6 = bind5;
    bindEffect2 = bindEffect;
    bindTo6 = bindTo5;
    let_6 = let_5;
    decodeText2 = decodeText;
    encodeText2 = encodeText;
    fromEventListener2 = fromEventListener;
  }
});

// node_modules/effect/dist/esm/StreamEmit.js
var init_StreamEmit = __esm({
  "node_modules/effect/dist/esm/StreamEmit.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Streamable.js
var streamVariance2, Class7;
var init_Streamable = __esm({
  "node_modules/effect/dist/esm/Streamable.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Pipeable();
    init_Stream2();
    streamVariance2 = {
      /* c8 ignore next */
      _R: /* @__PURE__ */ __name((_) => _, "_R"),
      /* c8 ignore next */
      _E: /* @__PURE__ */ __name((_) => _, "_E"),
      /* c8 ignore next */
      _A: /* @__PURE__ */ __name((_) => _, "_A")
    };
    Class7 = class {
      static {
        __name(this, "Class");
      }
      /**
       * @since 2.0.0
       */
      [StreamTypeId3] = streamVariance2;
      /**
       * @since 2.0.0
       */
      pipe() {
        return pipeArguments(this, arguments);
      }
      /**
       * @internal
       */
      get channel() {
        return toChannel3(this.toStream());
      }
    };
  }
});

// node_modules/effect/dist/esm/Subscribable.js
var TypeId31, Proto8;
var init_Subscribable = __esm({
  "node_modules/effect/dist/esm/Subscribable.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Pipeable();
    init_Readable();
    TypeId31 = /* @__PURE__ */ Symbol.for("effect/Subscribable");
    Proto8 = {
      [TypeId14]: TypeId14,
      [TypeId31]: TypeId31,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
  }
});

// node_modules/effect/dist/esm/SynchronizedRef.js
var init_SynchronizedRef = __esm({
  "node_modules/effect/dist/esm/SynchronizedRef.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/SubscriptionRef.js
var init_SubscriptionRef = __esm({
  "node_modules/effect/dist/esm/SubscriptionRef.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Supervisor.js
var SupervisorTypeId2, AbstractSupervisor;
var init_Supervisor = __esm({
  "node_modules/effect/dist/esm/Supervisor.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_core();
    init_supervisor();
    SupervisorTypeId2 = SupervisorTypeId;
    AbstractSupervisor = class {
      static {
        __name(this, "AbstractSupervisor");
      }
      /**
       * @since 2.0.0
       */
      onStart(_context, _effect, _parent, _fiber) {
      }
      /**
       * @since 2.0.0
       */
      onEnd(_value, _fiber) {
      }
      /**
       * @since 2.0.0
       */
      onEffect(_fiber, _effect) {
      }
      /**
       * @since 2.0.0
       */
      onSuspend(_fiber) {
      }
      /**
       * @since 2.0.0
       */
      onResume(_fiber) {
      }
      /**
       * @since 2.0.0
       */
      map(f) {
        return new ProxySupervisor(this, map11(this.value, f));
      }
      /**
       * @since 2.0.0
       */
      zip(right3) {
        return new Zip(this, right3);
      }
      /**
       * @since 2.0.0
       */
      onRun(execution, _fiber) {
        return execution();
      }
      /**
       * @since 2.0.0
       */
      [SupervisorTypeId2] = supervisorVariance;
    };
  }
});

// node_modules/effect/dist/esm/Symbol.js
var init_Symbol = __esm({
  "node_modules/effect/dist/esm/Symbol.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/TArray.js
var init_TArray = __esm({
  "node_modules/effect/dist/esm/TArray.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/TDeferred.js
var init_TDeferred = __esm({
  "node_modules/effect/dist/esm/TDeferred.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/TMap.js
var init_TMap = __esm({
  "node_modules/effect/dist/esm/TMap.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/TPriorityQueue.js
var init_TPriorityQueue = __esm({
  "node_modules/effect/dist/esm/TPriorityQueue.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/TRandom.js
var init_TRandom = __esm({
  "node_modules/effect/dist/esm/TRandom.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/TReentrantLock.js
var init_TReentrantLock = __esm({
  "node_modules/effect/dist/esm/TReentrantLock.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/TRef.js
var init_TRef = __esm({
  "node_modules/effect/dist/esm/TRef.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/TSemaphore.js
var init_TSemaphore = __esm({
  "node_modules/effect/dist/esm/TSemaphore.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/TSet.js
var init_TSet = __esm({
  "node_modules/effect/dist/esm/TSet.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/TSubscriptionRef.js
var init_TSubscriptionRef = __esm({
  "node_modules/effect/dist/esm/TSubscriptionRef.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Take.js
var init_Take = __esm({
  "node_modules/effect/dist/esm/Take.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/TestAnnotation.js
var TestAnnotationSymbolKey, TestAnnotationTypeId, TestAnnotationImpl, isTestAnnotation, make59, compose5, fibers;
var init_TestAnnotation = __esm({
  "node_modules/effect/dist/esm/TestAnnotation.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Chunk();
    init_Either();
    init_Equal();
    init_Function();
    init_Hash();
    init_errors();
    init_Predicate();
    TestAnnotationSymbolKey = "effect/TestAnnotation";
    TestAnnotationTypeId = /* @__PURE__ */ Symbol.for(TestAnnotationSymbolKey);
    TestAnnotationImpl = class {
      static {
        __name(this, "TestAnnotationImpl");
      }
      identifier;
      initial;
      combine;
      [TestAnnotationTypeId] = {
        _A: /* @__PURE__ */ __name((_) => _, "_A")
      };
      constructor(identifier2, initial, combine11) {
        this.identifier = identifier2;
        this.initial = initial;
        this.combine = combine11;
      }
      [symbol]() {
        return pipe(hash(TestAnnotationSymbolKey), combine(hash(this.identifier)), cached(this));
      }
      [symbol2](that) {
        return isTestAnnotation(that) && this.identifier === that.identifier;
      }
    };
    isTestAnnotation = /* @__PURE__ */ __name((u) => hasProperty(u, TestAnnotationTypeId), "isTestAnnotation");
    make59 = /* @__PURE__ */ __name((identifier2, initial, combine11) => {
      return new TestAnnotationImpl(identifier2, initial, combine11);
    }, "make");
    compose5 = /* @__PURE__ */ __name((left3, right3) => {
      if (isLeft2(left3) && isLeft2(right3)) {
        return left2(left3.left + right3.left);
      }
      if (isRight2(left3) && isRight2(right3)) {
        return right2(pipe(left3.right, appendAll2(right3.right)));
      }
      if (isRight2(left3) && isLeft2(right3)) {
        return right3;
      }
      if (isLeft2(left3) && isRight2(right3)) {
        return right3;
      }
      throw new Error(getBugErrorMessage("TestAnnotation.compose"));
    }, "compose");
    fibers = /* @__PURE__ */ make59("fibers", /* @__PURE__ */ left2(0), compose5);
  }
});

// node_modules/effect/dist/esm/TestAnnotationMap.js
var TestAnnotationMapTypeId, TestAnnotationMapImpl, make60, overwrite, update5, get17, annotate;
var init_TestAnnotationMap = __esm({
  "node_modules/effect/dist/esm/TestAnnotationMap.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Function();
    init_HashMap();
    TestAnnotationMapTypeId = /* @__PURE__ */ Symbol.for("effect/TestAnnotationMap");
    TestAnnotationMapImpl = class {
      static {
        __name(this, "TestAnnotationMapImpl");
      }
      map;
      [TestAnnotationMapTypeId] = TestAnnotationMapTypeId;
      constructor(map31) {
        this.map = map31;
      }
    };
    make60 = /* @__PURE__ */ __name((map31) => {
      return new TestAnnotationMapImpl(map31);
    }, "make");
    overwrite = /* @__PURE__ */ dual(3, (self2, key, value3) => make60(set3(self2.map, key, value3)));
    update5 = /* @__PURE__ */ dual(3, (self2, key, f) => {
      let value3 = key.initial;
      if (has4(self2.map, key)) {
        value3 = unsafeGet6(self2.map, key);
      }
      return overwrite(self2, key, f(value3));
    });
    get17 = /* @__PURE__ */ dual(2, (self2, key) => {
      if (has4(self2.map, key)) {
        return unsafeGet6(self2.map, key);
      }
      return key.initial;
    });
    annotate = /* @__PURE__ */ dual(3, (self2, key, value3) => update5(self2, key, (_) => key.combine(_, value3)));
  }
});

// node_modules/effect/dist/esm/TestAnnotations.js
var TestAnnotationsTypeId, AnnotationsImpl;
var init_TestAnnotations = __esm({
  "node_modules/effect/dist/esm/TestAnnotations.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Array();
    init_Equal();
    init_Function();
    init_core_effect();
    init_core();
    init_fiber();
    init_MutableRef();
    init_Ref();
    init_SortedSet();
    init_TestAnnotation();
    init_TestAnnotationMap();
    TestAnnotationsTypeId = /* @__PURE__ */ Symbol.for("effect/TestAnnotations");
    AnnotationsImpl = class {
      static {
        __name(this, "AnnotationsImpl");
      }
      ref;
      [TestAnnotationsTypeId] = TestAnnotationsTypeId;
      constructor(ref2) {
        this.ref = ref2;
      }
      get(key) {
        return map11(get12(this.ref), get17(key));
      }
      annotate(key, value3) {
        return update3(this.ref, annotate(key, value3));
      }
      get supervisedFibers() {
        return descriptorWith((descriptor3) => flatMap8(this.get(fibers), (either8) => {
          switch (either8._tag) {
            case "Left": {
              return succeed(empty26(Order6));
            }
            case "Right": {
              return pipe(either8.right, forEachSequential((ref2) => sync(() => get6(ref2))), map11(reduce(empty26(Order6), (a, b) => union5(a, b))), map11(filter6((fiber) => !equals(fiber.id(), descriptor3.id))));
            }
          }
        }));
      }
    };
  }
});

// node_modules/effect/dist/esm/internal/testing/suspendedWarningData.js
var OP_SUSPENDED_WARNING_DATA_START, OP_SUSPENDED_WARNING_DATA_PENDING, OP_SUSPENDED_WARNING_DATA_DONE, start3, pending3, done11, isStart, isPending;
var init_suspendedWarningData = __esm({
  "node_modules/effect/dist/esm/internal/testing/suspendedWarningData.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_SUSPENDED_WARNING_DATA_START = "Start";
    OP_SUSPENDED_WARNING_DATA_PENDING = "Pending";
    OP_SUSPENDED_WARNING_DATA_DONE = "Done";
    start3 = {
      _tag: OP_SUSPENDED_WARNING_DATA_START
    };
    pending3 = /* @__PURE__ */ __name((fiber) => {
      return {
        _tag: OP_SUSPENDED_WARNING_DATA_PENDING,
        fiber
      };
    }, "pending");
    done11 = {
      _tag: OP_SUSPENDED_WARNING_DATA_DONE
    };
    isStart = /* @__PURE__ */ __name((self2) => {
      return self2._tag === OP_SUSPENDED_WARNING_DATA_START;
    }, "isStart");
    isPending = /* @__PURE__ */ __name((self2) => {
      return self2._tag === OP_SUSPENDED_WARNING_DATA_PENDING;
    }, "isPending");
  }
});

// node_modules/effect/dist/esm/internal/testing/warningData.js
var OP_WARNING_DATA_START, OP_WARNING_DATA_PENDING, OP_WARNING_DATA_DONE, pending4, done12, isStart2, isPending2;
var init_warningData = __esm({
  "node_modules/effect/dist/esm/internal/testing/warningData.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    OP_WARNING_DATA_START = "Start";
    OP_WARNING_DATA_PENDING = "Pending";
    OP_WARNING_DATA_DONE = "Done";
    pending4 = /* @__PURE__ */ __name((fiber) => {
      return {
        _tag: OP_WARNING_DATA_PENDING,
        fiber
      };
    }, "pending");
    done12 = {
      _tag: OP_WARNING_DATA_DONE
    };
    isStart2 = /* @__PURE__ */ __name((self2) => {
      return self2._tag === OP_WARNING_DATA_START;
    }, "isStart");
    isPending2 = /* @__PURE__ */ __name((self2) => {
      return self2._tag === OP_WARNING_DATA_PENDING;
    }, "isPending");
  }
});

// node_modules/effect/dist/esm/TestLive.js
var TestLiveTypeId, LiveImpl;
var init_TestLive = __esm({
  "node_modules/effect/dist/esm/TestLive.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Context();
    init_core();
    init_defaultServices();
    TestLiveTypeId = /* @__PURE__ */ Symbol.for("effect/TestLive");
    LiveImpl = class {
      static {
        __name(this, "LiveImpl");
      }
      services;
      [TestLiveTypeId] = TestLiveTypeId;
      constructor(services) {
        this.services = services;
      }
      provide(effect4) {
        return fiberRefLocallyWith(currentServices, merge3(this.services))(effect4);
      }
    };
  }
});

// node_modules/effect/dist/esm/TestClock.js
var makeData, warning, suspendedWarning, TestClockImpl;
var init_TestClock = __esm({
  "node_modules/effect/dist/esm/TestClock.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Chunk();
    init_Duration();
    init_Equal();
    init_FiberStatus();
    init_Function();
    init_HashMap();
    init_clock();
    init_core_effect();
    init_core();
    init_fiberRuntime();
    init_ref();
    init_synchronizedRef();
    init_suspendedWarningData();
    init_warningData();
    init_Number();
    init_Option();
    init_Order();
    makeData = /* @__PURE__ */ __name((instant, sleeps) => ({
      instant,
      sleeps
    }), "makeData");
    warning = "Warning: A test is using time, but is not advancing the test clock, which may result in the test hanging. Use TestClock.adjust to manually advance the time.";
    suspendedWarning = "Warning: A test is advancing the test clock, but a fiber is not suspending, which may result in the test hanging. Use TestAspect.diagnose to identity the fiber that is not suspending.";
    TestClockImpl = class {
      static {
        __name(this, "TestClockImpl");
      }
      clockState;
      live;
      annotations;
      warningState;
      suspendedWarningState;
      [ClockTypeId] = ClockTypeId;
      constructor(clockState, live, annotations3, warningState, suspendedWarningState) {
        this.clockState = clockState;
        this.live = live;
        this.annotations = annotations3;
        this.warningState = warningState;
        this.suspendedWarningState = suspendedWarningState;
        this.currentTimeMillis = map11(get11(this.clockState), (data) => data.instant);
        this.currentTimeNanos = map11(get11(this.clockState), (data) => BigInt(data.instant * 1e6));
      }
      /**
       * Unsafely returns the current time in milliseconds.
       */
      unsafeCurrentTimeMillis() {
        return unsafeGet7(this.clockState).instant;
      }
      /**
       * Unsafely returns the current time in nanoseconds.
       */
      unsafeCurrentTimeNanos() {
        return BigInt(unsafeGet7(this.clockState).instant * 1e6);
      }
      /**
       * Returns the current clock time in milliseconds.
       */
      currentTimeMillis;
      /**
       * Returns the current clock time in nanoseconds.
       */
      currentTimeNanos;
      /**
       * Saves the `TestClock`'s current state in an effect which, when run, will
       * restore the `TestClock` state to the saved state.
       */
      get save() {
        return map11(get11(this.clockState), (data) => set5(this.clockState, data));
      }
      /**
       * Sets the current clock time to the specified instant. Any effects that
       * were scheduled to occur on or before the new time will be run in order.
       */
      setTime(instant) {
        return zipRight2(this.warningDone(), this.run(() => instant));
      }
      /**
       * Semantically blocks the current fiber until the clock time is equal to or
       * greater than the specified duration. Once the clock time is adjusted to
       * on or after the duration, the fiber will automatically be resumed.
       */
      sleep(durationInput) {
        const duration6 = decode(durationInput);
        return flatMap8(deferredMake(), (deferred) => pipe(modify3(this.clockState, (data) => {
          const end6 = data.instant + toMillis(duration6);
          if (end6 > data.instant) {
            return [true, makeData(data.instant, pipe(data.sleeps, prepend2([end6, deferred])))];
          }
          return [false, data];
        }), flatMap8((shouldAwait) => shouldAwait ? pipe(this.warningStart(), zipRight2(deferredAwait(deferred))) : pipe(deferredSucceed(deferred, void 0), asVoid2))));
      }
      /**
       * Returns a list of the times at which all queued effects are scheduled to
       * resume.
       */
      get sleeps() {
        return map11(get11(this.clockState), (data) => map5(data.sleeps, (_) => _[0]));
      }
      /**
       * Increments the current clock time by the specified duration. Any effects
       * that were scheduled to occur on or before the new time will be run in
       * order.
       */
      adjust(durationInput) {
        const duration6 = decode(durationInput);
        return zipRight2(this.warningDone(), this.run((n) => n + toMillis(duration6)));
      }
      /**
       * Increments the current clock time by the specified duration. Any effects
       * that were scheduled to occur on or before the new time will be run in
       * order.
       */
      adjustWith(durationInput) {
        const duration6 = decode(durationInput);
        return (effect4) => zipLeftOptions(effect4, this.adjust(duration6), {
          concurrent: true
        });
      }
      /**
       * Returns a set of all fibers in this test.
       */
      supervisedFibers() {
        return this.annotations.supervisedFibers;
      }
      /**
       * Captures a "snapshot" of the identifier and status of all fibers in this
       * test other than the current fiber. Fails with the `void` value if any of
       * these fibers are not done or suspended. Note that because we cannot
       * synchronize on the status of multiple fibers at the same time this
       * snapshot may not be fully consistent.
       */
      freeze() {
        return flatMap8(this.supervisedFibers(), (fibers2) => pipe(fibers2, reduce9(empty9(), (map31, fiber) => pipe(fiber.status, flatMap8((status2) => {
          if (isDone3(status2)) {
            return succeed(set3(map31, fiber.id(), status2));
          }
          if (isSuspended2(status2)) {
            return succeed(set3(map31, fiber.id(), status2));
          }
          return fail2(void 0);
        })))));
      }
      /**
       * Forks a fiber that will display a warning message if a test is using time
       * but is not advancing the `TestClock`.
       */
      warningStart() {
        return updateSomeEffect(this.warningState, (data) => isStart2(data) ? some2(pipe(this.live.provide(pipe(logWarning(warning), delay(seconds(5)))), interruptible2, fork, map11((fiber) => pending4(fiber)))) : none2());
      }
      /**
       * Cancels the warning message that is displayed if a test is using time but
       * is not advancing the `TestClock`.
       */
      warningDone() {
        return updateSomeEffect(this.warningState, (warningData) => {
          if (isStart2(warningData)) {
            return some2(succeed(done12));
          }
          if (isPending2(warningData)) {
            return some2(pipe(interruptFiber(warningData.fiber), as2(done12)));
          }
          return none2();
        });
      }
      yieldTimer = /* @__PURE__ */ async_((resume2) => {
        const timer2 = setTimeout(() => {
          resume2(void_2);
        }, 0);
        return sync(() => clearTimeout(timer2));
      });
      /**
       * Returns whether all descendants of this fiber are done or suspended.
       */
      suspended() {
        return pipe(this.freeze(), zip2(pipe(this.yieldTimer, zipRight2(this.freeze()))), flatMap8(([first3, last6]) => equals(first3, last6) ? succeed(first3) : fail2(void 0)));
      }
      /**
       * Polls until all descendants of this fiber are done or suspended.
       */
      awaitSuspended() {
        return pipe(this.suspendedWarningStart(), zipRight2(pipe(this.suspended(), zipWith4(pipe(this.yieldTimer, zipRight2(this.suspended())), equals), filterOrFail(identity, constVoid), eventually)), zipRight2(this.suspendedWarningDone()));
      }
      /**
       * Forks a fiber that will display a warning message if a test is advancing
       * the `TestClock` but a fiber is not suspending.
       */
      suspendedWarningStart() {
        return updateSomeEffect(this.suspendedWarningState, (suspendedWarningData) => {
          if (isStart(suspendedWarningData)) {
            return some2(pipe(this.live.provide(pipe(logWarning(suspendedWarning), zipRight2(set5(this.suspendedWarningState, done11)), delay(seconds(5)))), interruptible2, fork, map11((fiber) => pending3(fiber))));
          }
          return none2();
        });
      }
      /**
       * Cancels the warning message that is displayed if a test is advancing the
       * `TestClock` but a fiber is not suspending.
       */
      suspendedWarningDone() {
        return updateSomeEffect(this.suspendedWarningState, (suspendedWarningData) => {
          if (isPending(suspendedWarningData)) {
            return some2(pipe(interruptFiber(suspendedWarningData.fiber), as2(start3)));
          }
          return none2();
        });
      }
      /**
       * Runs all effects scheduled to occur on or before the specified instant,
       * which may depend on the current time, in order.
       */
      run(f) {
        return pipe(this.awaitSuspended(), zipRight2(pipe(modify3(this.clockState, (data) => {
          const end6 = f(data.instant);
          const sorted = pipe(data.sleeps, sort2(pipe(Order, mapInput2((_) => _[0]))));
          if (isNonEmpty2(sorted)) {
            const [instant, deferred] = headNonEmpty2(sorted);
            if (instant <= end6) {
              return [some2([end6, deferred]), makeData(instant, tailNonEmpty2(sorted))];
            }
          }
          return [none2(), makeData(end6, data.sleeps)];
        }), flatMap8((option5) => {
          switch (option5._tag) {
            case "None": {
              return void_2;
            }
            case "Some": {
              const [end6, deferred] = option5.value;
              return pipe(deferredSucceed(deferred, void 0), zipRight2(yieldNow()), zipRight2(this.run(() => end6)));
            }
          }
        }))));
      }
    };
  }
});

// node_modules/effect/dist/esm/TestConfig.js
var init_TestConfig = __esm({
  "node_modules/effect/dist/esm/TestConfig.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/TestSized.js
var TestSizedTypeId, SizedImpl;
var init_TestSized = __esm({
  "node_modules/effect/dist/esm/TestSized.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_core();
    TestSizedTypeId = /* @__PURE__ */ Symbol.for("effect/TestSized");
    SizedImpl = class {
      static {
        __name(this, "SizedImpl");
      }
      fiberRef;
      [TestSizedTypeId] = TestSizedTypeId;
      constructor(fiberRef) {
        this.fiberRef = fiberRef;
      }
      get size() {
        return fiberRefGet(this.fiberRef);
      }
      withSize(size15) {
        return (effect4) => fiberRefLocally(this.fiberRef, size15)(effect4);
      }
    };
  }
});

// node_modules/effect/dist/esm/TestServices.js
var init_TestServices = __esm({
  "node_modules/effect/dist/esm/TestServices.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/TestContext.js
var init_TestContext = __esm({
  "node_modules/effect/dist/esm/TestContext.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Trie.js
var init_Trie = __esm({
  "node_modules/effect/dist/esm/Trie.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Types.js
var init_Types = __esm({
  "node_modules/effect/dist/esm/Types.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/Unify.js
var init_Unify = __esm({
  "node_modules/effect/dist/esm/Unify.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/UpstreamPullRequest.js
var init_UpstreamPullRequest = __esm({
  "node_modules/effect/dist/esm/UpstreamPullRequest.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/UpstreamPullStrategy.js
var init_UpstreamPullStrategy = __esm({
  "node_modules/effect/dist/esm/UpstreamPullStrategy.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/effect/dist/esm/index.js
var init_esm = __esm({
  "node_modules/effect/dist/esm/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_Arbitrary2();
    init_Array();
    init_BigDecimal();
    init_BigInt();
    init_Boolean();
    init_Brand();
    init_Cache();
    init_Cause();
    init_Channel();
    init_ChildExecutorDecision();
    init_Chunk();
    init_Clock();
    init_Config();
    init_ConfigError();
    init_ConfigProvider();
    init_ConfigProviderPathPatch();
    init_Console();
    init_Context();
    init_Cron();
    init_Data();
    init_DateTime();
    init_DefaultServices();
    init_Deferred();
    init_Differ();
    init_Duration();
    init_Effect();
    init_Effectable();
    init_Either();
    init_Encoding();
    init_Equal();
    init_Equivalence();
    init_ExecutionPlan();
    init_ExecutionStrategy();
    init_Exit();
    init_FastCheck();
    init_Fiber();
    init_FiberHandle();
    init_FiberId();
    init_FiberMap();
    init_FiberRef();
    init_FiberRefs();
    init_FiberRefsPatch();
    init_FiberSet();
    init_FiberStatus();
    init_Function();
    init_GlobalValue();
    init_Graph();
    init_GroupBy();
    init_HKT();
    init_Hash();
    init_HashMap();
    init_HashRing();
    init_HashSet();
    init_Inspectable();
    init_Iterable();
    init_JSONSchema();
    init_KeyedPool();
    init_Layer();
    init_LayerMap();
    init_List();
    init_LogLevel();
    init_LogSpan();
    init_Logger();
    init_Mailbox();
    init_ManagedRuntime();
    init_Match();
    init_MergeDecision();
    init_MergeState();
    init_MergeStrategy();
    init_Metric();
    init_MetricBoundaries();
    init_MetricHook();
    init_MetricKey();
    init_MetricKeyType();
    init_MetricLabel();
    init_MetricPair();
    init_MetricPolling();
    init_MetricRegistry();
    init_MetricState();
    init_Micro();
    init_ModuleVersion();
    init_MutableHashMap();
    init_MutableHashSet();
    init_MutableList();
    init_MutableQueue();
    init_MutableRef();
    init_NonEmptyIterable();
    init_Number();
    init_Option();
    init_Order();
    init_Ordering();
    init_ParseResult();
    init_PartitionedSemaphore();
    init_Pipeable();
    init_Pool();
    init_Predicate();
    init_Pretty();
    init_PrimaryKey();
    init_PubSub();
    init_Queue();
    init_Random2();
    init_RateLimiter();
    init_RcMap();
    init_RcRef();
    init_Readable();
    init_Record();
    init_RedBlackTree();
    init_Redacted();
    init_Ref();
    init_RegExp();
    init_Reloadable();
    init_Request();
    init_RequestBlock();
    init_RequestResolver();
    init_Resource();
    init_Runtime();
    init_RuntimeFlags();
    init_RuntimeFlagsPatch();
    init_STM();
    init_Schedule();
    init_ScheduleDecision();
    init_ScheduleInterval();
    init_ScheduleIntervals();
    init_Scheduler();
    init_Schema();
    init_SchemaAST();
    init_Scope();
    init_ScopedCache();
    init_ScopedRef();
    init_Secret();
    init_SingleProducerAsyncInput();
    init_Sink();
    init_SortedMap();
    init_SortedSet();
    init_Stream2();
    init_StreamEmit();
    init_StreamHaltStrategy();
    init_Streamable();
    init_String();
    init_Struct();
    init_Subscribable();
    init_SubscriptionRef();
    init_Supervisor();
    init_Symbol();
    init_SynchronizedRef();
    init_TArray();
    init_TDeferred();
    init_TMap();
    init_TPriorityQueue();
    init_TPubSub();
    init_TQueue();
    init_TRandom();
    init_TReentrantLock();
    init_TRef();
    init_TSemaphore();
    init_TSet();
    init_TSubscriptionRef();
    init_Take();
    init_TestAnnotation();
    init_TestAnnotationMap();
    init_TestAnnotations();
    init_TestClock();
    init_TestConfig();
    init_TestContext();
    init_TestLive();
    init_TestServices();
    init_TestSized();
    init_Tracer();
    init_Trie();
    init_Tuple();
    init_Types();
    init_Unify();
    init_UpstreamPullRequest();
    init_UpstreamPullStrategy();
    init_Utils();
  }
});

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
      static {
        __name(this, "_CodeOrName");
      }
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name2 = class extends _CodeOrName {
      static {
        __name(this, "Name");
      }
      constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name2;
    var _Code = class extends _CodeOrName {
      static {
        __name(this, "_Code");
      }
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a2;
        return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a2;
        return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name2)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args2) {
      const code = [strs[0]];
      let i = 0;
      while (i < args2.length) {
        addCodeArg(code, args2[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    __name(_, "_");
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args2) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args2.length) {
        expr.push(plus);
        addCodeArg(expr, args2[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize2(expr);
      return new _Code(expr);
    }
    __name(str, "str");
    exports.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name2)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    __name(addCodeArg, "addCodeArg");
    exports.addCodeArg = addCodeArg;
    function optimize2(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    __name(optimize2, "optimize");
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name2 || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name2))
        return `"${a}${b.slice(1)}`;
      return;
    }
    __name(mergeExprItems, "mergeExprItems");
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    __name(strConcat, "strConcat");
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    __name(interpolate, "interpolate");
    function stringify3(x) {
      return new _Code(safeStringify(x));
    }
    __name(stringify3, "stringify");
    exports.stringify = stringify3;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    __name(safeStringify, "safeStringify");
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    __name(getProperty, "getProperty");
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    __name(getEsmExportName, "getEsmExportName");
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    __name(regexpCode, "regexpCode");
    exports.regexpCode = regexpCode;
  }
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      static {
        __name(this, "ValueError");
      }
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope2 = class {
      static {
        __name(this, "Scope");
      }
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a2, _b;
        if (((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope2;
    var ValueScopeName = class extends code_1.Name {
      static {
        __name(this, "ValueScopeName");
      }
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value3, { property: property2, itemIndex }) {
        this.value = value3;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property2)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope2 {
      static {
        __name(this, "ValueScope");
      }
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value3) {
        var _a2;
        if (value3.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a2 = value3.key) !== null && _a2 !== void 0 ? _a2 : value3.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value3.ref;
        name.setValue(value3, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values4 = this._values) {
        return this._reduceValues(values4, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values4 = this._values, usedValues, getCode) {
        return this._reduceValues(values4, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values4, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values4) {
          const vs = values4[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return code_2._;
    }, "get") });
    Object.defineProperty(exports, "str", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return code_2.str;
    }, "get") });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return code_2.strConcat;
    }, "get") });
    Object.defineProperty(exports, "nil", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return code_2.nil;
    }, "get") });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return code_2.getProperty;
    }, "get") });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return code_2.stringify;
    }, "get") });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return code_2.regexpCode;
    }, "get") });
    Object.defineProperty(exports, "Name", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return code_2.Name;
    }, "get") });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return scope_2.Scope;
    }, "get") });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return scope_2.ValueScope;
    }, "get") });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return scope_2.ValueScopeName;
    }, "get") });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return scope_2.varKinds;
    }, "get") });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node2 = class {
      static {
        __name(this, "Node");
      }
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node2 {
      static {
        __name(this, "Def");
      }
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node2 {
      static {
        __name(this, "Assign");
      }
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      static {
        __name(this, "AssignOp");
      }
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node2 {
      static {
        __name(this, "Label");
      }
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node2 {
      static {
        __name(this, "Break");
      }
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node2 {
      static {
        __name(this, "Throw");
      }
      constructor(error50) {
        super();
        this.error = error50;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node2 {
      static {
        __name(this, "AnyCode");
      }
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node2 {
      static {
        __name(this, "ParentNode");
      }
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      static {
        __name(this, "BlockNode");
      }
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
      static {
        __name(this, "Root");
      }
    };
    var Else = class extends BlockNode {
      static {
        __name(this, "Else");
      }
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      static {
        __name(this, "If");
      }
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not3(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a2;
        this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
      static {
        __name(this, "For");
      }
    };
    For.kind = "for";
    var ForLoop = class extends For {
      static {
        __name(this, "ForLoop");
      }
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      static {
        __name(this, "ForRange");
      }
      constructor(varKind, name, from2, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from2;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from: from2, to } = this;
        return `for(${varKind} ${name}=${from2}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      static {
        __name(this, "ForIter");
      }
      constructor(loop3, varKind, name, iterable) {
        super();
        this.loop = loop3;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      static {
        __name(this, "Func");
      }
      constructor(name, args2, async4) {
        super();
        this.name = name;
        this.args = args2;
        this.async = async4;
      }
      render(opts) {
        const _async3 = this.async ? "async " : "";
        return `${_async3}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      static {
        __name(this, "Return");
      }
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      static {
        __name(this, "Try");
      }
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a2, _b;
        super.optimizeNodes();
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a2, _b;
        super.optimizeNames(names, constants);
        (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      static {
        __name(this, "Catch");
      }
      constructor(error50) {
        super();
        this.error = error50;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      static {
        __name(this, "Finally");
      }
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      static {
        __name(this, "CodeGen");
      }
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value3) {
        const name = this._extScope.value(prefixOrName, value3);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant3) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant3)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value3] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value3 || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value3);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from2, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from2, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value3) {
        const node = new Return();
        this._blockNode(node);
        this.code(value3);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error50 = this.name("e");
          this._currNode = node.catch = new Catch(error50);
          catchCode(error50);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error50) {
        return this._leafNode(new Throw(error50));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args2 = code_1.nil, async4, funcBody) {
        this._blockNode(new Func(name, args2, async4));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from2) {
      for (const n in from2)
        names[n] = (names[n] || 0) + (from2[n] || 0);
      return names;
    }
    __name(addNames, "addNames");
    function addExprNames(names, from2) {
      return from2 instanceof code_1._CodeOrName ? addNames(names, from2.names) : names;
    }
    __name(addExprNames, "addExprNames");
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      __name(replaceName, "replaceName");
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
      __name(canOptimize, "canOptimize");
    }
    __name(optimizeExpr, "optimizeExpr");
    function subtractNames(names, from2) {
      for (const n in from2)
        names[n] = (names[n] || 0) - (from2[n] || 0);
    }
    __name(subtractNames, "subtractNames");
    function not3(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par2(x)}`;
    }
    __name(not3, "not");
    exports.not = not3;
    var andCode = mappend(exports.operators.AND);
    function and2(...args2) {
      return args2.reduce(andCode);
    }
    __name(and2, "and");
    exports.and = and2;
    var orCode = mappend(exports.operators.OR);
    function or2(...args2) {
      return args2.reduce(orCode);
    }
    __name(or2, "or");
    exports.or = or2;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par2(x)} ${op} ${par2(y)}`;
    }
    __name(mappend, "mappend");
    function par2(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
    __name(par2, "par");
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash4 = {};
      for (const item of arr)
        hash4[item] = true;
      return hash4;
    }
    __name(toHash, "toHash");
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    __name(alwaysValidSchema, "alwaysValidSchema");
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    __name(checkUnknownRules, "checkUnknownRules");
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    __name(schemaHasRules, "schemaHasRules");
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    __name(schemaHasRulesButRef, "schemaHasRulesButRef");
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    __name(schemaRefOrVal, "schemaRefOrVal");
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    __name(unescapeFragment, "unescapeFragment");
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    __name(escapeFragment, "escapeFragment");
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    __name(escapeJsonPointer, "escapeJsonPointer");
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    __name(unescapeJsonPointer, "unescapeJsonPointer");
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    __name(eachItem, "eachItem");
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues3, resultToName }) {
      return (gen5, from2, to, toName) => {
        const res = to === void 0 ? from2 : to instanceof codegen_1.Name ? (from2 instanceof codegen_1.Name ? mergeNames(gen5, from2, to) : mergeToName(gen5, from2, to), to) : from2 instanceof codegen_1.Name ? (mergeToName(gen5, to, from2), from2) : mergeValues3(from2, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen5, res) : res;
      };
    }
    __name(makeMergeEvaluated, "makeMergeEvaluated");
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: /* @__PURE__ */ __name((gen5, from2, to) => gen5.if((0, codegen_1._)`${to} !== true && ${from2} !== undefined`, () => {
          gen5.if((0, codegen_1._)`${from2} === true`, () => gen5.assign(to, true), () => gen5.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from2})`));
        }), "mergeNames"),
        mergeToName: /* @__PURE__ */ __name((gen5, from2, to) => gen5.if((0, codegen_1._)`${to} !== true`, () => {
          if (from2 === true) {
            gen5.assign(to, true);
          } else {
            gen5.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen5, to, from2);
          }
        }), "mergeToName"),
        mergeValues: /* @__PURE__ */ __name((from2, to) => from2 === true ? true : { ...from2, ...to }, "mergeValues"),
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: /* @__PURE__ */ __name((gen5, from2, to) => gen5.if((0, codegen_1._)`${to} !== true && ${from2} !== undefined`, () => gen5.assign(to, (0, codegen_1._)`${from2} === true ? true : ${to} > ${from2} ? ${to} : ${from2}`)), "mergeNames"),
        mergeToName: /* @__PURE__ */ __name((gen5, from2, to) => gen5.if((0, codegen_1._)`${to} !== true`, () => gen5.assign(to, from2 === true ? true : (0, codegen_1._)`${to} > ${from2} ? ${to} : ${from2}`)), "mergeToName"),
        mergeValues: /* @__PURE__ */ __name((from2, to) => from2 === true ? true : Math.max(from2, to), "mergeValues"),
        resultToName: /* @__PURE__ */ __name((gen5, items) => gen5.var("items", items), "resultToName")
      })
    };
    function evaluatedPropsToName(gen5, ps) {
      if (ps === true)
        return gen5.var("props", true);
      const props = gen5.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen5, props, ps);
      return props;
    }
    __name(evaluatedPropsToName, "evaluatedPropsToName");
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen5, props, ps) {
      Object.keys(ps).forEach((p) => gen5.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    __name(setEvaluated, "setEvaluated");
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen5, f) {
      return gen5.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    __name(useFunc, "useFunc");
    exports.useFunc = useFunc;
    var Type3;
    (function(Type4) {
      Type4[Type4["Num"] = 0] = "Num";
      Type4[Type4["Str"] = 1] = "Str";
    })(Type3 || (exports.Type = Type3 = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber3 = dataPropType === Type3.Num;
        return jsPropertySyntax ? isNumber3 ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber3 ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    __name(getErrorPath, "getErrorPath");
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    __name(checkStrictMode, "checkStrictMode");
    exports.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports.keywordError = {
      message: /* @__PURE__ */ __name(({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`, "message")
    };
    exports.keyword$DataError = {
      message: /* @__PURE__ */ __name(({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`, "message")
    };
    function reportError(cxt, error50 = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen: gen5, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error50, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen5, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    __name(reportError, "reportError");
    exports.reportError = reportError;
    function reportExtraError(cxt, error50 = exports.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen: gen5, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error50, errorPaths);
      addError(gen5, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    __name(reportExtraError, "reportExtraError");
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen5, errsCount) {
      gen5.assign(names_1.default.errors, errsCount);
      gen5.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen5.if(errsCount, () => gen5.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen5.assign(names_1.default.vErrors, null)));
    }
    __name(resetErrorsCount, "resetErrorsCount");
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen: gen5, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen5.name("err");
      gen5.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen5.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen5.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen5.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen5.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen5.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen5.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    __name(extendErrors, "extendErrors");
    exports.extendErrors = extendErrors;
    function addError(gen5, errObj) {
      const err = gen5.const("err", errObj);
      gen5.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen5.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen5.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    __name(addError, "addError");
    function returnErrors(it, errs) {
      const { gen: gen5, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen5.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen5.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen5.return(false);
      }
    }
    __name(returnErrors, "returnErrors");
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error50, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error50, errorPaths);
    }
    __name(errorObjectCode, "errorObjectCode");
    function errorObject(cxt, error50, errorPaths = {}) {
      const { gen: gen5, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error50, keyValues);
      return gen5.object(...keyValues);
    }
    __name(errorObject, "errorObject");
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    __name(errorInstancePath, "errorInstancePath");
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    __name(errorSchemaPath, "errorSchemaPath");
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
    __name(extraErrorProps, "extraErrorProps");
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen: gen5, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen5.return(names_1.default.data);
      } else {
        gen5.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen5.return(true);
      }
    }
    __name(topBoolOrEmptySchema, "topBoolOrEmptySchema");
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen: gen5, schema } = it;
      if (schema === false) {
        gen5.var(valid, false);
        falseSchemaError(it);
      } else {
        gen5.var(valid, true);
      }
    }
    __name(boolOrEmptySchema, "boolOrEmptySchema");
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen: gen5, data } = it;
      const cxt = {
        gen: gen5,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
    __name(falseSchemaError, "falseSchemaError");
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    __name(isJSONType, "isJSONType");
    exports.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    __name(getRules, "getRules");
    exports.getRules = getRules;
  }
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group3 = self2.RULES.types[type];
      return group3 && group3 !== true && shouldUseGroup(schema, group3);
    }
    __name(schemaHasRulesForType, "schemaHasRulesForType");
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group3) {
      return group3.rules.some((rule) => shouldUseRule(schema, rule));
    }
    __name(shouldUseGroup, "shouldUseGroup");
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a2;
      return schema[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema[kwd] !== void 0));
    }
    __name(shouldUseRule, "shouldUseRule");
    exports.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    __name(getSchemaTypes, "getSchemaTypes");
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    __name(getJSONTypes, "getJSONTypes");
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen: gen5, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen5.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    __name(coerceAndCheckDataType, "coerceAndCheckDataType");
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    __name(coerceToTypes, "coerceToTypes");
    function coerceData(it, types, coerceTo) {
      const { gen: gen5, data, opts } = it;
      const dataType = gen5.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen5.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen5.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen5.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen5.assign(coerced, data)));
      }
      gen5.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen5.else();
      reportTypeError(it);
      gen5.endIf();
      gen5.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen5.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen5.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen5.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen5.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen5.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen5.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen5.assign(coerced, null);
            return;
          case "array":
            gen5.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
      __name(coerceSpecificType, "coerceSpecificType");
    }
    __name(coerceData, "coerceData");
    function assignParentData({ gen: gen5, parentData, parentDataProperty }, expr) {
      gen5.if((0, codegen_1._)`${parentData} !== undefined`, () => gen5.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    __name(assignParentData, "assignParentData");
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
      __name(numCond, "numCond");
    }
    __name(checkDataType, "checkDataType");
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    __name(checkDataTypes, "checkDataTypes");
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: /* @__PURE__ */ __name(({ schema }) => `must be ${schema}`, "message"),
      params: /* @__PURE__ */ __name(({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`, "params")
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    __name(reportTypeError, "reportTypeError");
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen: gen5, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen: gen5,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
    __name(getTypeErrorContext, "getTypeErrorContext");
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    __name(assignDefaults, "assignDefaults");
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen: gen5, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen5.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
    __name(assignDefault, "assignDefault");
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen: gen5, data, it } = cxt;
      gen5.if(noPropertyInData(gen5, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    __name(checkReportMissingProp, "checkReportMissingProp");
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen: gen5, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen5, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    __name(checkMissingProp, "checkMissingProp");
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    __name(reportMissingProp, "reportMissingProp");
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen5) {
      return gen5.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    __name(hasPropFunc, "hasPropFunc");
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen5, data, property2) {
      return (0, codegen_1._)`${hasPropFunc(gen5)}.call(${data}, ${property2})`;
    }
    __name(isOwnProperty, "isOwnProperty");
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen5, data, property2, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property2)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen5, data, property2)}` : cond;
    }
    __name(propertyInData, "propertyInData");
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen5, data, property2, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property2)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen5, data, property2))) : cond;
    }
    __name(noPropertyInData, "noPropertyInData");
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    __name(allSchemaProperties, "allSchemaProperties");
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    __name(schemaProperties, "schemaProperties");
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen: gen5, topSchemaRef, schemaPath, errorPath }, it }, func2, context10, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args2 = (0, codegen_1._)`${dataAndSchema}, ${gen5.object(...valCxt)}`;
      return context10 !== codegen_1.nil ? (0, codegen_1._)`${func2}.call(${context10}, ${args2})` : (0, codegen_1._)`${func2}(${args2})`;
    }
    __name(callValidateCode, "callValidateCode");
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen: gen5, it: { opts } }, pattern2) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern2, u);
      return gen5.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen5, regExp)}(${pattern2}, ${u})`
      });
    }
    __name(usePattern, "usePattern");
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen: gen5, data, keyword, it } = cxt;
      const valid = gen5.name("valid");
      if (it.allErrors) {
        const validArr = gen5.let("valid", true);
        validateItems(() => gen5.assign(validArr, false));
        return validArr;
      }
      gen5.var(valid, true);
      validateItems(() => gen5.break());
      return valid;
      function validateItems(notValid) {
        const len = gen5.const("len", (0, codegen_1._)`${data}.length`);
        gen5.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen5.if((0, codegen_1.not)(valid), notValid);
        });
      }
      __name(validateItems, "validateItems");
    }
    __name(validateArray, "validateArray");
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen: gen5, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen5.let("valid", false);
      const schValid = gen5.name("_valid");
      gen5.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen5.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen5.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    __name(validateUnion, "validateUnion");
    exports.validateUnion = validateUnion;
  }
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen: gen5, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen5, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen5.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    __name(macroKeywordCode, "macroKeywordCode");
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a2;
      const { gen: gen5, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate6 = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen5, keyword, validate6);
      const valid = gen5.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync2();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      __name(validateKeyword, "validateKeyword");
      function validateAsync() {
        const ruleErrs = gen5.let("ruleErrs", null);
        gen5.try(() => assignValid((0, codegen_1._)`await `), (e) => gen5.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen5.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen5.throw(e)));
        return ruleErrs;
      }
      __name(validateAsync, "validateAsync");
      function validateSync2() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen5.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      __name(validateSync2, "validateSync");
      function assignValid(_await4 = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen5.assign(valid, (0, codegen_1._)`${_await4}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      __name(assignValid, "assignValid");
      function reportErrs(errors) {
        var _a3;
        gen5.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== void 0 ? _a3 : valid), errors);
      }
      __name(reportErrs, "reportErrs");
    }
    __name(funcKeywordCode, "funcKeywordCode");
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen: gen5, data, it } = cxt;
      gen5.if(it.parentData, () => gen5.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    __name(modifyData, "modifyData");
    function addErrs(cxt, errs) {
      const { gen: gen5 } = cxt;
      gen5.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen5.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    __name(addErrs, "addErrs");
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    __name(checkAsyncKeyword, "checkAsyncKeyword");
    function useKeyword(gen5, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen5.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    __name(useKeyword, "useKeyword");
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    __name(validSchemaType, "validSchemaType");
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    __name(validateKeywordUsage, "validateKeywordUsage");
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    __name(getSubschema, "getSubschema");
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen: gen5 } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen5.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen5.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
      __name(dataContextProps, "dataContextProps");
    }
    __name(extendSubschemaData, "extendSubschemaData");
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    __name(extendSubschemaMode, "extendSubschemaMode");
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length4, i, keys5;
        if (Array.isArray(a)) {
          length4 = a.length;
          if (length4 != b.length) return false;
          for (i = length4; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys5 = Object.keys(a);
        length4 = keys5.length;
        if (length4 !== Object.keys(b).length) return false;
        for (i = length4; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys5[i])) return false;
        for (i = length4; i-- !== 0; ) {
          var key = keys5[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    }, "equal");
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre2 = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre2, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre2, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre2(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre2, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre2, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre2, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    __name(_traverse, "_traverse");
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    __name(escapeJsonPtr, "escapeJsonPtr");
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    __name(inlineRef, "inlineRef");
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    __name(hasRef, "hasRef");
    function countKeys(schema) {
      let count6 = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count6++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count6 += countKeys(sch));
        }
        if (count6 === Infinity)
          return Infinity;
      }
      return count6;
    }
    __name(countKeys, "countKeys");
    function getFullPath(resolver, id2 = "", normalize2) {
      if (normalize2 !== false)
        id2 = normalizeId(id2);
      const p = resolver.parse(id2);
      return _getFullPath(resolver, p);
    }
    __name(getFullPath, "getFullPath");
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    __name(_getFullPath, "_getFullPath");
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id2) {
      return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
    }
    __name(normalizeId, "normalizeId");
    exports.normalizeId = normalizeId;
    function resolveUrl2(resolver, baseId, id2) {
      id2 = normalizeId(id2);
      return resolver.resolve(baseId, id2);
    }
    __name(resolveUrl2, "resolveUrl");
    exports.resolveUrl = resolveUrl2;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref2) {
          const _resolve = this.opts.uriResolver.resolve;
          ref2 = normalizeId(innerBaseId ? _resolve(innerBaseId, ref2) : ref2);
          if (schemaRefs.has(ref2))
            throw ambiguos(ref2);
          schemaRefs.add(ref2);
          let schOrRef = this.refs[ref2];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref2);
          } else if (ref2 !== normalizeId(fullPath)) {
            if (ref2[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref2], ref2);
              localRefs[ref2] = sch;
            } else {
              this.refs[ref2] = fullPath;
            }
          }
          return ref2;
        }
        __name(addRef, "addRef");
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
        __name(addAnchor, "addAnchor");
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref2) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref2);
      }
      __name(checkAmbiguosRef, "checkAmbiguosRef");
      function ambiguos(ref2) {
        return new Error(`reference "${ref2}" resolves to more than one schema`);
      }
      __name(ambiguos, "ambiguos");
    }
    __name(getSchemaRefs, "getSchemaRefs");
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    __name(validateFunctionCode, "validateFunctionCode");
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen: gen5, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen5.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen5.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen5, opts);
          gen5.code(body);
        });
      } else {
        gen5.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen5.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    __name(validateFunction, "validateFunction");
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    __name(destructureValCxt, "destructureValCxt");
    function destructureValCxtES5(gen5, opts) {
      gen5.if(names_1.default.valCxt, () => {
        gen5.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen5.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen5.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen5.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen5.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen5.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen5.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen5.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen5.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen5.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    __name(destructureValCxtES5, "destructureValCxtES5");
    function topSchemaObjCode(it) {
      const { schema, opts, gen: gen5 } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen5.let(names_1.default.vErrors, null);
        gen5.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    __name(topSchemaObjCode, "topSchemaObjCode");
    function resetEvaluated(it) {
      const { gen: gen5, validateName } = it;
      it.evaluated = gen5.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen5.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen5.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen5.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen5.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    __name(resetEvaluated, "resetEvaluated");
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    __name(funcSourceUrl, "funcSourceUrl");
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    __name(subschemaCode, "subschemaCode");
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    __name(schemaCxtHasRules, "schemaCxtHasRules");
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    __name(isSchemaObj, "isSchemaObj");
    function subSchemaObjCode(it, valid) {
      const { schema, gen: gen5, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext3(it);
      checkAsyncSchema(it);
      const errsCount = gen5.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen5.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    __name(subSchemaObjCode, "subSchemaObjCode");
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    __name(checkKeywords, "checkKeywords");
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    __name(typeAndKeywords, "typeAndKeywords");
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    __name(checkRefsAndKeywords, "checkRefsAndKeywords");
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    __name(checkNoDefault, "checkNoDefault");
    function updateContext3(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    __name(updateContext3, "updateContext");
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    __name(checkAsyncSchema, "checkAsyncSchema");
    function commentKeyword({ gen: gen5, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen5.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen5.scopeValue("root", { ref: schemaEnv.root });
        gen5.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    __name(commentKeyword, "commentKeyword");
    function returnResults(it) {
      const { gen: gen5, schemaEnv, validateName, ValidationError: ValidationError2, opts } = it;
      if (schemaEnv.$async) {
        gen5.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen5.return(names_1.default.data), () => gen5.throw((0, codegen_1._)`new ${ValidationError2}(${names_1.default.vErrors})`));
      } else {
        gen5.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen5.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    __name(returnResults, "returnResults");
    function assignEvaluated({ gen: gen5, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen5.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen5.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    __name(assignEvaluated, "assignEvaluated");
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen: gen5, schema, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen5.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen5.block(() => {
        for (const group3 of RULES.rules)
          groupKeywords(group3);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group3) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group3))
          return;
        if (group3.type) {
          gen5.if((0, dataType_2.checkDataType)(group3.type, data, opts.strictNumbers));
          iterateKeywords(it, group3);
          if (types.length === 1 && types[0] === group3.type && typeErrors) {
            gen5.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen5.endIf();
        } else {
          iterateKeywords(it, group3);
        }
        if (!allErrors)
          gen5.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
      __name(groupKeywords, "groupKeywords");
    }
    __name(schemaKeywords, "schemaKeywords");
    function iterateKeywords(it, group3) {
      const { gen: gen5, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group3.type);
      gen5.block(() => {
        for (const rule of group3.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group3.type);
          }
        }
      });
    }
    __name(iterateKeywords, "iterateKeywords");
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    __name(checkStrictTypes, "checkStrictTypes");
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    __name(checkContextTypes, "checkContextTypes");
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    __name(checkMultipleTypes, "checkMultipleTypes");
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    __name(checkKeywordTypes, "checkKeywordTypes");
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    __name(hasApplicableType, "hasApplicableType");
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    __name(includesType, "includesType");
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    __name(narrowSchemaTypes, "narrowSchemaTypes");
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    __name(strictTypesError, "strictTypesError");
    var KeywordCxt = class {
      static {
        __name(this, "KeywordCxt");
      }
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append4, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append4, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append4, errorPaths);
      }
      _error(append4, errorPaths) {
        ;
        (append4 ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen: gen5, schemaCode, schemaType, def } = this;
        gen5.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen5.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen5.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen5.assign(valid, false);
        }
        gen5.else();
      }
      invalid$data() {
        const { gen: gen5, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        __name(wrong$DataType, "wrong$DataType");
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen5.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
        __name(invalid$DataSchema, "invalid$DataSchema");
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen: gen5 } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen5, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen5, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen: gen5 } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen5.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    __name(keywordCode, "keywordCode");
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
      __name(errorMsg, "errorMsg");
    }
    __name(getData, "getData");
    exports.getData = getData;
  }
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError2 = class extends Error {
      static {
        __name(this, "ValidationError");
      }
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError2;
  }
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      static {
        __name(this, "MissingRefError");
      }
      constructor(resolver, baseId, ref2, msg) {
        super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref2);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      static {
        __name(this, "SchemaEnv");
      }
      constructor(env2) {
        var _a2;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env2.schema == "object")
          schema = env2.schema;
        this.schema = env2.schema;
        this.schemaId = env2.schemaId;
        this.root = env2.root || this;
        this.baseId = (_a2 = env2.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env2.schemaId || "$id"]);
        this.schemaPath = env2.schemaPath;
        this.localRefs = env2.localRefs;
        this.meta = env2.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen5 = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen5.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen5.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen: gen5,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen5.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen5.optimize(this.opts.code.optimize);
        const validateCode = gen5.toString();
        sourceCode = `${gen5.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate6 = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate6 });
        validate6.errors = null;
        validate6.schema = sch.schema;
        validate6.schemaEnv = sch;
        if (sch.$async)
          validate6.$async = true;
        if (this.opts.code.source === true) {
          validate6.source = { validateName, validateCode, scopeValues: gen5._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate6.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate6.source)
            validate6.source.evaluated = (0, codegen_1.stringify)(validate6.evaluated);
        }
        sch.validate = validate6;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    __name(compileSchema, "compileSchema");
    exports.compileSchema = compileSchema;
    function resolveRef2(root, baseId, ref2) {
      var _a2;
      ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
      const schOrFunc = root.refs[ref2];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref2);
      if (_sch === void 0) {
        const schema = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref2];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref2] = inlineOrCompile.call(this, _sch);
    }
    __name(resolveRef2, "resolveRef");
    exports.resolveRef = resolveRef2;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    __name(inlineOrCompile, "inlineOrCompile");
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    __name(getCompilingSchema, "getCompilingSchema");
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    __name(sameSchemaEnv, "sameSchemaEnv");
    function resolve(root, ref2) {
      let sch;
      while (typeof (sch = this.refs[ref2]) == "string")
        ref2 = sch;
      return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
    }
    __name(resolve, "resolve");
    function resolveSchema(root, ref2) {
      const p = this.opts.uriResolver.parse(ref2);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id2 = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id2] || this.schemas[id2];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id2 === (0, resolve_1.normalizeId)(ref2)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    __name(resolveSchema, "resolveSchema");
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a2;
      if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env2;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env2 = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env2 = env2 || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env2.schema !== env2.root.schema)
        return env2;
      return void 0;
    }
    __name(getJsonPointer, "getJsonPointer");
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "node_modules/fast-uri/lib/utils.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
    var isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function stringArrayToHexStripped(input) {
      let acc = "";
      let code = 0;
      let i = 0;
      for (i = 0; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (code === 48) {
          continue;
        }
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
        break;
      }
      for (i += 1; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
      }
      return acc;
    }
    __name(stringArrayToHexStripped, "stringArrayToHexStripped");
    var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function consumeIsZone(buffer3) {
      buffer3.length = 0;
      return true;
    }
    __name(consumeIsZone, "consumeIsZone");
    function consumeHextets(buffer3, address, output) {
      if (buffer3.length) {
        const hex3 = stringArrayToHexStripped(buffer3);
        if (hex3 !== "") {
          address.push(hex3);
        } else {
          output.error = true;
          return false;
        }
        buffer3.length = 0;
      }
      return true;
    }
    __name(consumeHextets, "consumeHextets");
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer3 = [];
      let endipv6Encountered = false;
      let endIpv6 = false;
      let consume = consumeHextets;
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume(buffer3, address, output)) {
            break;
          }
          if (++tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i > 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          address.push(":");
          continue;
        } else if (cursor === "%") {
          if (!consume(buffer3, address, output)) {
            break;
          }
          consume = consumeIsZone;
        } else {
          buffer3.push(cursor);
          continue;
        }
      }
      if (buffer3.length) {
        if (consume === consumeIsZone) {
          output.zone = buffer3.join("");
        } else if (endIpv6) {
          address.push(buffer3.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer3));
        }
      }
      output.address = address.join("");
      return output;
    }
    __name(getIPV6, "getIPV6");
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv63 = getIPV6(host);
      if (!ipv63.error) {
        let newHost = ipv63.address;
        let escapedHost = ipv63.address;
        if (ipv63.zone) {
          newHost += "%" + ipv63.zone;
          escapedHost += "%25" + ipv63.zone;
        }
        return { host: newHost, isIPV6: true, escapedHost };
      } else {
        return { host, isIPV6: false };
      }
    }
    __name(normalizeIPv6, "normalizeIPv6");
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    __name(findToken, "findToken");
    function removeDotSegments(path) {
      let input = path;
      const output = [];
      let nextSlash = -1;
      let len = 0;
      while (len = input.length) {
        if (len === 1) {
          if (input === ".") {
            break;
          } else if (input === "/") {
            output.push("/");
            break;
          } else {
            output.push(input);
            break;
          }
        } else if (len === 2) {
          if (input[0] === ".") {
            if (input[1] === ".") {
              break;
            } else if (input[1] === "/") {
              input = input.slice(2);
              continue;
            }
          } else if (input[0] === "/") {
            if (input[1] === "." || input[1] === "/") {
              output.push("/");
              break;
            }
          }
        } else if (len === 3) {
          if (input === "/..") {
            if (output.length !== 0) {
              output.pop();
            }
            output.push("/");
            break;
          }
        }
        if (input[0] === ".") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(3);
              continue;
            }
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(2);
              continue;
            } else if (input[2] === ".") {
              if (input[3] === "/") {
                input = input.slice(3);
                if (output.length !== 0) {
                  output.pop();
                }
                continue;
              }
            }
          }
        }
        if ((nextSlash = input.indexOf("/", 1)) === -1) {
          output.push(input);
          break;
        } else {
          output.push(input.slice(0, nextSlash));
          input = input.slice(nextSlash);
        }
      }
      return output.join("");
    }
    __name(removeDotSegments, "removeDotSegments");
    function normalizeComponentEncoding(component, esc2) {
      const func2 = esc2 !== true ? escape : unescape;
      if (component.scheme !== void 0) {
        component.scheme = func2(component.scheme);
      }
      if (component.userinfo !== void 0) {
        component.userinfo = func2(component.userinfo);
      }
      if (component.host !== void 0) {
        component.host = func2(component.host);
      }
      if (component.path !== void 0) {
        component.path = func2(component.path);
      }
      if (component.query !== void 0) {
        component.query = func2(component.query);
      }
      if (component.fragment !== void 0) {
        component.fragment = func2(component.fragment);
      }
      return component;
    }
    __name(normalizeComponentEncoding, "normalizeComponentEncoding");
    function recomposeAuthority(component) {
      const uriTokens = [];
      if (component.userinfo !== void 0) {
        uriTokens.push(component.userinfo);
        uriTokens.push("@");
      }
      if (component.host !== void 0) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
          const ipV6res = normalizeIPv6(host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = component.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof component.port === "number" || typeof component.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(component.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    __name(recomposeAuthority, "recomposeAuthority");
    module.exports = {
      nonSimpleDomain,
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      isIPv4,
      isUUID,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/fast-uri/lib/schemes.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { isUUID } = require_utils();
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    var supportedSchemeNames = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function isValidSchemeName(name) {
      return supportedSchemeNames.indexOf(
        /** @type {*} */
        name
      ) !== -1;
    }
    __name(isValidSchemeName, "isValidSchemeName");
    function wsIsSecure(wsComponent) {
      if (wsComponent.secure === true) {
        return true;
      } else if (wsComponent.secure === false) {
        return false;
      } else if (wsComponent.scheme) {
        return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
      } else {
        return false;
      }
    }
    __name(wsIsSecure, "wsIsSecure");
    function httpParse(component) {
      if (!component.host) {
        component.error = component.error || "HTTP URIs must have a host.";
      }
      return component;
    }
    __name(httpParse, "httpParse");
    function httpSerialize(component) {
      const secure = String(component.scheme).toLowerCase() === "https";
      if (component.port === (secure ? 443 : 80) || component.port === "") {
        component.port = void 0;
      }
      if (!component.path) {
        component.path = "/";
      }
      return component;
    }
    __name(httpSerialize, "httpSerialize");
    function wsParse(wsComponent) {
      wsComponent.secure = wsIsSecure(wsComponent);
      wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
      wsComponent.path = void 0;
      wsComponent.query = void 0;
      return wsComponent;
    }
    __name(wsParse, "wsParse");
    function wsSerialize(wsComponent) {
      if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
        wsComponent.port = void 0;
      }
      if (typeof wsComponent.secure === "boolean") {
        wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
        wsComponent.secure = void 0;
      }
      if (wsComponent.resourceName) {
        const [path, query] = wsComponent.resourceName.split("?");
        wsComponent.path = path && path !== "/" ? path : void 0;
        wsComponent.query = query;
        wsComponent.resourceName = void 0;
      }
      wsComponent.fragment = void 0;
      return wsComponent;
    }
    __name(wsSerialize, "wsSerialize");
    function urnParse(urnComponent, options) {
      if (!urnComponent.path) {
        urnComponent.error = "URN can not be parsed";
        return urnComponent;
      }
      const matches = urnComponent.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponent.scheme || "urn";
        urnComponent.nid = matches[1].toLowerCase();
        urnComponent.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
        const schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = void 0;
        if (schemeHandler) {
          urnComponent = schemeHandler.parse(urnComponent, options);
        }
      } else {
        urnComponent.error = urnComponent.error || "URN can not be parsed.";
      }
      return urnComponent;
    }
    __name(urnParse, "urnParse");
    function urnSerialize(urnComponent, options) {
      if (urnComponent.nid === void 0) {
        throw new Error("URN without nid cannot be serialized");
      }
      const scheme = options.scheme || urnComponent.scheme || "urn";
      const nid = urnComponent.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      if (schemeHandler) {
        urnComponent = schemeHandler.serialize(urnComponent, options);
      }
      const uriComponent = urnComponent;
      const nss = urnComponent.nss;
      uriComponent.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponent;
    }
    __name(urnSerialize, "urnSerialize");
    function urnuuidParse(urnComponent, options) {
      const uuidComponent = urnComponent;
      uuidComponent.uuid = uuidComponent.nss;
      uuidComponent.nss = void 0;
      if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
        uuidComponent.error = uuidComponent.error || "UUID is not valid.";
      }
      return uuidComponent;
    }
    __name(urnuuidParse, "urnuuidParse");
    function urnuuidSerialize(uuidComponent) {
      const urnComponent = uuidComponent;
      urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
      return urnComponent;
    }
    __name(urnuuidSerialize, "urnuuidSerialize");
    var http = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: true,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var https = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var ws = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: true,
        parse: wsParse,
        serialize: wsSerialize
      }
    );
    var wss = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      }
    );
    var urn = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: true
      }
    );
    var urnuuid = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: true
      }
    );
    var SCHEMES = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      }
    );
    Object.setPrototypeOf(SCHEMES, null);
    function getSchemeHandler(scheme) {
      return scheme && (SCHEMES[
        /** @type {SchemeName} */
        scheme
      ] || SCHEMES[
        /** @type {SchemeName} */
        scheme.toLowerCase()
      ]) || void 0;
    }
    __name(getSchemeHandler, "getSchemeHandler");
    module.exports = {
      wsIsSecure,
      SCHEMES,
      isValidSchemeName,
      getSchemeHandler
    };
  }
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/fast-uri/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
    var { SCHEMES, getSchemeHandler } = require_schemes();
    function normalize2(uri, options) {
      if (typeof uri === "string") {
        uri = /** @type {T} */
        serialize2(parse5(uri, options), options);
      } else if (typeof uri === "object") {
        uri = /** @type {T} */
        parse5(serialize2(uri, options), options);
      }
      return uri;
    }
    __name(normalize2, "normalize");
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
      const resolved = resolveComponent(parse5(baseURI, schemelessOptions), parse5(relativeURI, schemelessOptions), schemelessOptions, true);
      schemelessOptions.skipEscape = true;
      return serialize2(resolved, schemelessOptions);
    }
    __name(resolve, "resolve");
    function resolveComponent(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse5(serialize2(base, options), options);
        relative = parse5(serialize2(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path[0] === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    __name(resolveComponent, "resolveComponent");
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize2(normalizeComponentEncoding(parse5(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize2(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize2(normalizeComponentEncoding(parse5(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize2(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    __name(equal, "equal");
    function serialize2(cmpts, opts) {
      const component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
      if (component.path !== void 0) {
        if (!options.skipEscape) {
          component.path = escape(component.path);
          if (component.scheme !== void 0) {
            component.path = component.path.split("%3A").join(":");
          }
        } else {
          component.path = unescape(component.path);
        }
      }
      if (options.reference !== "suffix" && component.scheme) {
        uriTokens.push(component.scheme, ":");
      }
      const authority = recomposeAuthority(component);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (component.path && component.path[0] !== "/") {
          uriTokens.push("/");
        }
      }
      if (component.path !== void 0) {
        let s = component.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0 && s[0] === "/" && s[1] === "/") {
          s = "/%2F" + s.slice(2);
        }
        uriTokens.push(s);
      }
      if (component.query !== void 0) {
        uriTokens.push("?", component.query);
      }
      if (component.fragment !== void 0) {
        uriTokens.push("#", component.fragment);
      }
      return uriTokens.join("");
    }
    __name(serialize2, "serialize");
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse5(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      let isIP = false;
      if (options.reference === "suffix") {
        if (options.scheme) {
          uri = options.scheme + ":" + uri;
        } else {
          uri = "//" + uri;
        }
      }
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = isIPv4(parsed.host);
          if (ipv4result === false) {
            const ipv6result = normalizeIPv6(parsed.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (uri.indexOf("%") !== -1) {
            if (parsed.scheme !== void 0) {
              parsed.scheme = unescape(parsed.scheme);
            }
            if (parsed.host !== void 0) {
              parsed.host = unescape(parsed.host);
            }
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    __name(parse5, "parse");
    var fastUri = {
      SCHEMES,
      normalize: normalize2,
      resolve,
      resolveComponent,
      equal,
      serialize: serialize2,
      parse: parse5
    };
    module.exports = fastUri;
    module.exports.default = fastUri;
    module.exports.fastUri = fastUri;
  }
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return validate_1.KeywordCxt;
    }, "get") });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return codegen_1._;
    }, "get") });
    Object.defineProperty(exports, "str", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return codegen_1.str;
    }, "get") });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return codegen_1.stringify;
    }, "get") });
    Object.defineProperty(exports, "nil", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return codegen_1.nil;
    }, "get") });
    Object.defineProperty(exports, "Name", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return codegen_1.Name;
    }, "get") });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return codegen_1.CodeGen;
    }, "get") });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = /* @__PURE__ */ __name((str, flags) => new RegExp(str, flags), "defaultRegExp");
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a2 = o.code) === null || _a2 === void 0 ? void 0 : _a2.optimize;
      const optimize2 = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize: optimize2, regExp } : { optimize: optimize2, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    __name(requiredOptions, "requiredOptions");
    var Ajv2 = class {
      static {
        __name(this, "Ajv");
      }
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta: meta3, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta3 && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta: meta3, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta3 == "object" ? meta3[schemaId] || meta3 : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta3) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta3);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        __name(runCompileAsync, "runCompileAsync");
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        __name(loadMetaSchema, "loadMetaSchema");
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        __name(_compileAsync, "_compileAsync");
        function checkLoaded({ missingSchema: ref2, missingRef }) {
          if (this.refs[ref2]) {
            throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        __name(checkLoaded, "checkLoaded");
        async function loadMissingSchema(ref2) {
          const _schema = await _loadSchema.call(this, ref2);
          if (!this.refs[ref2])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref2])
            this.addSchema(_schema, ref2, meta3);
        }
        __name(loadMissingSchema, "loadMissingSchema");
        async function _loadSchema(ref2) {
          const p = this._loading[ref2];
          if (p)
            return p;
          try {
            return await (this._loading[ref2] = loadSchema(ref2));
          } finally {
            delete this._loading[ref2];
          }
        }
        __name(_loadSchema, "_loadSchema");
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id2;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id2 = schema[schemaId];
          if (id2 !== void 0 && typeof id2 != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id2);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id2 = schemaKeyRef[this.opts.schemaId];
            if (id2) {
              id2 = (0, resolve_1.normalizeId)(id2);
              delete this.schemas[id2];
              delete this.refs[id2];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group3 of RULES.rules) {
          const i = group3.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group3.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format7) {
        if (typeof format7 == "string")
          format7 = new RegExp(format7);
        this.formats[name] = format7;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text2, msg) => text2 + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta3, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id2;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id2 = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id2 || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta: meta3, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id2) {
        if (this.schemas[id2] || this.refs[id2]) {
          throw new Error(`schema with key or id "${id2}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log5 = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log5](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    __name(checkOptions, "checkOptions");
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    __name(getSchEnv, "getSchEnv");
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    __name(addInitialSchemas, "addInitialSchemas");
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format7 = this.opts.formats[name];
        if (format7)
          this.addFormat(name, format7);
      }
    }
    __name(addInitialFormats, "addInitialFormats");
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    __name(addInitialKeywords, "addInitialKeywords");
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    __name(getMetaSchemaOptions, "getMetaSchemaOptions");
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    __name(getLogger, "getLogger");
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    __name(checkKeyword, "checkKeyword");
    function addRule(keyword, definition, dataType) {
      var _a2;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a2 = definition.implements) === null || _a2 === void 0 ? void 0 : _a2.forEach((kwd) => this.addKeyword(kwd));
    }
    __name(addRule, "addRule");
    function addBeforeRule(ruleGroup, rule, before2) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before2);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before2} is not defined`);
      }
    }
    __name(addBeforeRule, "addBeforeRule");
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    __name(keywordMetaschema, "keywordMetaschema");
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
    __name(schemaOrData, "schemaOrData");
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen: gen5, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env2, validateName, opts, self: self2 } = it;
        const { root } = env2;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env2 === root)
            return callRef(cxt, validateName, env2, env2.$async);
          const rootName = gen5.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        __name(callRootRef, "callRootRef");
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        __name(callValidate, "callValidate");
        function inlineRefSchema(sch) {
          const schName = gen5.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen5.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
        __name(inlineRefSchema, "inlineRefSchema");
      }
    };
    function getValidate(cxt, sch) {
      const { gen: gen5 } = cxt;
      return sch.validate ? gen5.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen5.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    __name(getValidate, "getValidate");
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen: gen5, it } = cxt;
      const { allErrors, schemaEnv: env2, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env2.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen5.let("valid");
        gen5.try(() => {
          gen5.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen5.assign(valid, true);
        }, (e) => {
          gen5.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen5.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen5.assign(valid, false);
        });
        cxt.ok(valid);
      }
      __name(callAsyncRef, "callAsyncRef");
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      __name(callSyncRef, "callSyncRef");
      function addErrorsFrom(source2) {
        const errs = (0, codegen_1._)`${source2}.errors`;
        gen5.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen5.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      __name(addErrorsFrom, "addErrorsFrom");
      function addEvaluatedFrom(source2) {
        var _a2;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a2 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen5, schEvaluated.props, it.props);
            }
          } else {
            const props = gen5.var("props", (0, codegen_1._)`${source2}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen5, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen5, schEvaluated.items, it.items);
            }
          } else {
            const items = gen5.var("items", (0, codegen_1._)`${source2}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen5, items, it.items, codegen_1.Name);
          }
        }
      }
      __name(addEvaluatedFrom, "addEvaluatedFrom");
    }
    __name(callRef, "callRef");
    exports.callRef = callRef;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error50 = {
      message: /* @__PURE__ */ __name(({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`, "message"),
      params: /* @__PURE__ */ __name(({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`, "params")
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error: error50,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error50 = {
      message: /* @__PURE__ */ __name(({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`, "message"),
      params: /* @__PURE__ */ __name(({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`, "params")
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error: error50,
      code(cxt) {
        const { gen: gen5, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen5.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length4 = 0;
      let pos = 0;
      let value3;
      while (pos < len) {
        length4++;
        value3 = str.charCodeAt(pos++);
        if (value3 >= 55296 && value3 <= 56319 && pos < len) {
          value3 = str.charCodeAt(pos);
          if ((value3 & 64512) === 56320)
            pos++;
        }
      }
      return length4;
    }
    __name(ucs2length, "ucs2length");
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error50 = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: /* @__PURE__ */ __name(({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`, "params")
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error: error50,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error50 = {
      message: /* @__PURE__ */ __name(({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`, "message"),
      params: /* @__PURE__ */ __name(({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`, "params")
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error: error50,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error50 = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: /* @__PURE__ */ __name(({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`, "params")
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error: error50,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error50 = {
      message: /* @__PURE__ */ __name(({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`, "message"),
      params: /* @__PURE__ */ __name(({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`, "params")
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error: error50,
      code(cxt) {
        const { gen: gen5, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        __name(allErrorsMode, "allErrorsMode");
        function exitOnErrorMode() {
          const missing = gen5.let("missing");
          if (useLoop || $data) {
            const valid = gen5.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen5.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen5.else();
          }
        }
        __name(exitOnErrorMode, "exitOnErrorMode");
        function loopAllRequired() {
          gen5.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen5.if((0, code_1.noPropertyInData)(gen5, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        __name(loopAllRequired, "loopAllRequired");
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen5.forOf(missing, schemaCode, () => {
            gen5.assign(valid, (0, code_1.propertyInData)(gen5, data, missing, opts.ownProperties));
            gen5.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen5.break();
            });
          }, codegen_1.nil);
        }
        __name(loopUntilMissing, "loopUntilMissing");
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error50 = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: /* @__PURE__ */ __name(({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`, "params")
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error: error50,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error50 = {
      message: /* @__PURE__ */ __name(({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`, "message"),
      params: /* @__PURE__ */ __name(({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`, "params")
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error: error50,
      code(cxt) {
        const { gen: gen5, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen5.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen5.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen5.let("j");
          cxt.setParams({ i, j });
          gen5.assign(valid, true);
          gen5.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        __name(validateUniqueItems, "validateUniqueItems");
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        __name(canOptimize, "canOptimize");
        function loopN(i, j) {
          const item = gen5.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen5.const("indices", (0, codegen_1._)`{}`);
          gen5.for((0, codegen_1._)`;${i}--;`, () => {
            gen5.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen5.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen5.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen5.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen5.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen5.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        __name(loopN, "loopN");
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen5, equal_1.default);
          const outer = gen5.name("outer");
          gen5.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen5.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen5.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen5.assign(valid, false).break(outer);
          })));
        }
        __name(loopN2, "loopN2");
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error50 = {
      message: "must be equal to constant",
      params: /* @__PURE__ */ __name(({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`, "params")
    };
    var def = {
      keyword: "const",
      $data: true,
      error: error50,
      code(cxt) {
        const { gen: gen5, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen5, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error50 = {
      message: "must be equal to one of the allowed values",
      params: /* @__PURE__ */ __name(({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`, "params")
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error: error50,
      code(cxt) {
        const { gen: gen5, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = /* @__PURE__ */ __name(() => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen5, equal_1.default), "getEql");
        let valid;
        if (useLoop || $data) {
          valid = gen5.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen5.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen5.assign(valid, false);
          gen5.forOf("v", schemaCode, (v) => gen5.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen5.assign(valid, true).break()));
        }
        __name(loopEnum, "loopEnum");
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
        __name(equalCode, "equalCode");
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error50 = {
      message: /* @__PURE__ */ __name(({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`, "message"),
      params: /* @__PURE__ */ __name(({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`, "params")
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error: error50,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen: gen5, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen5.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen5.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen5.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen5.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen5.if((0, codegen_1.not)(valid), () => gen5.break());
        });
      }
      __name(validateItems, "validateItems");
    }
    __name(validateAdditionalItems, "validateAdditionalItems");
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen: gen5, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen5, schArr.length, it.items);
      }
      const valid = gen5.name("valid");
      const len = gen5.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen5.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
      __name(checkStrictTuple, "checkStrictTuple");
    }
    __name(validateTuple, "validateTuple");
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: /* @__PURE__ */ __name((cxt) => (0, items_1.validateTuple)(cxt, "items"), "code")
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error50 = {
      message: /* @__PURE__ */ __name(({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`, "message"),
      params: /* @__PURE__ */ __name(({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`, "params")
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error: error50,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error50 = {
      message: /* @__PURE__ */ __name(({ params: { min: min4, max: max6 } }) => max6 === void 0 ? (0, codegen_1.str)`must contain at least ${min4} valid item(s)` : (0, codegen_1.str)`must contain at least ${min4} and no more than ${max6} valid item(s)`, "message"),
      params: /* @__PURE__ */ __name(({ params: { min: min4, max: max6 } }) => max6 === void 0 ? (0, codegen_1._)`{minContains: ${min4}}` : (0, codegen_1._)`{minContains: ${min4}, maxContains: ${max6}}`, "params")
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error: error50,
      code(cxt) {
        const { gen: gen5, schema, parentSchema, data, it } = cxt;
        let min4;
        let max6;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min4 = minContains === void 0 ? 1 : minContains;
          max6 = maxContains;
        } else {
          min4 = 1;
        }
        const len = gen5.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min: min4, max: max6 });
        if (max6 === void 0 && min4 === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max6 !== void 0 && min4 > max6) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min4}`;
          if (max6 !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max6}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen5.name("valid");
        if (max6 === void 0 && min4 === 1) {
          validateItems(valid, () => gen5.if(valid, () => gen5.break()));
        } else if (min4 === 0) {
          gen5.let(valid, true);
          if (max6 !== void 0)
            gen5.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen5.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen5.name("_valid");
          const count6 = gen5.let("count", 0);
          validateItems(schValid, () => gen5.if(schValid, () => checkLimits(count6)));
        }
        __name(validateItemsWithCount, "validateItemsWithCount");
        function validateItems(_valid, block) {
          gen5.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        __name(validateItems, "validateItems");
        function checkLimits(count6) {
          gen5.code((0, codegen_1._)`${count6}++`);
          if (max6 === void 0) {
            gen5.if((0, codegen_1._)`${count6} >= ${min4}`, () => gen5.assign(valid, true).break());
          } else {
            gen5.if((0, codegen_1._)`${count6} > ${max6}`, () => gen5.assign(valid, false).break());
            if (min4 === 1)
              gen5.assign(valid, true);
            else
              gen5.if((0, codegen_1._)`${count6} >= ${min4}`, () => gen5.assign(valid, true));
          }
        }
        __name(checkLimits, "checkLimits");
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports.error = {
      message: /* @__PURE__ */ __name(({ params: { property: property2, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property2} is present`;
      }, "message"),
      params: /* @__PURE__ */ __name(({ params: { property: property2, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property2},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`, "params")
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    __name(splitDependencies, "splitDependencies");
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen: gen5, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen5.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty2 = (0, code_1.propertyInData)(gen5, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen5.if(hasProperty2, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen5.if((0, codegen_1._)`${hasProperty2} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen5.else();
        }
      }
    }
    __name(validatePropertyDeps, "validatePropertyDeps");
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen: gen5, data, keyword, it } = cxt;
      const valid = gen5.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen5.if(
          (0, code_1.propertyInData)(gen5, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen5.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    __name(validateSchemaDeps, "validateSchemaDeps");
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error50 = {
      message: "property name must be valid",
      params: /* @__PURE__ */ __name(({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`, "params")
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error: error50,
      code(cxt) {
        const { gen: gen5, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen5.name("valid");
        gen5.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen5.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen5.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error50 = {
      message: "must NOT have additional properties",
      params: /* @__PURE__ */ __name(({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`, "params")
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error: error50,
      code(cxt) {
        const { gen: gen5, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen5.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen5.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        __name(checkAdditionalProperties, "checkAdditionalProperties");
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen5, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        __name(isAdditional, "isAdditional");
        function deleteAdditional(key) {
          gen5.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        __name(deleteAdditional, "deleteAdditional");
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen5.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen5.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen5.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen5.if((0, codegen_1.not)(valid), () => gen5.break());
            }
          }
        }
        __name(additionalPropertyCode, "additionalPropertyCode");
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
        __name(applyAdditionalSchema, "applyAdditionalSchema");
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen: gen5, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen5, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen5.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen5.if((0, code_1.propertyInData)(gen5, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen5.else().var(valid, true);
            gen5.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        __name(hasDefault, "hasDefault");
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
        __name(applyPropertySchema, "applyPropertySchema");
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen: gen5, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen5.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen5, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen5.var(valid, true);
              validateProperties(pat);
              gen5.if(valid);
            }
          }
        }
        __name(validatePatternProperties, "validatePatternProperties");
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        __name(checkMatchingProperties, "checkMatchingProperties");
        function validateProperties(pat) {
          gen5.forIn("key", data, (key) => {
            gen5.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen5.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen5.if((0, codegen_1.not)(valid), () => gen5.break());
              }
            });
          });
        }
        __name(validateProperties, "validateProperties");
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen: gen5, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen5.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error50 = {
      message: "must match exactly one schema in oneOf",
      params: /* @__PURE__ */ __name(({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`, "params")
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error: error50,
      code(cxt) {
        const { gen: gen5, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen5.let("valid", false);
        const passing = gen5.let("passing", null);
        const schValid = gen5.name("_valid");
        cxt.setParams({ passing });
        gen5.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen5.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen5.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen5.if(schValid, () => {
              gen5.assign(valid, true);
              gen5.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
        __name(validateOneOf, "validateOneOf");
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen: gen5, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen5.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error50 = {
      message: /* @__PURE__ */ __name(({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`, "message"),
      params: /* @__PURE__ */ __name(({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`, "params")
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error: error50,
      code(cxt) {
        const { gen: gen5, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen5.let("valid", true);
        const schValid = gen5.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen5.let("ifClause");
          cxt.setParams({ ifClause });
          gen5.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen5.if(schValid, validateClause("then"));
        } else {
          gen5.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        __name(validateIf, "validateIf");
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen5.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen5.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
        __name(validateClause, "validateClause");
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    __name(hasSchema, "hasSchema");
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    __name(getApplicator, "getApplicator");
    exports.default = getApplicator;
  }
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error50 = {
      message: /* @__PURE__ */ __name(({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`, "message"),
      params: /* @__PURE__ */ __name(({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`, "params")
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error: error50,
      code(cxt, ruleType) {
        const { gen: gen5, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen5.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen5.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen5.let("fType");
          const format7 = gen5.let("format");
          gen5.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen5.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format7, (0, codegen_1._)`${fDef}.validate`), () => gen5.assign(fType, (0, codegen_1._)`"string"`).assign(format7, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format7}`;
          }
          __name(unknownFmt, "unknownFmt");
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format7}(${data}) : ${format7}(${data}))` : (0, codegen_1._)`${format7}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format7} == "function" ? ${callFormat} : ${format7}.test(${data}))`;
            return (0, codegen_1._)`${format7} && ${format7} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
          __name(invalidFmt, "invalidFmt");
        }
        __name(validate$DataFormat, "validate$DataFormat");
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format7, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
            __name(unknownMsg, "unknownMsg");
          }
          __name(unknownFormat, "unknownFormat");
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen5.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          __name(getFormat, "getFormat");
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format7 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
          __name(validCondition, "validCondition");
        }
        __name(validateFormat, "validateFormat");
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format();
    var format7 = [format_1.default];
    exports.default = format7;
  }
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports.DiscrError = DiscrError = {}));
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error50 = {
      message: /* @__PURE__ */ __name(({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`, "message"),
      params: /* @__PURE__ */ __name(({ params: { discrError, tag: tag2, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag2}}`, "params")
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error: error50,
      code(cxt) {
        const { gen: gen5, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen5.let("valid", false);
        const tag2 = gen5.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen5.if((0, codegen_1._)`typeof ${tag2} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag: tag2, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen5.if(false);
          for (const tagValue in mapping) {
            gen5.elseIf((0, codegen_1._)`${tag2} === ${tagValue}`);
            gen5.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen5.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag: tag2, tagName });
          gen5.endIf();
        }
        __name(validateMapping, "validateMapping");
        function applyTagSchema(schemaProp) {
          const _valid = gen5.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        __name(applyTagSchema, "applyTagSchema");
        function getMapping() {
          var _a2;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref2 = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref2);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref2);
            }
            const propSch = (_a2 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required: required4 }) {
            return Array.isArray(required4) && required4.includes(tagName);
          }
          __name(hasRequired, "hasRequired");
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          __name(addMappings, "addMappings");
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
          __name(addMapping, "addMapping");
        }
        __name(getMapping, "getMapping");
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/dist/ajv.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv2 = class extends core_1.default {
      static {
        __name(this, "Ajv");
      }
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports.Ajv = Ajv2;
    module.exports = exports = Ajv2;
    module.exports.Ajv = Ajv2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return validate_1.KeywordCxt;
    }, "get") });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return codegen_1._;
    }, "get") });
    Object.defineProperty(exports, "str", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return codegen_1.str;
    }, "get") });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return codegen_1.stringify;
    }, "get") });
    Object.defineProperty(exports, "nil", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return codegen_1.nil;
    }, "get") });
    Object.defineProperty(exports, "Name", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return codegen_1.Name;
    }, "get") });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return codegen_1.CodeGen;
    }, "get") });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return validation_error_1.default;
    }, "get") });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ref_error_1.default;
    }, "get") });
  }
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "node_modules/ajv-formats/dist/formats.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
    function fmtDef(validate6, compare2) {
      return { validate: validate6, compare: compare2 };
    }
    __name(fmtDef, "fmtDef");
    exports.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date7, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(true), compareTime),
      "date-time": fmtDef(getDateTime(true), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports.fastFormats = {
      ...exports.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports.formatNames = Object.keys(exports.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    __name(isLeapYear, "isLeapYear");
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date7(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    __name(date7, "date");
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    __name(compareDate, "compareDate");
    var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return /* @__PURE__ */ __name(function time5(str) {
        const matches = TIME.exec(str);
        if (!matches)
          return false;
        const hr = +matches[1];
        const min4 = +matches[2];
        const sec = +matches[3];
        const tz = matches[4];
        const tzSign = matches[5] === "-" ? -1 : 1;
        const tzH = +(matches[6] || 0);
        const tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return false;
        if (hr <= 23 && min4 <= 59 && sec < 60)
          return true;
        const utcMin = min4 - tzM * tzSign;
        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      }, "time");
    }
    __name(getTime, "getTime");
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return void 0;
      const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
      const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (!(t1 && t2))
        return void 0;
      return t1 - t2;
    }
    __name(compareTime, "compareTime");
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3];
      t2 = a2[1] + a2[2] + a2[3];
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    __name(compareIsoTime, "compareIsoTime");
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      const time5 = getTime(strictTimeZone);
      return /* @__PURE__ */ __name(function date_time(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date7(dateTime[0]) && time5(dateTime[1]);
      }, "date_time");
    }
    __name(getDateTime, "getDateTime");
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const d1 = new Date(dt1).valueOf();
      const d2 = new Date(dt2).valueOf();
      if (!(d1 && d2))
        return void 0;
      return d1 - d2;
    }
    __name(compareDateTime, "compareDateTime");
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    __name(compareIsoDateTime, "compareIsoDateTime");
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    __name(uri, "uri");
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    __name(byte, "byte");
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value3) {
      return Number.isInteger(value3) && value3 <= MAX_INT32 && value3 >= MIN_INT32;
    }
    __name(validateInt32, "validateInt32");
    function validateInt64(value3) {
      return Number.isInteger(value3);
    }
    __name(validateInt64, "validateInt64");
    function validateNumber() {
      return true;
    }
    __name(validateNumber, "validateNumber");
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
    __name(regex, "regex");
  }
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "node_modules/ajv-formats/dist/limit.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv();
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error50 = {
      message: /* @__PURE__ */ __name(({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`, "message"),
      params: /* @__PURE__ */ __name(({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`, "params")
    };
    exports.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error: error50,
      code(cxt) {
        const { gen: gen5, data, schemaCode, keyword, it } = cxt;
        const { opts, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen5.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fmt = gen5.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        __name(validate$DataFormat, "validate$DataFormat");
        function validateFormat() {
          const format7 = fCxt.schema;
          const fmtDef = self2.formats[format7];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword}": format "${format7}" does not define "compare" function`);
          }
          const fmt = gen5.scopeValue("formats", {
            key: format7,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format7)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        __name(validateFormat, "validateFormat");
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
        __name(compareCode, "compareCode");
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = /* @__PURE__ */ __name((ajv) => {
      ajv.addKeyword(exports.formatLimitDefinition);
      return ajv;
    }, "formatLimitPlugin");
    exports.default = formatLimitPlugin;
  }
});

// node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS({
  "node_modules/ajv-formats/dist/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = /* @__PURE__ */ __name((ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv, list, formats, exportName);
      if (opts.keywords)
        (0, limit_1.default)(ajv);
      return ajv;
    }, "formatsPlugin");
    formatsPlugin.get = (name, mode = "full") => {
      const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv, list, fs2, exportName) {
      var _a2;
      var _b;
      (_a2 = (_b = ajv.opts.code).formats) !== null && _a2 !== void 0 ? _a2 : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list)
        ajv.addFormat(f, fs2[f]);
    }
    __name(addFormats, "addFormats");
    module.exports = exports = formatsPlugin;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = formatsPlugin;
  }
});

// src/domain/Errors.ts
var Errors_exports = {};
__export(Errors_exports, {
  BlockedDomainError: () => BlockedDomainError,
  BrowserError: () => BrowserError,
  NetworkError: () => NetworkError,
  NotFoundError: () => NotFoundError,
  PathBrokenError: () => PathBrokenError,
  StoreError: () => StoreError,
  ValidationError: () => ValidationError
});
var NetworkError, BrowserError, PathBrokenError, StoreError, NotFoundError, ValidationError, BlockedDomainError;
var init_Errors = __esm({
  "src/domain/Errors.ts"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_esm();
    NetworkError = class extends Schema_exports.TaggedError()("NetworkError", {
      url: Schema_exports.String,
      status: Schema_exports.optional(Schema_exports.Number),
      message: Schema_exports.String
    }) {
      static {
        __name(this, "NetworkError");
      }
    };
    BrowserError = class extends Schema_exports.TaggedError()("BrowserError", {
      message: Schema_exports.String,
      screenshot: Schema_exports.optional(Schema_exports.String)
    }) {
      static {
        __name(this, "BrowserError");
      }
    };
    PathBrokenError = class extends Schema_exports.TaggedError()("PathBrokenError", {
      pathId: Schema_exports.String,
      step: Schema_exports.optional(Schema_exports.Number),
      reason: Schema_exports.String
    }) {
      static {
        __name(this, "PathBrokenError");
      }
    };
    StoreError = class extends Schema_exports.TaggedError()("StoreError", {
      message: Schema_exports.String
    }) {
      static {
        __name(this, "StoreError");
      }
    };
    NotFoundError = class extends Schema_exports.TaggedError()("NotFoundError", {
      id: Schema_exports.String,
      resource: Schema_exports.optional(Schema_exports.String)
    }) {
      static {
        __name(this, "NotFoundError");
      }
    };
    ValidationError = class extends Schema_exports.TaggedError()("ValidationError", {
      field: Schema_exports.String,
      message: Schema_exports.String
    }) {
      static {
        __name(this, "ValidationError");
      }
    };
    BlockedDomainError = class extends Schema_exports.TaggedError()(
      "BlockedDomainError",
      {
        domain: Schema_exports.String,
        message: Schema_exports.String
      }
    ) {
      static {
        __name(this, "BlockedDomainError");
      }
    };
  }
});

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/generated/version.js
var packageVersion;
var init_version2 = __esm({
  "node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/generated/version.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    packageVersion = "1.0.6";
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse5(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse5(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match20 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match20) {
        return;
      }
      var n = parseFloat(match20[1]);
      var type = (match20[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    __name(parse5, "parse");
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    __name(fmtShort, "fmtShort");
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    __name(fmtLong, "fmtLong");
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
    __name(plural, "plural");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable4;
      createDebug.enable = enable4;
      createDebug.enabled = enabled2;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash4 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash4 = (hash4 << 5) - hash4 + namespace.charCodeAt(i);
          hash4 |= 0;
        }
        return createDebug.colors[Math.abs(hash4) % createDebug.colors.length];
      }
      __name(selectColor, "selectColor");
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug4(...args2) {
          if (!debug4.enabled) {
            return;
          }
          const self2 = debug4;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args2[0] = createDebug.coerce(args2[0]);
          if (typeof args2[0] !== "string") {
            args2.unshift("%O");
          }
          let index2 = 0;
          args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match20, format7) => {
            if (match20 === "%%") {
              return "%";
            }
            index2++;
            const formatter = createDebug.formatters[format7];
            if (typeof formatter === "function") {
              const val = args2[index2];
              match20 = formatter.call(self2, val);
              args2.splice(index2, 1);
              index2--;
            }
            return match20;
          });
          createDebug.formatArgs.call(self2, args2);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args2);
        }
        __name(debug4, "debug");
        debug4.namespace = namespace;
        debug4.useColors = createDebug.useColors();
        debug4.color = createDebug.selectColor(namespace);
        debug4.extend = extend5;
        debug4.destroy = createDebug.destroy;
        Object.defineProperty(debug4, "enabled", {
          enumerable: true,
          configurable: false,
          get: /* @__PURE__ */ __name(() => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          }, "get"),
          set: /* @__PURE__ */ __name((v) => {
            enableOverride = v;
          }, "set")
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug4);
        }
        return debug4;
      }
      __name(createDebug, "createDebug");
      function extend5(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      __name(extend5, "extend");
      function enable4(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split4 = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split4) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      __name(enable4, "enable");
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      __name(matchesTemplate, "matchesTemplate");
      function disable4() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      __name(disable4, "disable");
      function enabled2(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      __name(enabled2, "enabled");
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      __name(coerce, "coerce");
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      __name(destroy, "destroy");
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    __name(setup, "setup");
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && "Cloudflare-Workers" && (m = "Cloudflare-Workers".toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && "Cloudflare-Workers" && "Cloudflare-Workers".toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    function formatArgs(args2) {
      args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args2.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args2[0].replace(/%[a-zA-Z%]/g, (match20) => {
        if (match20 === "%%") {
          return;
        }
        index2++;
        if (match20 === "%c") {
          lastC = index2;
        }
      });
      args2.splice(lastC, 0, c);
    }
    __name(formatArgs, "formatArgs");
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error50) {
      }
    }
    __name(save, "save");
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error50) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    __name(load, "load");
    function localstorage() {
      try {
        return localStorage;
      } catch (error50) {
      }
    }
    __name(localstorage, "localstorage");
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error50) {
        return "[UnexpectedJSONParseError]: " + error50.message;
      }
    };
  }
});

// node-built-in-modules:tty
var require_tty = __commonJS({
  "node-built-in-modules:tty"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    module.exports = tty_default;
  }
});

// node-built-in-modules:util
import libDefault from "util";
var require_util2 = __commonJS({
  "node-built-in-modules:util"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault;
  }
});

// node_modules/supports-color/browser.js
var require_browser2 = __commonJS({
  "node_modules/supports-color/browser.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      stdout: false,
      stderr: false
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var tty = require_tty();
    var util2 = require_util2();
    exports.init = init;
    exports.log = log5;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_browser2();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error50) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    __name(useColors, "useColors");
    function formatArgs(args2) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
        args2.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args2[0] = getDate() + name + " " + args2[0];
      }
    }
    __name(formatArgs, "formatArgs");
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    __name(getDate, "getDate");
    function log5(...args2) {
      return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args2) + "\n");
    }
    __name(log5, "log");
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    __name(save, "save");
    function load() {
      return process.env.DEBUG;
    }
    __name(load, "load");
    function init(debug4) {
      debug4.inspectOpts = {};
      const keys5 = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys5.length; i++) {
        debug4.inspectOpts[keys5[i]] = exports.inspectOpts[keys5[i]];
      }
    }
    __name(init, "init");
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  }
});

// node_modules/ws/browser.js
var require_browser3 = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/node/NodeWebSocketTransport.js
var NodeWebSocketTransport_exports = {};
__export(NodeWebSocketTransport_exports, {
  NodeWebSocketTransport: () => NodeWebSocketTransport
});
var import_ws, NodeWebSocketTransport;
var init_NodeWebSocketTransport = __esm({
  "node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/node/NodeWebSocketTransport.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    import_ws = __toESM(require_browser3(), 1);
    init_version2();
    NodeWebSocketTransport = class _NodeWebSocketTransport {
      static {
        __name(this, "NodeWebSocketTransport");
      }
      static create(url3, headers) {
        return new Promise((resolve, reject) => {
          const ws = new import_ws.default(url3, [], {
            followRedirects: true,
            perMessageDeflate: false,
            // @ts-expect-error https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketaddress-protocols-options
            allowSynchronousEvents: false,
            maxPayload: 256 * 1024 * 1024,
            // 256Mb
            headers: {
              "User-Agent": `Puppeteer ${packageVersion}`,
              ...headers
            }
          });
          ws.addEventListener("open", () => {
            return resolve(new _NodeWebSocketTransport(ws));
          });
          ws.addEventListener("error", reject);
        });
      }
      #ws;
      onmessage;
      onclose;
      constructor(ws) {
        this.#ws = ws;
        this.#ws.addEventListener("message", (event) => {
          if (this.onmessage) {
            this.onmessage.call(null, event.data);
          }
        });
        this.#ws.addEventListener("close", () => {
          if (this.onclose) {
            this.onclose.call(null);
          }
        });
        this.#ws.addEventListener("error", () => {
        });
      }
      send(message) {
        this.#ws.send(message);
      }
      close() {
        this.#ws.close();
      }
    };
  }
});

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/BrowserWebSocketTransport.js
var BrowserWebSocketTransport_exports = {};
__export(BrowserWebSocketTransport_exports, {
  BrowserWebSocketTransport: () => BrowserWebSocketTransport
});
var BrowserWebSocketTransport;
var init_BrowserWebSocketTransport = __esm({
  "node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/BrowserWebSocketTransport.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    BrowserWebSocketTransport = class _BrowserWebSocketTransport {
      static {
        __name(this, "BrowserWebSocketTransport");
      }
      static create(url3) {
        return new Promise((resolve, reject) => {
          const ws = new WebSocket(url3);
          ws.addEventListener("open", () => {
            return resolve(new _BrowserWebSocketTransport(ws));
          });
          ws.addEventListener("error", reject);
        });
      }
      #ws;
      onmessage;
      onclose;
      constructor(ws) {
        this.#ws = ws;
        this.#ws.addEventListener("message", (event) => {
          if (this.onmessage) {
            this.onmessage.call(null, event.data);
          }
        });
        this.#ws.addEventListener("close", () => {
          if (this.onclose) {
            this.onclose.call(null);
          }
        });
        this.#ws.addEventListener("error", () => {
        });
      }
      send(message) {
        this.#ws.send(message);
      }
      close() {
        this.#ws.close();
      }
    };
  }
});

// src/lib/validate.ts
var validate_exports = {};
__export(validate_exports, {
  validateEndpoint: () => validateEndpoint,
  validateSite: () => validateSite,
  validateSiteEffect: () => validateSiteEffect
});
async function validateEndpoint(baseUrl, method, path, timeout6 = 1e4) {
  const url3 = new URL(path, baseUrl).toString();
  const start5 = Date.now();
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout6);
    const response = await fetch(url3, {
      method: method === "GET" ? "GET" : "HEAD",
      // Don't POST/PUT/DELETE during validation
      signal: controller.signal,
      headers: {
        "User-Agent": "unsurf-validator/1.0",
        Accept: "application/json, text/html, */*"
      }
    });
    clearTimeout(timeoutId);
    const responseTime = Date.now() - start5;
    return {
      endpoint: path,
      method,
      status: response.status,
      ok: response.ok,
      responseTime
    };
  } catch (err) {
    const responseTime = Date.now() - start5;
    return {
      endpoint: path,
      method,
      status: 0,
      ok: false,
      responseTime,
      error: err instanceof Error ? err.message : String(err)
    };
  }
}
async function validateSite(domain4, endpoints2, minValid = 1) {
  const baseUrl = `https://${domain4}`;
  const results = [];
  for (const ep of endpoints2.slice(0, 10)) {
    const result = await validateEndpoint(baseUrl, ep.method, ep.path);
    results.push(result);
    await new Promise((r) => setTimeout(r, 200));
  }
  const validatedEndpoints = results.filter((r) => r.ok).length;
  const failedEndpoints = results.filter((r) => !r.ok).length;
  return {
    domain: domain4,
    totalEndpoints: endpoints2.length,
    validatedEndpoints,
    failedEndpoints,
    results,
    overallValid: validatedEndpoints >= minValid
  };
}
var validateSiteEffect;
var init_validate = __esm({
  "src/lib/validate.ts"() {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_esm();
    init_Errors();
    __name(validateEndpoint, "validateEndpoint");
    __name(validateSite, "validateSite");
    validateSiteEffect = /* @__PURE__ */ __name((domain4, endpoints2, minValid = 1) => Effect_exports.tryPromise({
      try: /* @__PURE__ */ __name(() => validateSite(domain4, endpoints2, minValid), "try"),
      catch: /* @__PURE__ */ __name((e) => new StoreError({ message: `Validation failed: ${e}` }), "catch")
    }), "validateSiteEffect");
  }
});

// src/cf-worker.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();

// src/db/queries.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/alias.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/column.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/entity.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
function is2(value3, type) {
  if (!value3 || typeof value3 !== "object") {
    return false;
  }
  if (value3 instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(
      `Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`
    );
  }
  let cls = Object.getPrototypeOf(value3).constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}
__name(is2, "is");

// node_modules/drizzle-orm/column.js
var Column = class {
  static {
    __name(this, "Column");
  }
  constructor(table3, config5) {
    this.table = table3;
    this.config = config5;
    this.name = config5.name;
    this.keyAsName = config5.keyAsName;
    this.notNull = config5.notNull;
    this.default = config5.default;
    this.defaultFn = config5.defaultFn;
    this.onUpdateFn = config5.onUpdateFn;
    this.hasDefault = config5.hasDefault;
    this.primary = config5.primaryKey;
    this.isUnique = config5.isUnique;
    this.uniqueName = config5.uniqueName;
    this.uniqueType = config5.uniqueType;
    this.dataType = config5.dataType;
    this.columnType = config5.columnType;
    this.generated = config5.generated;
    this.generatedIdentity = config5.generatedIdentity;
  }
  static [entityKind] = "Column";
  name;
  keyAsName;
  primary;
  notNull;
  default;
  defaultFn;
  onUpdateFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = void 0;
  generated = void 0;
  generatedIdentity = void 0;
  config;
  mapFromDriverValue(value3) {
    return value3;
  }
  mapToDriverValue(value3) {
    return value3;
  }
  // ** @internal */
  shouldDisableInsert() {
    return this.config.generated !== void 0 && this.config.generated.type !== "byDefault";
  }
};

// node_modules/drizzle-orm/sql/sql.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/pg-core/columns/enum.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/pg-core/columns/common.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/column-builder.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ColumnBuilder = class {
  static {
    __name(this, "ColumnBuilder");
  }
  static [entityKind] = "ColumnBuilder";
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      keyAsName: name === "",
      notNull: false,
      default: void 0,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: void 0,
      uniqueType: void 0,
      dataType,
      columnType,
      generated: void 0
    };
  }
  /**
   * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
   *
   * @example
   * ```ts
   * const users = pgTable('users', {
   * 	id: integer('id').$type<UserId>().primaryKey(),
   * 	details: json('details').$type<UserDetails>().notNull(),
   * });
   * ```
   */
  $type() {
    return this;
  }
  /**
   * Adds a `not null` clause to the column definition.
   *
   * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
   */
  notNull() {
    this.config.notNull = true;
    return this;
  }
  /**
   * Adds a `default <value>` clause to the column definition.
   *
   * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
   *
   * If you need to set a dynamic default value, use {@link $defaultFn} instead.
   */
  default(value3) {
    this.config.default = value3;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Adds a dynamic default value to the column.
   * The function will be called when the row is inserted, and the returned value will be used as the column value.
   *
   * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
   */
  $defaultFn(fn2) {
    this.config.defaultFn = fn2;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Alias for {@link $defaultFn}.
   */
  $default = this.$defaultFn;
  /**
   * Adds a dynamic update value to the column.
   * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.
   * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.
   *
   * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
   */
  $onUpdateFn(fn2) {
    this.config.onUpdateFn = fn2;
    this.config.hasDefault = true;
    return this;
  }
  /**
   * Alias for {@link $onUpdateFn}.
   */
  $onUpdate = this.$onUpdateFn;
  /**
   * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
   *
   * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
   */
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
  /** @internal Sets the name of the column to the key within the table definition if a name was not given. */
  setName(name) {
    if (this.config.name !== "") return;
    this.config.name = name;
  }
};

// node_modules/drizzle-orm/pg-core/foreign-keys.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/table.utils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TableName = Symbol.for("drizzle:Name");

// node_modules/drizzle-orm/pg-core/foreign-keys.js
var ForeignKeyBuilder = class {
  static {
    __name(this, "ForeignKeyBuilder");
  }
  static [entityKind] = "PgForeignKeyBuilder";
  /** @internal */
  reference;
  /** @internal */
  _onUpdate = "no action";
  /** @internal */
  _onDelete = "no action";
  constructor(config5, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config5();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === void 0 ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === void 0 ? "no action" : action;
    return this;
  }
  /** @internal */
  build(table3) {
    return new ForeignKey(table3, this);
  }
};
var ForeignKey = class {
  static {
    __name(this, "ForeignKey");
  }
  constructor(table3, builder) {
    this.table = table3;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  static [entityKind] = "PgForeignKey";
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks3 = [
      this.table[TableName],
      ...columnNames,
      foreignColumns[0].table[TableName],
      ...foreignColumnNames
    ];
    return name ?? `${chunks3.join("_")}_fk`;
  }
};

// node_modules/drizzle-orm/tracing-utils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function iife(fn2, ...args2) {
  return fn2(...args2);
}
__name(iife, "iife");

// node_modules/drizzle-orm/pg-core/unique-constraint.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function uniqueKeyName(table3, columns) {
  return `${table3[TableName]}_${columns.join("_")}_unique`;
}
__name(uniqueKeyName, "uniqueKeyName");
var UniqueConstraintBuilder = class {
  static {
    __name(this, "UniqueConstraintBuilder");
  }
  constructor(columns, name) {
    this.name = name;
    this.columns = columns;
  }
  static [entityKind] = "PgUniqueConstraintBuilder";
  /** @internal */
  columns;
  /** @internal */
  nullsNotDistinctConfig = false;
  nullsNotDistinct() {
    this.nullsNotDistinctConfig = true;
    return this;
  }
  /** @internal */
  build(table3) {
    return new UniqueConstraint(table3, this.columns, this.nullsNotDistinctConfig, this.name);
  }
};
var UniqueOnConstraintBuilder = class {
  static {
    __name(this, "UniqueOnConstraintBuilder");
  }
  static [entityKind] = "PgUniqueOnConstraintBuilder";
  /** @internal */
  name;
  constructor(name) {
    this.name = name;
  }
  on(...columns) {
    return new UniqueConstraintBuilder(columns, this.name);
  }
};
var UniqueConstraint = class {
  static {
    __name(this, "UniqueConstraint");
  }
  constructor(table3, columns, nullsNotDistinct, name) {
    this.table = table3;
    this.columns = columns;
    this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
    this.nullsNotDistinct = nullsNotDistinct;
  }
  static [entityKind] = "PgUniqueConstraint";
  columns;
  name;
  nullsNotDistinct = false;
  getName() {
    return this.name;
  }
};

// node_modules/drizzle-orm/pg-core/utils/array.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i = startFrom; i < arrayString.length; i++) {
    const char2 = arrayString[i];
    if (char2 === "\\") {
      i++;
      continue;
    }
    if (char2 === '"') {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char2 === "," || char2 === "}") {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
__name(parsePgArrayValue, "parsePgArrayValue");
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i = startFrom;
  let lastCharIsComma = false;
  while (i < arrayString.length) {
    const char2 = arrayString[i];
    if (char2 === ",") {
      if (lastCharIsComma || i === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i++;
      continue;
    }
    lastCharIsComma = false;
    if (char2 === "\\") {
      i += 2;
      continue;
    }
    if (char2 === '"') {
      const [value22, startFrom2] = parsePgArrayValue(arrayString, i + 1, true);
      result.push(value22);
      i = startFrom2;
      continue;
    }
    if (char2 === "}") {
      return [result, i + 1];
    }
    if (char2 === "{") {
      const [value22, startFrom2] = parsePgNestedArray(arrayString, i + 1);
      result.push(value22);
      i = startFrom2;
      continue;
    }
    const [value3, newStartFrom] = parsePgArrayValue(arrayString, i, false);
    result.push(value3);
    i = newStartFrom;
  }
  return [result, i];
}
__name(parsePgNestedArray, "parsePgNestedArray");
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
__name(parsePgArray, "parsePgArray");
function makePgArray(array7) {
  return `{${array7.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}
__name(makePgArray, "makePgArray");

// node_modules/drizzle-orm/pg-core/columns/common.js
var PgColumnBuilder = class extends ColumnBuilder {
  static {
    __name(this, "PgColumnBuilder");
  }
  foreignKeyConfigs = [];
  static [entityKind] = "PgColumnBuilder";
  array(size15) {
    return new PgArrayBuilder(this.config.name, this, size15);
  }
  references(ref2, actions = {}) {
    this.foreignKeyConfigs.push({ ref: ref2, actions });
    return this;
  }
  unique(name, config5) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    this.config.uniqueType = config5?.nulls;
    return this;
  }
  generatedAlwaysAs(as12) {
    this.config.generated = {
      as: as12,
      type: "always",
      mode: "stored"
    };
    return this;
  }
  /** @internal */
  buildForeignKeys(column, table3) {
    return this.foreignKeyConfigs.map(({ ref: ref2, actions }) => {
      return iife(
        (ref22, actions2) => {
          const builder = new ForeignKeyBuilder(() => {
            const foreignColumn = ref22();
            return { columns: [column], foreignColumns: [foreignColumn] };
          });
          if (actions2.onUpdate) {
            builder.onUpdate(actions2.onUpdate);
          }
          if (actions2.onDelete) {
            builder.onDelete(actions2.onDelete);
          }
          return builder.build(table3);
        },
        ref2,
        actions
      );
    });
  }
  /** @internal */
  buildExtraConfigColumn(table3) {
    return new ExtraConfigColumn(table3, this.config);
  }
};
var PgColumn = class extends Column {
  static {
    __name(this, "PgColumn");
  }
  constructor(table3, config5) {
    if (!config5.uniqueName) {
      config5.uniqueName = uniqueKeyName(table3, [config5.name]);
    }
    super(table3, config5);
    this.table = table3;
  }
  static [entityKind] = "PgColumn";
};
var ExtraConfigColumn = class extends PgColumn {
  static {
    __name(this, "ExtraConfigColumn");
  }
  static [entityKind] = "ExtraConfigColumn";
  getSQLType() {
    return this.getSQLType();
  }
  indexConfig = {
    order: this.config.order ?? "asc",
    nulls: this.config.nulls ?? "last",
    opClass: this.config.opClass
  };
  defaultConfig = {
    order: "asc",
    nulls: "last",
    opClass: void 0
  };
  asc() {
    this.indexConfig.order = "asc";
    return this;
  }
  desc() {
    this.indexConfig.order = "desc";
    return this;
  }
  nullsFirst() {
    this.indexConfig.nulls = "first";
    return this;
  }
  nullsLast() {
    this.indexConfig.nulls = "last";
    return this;
  }
  /**
   * ### PostgreSQL documentation quote
   *
   * > An operator class with optional parameters can be specified for each column of an index.
   * The operator class identifies the operators to be used by the index for that column.
   * For example, a B-tree index on four-byte integers would use the int4_ops class;
   * this operator class includes comparison functions for four-byte integers.
   * In practice the default operator class for the column's data type is usually sufficient.
   * The main point of having operator classes is that for some data types, there could be more than one meaningful ordering.
   * For example, we might want to sort a complex-number data type either by absolute value or by real part.
   * We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index.
   * More information about operator classes check:
   *
   * ### Useful links
   * https://www.postgresql.org/docs/current/sql-createindex.html
   *
   * https://www.postgresql.org/docs/current/indexes-opclass.html
   *
   * https://www.postgresql.org/docs/current/xindex.html
   *
   * ### Additional types
   * If you have the `pg_vector` extension installed in your database, you can use the
   * `vector_l2_ops`, `vector_ip_ops`, `vector_cosine_ops`, `vector_l1_ops`, `bit_hamming_ops`, `bit_jaccard_ops`, `halfvec_l2_ops`, `sparsevec_l2_ops` options, which are predefined types.
   *
   * **You can always specify any string you want in the operator class, in case Drizzle doesn't have it natively in its types**
   *
   * @param opClass
   * @returns
   */
  op(opClass) {
    this.indexConfig.opClass = opClass;
    return this;
  }
};
var IndexedColumn = class {
  static {
    __name(this, "IndexedColumn");
  }
  static [entityKind] = "IndexedColumn";
  constructor(name, keyAsName, type, indexConfig) {
    this.name = name;
    this.keyAsName = keyAsName;
    this.type = type;
    this.indexConfig = indexConfig;
  }
  name;
  keyAsName;
  type;
  indexConfig;
};
var PgArrayBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgArrayBuilder");
  }
  static [entityKind] = "PgArrayBuilder";
  constructor(name, baseBuilder, size15) {
    super(name, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size15;
  }
  /** @internal */
  build(table3) {
    const baseColumn = this.config.baseBuilder.build(table3);
    return new PgArray(
      table3,
      this.config,
      baseColumn
    );
  }
};
var PgArray = class _PgArray extends PgColumn {
  static {
    __name(this, "PgArray");
  }
  constructor(table3, config5, baseColumn, range4) {
    super(table3, config5);
    this.baseColumn = baseColumn;
    this.range = range4;
    this.size = config5.size;
  }
  size;
  static [entityKind] = "PgArray";
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value3) {
    if (typeof value3 === "string") {
      value3 = parsePgArray(value3);
    }
    return value3.map((v) => this.baseColumn.mapFromDriverValue(v));
  }
  mapToDriverValue(value3, isNestedArray = false) {
    const a = value3.map(
      (v) => v === null ? null : is2(this.baseColumn, _PgArray) ? this.baseColumn.mapToDriverValue(v, true) : this.baseColumn.mapToDriverValue(v)
    );
    if (isNestedArray) return a;
    return makePgArray(a);
  }
};

// node_modules/drizzle-orm/pg-core/columns/enum.js
var PgEnumObjectColumnBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgEnumObjectColumnBuilder");
  }
  static [entityKind] = "PgEnumObjectColumnBuilder";
  constructor(name, enumInstance) {
    super(name, "string", "PgEnumObjectColumn");
    this.config.enum = enumInstance;
  }
  /** @internal */
  build(table3) {
    return new PgEnumObjectColumn(
      table3,
      this.config
    );
  }
};
var PgEnumObjectColumn = class extends PgColumn {
  static {
    __name(this, "PgEnumObjectColumn");
  }
  static [entityKind] = "PgEnumObjectColumn";
  enum;
  enumValues = this.config.enum.enumValues;
  constructor(table3, config5) {
    super(table3, config5);
    this.enum = config5.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
};
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
__name(isPgEnum, "isPgEnum");
var PgEnumColumnBuilder = class extends PgColumnBuilder {
  static {
    __name(this, "PgEnumColumnBuilder");
  }
  static [entityKind] = "PgEnumColumnBuilder";
  constructor(name, enumInstance) {
    super(name, "string", "PgEnumColumn");
    this.config.enum = enumInstance;
  }
  /** @internal */
  build(table3) {
    return new PgEnumColumn(
      table3,
      this.config
    );
  }
};
var PgEnumColumn = class extends PgColumn {
  static {
    __name(this, "PgEnumColumn");
  }
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table3, config5) {
    super(table3, config5);
    this.enum = config5.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
};

// node_modules/drizzle-orm/subquery.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Subquery = class {
  static {
    __name(this, "Subquery");
  }
  static [entityKind] = "Subquery";
  constructor(sql2, fields, alias, isWith = false, usedTables = []) {
    this._ = {
      brand: "Subquery",
      sql: sql2,
      selectedFields: fields,
      alias,
      isWith,
      usedTables
    };
  }
  // getSQL(): SQL<unknown> {
  // 	return new SQL([this]);
  // }
};
var WithSubquery = class extends Subquery {
  static {
    __name(this, "WithSubquery");
  }
  static [entityKind] = "WithSubquery";
};

// node_modules/drizzle-orm/tracing.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/version.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var version2 = "0.45.1";

// node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer3 = {
  startActiveSpan(name, fn2) {
    if (!otel) {
      return fn2();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version2);
    }
    return iife(
      (otel2, rawTracer2) => rawTracer2.startActiveSpan(
        name,
        (span4) => {
          try {
            return fn2(span4);
          } catch (e) {
            span4.setStatus({
              code: otel2.SpanStatusCode.ERROR,
              message: e instanceof Error ? e.message : "Unknown error"
              // eslint-disable-line no-instanceof/no-instanceof
            });
            throw e;
          } finally {
            span4.end();
          }
        }
      ),
      otel,
      rawTracer
    );
  }
};

// node_modules/drizzle-orm/view-common.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// node_modules/drizzle-orm/table.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");
var Table = class {
  static {
    __name(this, "Table");
  }
  static [entityKind] = "Table";
  /** @internal */
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    ExtraConfigColumns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  /**
   * @internal
   * Can be changed if the table is aliased.
   */
  [TableName];
  /**
   * @internal
   * Used to store the original name of the table, before any aliasing.
   */
  [OriginalName];
  /** @internal */
  [Schema];
  /** @internal */
  [Columns];
  /** @internal */
  [ExtraConfigColumns];
  /**
   *  @internal
   * Used to store the table name before the transformation via the `tableCreator` functions.
   */
  [BaseName];
  /** @internal */
  [IsAlias] = false;
  /** @internal */
  [IsDrizzleTable] = true;
  /** @internal */
  [ExtraConfigBuilder] = void 0;
  constructor(name, schema, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
};
function getTableName(table3) {
  return table3[TableName];
}
__name(getTableName, "getTableName");
function getTableUniqueName(table3) {
  return `${table3[Schema] ?? "public"}.${table3[TableName]}`;
}
__name(getTableUniqueName, "getTableUniqueName");

// node_modules/drizzle-orm/sql/sql.js
var FakePrimitiveParam = class {
  static {
    __name(this, "FakePrimitiveParam");
  }
  static [entityKind] = "FakePrimitiveParam";
};
function isSQLWrapper(value3) {
  return value3 !== null && value3 !== void 0 && typeof value3.getSQL === "function";
}
__name(isSQLWrapper, "isSQLWrapper");
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}
__name(mergeQueries, "mergeQueries");
var StringChunk = class {
  static {
    __name(this, "StringChunk");
  }
  static [entityKind] = "StringChunk";
  value;
  constructor(value3) {
    this.value = Array.isArray(value3) ? value3 : [value3];
  }
  getSQL() {
    return new SQL([this]);
  }
};
var SQL = class _SQL {
  static {
    __name(this, "SQL");
  }
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
    for (const chunk4 of queryChunks) {
      if (is2(chunk4, Table)) {
        const schemaName = chunk4[Table.Symbol.Schema];
        this.usedTables.push(
          schemaName === void 0 ? chunk4[Table.Symbol.Name] : schemaName + "." + chunk4[Table.Symbol.Name]
        );
      }
    }
  }
  static [entityKind] = "SQL";
  /** @internal */
  decoder = noopDecoder;
  shouldInlineParams = false;
  /** @internal */
  usedTables = [];
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config5) {
    return tracer3.startActiveSpan("drizzle.buildSQL", (span4) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config5);
      span4?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks3, _config) {
    const config5 = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      casing,
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config5;
    return mergeQueries(chunks3.map((chunk4) => {
      if (is2(chunk4, StringChunk)) {
        return { sql: chunk4.value.join(""), params: [] };
      }
      if (is2(chunk4, Name)) {
        return { sql: escapeName(chunk4.value), params: [] };
      }
      if (chunk4 === void 0) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk4)) {
        const result = [new StringChunk("(")];
        for (const [i, p] of chunk4.entries()) {
          result.push(p);
          if (i < chunk4.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config5);
      }
      if (is2(chunk4, _SQL)) {
        return this.buildQueryFromSourceParams(chunk4.queryChunks, {
          ...config5,
          inlineParams: inlineParams || chunk4.shouldInlineParams
        });
      }
      if (is2(chunk4, Table)) {
        const schemaName = chunk4[Table.Symbol.Schema];
        const tableName = chunk4[Table.Symbol.Name];
        return {
          sql: schemaName === void 0 || chunk4[IsAlias] ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is2(chunk4, Column)) {
        const columnName = casing.getColumnCasing(chunk4);
        if (_config.invokeSource === "indexes") {
          return { sql: escapeName(columnName), params: [] };
        }
        const schemaName = chunk4.table[Table.Symbol.Schema];
        return {
          sql: chunk4.table[IsAlias] || schemaName === void 0 ? escapeName(chunk4.table[Table.Symbol.Name]) + "." + escapeName(columnName) : escapeName(schemaName) + "." + escapeName(chunk4.table[Table.Symbol.Name]) + "." + escapeName(columnName),
          params: []
        };
      }
      if (is2(chunk4, View)) {
        const schemaName = chunk4[ViewBaseConfig].schema;
        const viewName = chunk4[ViewBaseConfig].name;
        return {
          sql: schemaName === void 0 || chunk4[ViewBaseConfig].isAlias ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is2(chunk4, Param)) {
        if (is2(chunk4.value, Placeholder)) {
          return { sql: escapeParam(paramStartIndex.value++, chunk4), params: [chunk4], typings: ["none"] };
        }
        const mappedValue = chunk4.value === null ? null : chunk4.encoder.mapToDriverValue(chunk4.value);
        if (is2(mappedValue, _SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config5);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config5), params: [] };
        }
        let typings = ["none"];
        if (prepareTyping) {
          typings = [prepareTyping(chunk4.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is2(chunk4, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk4), params: [chunk4], typings: ["none"] };
      }
      if (is2(chunk4, _SQL.Aliased) && chunk4.fieldAlias !== void 0) {
        return { sql: escapeName(chunk4.fieldAlias), params: [] };
      }
      if (is2(chunk4, Subquery)) {
        if (chunk4._.isWith) {
          return { sql: escapeName(chunk4._.alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk4._.sql,
          new StringChunk(") "),
          new Name(chunk4._.alias)
        ], config5);
      }
      if (isPgEnum(chunk4)) {
        if (chunk4.schema) {
          return { sql: escapeName(chunk4.schema) + "." + escapeName(chunk4.enumName), params: [] };
        }
        return { sql: escapeName(chunk4.enumName), params: [] };
      }
      if (isSQLWrapper(chunk4)) {
        if (chunk4.shouldOmitSQLParens?.()) {
          return this.buildQueryFromSourceParams([chunk4.getSQL()], config5);
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk4.getSQL(),
          new StringChunk(")")
        ], config5);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk4, config5), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk4), params: [chunk4], typings: ["none"] };
    }));
  }
  mapInlineParam(chunk4, { escapeString }) {
    if (chunk4 === null) {
      return "null";
    }
    if (typeof chunk4 === "number" || typeof chunk4 === "boolean") {
      return chunk4.toString();
    }
    if (typeof chunk4 === "string") {
      return escapeString(chunk4);
    }
    if (typeof chunk4 === "object") {
      const mappedValueAsString = chunk4.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk4));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk4);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === void 0) {
      return this;
    }
    return new _SQL.Aliased(this, alias);
  }
  mapWith(decoder2) {
    this.decoder = typeof decoder2 === "function" ? { mapFromDriverValue: decoder2 } : decoder2;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
  /**
   * This method is used to conditionally include a part of the query.
   *
   * @param condition - Condition to check
   * @returns itself if the condition is `true`, otherwise `undefined`
   */
  if(condition) {
    return condition ? this : void 0;
  }
};
var Name = class {
  static {
    __name(this, "Name");
  }
  constructor(value3) {
    this.value = value3;
  }
  static [entityKind] = "Name";
  brand;
  getSQL() {
    return new SQL([this]);
  }
};
function isDriverValueEncoder(value3) {
  return typeof value3 === "object" && value3 !== null && "mapToDriverValue" in value3 && typeof value3.mapToDriverValue === "function";
}
__name(isDriverValueEncoder, "isDriverValueEncoder");
var noopDecoder = {
  mapFromDriverValue: /* @__PURE__ */ __name((value3) => value3, "mapFromDriverValue")
};
var noopEncoder = {
  mapToDriverValue: /* @__PURE__ */ __name((value3) => value3, "mapToDriverValue")
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};
var Param = class {
  static {
    __name(this, "Param");
  }
  /**
   * @param value - Parameter value
   * @param encoder - Encoder to convert the value to a driver parameter
   */
  constructor(value3, encoder2 = noopEncoder) {
    this.value = value3;
    this.encoder = encoder2;
  }
  static [entityKind] = "Param";
  brand;
  getSQL() {
    return new SQL([this]);
  }
};
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
__name(sql, "sql");
((sql2) => {
  function empty36() {
    return new SQL([]);
  }
  __name(empty36, "empty");
  sql2.empty = empty36;
  function fromList(list) {
    return new SQL(list);
  }
  __name(fromList, "fromList");
  sql2.fromList = fromList;
  function raw(str) {
    return new SQL([new StringChunk(str)]);
  }
  __name(raw, "raw");
  sql2.raw = raw;
  function join4(chunks3, separator) {
    const result = [];
    for (const [i, chunk4] of chunks3.entries()) {
      if (i > 0 && separator !== void 0) {
        result.push(separator);
      }
      result.push(chunk4);
    }
    return new SQL(result);
  }
  __name(join4, "join");
  sql2.join = join4;
  function identifier2(value3) {
    return new Name(value3);
  }
  __name(identifier2, "identifier");
  sql2.identifier = identifier2;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  __name(placeholder2, "placeholder2");
  sql2.placeholder = placeholder2;
  function param2(value3, encoder2) {
    return new Param(value3, encoder2);
  }
  __name(param2, "param2");
  sql2.param = param2;
})(sql || (sql = {}));
((SQL2) => {
  class Aliased {
    static {
      __name(this, "Aliased");
    }
    constructor(sql2, fieldAlias) {
      this.sql = sql2;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    /** @internal */
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    /** @internal */
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));
var Placeholder = class {
  static {
    __name(this, "Placeholder");
  }
  constructor(name2) {
    this.name = name2;
  }
  static [entityKind] = "Placeholder";
  getSQL() {
    return new SQL([this]);
  }
};
function fillPlaceholders(params, values4) {
  return params.map((p) => {
    if (is2(p, Placeholder)) {
      if (!(p.name in values4)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values4[p.name];
    }
    if (is2(p, Param) && is2(p.value, Placeholder)) {
      if (!(p.value.name in values4)) {
        throw new Error(`No value for placeholder "${p.value.name}" was provided`);
      }
      return p.encoder.mapToDriverValue(values4[p.value.name]);
    }
    return p;
  });
}
__name(fillPlaceholders, "fillPlaceholders");
var IsDrizzleView = Symbol.for("drizzle:IsDrizzleView");
var View = class {
  static {
    __name(this, "View");
  }
  static [entityKind] = "View";
  /** @internal */
  [ViewBaseConfig];
  /** @internal */
  [IsDrizzleView] = true;
  constructor({ name: name2, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
};
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// node_modules/drizzle-orm/alias.js
var ColumnAliasProxyHandler = class {
  static {
    __name(this, "ColumnAliasProxyHandler");
  }
  constructor(table3) {
    this.table = table3;
  }
  static [entityKind] = "ColumnAliasProxyHandler";
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
};
var TableAliasProxyHandler = class {
  static {
    __name(this, "TableAliasProxyHandler");
  }
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  static [entityKind] = "TableAliasProxyHandler";
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(
          columns[key],
          new ColumnAliasProxyHandler(new Proxy(target, this))
        );
      });
      return proxiedColumns;
    }
    const value3 = target[prop];
    if (is2(value3, Column)) {
      return new Proxy(value3, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value3;
  }
};
var RelationTableAliasProxyHandler = class {
  static {
    __name(this, "RelationTableAliasProxyHandler");
  }
  constructor(alias) {
    this.alias = alias;
  }
  static [entityKind] = "RelationTableAliasProxyHandler";
  get(target, prop) {
    if (prop === "sourceTable") {
      return aliasedTable(target.sourceTable, this.alias);
    }
    return target[prop];
  }
};
function aliasedTable(table3, tableAlias) {
  return new Proxy(table3, new TableAliasProxyHandler(tableAlias, false));
}
__name(aliasedTable, "aliasedTable");
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(
    column,
    new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false)))
  );
}
__name(aliasedTableColumn, "aliasedTableColumn");
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
__name(mapColumnsInAliasedSQLToAlias, "mapColumnsInAliasedSQLToAlias");
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c) => {
    if (is2(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is2(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is2(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
}
__name(mapColumnsInSQLToAlias, "mapColumnsInSQLToAlias");

// node_modules/drizzle-orm/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DrizzleError = class extends Error {
  static {
    __name(this, "DrizzleError");
  }
  static [entityKind] = "DrizzleError";
  constructor({ message, cause: cause3 }) {
    super(message);
    this.name = "DrizzleError";
    this.cause = cause3;
  }
};
var DrizzleQueryError = class _DrizzleQueryError extends Error {
  static {
    __name(this, "DrizzleQueryError");
  }
  constructor(query, params, cause3) {
    super(`Failed query: ${query}
params: ${params}`);
    this.query = query;
    this.params = params;
    this.cause = cause3;
    Error.captureStackTrace(this, _DrizzleQueryError);
    if (cause3) this.cause = cause3;
  }
};
var TransactionRollbackError = class extends DrizzleError {
  static {
    __name(this, "TransactionRollbackError");
  }
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super({ message: "Rollback" });
  }
};

// node_modules/drizzle-orm/logger.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ConsoleLogWriter = class {
  static {
    __name(this, "ConsoleLogWriter");
  }
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
};
var DefaultLogger = class {
  static {
    __name(this, "DefaultLogger");
  }
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config5) {
    this.writer = config5?.writer ?? new ConsoleLogWriter();
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p) => {
      try {
        return JSON.stringify(p);
      } catch {
        return String(p);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
};
var NoopLogger = class {
  static {
    __name(this, "NoopLogger");
  }
  static [entityKind] = "NoopLogger";
  logQuery() {
  }
};

// node_modules/drizzle-orm/query-promise.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var QueryPromise = class {
  static {
    __name(this, "QueryPromise");
  }
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(void 0, onRejected);
  }
  finally(onFinally) {
    return this.then(
      (value3) => {
        onFinally?.();
        return value3;
      },
      (reason) => {
        onFinally?.();
        throw reason;
      }
    );
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
};

// node_modules/drizzle-orm/relations.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/pg-core/primary-keys.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/pg-core/table.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/utils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce(
    (result2, { path, field }, columnIndex) => {
      let decoder2;
      if (is2(field, Column)) {
        decoder2 = field;
      } else if (is2(field, SQL)) {
        decoder2 = field.decoder;
      } else if (is2(field, Subquery)) {
        decoder2 = field._.sql.decoder;
      } else {
        decoder2 = field.sql.decoder;
      }
      let node = result2;
      for (const [pathChunkIndex, pathChunk] of path.entries()) {
        if (pathChunkIndex < path.length - 1) {
          if (!(pathChunk in node)) {
            node[pathChunk] = {};
          }
          node = node[pathChunk];
        } else {
          const rawValue = row[columnIndex];
          const value3 = node[pathChunk] = rawValue === null ? null : decoder2.mapFromDriverValue(rawValue);
          if (joinsNotNullableMap && is2(field, Column) && path.length === 2) {
            const objectName = path[0];
            if (!(objectName in nullifyMap)) {
              nullifyMap[objectName] = value3 === null ? getTableName(field.table) : false;
            } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
              nullifyMap[objectName] = false;
            }
          }
        }
      }
      return result2;
    },
    {}
  );
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
__name(mapResultRow, "mapResultRow");
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is2(field, Column) || is2(field, SQL) || is2(field, SQL.Aliased) || is2(field, Subquery)) {
      result.push({ path: newPath, field });
    } else if (is2(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
__name(orderSelectedFields, "orderSelectedFields");
function haveSameKeys(left3, right3) {
  const leftKeys = Object.keys(left3);
  const rightKeys = Object.keys(right3);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index2, key] of leftKeys.entries()) {
    if (key !== rightKeys[index2]) {
      return false;
    }
  }
  return true;
}
__name(haveSameKeys, "haveSameKeys");
function mapUpdateSet(table3, values4) {
  const entries2 = Object.entries(values4).filter(([, value3]) => value3 !== void 0).map(([key, value3]) => {
    if (is2(value3, SQL) || is2(value3, Column)) {
      return [key, value3];
    } else {
      return [key, new Param(value3, table3[Table.Symbol.Columns][key])];
    }
  });
  if (entries2.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries2);
}
__name(mapUpdateSet, "mapUpdateSet");
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor") continue;
      Object.defineProperty(
        baseClass.prototype,
        name,
        Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null)
      );
    }
  }
}
__name(applyMixins, "applyMixins");
function getTableColumns(table3) {
  return table3[Table.Symbol.Columns];
}
__name(getTableColumns, "getTableColumns");
function getTableLikeName(table3) {
  return is2(table3, Subquery) ? table3._.alias : is2(table3, View) ? table3[ViewBaseConfig].name : is2(table3, SQL) ? void 0 : table3[Table.Symbol.IsAlias] ? table3[Table.Symbol.Name] : table3[Table.Symbol.BaseName];
}
__name(getTableLikeName, "getTableLikeName");
function getColumnNameAndConfig(a, b) {
  return {
    name: typeof a === "string" && a.length > 0 ? a : "",
    config: typeof a === "object" ? a : b
  };
}
__name(getColumnNameAndConfig, "getColumnNameAndConfig");
var textDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder();

// node_modules/drizzle-orm/pg-core/table.js
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
var EnableRLS = Symbol.for("drizzle:EnableRLS");
var PgTable = class extends Table {
  static {
    __name(this, "PgTable");
  }
  static [entityKind] = "PgTable";
  /** @internal */
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys,
    EnableRLS
  });
  /**@internal */
  [InlineForeignKeys] = [];
  /** @internal */
  [EnableRLS] = false;
  /** @internal */
  [Table.Symbol.ExtraConfigBuilder] = void 0;
  /** @internal */
  [Table.Symbol.ExtraConfigColumns] = {};
};

// node_modules/drizzle-orm/pg-core/primary-keys.js
var PrimaryKeyBuilder = class {
  static {
    __name(this, "PrimaryKeyBuilder");
  }
  static [entityKind] = "PgPrimaryKeyBuilder";
  /** @internal */
  columns;
  /** @internal */
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  /** @internal */
  build(table3) {
    return new PrimaryKey(table3, this.columns, this.name);
  }
};
var PrimaryKey = class {
  static {
    __name(this, "PrimaryKey");
  }
  constructor(table3, columns, name) {
    this.table = table3;
    this.columns = columns;
    this.name = name;
  }
  static [entityKind] = "PgPrimaryKey";
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
};

// node_modules/drizzle-orm/sql/expressions/conditions.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function bindIfParam(value3, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value3) && !is2(value3, Param) && !is2(value3, Placeholder) && !is2(value3, Column) && !is2(value3, Table) && !is2(value3, View)) {
    return new Param(value3, column);
  }
  return value3;
}
__name(bindIfParam, "bindIfParam");
var eq = /* @__PURE__ */ __name((left3, right3) => {
  return sql`${left3} = ${bindIfParam(right3, left3)}`;
}, "eq");
var ne = /* @__PURE__ */ __name((left3, right3) => {
  return sql`${left3} <> ${bindIfParam(right3, left3)}`;
}, "ne");
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c) => c !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
__name(and, "and");
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter(
    (c) => c !== void 0
  );
  if (conditions.length === 0) {
    return void 0;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
__name(or, "or");
function not2(condition) {
  return sql`not ${condition}`;
}
__name(not2, "not");
var gt = /* @__PURE__ */ __name((left3, right3) => {
  return sql`${left3} > ${bindIfParam(right3, left3)}`;
}, "gt");
var gte = /* @__PURE__ */ __name((left3, right3) => {
  return sql`${left3} >= ${bindIfParam(right3, left3)}`;
}, "gte");
var lt = /* @__PURE__ */ __name((left3, right3) => {
  return sql`${left3} < ${bindIfParam(right3, left3)}`;
}, "lt");
var lte = /* @__PURE__ */ __name((left3, right3) => {
  return sql`${left3} <= ${bindIfParam(right3, left3)}`;
}, "lte");
function inArray(column, values4) {
  if (Array.isArray(values4)) {
    if (values4.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values4.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} in ${bindIfParam(values4, column)}`;
}
__name(inArray, "inArray");
function notInArray(column, values4) {
  if (Array.isArray(values4)) {
    if (values4.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values4.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values4, column)}`;
}
__name(notInArray, "notInArray");
function isNull(value3) {
  return sql`${value3} is null`;
}
__name(isNull, "isNull");
function isNotNull2(value3) {
  return sql`${value3} is not null`;
}
__name(isNotNull2, "isNotNull");
function exists4(subquery) {
  return sql`exists ${subquery}`;
}
__name(exists4, "exists");
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
__name(notExists, "notExists");
function between6(column, min4, max6) {
  return sql`${column} between ${bindIfParam(min4, column)} and ${bindIfParam(
    max6,
    column
  )}`;
}
__name(between6, "between");
function notBetween(column, min4, max6) {
  return sql`${column} not between ${bindIfParam(
    min4,
    column
  )} and ${bindIfParam(max6, column)}`;
}
__name(notBetween, "notBetween");
function like(column, value3) {
  return sql`${column} like ${value3}`;
}
__name(like, "like");
function notLike(column, value3) {
  return sql`${column} not like ${value3}`;
}
__name(notLike, "notLike");
function ilike(column, value3) {
  return sql`${column} ilike ${value3}`;
}
__name(ilike, "ilike");
function notIlike(column, value3) {
  return sql`${column} not ilike ${value3}`;
}
__name(notIlike, "notIlike");

// node_modules/drizzle-orm/sql/expressions/select.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function asc(column) {
  return sql`${column} asc`;
}
__name(asc, "asc");
function desc(column) {
  return sql`${column} desc`;
}
__name(desc, "desc");

// node_modules/drizzle-orm/relations.js
var Relation = class {
  static {
    __name(this, "Relation");
  }
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
};
var Relations = class {
  static {
    __name(this, "Relations");
  }
  constructor(table3, config5) {
    this.table = table3;
    this.config = config5;
  }
  static [entityKind] = "Relations";
};
var One = class _One extends Relation {
  static {
    __name(this, "One");
  }
  constructor(sourceTable, referencedTable, config5, isNullable2) {
    super(sourceTable, referencedTable, config5?.relationName);
    this.config = config5;
    this.isNullable = isNullable2;
  }
  static [entityKind] = "One";
  withFieldName(fieldName) {
    const relation = new _One(
      this.sourceTable,
      this.referencedTable,
      this.config,
      this.isNullable
    );
    relation.fieldName = fieldName;
    return relation;
  }
};
var Many = class _Many extends Relation {
  static {
    __name(this, "Many");
  }
  constructor(sourceTable, referencedTable, config5) {
    super(sourceTable, referencedTable, config5?.relationName);
    this.config = config5;
  }
  static [entityKind] = "Many";
  withFieldName(fieldName) {
    const relation = new _Many(
      this.sourceTable,
      this.referencedTable,
      this.config
    );
    relation.fieldName = fieldName;
    return relation;
  }
};
function getOperators() {
  return {
    and,
    between: between6,
    eq,
    exists: exists4,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull: isNotNull2,
    like,
    lt,
    lte,
    ne,
    not: not2,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
__name(getOperators, "getOperators");
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
__name(getOrderByOperators, "getOrderByOperators");
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is2(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value3] of Object.entries(schema)) {
    if (is2(value3, Table)) {
      const dbName = getTableUniqueName(value3);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value3[Table.Symbol.Name],
        schema: value3[Table.Symbol.Schema],
        columns: value3[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(
        value3[Table.Symbol.Columns]
      )) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value3[Table.Symbol.ExtraConfigBuilder]?.(value3[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is2(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is2(value3, Relations)) {
      const dbName = getTableUniqueName(value3.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value3.config(
        configHelpers(value3.table)
      );
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
__name(extractTablesRelationalConfig, "extractTablesRelationalConfig");
function createOne(sourceTable) {
  return /* @__PURE__ */ __name(function one(table3, config5) {
    return new One(
      sourceTable,
      table3,
      config5,
      config5?.fields.reduce((res, f) => res && f.notNull, true) ?? false
    );
  }, "one");
}
__name(createOne, "createOne");
function createMany(sourceTable) {
  return /* @__PURE__ */ __name(function many(referencedTable, config5) {
    return new Many(sourceTable, referencedTable, config5);
  }, "many");
}
__name(createMany, "createMany");
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is2(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(
      `Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(
      `Table "${sourceTable[Table.Symbol.Name]}" not found in schema`
    );
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(
    referencedTableConfig.relations
  )) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(
      `There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`
    ) : new Error(
      `There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`
    );
  }
  if (reverseRelations[0] && is2(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(
    `There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`
  );
}
__name(normalizeRelation, "normalizeRelation");
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
__name(createTableRelationsHelpers, "createTableRelationsHelpers");
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value3) => value3) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is2(relation, One) ? subRows && mapRelationalRow(
        tablesConfig,
        tablesConfig[selectionItem.relationTableTsKey],
        subRows,
        selectionItem.selection,
        mapColumnValue
      ) : subRows.map(
        (subRow) => mapRelationalRow(
          tablesConfig,
          tablesConfig[selectionItem.relationTableTsKey],
          subRow,
          selectionItem.selection,
          mapColumnValue
        )
      );
    } else {
      const value3 = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder2;
      if (is2(field, Column)) {
        decoder2 = field;
      } else if (is2(field, SQL)) {
        decoder2 = field.decoder;
      } else {
        decoder2 = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value3 === null ? null : decoder2.mapFromDriverValue(value3);
    }
  }
  return result;
}
__name(mapRelationalRow, "mapRelationalRow");

// node_modules/drizzle-orm/d1/driver.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/sqlite-core/db.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/selection-proxy.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SelectionProxyHandler = class _SelectionProxyHandler {
  static {
    __name(this, "SelectionProxyHandler");
  }
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config5) {
    this.config = { ...config5 };
  }
  get(subquery, prop) {
    if (prop === "_") {
      return {
        ...subquery["_"],
        selectedFields: new Proxy(
          subquery._.selectedFields,
          this
        )
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(
          subquery[ViewBaseConfig].selectedFields,
          this
        )
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is2(subquery, Subquery) ? subquery._.selectedFields : is2(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value3 = columns[prop];
    if (is2(value3, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value3.isSelectionField) {
        return value3.sql;
      }
      const newValue = value3.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is2(value3, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value3;
      }
      throw new Error(
        `You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`
      );
    }
    if (is2(value3, Column)) {
      if (this.config.alias) {
        return new Proxy(
          value3,
          new ColumnAliasProxyHandler(
            new Proxy(
              value3.table,
              new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false)
            )
          )
        );
      }
      return value3;
    }
    if (typeof value3 !== "object" || value3 === null) {
      return value3;
    }
    return new Proxy(value3, new _SelectionProxyHandler(this.config));
  }
};

// node_modules/drizzle-orm/sqlite-core/query-builders/delete.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/sqlite-core/table.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/sqlite-core/columns/all.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/sqlite-core/columns/blob.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/sqlite-core/columns/common.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/sqlite-core/foreign-keys.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ForeignKeyBuilder2 = class {
  static {
    __name(this, "ForeignKeyBuilder");
  }
  static [entityKind] = "SQLiteForeignKeyBuilder";
  /** @internal */
  reference;
  /** @internal */
  _onUpdate;
  /** @internal */
  _onDelete;
  constructor(config5, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config5();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action;
    return this;
  }
  /** @internal */
  build(table3) {
    return new ForeignKey2(table3, this);
  }
};
var ForeignKey2 = class {
  static {
    __name(this, "ForeignKey");
  }
  constructor(table3, builder) {
    this.table = table3;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  static [entityKind] = "SQLiteForeignKey";
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks3 = [
      this.table[TableName],
      ...columnNames,
      foreignColumns[0].table[TableName],
      ...foreignColumnNames
    ];
    return name ?? `${chunks3.join("_")}_fk`;
  }
};

// node_modules/drizzle-orm/sqlite-core/unique-constraint.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function uniqueKeyName2(table3, columns) {
  return `${table3[TableName]}_${columns.join("_")}_unique`;
}
__name(uniqueKeyName2, "uniqueKeyName");
var UniqueConstraintBuilder2 = class {
  static {
    __name(this, "UniqueConstraintBuilder");
  }
  constructor(columns, name) {
    this.name = name;
    this.columns = columns;
  }
  static [entityKind] = "SQLiteUniqueConstraintBuilder";
  /** @internal */
  columns;
  /** @internal */
  build(table3) {
    return new UniqueConstraint2(table3, this.columns, this.name);
  }
};
var UniqueOnConstraintBuilder2 = class {
  static {
    __name(this, "UniqueOnConstraintBuilder");
  }
  static [entityKind] = "SQLiteUniqueOnConstraintBuilder";
  /** @internal */
  name;
  constructor(name) {
    this.name = name;
  }
  on(...columns) {
    return new UniqueConstraintBuilder2(columns, this.name);
  }
};
var UniqueConstraint2 = class {
  static {
    __name(this, "UniqueConstraint");
  }
  constructor(table3, columns, name) {
    this.table = table3;
    this.columns = columns;
    this.name = name ?? uniqueKeyName2(this.table, this.columns.map((column) => column.name));
  }
  static [entityKind] = "SQLiteUniqueConstraint";
  columns;
  name;
  getName() {
    return this.name;
  }
};

// node_modules/drizzle-orm/sqlite-core/columns/common.js
var SQLiteColumnBuilder = class extends ColumnBuilder {
  static {
    __name(this, "SQLiteColumnBuilder");
  }
  static [entityKind] = "SQLiteColumnBuilder";
  foreignKeyConfigs = [];
  references(ref2, actions = {}) {
    this.foreignKeyConfigs.push({ ref: ref2, actions });
    return this;
  }
  unique(name) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    return this;
  }
  generatedAlwaysAs(as12, config5) {
    this.config.generated = {
      as: as12,
      type: "always",
      mode: config5?.mode ?? "virtual"
    };
    return this;
  }
  /** @internal */
  buildForeignKeys(column, table3) {
    return this.foreignKeyConfigs.map(({ ref: ref2, actions }) => {
      return ((ref22, actions2) => {
        const builder = new ForeignKeyBuilder2(() => {
          const foreignColumn = ref22();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table3);
      })(ref2, actions);
    });
  }
};
var SQLiteColumn = class extends Column {
  static {
    __name(this, "SQLiteColumn");
  }
  constructor(table3, config5) {
    if (!config5.uniqueName) {
      config5.uniqueName = uniqueKeyName2(table3, [config5.name]);
    }
    super(table3, config5);
    this.table = table3;
  }
  static [entityKind] = "SQLiteColumn";
};

// node_modules/drizzle-orm/sqlite-core/columns/blob.js
var SQLiteBigIntBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteBigIntBuilder");
  }
  static [entityKind] = "SQLiteBigIntBuilder";
  constructor(name) {
    super(name, "bigint", "SQLiteBigInt");
  }
  /** @internal */
  build(table3) {
    return new SQLiteBigInt(table3, this.config);
  }
};
var SQLiteBigInt = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteBigInt");
  }
  static [entityKind] = "SQLiteBigInt";
  getSQLType() {
    return "blob";
  }
  mapFromDriverValue(value3) {
    if (typeof Buffer !== "undefined" && Buffer.from) {
      const buf = Buffer.isBuffer(value3) ? value3 : value3 instanceof ArrayBuffer ? Buffer.from(value3) : value3.buffer ? Buffer.from(value3.buffer, value3.byteOffset, value3.byteLength) : Buffer.from(value3);
      return BigInt(buf.toString("utf8"));
    }
    return BigInt(textDecoder.decode(value3));
  }
  mapToDriverValue(value3) {
    return Buffer.from(value3.toString());
  }
};
var SQLiteBlobJsonBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteBlobJsonBuilder");
  }
  static [entityKind] = "SQLiteBlobJsonBuilder";
  constructor(name) {
    super(name, "json", "SQLiteBlobJson");
  }
  /** @internal */
  build(table3) {
    return new SQLiteBlobJson(
      table3,
      this.config
    );
  }
};
var SQLiteBlobJson = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteBlobJson");
  }
  static [entityKind] = "SQLiteBlobJson";
  getSQLType() {
    return "blob";
  }
  mapFromDriverValue(value3) {
    if (typeof Buffer !== "undefined" && Buffer.from) {
      const buf = Buffer.isBuffer(value3) ? value3 : value3 instanceof ArrayBuffer ? Buffer.from(value3) : value3.buffer ? Buffer.from(value3.buffer, value3.byteOffset, value3.byteLength) : Buffer.from(value3);
      return JSON.parse(buf.toString("utf8"));
    }
    return JSON.parse(textDecoder.decode(value3));
  }
  mapToDriverValue(value3) {
    return Buffer.from(JSON.stringify(value3));
  }
};
var SQLiteBlobBufferBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteBlobBufferBuilder");
  }
  static [entityKind] = "SQLiteBlobBufferBuilder";
  constructor(name) {
    super(name, "buffer", "SQLiteBlobBuffer");
  }
  /** @internal */
  build(table3) {
    return new SQLiteBlobBuffer(table3, this.config);
  }
};
var SQLiteBlobBuffer = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteBlobBuffer");
  }
  static [entityKind] = "SQLiteBlobBuffer";
  mapFromDriverValue(value3) {
    if (Buffer.isBuffer(value3)) {
      return value3;
    }
    return Buffer.from(value3);
  }
  getSQLType() {
    return "blob";
  }
};
function blob(a, b) {
  const { name, config: config5 } = getColumnNameAndConfig(a, b);
  if (config5?.mode === "json") {
    return new SQLiteBlobJsonBuilder(name);
  }
  if (config5?.mode === "bigint") {
    return new SQLiteBigIntBuilder(name);
  }
  return new SQLiteBlobBufferBuilder(name);
}
__name(blob, "blob");

// node_modules/drizzle-orm/sqlite-core/columns/custom.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SQLiteCustomColumnBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteCustomColumnBuilder");
  }
  static [entityKind] = "SQLiteCustomColumnBuilder";
  constructor(name, fieldConfig, customTypeParams) {
    super(name, "custom", "SQLiteCustomColumn");
    this.config.fieldConfig = fieldConfig;
    this.config.customTypeParams = customTypeParams;
  }
  /** @internal */
  build(table3) {
    return new SQLiteCustomColumn(
      table3,
      this.config
    );
  }
};
var SQLiteCustomColumn = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteCustomColumn");
  }
  static [entityKind] = "SQLiteCustomColumn";
  sqlName;
  mapTo;
  mapFrom;
  constructor(table3, config5) {
    super(table3, config5);
    this.sqlName = config5.customTypeParams.dataType(config5.fieldConfig);
    this.mapTo = config5.customTypeParams.toDriver;
    this.mapFrom = config5.customTypeParams.fromDriver;
  }
  getSQLType() {
    return this.sqlName;
  }
  mapFromDriverValue(value3) {
    return typeof this.mapFrom === "function" ? this.mapFrom(value3) : value3;
  }
  mapToDriverValue(value3) {
    return typeof this.mapTo === "function" ? this.mapTo(value3) : value3;
  }
};
function customType(customTypeParams) {
  return (a, b) => {
    const { name, config: config5 } = getColumnNameAndConfig(a, b);
    return new SQLiteCustomColumnBuilder(
      name,
      config5,
      customTypeParams
    );
  };
}
__name(customType, "customType");

// node_modules/drizzle-orm/sqlite-core/columns/integer.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SQLiteBaseIntegerBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteBaseIntegerBuilder");
  }
  static [entityKind] = "SQLiteBaseIntegerBuilder";
  constructor(name, dataType, columnType) {
    super(name, dataType, columnType);
    this.config.autoIncrement = false;
  }
  primaryKey(config5) {
    if (config5?.autoIncrement) {
      this.config.autoIncrement = true;
    }
    this.config.hasDefault = true;
    return super.primaryKey();
  }
};
var SQLiteBaseInteger = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteBaseInteger");
  }
  static [entityKind] = "SQLiteBaseInteger";
  autoIncrement = this.config.autoIncrement;
  getSQLType() {
    return "integer";
  }
};
var SQLiteIntegerBuilder = class extends SQLiteBaseIntegerBuilder {
  static {
    __name(this, "SQLiteIntegerBuilder");
  }
  static [entityKind] = "SQLiteIntegerBuilder";
  constructor(name) {
    super(name, "number", "SQLiteInteger");
  }
  build(table3) {
    return new SQLiteInteger(
      table3,
      this.config
    );
  }
};
var SQLiteInteger = class extends SQLiteBaseInteger {
  static {
    __name(this, "SQLiteInteger");
  }
  static [entityKind] = "SQLiteInteger";
};
var SQLiteTimestampBuilder = class extends SQLiteBaseIntegerBuilder {
  static {
    __name(this, "SQLiteTimestampBuilder");
  }
  static [entityKind] = "SQLiteTimestampBuilder";
  constructor(name, mode) {
    super(name, "date", "SQLiteTimestamp");
    this.config.mode = mode;
  }
  /**
   * @deprecated Use `default()` with your own expression instead.
   *
   * Adds `DEFAULT (cast((julianday('now') - 2440587.5)*86400000 as integer))` to the column, which is the current epoch timestamp in milliseconds.
   */
  defaultNow() {
    return this.default(sql`(cast((julianday('now') - 2440587.5)*86400000 as integer))`);
  }
  build(table3) {
    return new SQLiteTimestamp(
      table3,
      this.config
    );
  }
};
var SQLiteTimestamp = class extends SQLiteBaseInteger {
  static {
    __name(this, "SQLiteTimestamp");
  }
  static [entityKind] = "SQLiteTimestamp";
  mode = this.config.mode;
  mapFromDriverValue(value3) {
    if (this.config.mode === "timestamp") {
      return new Date(value3 * 1e3);
    }
    return new Date(value3);
  }
  mapToDriverValue(value3) {
    const unix = value3.getTime();
    if (this.config.mode === "timestamp") {
      return Math.floor(unix / 1e3);
    }
    return unix;
  }
};
var SQLiteBooleanBuilder = class extends SQLiteBaseIntegerBuilder {
  static {
    __name(this, "SQLiteBooleanBuilder");
  }
  static [entityKind] = "SQLiteBooleanBuilder";
  constructor(name, mode) {
    super(name, "boolean", "SQLiteBoolean");
    this.config.mode = mode;
  }
  build(table3) {
    return new SQLiteBoolean(
      table3,
      this.config
    );
  }
};
var SQLiteBoolean = class extends SQLiteBaseInteger {
  static {
    __name(this, "SQLiteBoolean");
  }
  static [entityKind] = "SQLiteBoolean";
  mode = this.config.mode;
  mapFromDriverValue(value3) {
    return Number(value3) === 1;
  }
  mapToDriverValue(value3) {
    return value3 ? 1 : 0;
  }
};
function integer3(a, b) {
  const { name, config: config5 } = getColumnNameAndConfig(a, b);
  if (config5?.mode === "timestamp" || config5?.mode === "timestamp_ms") {
    return new SQLiteTimestampBuilder(name, config5.mode);
  }
  if (config5?.mode === "boolean") {
    return new SQLiteBooleanBuilder(name, config5.mode);
  }
  return new SQLiteIntegerBuilder(name);
}
__name(integer3, "integer");

// node_modules/drizzle-orm/sqlite-core/columns/numeric.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SQLiteNumericBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteNumericBuilder");
  }
  static [entityKind] = "SQLiteNumericBuilder";
  constructor(name) {
    super(name, "string", "SQLiteNumeric");
  }
  /** @internal */
  build(table3) {
    return new SQLiteNumeric(
      table3,
      this.config
    );
  }
};
var SQLiteNumeric = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteNumeric");
  }
  static [entityKind] = "SQLiteNumeric";
  mapFromDriverValue(value3) {
    if (typeof value3 === "string") return value3;
    return String(value3);
  }
  getSQLType() {
    return "numeric";
  }
};
var SQLiteNumericNumberBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteNumericNumberBuilder");
  }
  static [entityKind] = "SQLiteNumericNumberBuilder";
  constructor(name) {
    super(name, "number", "SQLiteNumericNumber");
  }
  /** @internal */
  build(table3) {
    return new SQLiteNumericNumber(
      table3,
      this.config
    );
  }
};
var SQLiteNumericNumber = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteNumericNumber");
  }
  static [entityKind] = "SQLiteNumericNumber";
  mapFromDriverValue(value3) {
    if (typeof value3 === "number") return value3;
    return Number(value3);
  }
  mapToDriverValue = String;
  getSQLType() {
    return "numeric";
  }
};
var SQLiteNumericBigIntBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteNumericBigIntBuilder");
  }
  static [entityKind] = "SQLiteNumericBigIntBuilder";
  constructor(name) {
    super(name, "bigint", "SQLiteNumericBigInt");
  }
  /** @internal */
  build(table3) {
    return new SQLiteNumericBigInt(
      table3,
      this.config
    );
  }
};
var SQLiteNumericBigInt = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteNumericBigInt");
  }
  static [entityKind] = "SQLiteNumericBigInt";
  mapFromDriverValue = BigInt;
  mapToDriverValue = String;
  getSQLType() {
    return "numeric";
  }
};
function numeric(a, b) {
  const { name, config: config5 } = getColumnNameAndConfig(a, b);
  const mode = config5?.mode;
  return mode === "number" ? new SQLiteNumericNumberBuilder(name) : mode === "bigint" ? new SQLiteNumericBigIntBuilder(name) : new SQLiteNumericBuilder(name);
}
__name(numeric, "numeric");

// node_modules/drizzle-orm/sqlite-core/columns/real.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SQLiteRealBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteRealBuilder");
  }
  static [entityKind] = "SQLiteRealBuilder";
  constructor(name) {
    super(name, "number", "SQLiteReal");
  }
  /** @internal */
  build(table3) {
    return new SQLiteReal(table3, this.config);
  }
};
var SQLiteReal = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteReal");
  }
  static [entityKind] = "SQLiteReal";
  getSQLType() {
    return "real";
  }
};
function real(name) {
  return new SQLiteRealBuilder(name ?? "");
}
__name(real, "real");

// node_modules/drizzle-orm/sqlite-core/columns/text.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SQLiteTextBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteTextBuilder");
  }
  static [entityKind] = "SQLiteTextBuilder";
  constructor(name, config5) {
    super(name, "string", "SQLiteText");
    this.config.enumValues = config5.enum;
    this.config.length = config5.length;
  }
  /** @internal */
  build(table3) {
    return new SQLiteText(
      table3,
      this.config
    );
  }
};
var SQLiteText = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteText");
  }
  static [entityKind] = "SQLiteText";
  enumValues = this.config.enumValues;
  length = this.config.length;
  constructor(table3, config5) {
    super(table3, config5);
  }
  getSQLType() {
    return `text${this.config.length ? `(${this.config.length})` : ""}`;
  }
};
var SQLiteTextJsonBuilder = class extends SQLiteColumnBuilder {
  static {
    __name(this, "SQLiteTextJsonBuilder");
  }
  static [entityKind] = "SQLiteTextJsonBuilder";
  constructor(name) {
    super(name, "json", "SQLiteTextJson");
  }
  /** @internal */
  build(table3) {
    return new SQLiteTextJson(
      table3,
      this.config
    );
  }
};
var SQLiteTextJson = class extends SQLiteColumn {
  static {
    __name(this, "SQLiteTextJson");
  }
  static [entityKind] = "SQLiteTextJson";
  getSQLType() {
    return "text";
  }
  mapFromDriverValue(value3) {
    return JSON.parse(value3);
  }
  mapToDriverValue(value3) {
    return JSON.stringify(value3);
  }
};
function text(a, b = {}) {
  const { name, config: config5 } = getColumnNameAndConfig(a, b);
  if (config5.mode === "json") {
    return new SQLiteTextJsonBuilder(name);
  }
  return new SQLiteTextBuilder(name, config5);
}
__name(text, "text");

// node_modules/drizzle-orm/sqlite-core/columns/all.js
function getSQLiteColumnBuilders() {
  return {
    blob,
    customType,
    integer: integer3,
    numeric,
    real,
    text
  };
}
__name(getSQLiteColumnBuilders, "getSQLiteColumnBuilders");

// node_modules/drizzle-orm/sqlite-core/table.js
var InlineForeignKeys2 = Symbol.for("drizzle:SQLiteInlineForeignKeys");
var SQLiteTable = class extends Table {
  static {
    __name(this, "SQLiteTable");
  }
  static [entityKind] = "SQLiteTable";
  /** @internal */
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys2
  });
  /** @internal */
  [Table.Symbol.Columns];
  /** @internal */
  [InlineForeignKeys2] = [];
  /** @internal */
  [Table.Symbol.ExtraConfigBuilder] = void 0;
};
function sqliteTableBase(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new SQLiteTable(name, schema, baseName);
  const parsedColumns = typeof columns === "function" ? columns(getSQLiteColumnBuilders()) : columns;
  const builtColumns = Object.fromEntries(
    Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
      const colBuilder = colBuilderBase;
      colBuilder.setName(name2);
      const column = colBuilder.build(rawTable);
      rawTable[InlineForeignKeys2].push(...colBuilder.buildForeignKeys(column, rawTable));
      return [name2, column];
    })
  );
  const table3 = Object.assign(rawTable, builtColumns);
  table3[Table.Symbol.Columns] = builtColumns;
  table3[Table.Symbol.ExtraConfigColumns] = builtColumns;
  if (extraConfig) {
    table3[SQLiteTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table3;
}
__name(sqliteTableBase, "sqliteTableBase");
var sqliteTable = /* @__PURE__ */ __name((name, columns, extraConfig) => {
  return sqliteTableBase(name, columns, extraConfig);
}, "sqliteTable");

// node_modules/drizzle-orm/sqlite-core/utils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/sqlite-core/indexes.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var IndexBuilderOn = class {
  static {
    __name(this, "IndexBuilderOn");
  }
  constructor(name, unique) {
    this.name = name;
    this.unique = unique;
  }
  static [entityKind] = "SQLiteIndexBuilderOn";
  on(...columns) {
    return new IndexBuilder(this.name, columns, this.unique);
  }
};
var IndexBuilder = class {
  static {
    __name(this, "IndexBuilder");
  }
  static [entityKind] = "SQLiteIndexBuilder";
  /** @internal */
  config;
  constructor(name, columns, unique) {
    this.config = {
      name,
      columns,
      unique,
      where: void 0
    };
  }
  /**
   * Condition for partial index.
   */
  where(condition) {
    this.config.where = condition;
    return this;
  }
  /** @internal */
  build(table3) {
    return new Index(this.config, table3);
  }
};
var Index = class {
  static {
    __name(this, "Index");
  }
  static [entityKind] = "SQLiteIndex";
  config;
  constructor(config5, table3) {
    this.config = { ...config5, table: table3 };
  }
};
function index(name) {
  return new IndexBuilderOn(name, false);
}
__name(index, "index");
function uniqueIndex(name) {
  return new IndexBuilderOn(name, true);
}
__name(uniqueIndex, "uniqueIndex");

// node_modules/drizzle-orm/sqlite-core/utils.js
function extractUsedTable(table3) {
  if (is2(table3, SQLiteTable)) {
    return [`${table3[Table.Symbol.BaseName]}`];
  }
  if (is2(table3, Subquery)) {
    return table3._.usedTables ?? [];
  }
  if (is2(table3, SQL)) {
    return table3.usedTables ?? [];
  }
  return [];
}
__name(extractUsedTable, "extractUsedTable");

// node_modules/drizzle-orm/sqlite-core/query-builders/delete.js
var SQLiteDeleteBase = class extends QueryPromise {
  static {
    __name(this, "SQLiteDeleteBase");
  }
  constructor(table3, session, dialect, withList) {
    super();
    this.table = table3;
    this.session = session;
    this.dialect = dialect;
    this.config = { table: table3, withList };
  }
  static [entityKind] = "SQLiteDelete";
  /** @internal */
  config;
  /**
   * Adds a `where` clause to the query.
   *
   * Calling this method will delete only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/delete}
   *
   * @param where the `where` clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be deleted.
   *
   * ```ts
   * // Delete all cars with green color
   * db.delete(cars).where(eq(cars.color, 'green'));
   * // or
   * db.delete(cars).where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Delete all BMW cars with a green color
   * db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Delete all cars with the green or blue color
   * db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    this.config.where = where;
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](
        new Proxy(
          this.config.table[Table.Symbol.Columns],
          new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
        )
      );
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      this.config.orderBy = orderByArray;
    } else {
      const orderByArray = columns;
      this.config.orderBy = orderByArray;
    }
    return this;
  }
  limit(limit) {
    this.config.limit = limit;
    return this;
  }
  returning(fields = this.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(isOneTimeQuery = true) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
      this.dialect.sqlToQuery(this.getSQL()),
      this.config.returning,
      this.config.returning ? "all" : "run",
      true,
      void 0,
      {
        type: "delete",
        tables: extractUsedTable(this.config.table)
      }
    );
  }
  prepare() {
    return this._prepare(false);
  }
  run = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().run(placeholderValues);
  }, "run");
  all = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().all(placeholderValues);
  }, "all");
  get = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().get(placeholderValues);
  }, "get");
  values = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().values(placeholderValues);
  }, "values");
  async execute(placeholderValues) {
    return this._prepare().execute(placeholderValues);
  }
  $dynamic() {
    return this;
  }
};

// node_modules/drizzle-orm/sqlite-core/query-builders/insert.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/sqlite-core/query-builders/query-builder.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/sqlite-core/dialect.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/casing.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
__name(toSnakeCase, "toSnakeCase");
function toCamelCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i) => {
    const formattedWord = i === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
__name(toCamelCase, "toCamelCase");
function noopCase(input) {
  return input;
}
__name(noopCase, "noopCase");
var CasingCache = class {
  static {
    __name(this, "CasingCache");
  }
  static [entityKind] = "CasingCache";
  /** @internal */
  cache = {};
  cachedTables = {};
  convert;
  constructor(casing) {
    this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase : noopCase;
  }
  getColumnCasing(column) {
    if (!column.keyAsName) return column.name;
    const schema = column.table[Table.Symbol.Schema] ?? "public";
    const tableName = column.table[Table.Symbol.OriginalName];
    const key = `${schema}.${tableName}.${column.name}`;
    if (!this.cache[key]) {
      this.cacheTable(column.table);
    }
    return this.cache[key];
  }
  cacheTable(table3) {
    const schema = table3[Table.Symbol.Schema] ?? "public";
    const tableName = table3[Table.Symbol.OriginalName];
    const tableKey = `${schema}.${tableName}`;
    if (!this.cachedTables[tableKey]) {
      for (const column of Object.values(table3[Table.Symbol.Columns])) {
        const columnKey = `${tableKey}.${column.name}`;
        this.cache[columnKey] = this.convert(column.name);
      }
      this.cachedTables[tableKey] = true;
    }
  }
  clearCache() {
    this.cache = {};
    this.cachedTables = {};
  }
};

// node_modules/drizzle-orm/sqlite-core/view-base.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SQLiteViewBase = class extends View {
  static {
    __name(this, "SQLiteViewBase");
  }
  static [entityKind] = "SQLiteViewBase";
};

// node_modules/drizzle-orm/sqlite-core/dialect.js
var SQLiteDialect = class {
  static {
    __name(this, "SQLiteDialect");
  }
  static [entityKind] = "SQLiteDialect";
  /** @internal */
  casing;
  constructor(config5) {
    this.casing = new CasingCache(config5?.casing);
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(_num) {
    return "?";
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildWithCTE(queries) {
    if (!queries?.length) return void 0;
    const withSqlChunks = [sql`with `];
    for (const [i, w] of queries.entries()) {
      withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
      if (i < queries.length - 1) {
        withSqlChunks.push(sql`, `);
      }
    }
    withSqlChunks.push(sql` `);
    return sql.join(withSqlChunks);
  }
  buildDeleteQuery({ table: table3, where, returning, withList, limit, orderBy }) {
    const withSql = this.buildWithCTE(withList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    const orderBySql = this.buildOrderBy(orderBy);
    const limitSql = this.buildLimit(limit);
    return sql`${withSql}delete from ${table3}${whereSql}${returningSql}${orderBySql}${limitSql}`;
  }
  buildUpdateSet(table3, set10) {
    const tableColumns = table3[Table.Symbol.Columns];
    const columnNames = Object.keys(tableColumns).filter(
      (colName) => set10[colName] !== void 0 || tableColumns[colName]?.onUpdateFn !== void 0
    );
    const setSize = columnNames.length;
    return sql.join(columnNames.flatMap((colName, i) => {
      const col = tableColumns[colName];
      const onUpdateFnResult = col.onUpdateFn?.();
      const value3 = set10[colName] ?? (is2(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col));
      const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value3}`;
      if (i < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table: table3, set: set10, where, returning, withList, joins, from: from2, limit, orderBy }) {
    const withSql = this.buildWithCTE(withList);
    const setSql = this.buildUpdateSet(table3, set10);
    const fromSql = from2 && sql.join([sql.raw(" from "), this.buildFromTable(from2)]);
    const joinsSql = this.buildJoins(joins);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const whereSql = where ? sql` where ${where}` : void 0;
    const orderBySql = this.buildOrderBy(orderBy);
    const limitSql = this.buildLimit(limit);
    return sql`${withSql}update ${table3} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}${orderBySql}${limitSql}`;
  }
  /**
   * Builds selection SQL with provided fields/expressions
   *
   * Examples:
   *
   * `select <selection> from`
   *
   * `insert ... returning <selection>`
   *
   * If `isSingleTable` is true, then columns won't be prefixed with table name
   */
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks3 = fields.flatMap(({ field }, i) => {
      const chunk4 = [];
      if (is2(field, SQL.Aliased) && field.isSelectionField) {
        chunk4.push(sql.identifier(field.fieldAlias));
      } else if (is2(field, SQL.Aliased) || is2(field, SQL)) {
        const query = is2(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk4.push(
            new SQL(
              query.queryChunks.map((c) => {
                if (is2(c, Column)) {
                  return sql.identifier(this.casing.getColumnCasing(c));
                }
                return c;
              })
            )
          );
        } else {
          chunk4.push(query);
        }
        if (is2(field, SQL.Aliased)) {
          chunk4.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is2(field, Column)) {
        const tableName = field.table[Table.Symbol.Name];
        if (field.columnType === "SQLiteNumericBigInt") {
          if (isSingleTable) {
            chunk4.push(sql`cast(${sql.identifier(this.casing.getColumnCasing(field))} as text)`);
          } else {
            chunk4.push(
              sql`cast(${sql.identifier(tableName)}.${sql.identifier(this.casing.getColumnCasing(field))} as text)`
            );
          }
        } else {
          if (isSingleTable) {
            chunk4.push(sql.identifier(this.casing.getColumnCasing(field)));
          } else {
            chunk4.push(sql`${sql.identifier(tableName)}.${sql.identifier(this.casing.getColumnCasing(field))}`);
          }
        }
      } else if (is2(field, Subquery)) {
        const entries2 = Object.entries(field._.selectedFields);
        if (entries2.length === 1) {
          const entry = entries2[0][1];
          const fieldDecoder = is2(entry, SQL) ? entry.decoder : is2(entry, Column) ? { mapFromDriverValue: /* @__PURE__ */ __name((v) => entry.mapFromDriverValue(v), "mapFromDriverValue") } : entry.sql.decoder;
          if (fieldDecoder) field._.sql.decoder = fieldDecoder;
        }
        chunk4.push(field);
      }
      if (i < columnsLen - 1) {
        chunk4.push(sql`, `);
      }
      return chunk4;
    });
    return sql.join(chunks3);
  }
  buildJoins(joins) {
    if (!joins || joins.length === 0) {
      return void 0;
    }
    const joinsArray = [];
    if (joins) {
      for (const [index2, joinMeta] of joins.entries()) {
        if (index2 === 0) {
          joinsArray.push(sql` `);
        }
        const table3 = joinMeta.table;
        const onSql = joinMeta.on ? sql` on ${joinMeta.on}` : void 0;
        if (is2(table3, SQLiteTable)) {
          const tableName = table3[SQLiteTable.Symbol.Name];
          const tableSchema = table3[SQLiteTable.Symbol.Schema];
          const origTableName = table3[SQLiteTable.Symbol.OriginalName];
          const alias = tableName === origTableName ? void 0 : joinMeta.alias;
          joinsArray.push(
            sql`${sql.raw(joinMeta.joinType)} join ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : void 0}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`
          );
        } else {
          joinsArray.push(
            sql`${sql.raw(joinMeta.joinType)} join ${table3}${onSql}`
          );
        }
        if (index2 < joins.length - 1) {
          joinsArray.push(sql` `);
        }
      }
    }
    return sql.join(joinsArray);
  }
  buildLimit(limit) {
    return typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
  }
  buildOrderBy(orderBy) {
    const orderByList = [];
    if (orderBy) {
      for (const [index2, orderByValue] of orderBy.entries()) {
        orderByList.push(orderByValue);
        if (index2 < orderBy.length - 1) {
          orderByList.push(sql`, `);
        }
      }
    }
    return orderByList.length > 0 ? sql` order by ${sql.join(orderByList)}` : void 0;
  }
  buildFromTable(table3) {
    if (is2(table3, Table) && table3[Table.Symbol.IsAlias]) {
      return sql`${sql`${sql.identifier(table3[Table.Symbol.Schema] ?? "")}.`.if(table3[Table.Symbol.Schema])}${sql.identifier(table3[Table.Symbol.OriginalName])} ${sql.identifier(table3[Table.Symbol.Name])}`;
    }
    return table3;
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table: table3,
    joins,
    orderBy,
    groupBy: groupBy3,
    limit,
    offset,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f of fieldsList) {
      if (is2(f.field, Column) && getTableName(f.field.table) !== (is2(table3, Subquery) ? table3._.alias : is2(table3, SQLiteViewBase) ? table3[ViewBaseConfig].name : is2(table3, SQL) ? void 0 : getTableName(table3)) && !((table22) => joins?.some(
        ({ alias }) => alias === (table22[Table.Symbol.IsAlias] ? getTableName(table22) : table22[Table.Symbol.BaseName])
      ))(f.field.table)) {
        const tableName = getTableName(f.field.table);
        throw new Error(
          `Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`
        );
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    const withSql = this.buildWithCTE(withList);
    const distinctSql = distinct ? sql` distinct` : void 0;
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = this.buildFromTable(table3);
    const joinsSql = this.buildJoins(joins);
    const whereSql = where ? sql` where ${where}` : void 0;
    const havingSql = having ? sql` having ${having}` : void 0;
    const groupByList = [];
    if (groupBy3) {
      for (const [index2, groupByValue] of groupBy3.entries()) {
        groupByList.push(groupByValue);
        if (index2 < groupBy3.length - 1) {
          groupByList.push(sql`, `);
        }
      }
    }
    const groupBySql = groupByList.length > 0 ? sql` group by ${sql.join(groupByList)}` : void 0;
    const orderBySql = this.buildOrderBy(orderBy);
    const limitSql = this.buildLimit(limit);
    const offsetSql = offset ? sql` offset ${offset}` : void 0;
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(
      this.buildSetOperationQuery({ leftSelect, setOperator }),
      rest
    );
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`${leftSelect.getSQL()} `;
    const rightChunk = sql`${rightSelect.getSQL()}`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is2(singleOrderBy, SQLiteColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is2(singleOrderBy, SQL)) {
          for (let i = 0; i < singleOrderBy.queryChunks.length; i++) {
            const chunk4 = singleOrderBy.queryChunks[i];
            if (is2(chunk4, SQLiteColumn)) {
              singleOrderBy.queryChunks[i] = sql.identifier(this.casing.getColumnCasing(chunk4));
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)}`;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : void 0;
    const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : void 0;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table: table3, values: valuesOrSelect, onConflict, returning, withList, select }) {
    const valuesSqlList = [];
    const columns = table3[Table.Symbol.Columns];
    const colEntries = Object.entries(columns).filter(
      ([_, col]) => !col.shouldDisableInsert()
    );
    const insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));
    if (select) {
      const select2 = valuesOrSelect;
      if (is2(select2, SQL)) {
        valuesSqlList.push(select2);
      } else {
        valuesSqlList.push(select2.getSQL());
      }
    } else {
      const values4 = valuesOrSelect;
      valuesSqlList.push(sql.raw("values "));
      for (const [valueIndex, value3] of values4.entries()) {
        const valueList = [];
        for (const [fieldName, col] of colEntries) {
          const colValue = value3[fieldName];
          if (colValue === void 0 || is2(colValue, Param) && colValue.value === void 0) {
            let defaultValue;
            if (col.default !== null && col.default !== void 0) {
              defaultValue = is2(col.default, SQL) ? col.default : sql.param(col.default, col);
            } else if (col.defaultFn !== void 0) {
              const defaultFnResult = col.defaultFn();
              defaultValue = is2(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
            } else if (!col.default && col.onUpdateFn !== void 0) {
              const onUpdateFnResult = col.onUpdateFn();
              defaultValue = is2(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
            } else {
              defaultValue = sql`null`;
            }
            valueList.push(defaultValue);
          } else {
            valueList.push(colValue);
          }
        }
        valuesSqlList.push(valueList);
        if (valueIndex < values4.length - 1) {
          valuesSqlList.push(sql`, `);
        }
      }
    }
    const withSql = this.buildWithCTE(withList);
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : void 0;
    const onConflictSql = onConflict?.length ? sql.join(onConflict) : void 0;
    return sql`${withSql}insert into ${table3} ${insertOrder} ${valuesSql}${onConflictSql}${returningSql}`;
  }
  sqlToQuery(sql2, invokeSource) {
    return sql2.toQuery({
      casing: this.casing,
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      invokeSource
    });
  }
  buildRelationalQuery({
    fullSchema,
    schema,
    tableNamesMap,
    table: table3,
    tableConfig,
    queryConfig: config5,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config5 === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value3]) => ({
        dbKey: value3.name,
        tsKey: key,
        field: aliasedTableColumn(value3, tableAlias),
        relationTableTsKey: void 0,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(
        Object.entries(tableConfig.columns).map(([key, value3]) => [key, aliasedTableColumn(value3, tableAlias)])
      );
      if (config5.where) {
        const whereSql = typeof config5.where === "function" ? config5.where(aliasedColumns, getOperators()) : config5.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config5.columns) {
        let isIncludeMode = false;
        for (const [field, value3] of Object.entries(config5.columns)) {
          if (value3 === void 0) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value3 === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config5.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config5.with) {
        selectedRelations = Object.entries(config5.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config5.extras) {
        extras = typeof config5.extras === "function" ? config5.extras(aliasedColumns, { sql }) : config5.extras;
        for (const [tsKey, value3] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value3, tableAlias)
          });
        }
      }
      for (const { tsKey, value: value3 } of fieldsSelection) {
        selection.push({
          dbKey: is2(value3, SQL.Aliased) ? value3.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is2(value3, Column) ? aliasedTableColumn(value3, tableAlias) : value3,
          relationTableTsKey: void 0,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config5.orderBy === "function" ? config5.orderBy(aliasedColumns, getOrderByOperators()) : config5.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is2(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config5.limit;
      offset = config5.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = getTableUniqueName(relation.referencedTable);
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(
          ...normalizedRelation.fields.map(
            (field2, i) => eq(
              aliasedTableColumn(normalizedRelation.references[i], relationTableAlias),
              aliasedTableColumn(field2, tableAlias)
            )
          )
        );
        const builtRelation = this.buildRelationalQuery({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is2(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`(${builtRelation.sql})`.as(selectedRelationTsKey);
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({
        message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`
      });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_array(${sql.join(
        selection.map(
          ({ field: field2 }) => is2(field2, SQLiteColumn) ? sql.identifier(this.casing.getColumnCasing(field2)) : is2(field2, SQL.Aliased) ? field2.sql : field2
        ),
        sql`, `
      )})`;
      if (is2(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_group_array(${field}), json_array())`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== void 0 || offset !== void 0 || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table3, tableAlias),
          fields: {},
          fieldsFlat: [
            {
              path: [],
              field: sql.raw("*")
            }
          ],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = void 0;
        limit = void 0;
        offset = void 0;
        orderBy = void 0;
      } else {
        result = aliasedTable(table3, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is2(result, SQLiteTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is2(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table3, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is2(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
};
var SQLiteSyncDialect = class extends SQLiteDialect {
  static {
    __name(this, "SQLiteSyncDialect");
  }
  static [entityKind] = "SQLiteSyncDialect";
  migrate(migrations, session, config5) {
    const migrationsTable = config5 === void 0 ? "__drizzle_migrations" : typeof config5 === "string" ? "__drizzle_migrations" : config5.migrationsTable ?? "__drizzle_migrations";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
    session.run(migrationTableCreate);
    const dbMigrations = session.values(
      sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`
    );
    const lastDbMigration = dbMigrations[0] ?? void 0;
    session.run(sql`BEGIN`);
    try {
      for (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            session.run(sql.raw(stmt));
          }
          session.run(
            sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`
          );
        }
      }
      session.run(sql`COMMIT`);
    } catch (e) {
      session.run(sql`ROLLBACK`);
      throw e;
    }
  }
};
var SQLiteAsyncDialect = class extends SQLiteDialect {
  static {
    __name(this, "SQLiteAsyncDialect");
  }
  static [entityKind] = "SQLiteAsyncDialect";
  async migrate(migrations, session, config5) {
    const migrationsTable = config5 === void 0 ? "__drizzle_migrations" : typeof config5 === "string" ? "__drizzle_migrations" : config5.migrationsTable ?? "__drizzle_migrations";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
    await session.run(migrationTableCreate);
    const dbMigrations = await session.values(
      sql`SELECT id, hash, created_at FROM ${sql.identifier(migrationsTable)} ORDER BY created_at DESC LIMIT 1`
    );
    const lastDbMigration = dbMigrations[0] ?? void 0;
    await session.transaction(async (tx) => {
      for (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.run(sql.raw(stmt));
          }
          await tx.run(
            sql`INSERT INTO ${sql.identifier(migrationsTable)} ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`
          );
        }
      }
    });
  }
};

// node_modules/drizzle-orm/sqlite-core/query-builders/select.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/query-builders/query-builder.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypedQueryBuilder = class {
  static {
    __name(this, "TypedQueryBuilder");
  }
  static [entityKind] = "TypedQueryBuilder";
  /** @internal */
  getSelectedFields() {
    return this._.selectedFields;
  }
};

// node_modules/drizzle-orm/sqlite-core/query-builders/select.js
var SQLiteSelectBuilder = class {
  static {
    __name(this, "SQLiteSelectBuilder");
  }
  static [entityKind] = "SQLiteSelectBuilder";
  fields;
  session;
  dialect;
  withList;
  distinct;
  constructor(config5) {
    this.fields = config5.fields;
    this.session = config5.session;
    this.dialect = config5.dialect;
    this.withList = config5.withList;
    this.distinct = config5.distinct;
  }
  from(source2) {
    const isPartialSelect = !!this.fields;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is2(source2, Subquery)) {
      fields = Object.fromEntries(
        Object.keys(source2._.selectedFields).map((key) => [key, source2[key]])
      );
    } else if (is2(source2, SQLiteViewBase)) {
      fields = source2[ViewBaseConfig].selectedFields;
    } else if (is2(source2, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(source2);
    }
    return new SQLiteSelectBase({
      table: source2,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    });
  }
};
var SQLiteSelectQueryBuilderBase = class extends TypedQueryBuilder {
  static {
    __name(this, "SQLiteSelectQueryBuilderBase");
  }
  static [entityKind] = "SQLiteSelectQueryBuilder";
  _;
  /** @internal */
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  cacheConfig = void 0;
  usedTables = /* @__PURE__ */ new Set();
  constructor({ table: table3, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table: table3,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields,
      config: this.config
    };
    this.tableName = getTableLikeName(table3);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
    for (const item of extractUsedTable(table3)) this.usedTables.add(item);
  }
  /** @internal */
  getUsedTables() {
    return [...this.usedTables];
  }
  createJoin(joinType) {
    return (table3, on2) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table3);
      for (const item of extractUsedTable(table3)) this.usedTables.add(item);
      if (typeof tableName === "string" && this.config.joins?.some((join4) => join4.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is2(table3, SQL)) {
          const selection = is2(table3, Subquery) ? table3._.selectedFields : is2(table3, View) ? table3[ViewBaseConfig].selectedFields : table3[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on2 === "function") {
        on2 = on2(
          new Proxy(
            this.config.fields,
            new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
          )
        );
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on: on2, table: table3, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(
              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
            );
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "cross":
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(
              Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false])
            );
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  /**
   * Executes a `left join` operation by adding another table to the current query.
   *
   * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User; pets: Pet | null; }[] = await db.select()
   *   .from(users)
   *   .leftJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number; petId: number | null; }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .leftJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  leftJoin = this.createJoin("left");
  /**
   * Executes a `right join` operation by adding another table to the current query.
   *
   * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User | null; pets: Pet; }[] = await db.select()
   *   .from(users)
   *   .rightJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number | null; petId: number; }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .rightJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  rightJoin = this.createJoin("right");
  /**
   * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.
   *
   * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User; pets: Pet; }[] = await db.select()
   *   .from(users)
   *   .innerJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number; petId: number; }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .innerJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  innerJoin = this.createJoin("inner");
  /**
   * Executes a `full join` operation by combining rows from two tables into a new table.
   *
   * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}
   *
   * @param table the table to join.
   * @param on the `on` clause.
   *
   * @example
   *
   * ```ts
   * // Select all users and their pets
   * const usersWithPets: { user: User | null; pets: Pet | null; }[] = await db.select()
   *   .from(users)
   *   .fullJoin(pets, eq(users.id, pets.ownerId))
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number | null; petId: number | null; }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .fullJoin(pets, eq(users.id, pets.ownerId))
   * ```
   */
  fullJoin = this.createJoin("full");
  /**
   * Executes a `cross join` operation by combining rows from two tables into a new table.
   *
   * Calling this method retrieves all rows from both main and joined tables, merging all rows from each table.
   *
   * See docs: {@link https://orm.drizzle.team/docs/joins#cross-join}
   *
   * @param table the table to join.
   *
   * @example
   *
   * ```ts
   * // Select all users, each user with every pet
   * const usersWithPets: { user: User; pets: Pet; }[] = await db.select()
   *   .from(users)
   *   .crossJoin(pets)
   *
   * // Select userId and petId
   * const usersIdsAndPetIds: { userId: number; petId: number; }[] = await db.select({
   *   userId: users.id,
   *   petId: pets.id,
   * })
   *   .from(users)
   *   .crossJoin(pets)
   * ```
   */
  crossJoin = this.createJoin("cross");
  createSetOperator(type, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getSQLiteSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
      this.config.setOperators.push({ type, isAll, rightSelect });
      return this;
    };
  }
  /**
   * Adds `union` set operator to the query.
   *
   * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}
   *
   * @example
   *
   * ```ts
   * // Select all unique names from customers and users tables
   * await db.select({ name: users.name })
   *   .from(users)
   *   .union(
   *     db.select({ name: customers.name }).from(customers)
   *   );
   * // or
   * import { union } from 'drizzle-orm/sqlite-core'
   *
   * await union(
   *   db.select({ name: users.name }).from(users),
   *   db.select({ name: customers.name }).from(customers)
   * );
   * ```
   */
  union = this.createSetOperator("union", false);
  /**
   * Adds `union all` set operator to the query.
   *
   * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}
   *
   * @example
   *
   * ```ts
   * // Select all transaction ids from both online and in-store sales
   * await db.select({ transaction: onlineSales.transactionId })
   *   .from(onlineSales)
   *   .unionAll(
   *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
   *   );
   * // or
   * import { unionAll } from 'drizzle-orm/sqlite-core'
   *
   * await unionAll(
   *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),
   *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)
   * );
   * ```
   */
  unionAll = this.createSetOperator("union", true);
  /**
   * Adds `intersect` set operator to the query.
   *
   * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}
   *
   * @example
   *
   * ```ts
   * // Select course names that are offered in both departments A and B
   * await db.select({ courseName: depA.courseName })
   *   .from(depA)
   *   .intersect(
   *     db.select({ courseName: depB.courseName }).from(depB)
   *   );
   * // or
   * import { intersect } from 'drizzle-orm/sqlite-core'
   *
   * await intersect(
   *   db.select({ courseName: depA.courseName }).from(depA),
   *   db.select({ courseName: depB.courseName }).from(depB)
   * );
   * ```
   */
  intersect = this.createSetOperator("intersect", false);
  /**
   * Adds `except` set operator to the query.
   *
   * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}
   *
   * @example
   *
   * ```ts
   * // Select all courses offered in department A but not in department B
   * await db.select({ courseName: depA.courseName })
   *   .from(depA)
   *   .except(
   *     db.select({ courseName: depB.courseName }).from(depB)
   *   );
   * // or
   * import { except } from 'drizzle-orm/sqlite-core'
   *
   * await except(
   *   db.select({ courseName: depA.courseName }).from(depA),
   *   db.select({ courseName: depB.courseName }).from(depB)
   * );
   * ```
   */
  except = this.createSetOperator("except", false);
  /** @internal */
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  /**
   * Adds a `where` clause to the query.
   *
   * Calling this method will select only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#filtering}
   *
   * @param where the `where` clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be selected.
   *
   * ```ts
   * // Select all cars with green color
   * await db.select().from(cars).where(eq(cars.color, 'green'));
   * // or
   * await db.select().from(cars).where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Select all BMW cars with a green color
   * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Select all cars with the green or blue color
   * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    if (typeof where === "function") {
      where = where(
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
        )
      );
    }
    this.config.where = where;
    return this;
  }
  /**
   * Adds a `having` clause to the query.
   *
   * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}
   *
   * @param having the `having` clause.
   *
   * @example
   *
   * ```ts
   * // Select all brands with more than one car
   * await db.select({
   * 	brand: cars.brand,
   * 	count: sql<number>`cast(count(${cars.id}) as int)`,
   * })
   *   .from(cars)
   *   .groupBy(cars.brand)
   *   .having(({ count }) => gt(count, 1));
   * ```
   */
  having(having) {
    if (typeof having === "function") {
      having = having(
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
        )
      );
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy3 = columns[0](
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
        )
      );
      this.config.groupBy = Array.isArray(groupBy3) ? groupBy3 : [groupBy3];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](
        new Proxy(
          this.config.fields,
          new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
        )
      );
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  /**
   * Adds a `limit` clause to the query.
   *
   * Calling this method will set the maximum number of rows that will be returned by this query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
   *
   * @param limit the `limit` clause.
   *
   * @example
   *
   * ```ts
   * // Get the first 10 people from this query.
   * await db.select().from(people).limit(10);
   * ```
   */
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  /**
   * Adds an `offset` clause to the query.
   *
   * Calling this method will skip a number of rows when returning results from this query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}
   *
   * @param offset the `offset` clause.
   *
   * @example
   *
   * ```ts
   * // Get the 10th-20th people from this query.
   * await db.select().from(people).offset(10).limit(10);
   * ```
   */
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    const usedTables = [];
    usedTables.push(...extractUsedTable(this.config.table));
    if (this.config.joins) {
      for (const it of this.config.joins) usedTables.push(...extractUsedTable(it.table));
    }
    return new Proxy(
      new Subquery(this.getSQL(), this.config.fields, alias, false, [...new Set(usedTables)]),
      new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
    );
  }
  /** @internal */
  getSelectedFields() {
    return new Proxy(
      this.config.fields,
      new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
    );
  }
  $dynamic() {
    return this;
  }
};
var SQLiteSelectBase = class extends SQLiteSelectQueryBuilderBase {
  static {
    __name(this, "SQLiteSelectBase");
  }
  static [entityKind] = "SQLiteSelect";
  /** @internal */
  _prepare(isOneTimeQuery = true) {
    if (!this.session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    const fieldsList = orderSelectedFields(this.config.fields);
    const query = this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
      this.dialect.sqlToQuery(this.getSQL()),
      fieldsList,
      "all",
      true,
      void 0,
      {
        type: "select",
        tables: [...this.usedTables]
      },
      this.cacheConfig
    );
    query.joinsNotNullableMap = this.joinsNotNullableMap;
    return query;
  }
  $withCache(config5) {
    this.cacheConfig = config5 === void 0 ? { config: {}, enable: true, autoInvalidate: true } : config5 === false ? { enable: false } : { enable: true, autoInvalidate: true, ...config5 };
    return this;
  }
  prepare() {
    return this._prepare(false);
  }
  run = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().run(placeholderValues);
  }, "run");
  all = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().all(placeholderValues);
  }, "all");
  get = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().get(placeholderValues);
  }, "get");
  values = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().values(placeholderValues);
  }, "values");
  async execute() {
    return this.all();
  }
};
applyMixins(SQLiteSelectBase, [QueryPromise]);
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error(
          "Set operator error (union / intersect / except): selected fields are not the same or are in a different order"
        );
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
__name(createSetOperator, "createSetOperator");
var getSQLiteSetOperators = /* @__PURE__ */ __name(() => ({
  union: union11,
  unionAll,
  intersect: intersect7,
  except
}), "getSQLiteSetOperators");
var union11 = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect7 = createSetOperator("intersect", false);
var except = createSetOperator("except", false);

// node_modules/drizzle-orm/sqlite-core/query-builders/query-builder.js
var QueryBuilder = class {
  static {
    __name(this, "QueryBuilder");
  }
  static [entityKind] = "SQLiteQueryBuilder";
  dialect;
  dialectConfig;
  constructor(dialect) {
    this.dialect = is2(dialect, SQLiteDialect) ? dialect : void 0;
    this.dialectConfig = is2(dialect, SQLiteDialect) ? void 0 : dialect;
  }
  $with = /* @__PURE__ */ __name((alias, selection) => {
    const queryBuilder = this;
    const as12 = /* @__PURE__ */ __name((qb) => {
      if (typeof qb === "function") {
        qb = qb(queryBuilder);
      }
      return new Proxy(
        new WithSubquery(
          qb.getSQL(),
          selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}),
          alias,
          true
        ),
        new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
      );
    }, "as");
    return { as: as12 };
  }, "$with");
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    __name(select, "select");
    function selectDistinct(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: void 0,
        dialect: self2.getDialect(),
        withList: queries,
        distinct: true
      });
    }
    __name(selectDistinct, "selectDistinct");
    return { select, selectDistinct };
  }
  select(fields) {
    return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: void 0, dialect: this.getDialect() });
  }
  selectDistinct(fields) {
    return new SQLiteSelectBuilder({
      fields: fields ?? void 0,
      session: void 0,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  // Lazy load dialect to avoid circular dependency
  getDialect() {
    if (!this.dialect) {
      this.dialect = new SQLiteSyncDialect(this.dialectConfig);
    }
    return this.dialect;
  }
};

// node_modules/drizzle-orm/sqlite-core/query-builders/insert.js
var SQLiteInsertBuilder = class {
  static {
    __name(this, "SQLiteInsertBuilder");
  }
  constructor(table3, session, dialect, withList) {
    this.table = table3;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  static [entityKind] = "SQLiteInsertBuilder";
  values(values4) {
    values4 = Array.isArray(values4) ? values4 : [values4];
    if (values4.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values4.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is2(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new SQLiteInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);
  }
  select(selectQuery) {
    const select = typeof selectQuery === "function" ? selectQuery(new QueryBuilder()) : selectQuery;
    if (!is2(select, SQL) && !haveSameKeys(this.table[Columns], select._.selectedFields)) {
      throw new Error(
        "Insert select error: selected fields are not the same or are in a different order compared to the table definition"
      );
    }
    return new SQLiteInsertBase(this.table, select, this.session, this.dialect, this.withList, true);
  }
};
var SQLiteInsertBase = class extends QueryPromise {
  static {
    __name(this, "SQLiteInsertBase");
  }
  constructor(table3, values4, session, dialect, withList, select) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table: table3, values: values4, withList, select };
  }
  static [entityKind] = "SQLiteInsert";
  /** @internal */
  config;
  returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /**
   * Adds an `on conflict do nothing` clause to the query.
   *
   * Calling this method simply avoids inserting a row as its alternative action.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}
   *
   * @param config The `target` and `where` clauses.
   *
   * @example
   * ```ts
   * // Insert one row and cancel the insert if there's a conflict
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoNothing();
   *
   * // Explicitly specify conflict target
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoNothing({ target: cars.id });
   * ```
   */
  onConflictDoNothing(config5 = {}) {
    if (!this.config.onConflict) this.config.onConflict = [];
    if (config5.target === void 0) {
      this.config.onConflict.push(sql` on conflict do nothing`);
    } else {
      const targetSql = Array.isArray(config5.target) ? sql`${config5.target}` : sql`${[config5.target]}`;
      const whereSql = config5.where ? sql` where ${config5.where}` : sql``;
      this.config.onConflict.push(sql` on conflict ${targetSql} do nothing${whereSql}`);
    }
    return this;
  }
  /**
   * Adds an `on conflict do update` clause to the query.
   *
   * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}
   *
   * @param config The `target`, `set` and `where` clauses.
   *
   * @example
   * ```ts
   * // Update the row if there's a conflict
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoUpdate({
   *     target: cars.id,
   *     set: { brand: 'Porsche' }
   *   });
   *
   * // Upsert with 'where' clause
   * await db.insert(cars)
   *   .values({ id: 1, brand: 'BMW' })
   *   .onConflictDoUpdate({
   *     target: cars.id,
   *     set: { brand: 'newBMW' },
   *     where: sql`${cars.createdAt} > '2023-01-01'::date`,
   *   });
   * ```
   */
  onConflictDoUpdate(config5) {
    if (config5.where && (config5.targetWhere || config5.setWhere)) {
      throw new Error(
        'You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.'
      );
    }
    if (!this.config.onConflict) this.config.onConflict = [];
    const whereSql = config5.where ? sql` where ${config5.where}` : void 0;
    const targetWhereSql = config5.targetWhere ? sql` where ${config5.targetWhere}` : void 0;
    const setWhereSql = config5.setWhere ? sql` where ${config5.setWhere}` : void 0;
    const targetSql = Array.isArray(config5.target) ? sql`${config5.target}` : sql`${[config5.target]}`;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config5.set));
    this.config.onConflict.push(
      sql` on conflict ${targetSql}${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`
    );
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(isOneTimeQuery = true) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
      this.dialect.sqlToQuery(this.getSQL()),
      this.config.returning,
      this.config.returning ? "all" : "run",
      true,
      void 0,
      {
        type: "insert",
        tables: extractUsedTable(this.config.table)
      }
    );
  }
  prepare() {
    return this._prepare(false);
  }
  run = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().run(placeholderValues);
  }, "run");
  all = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().all(placeholderValues);
  }, "all");
  get = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().get(placeholderValues);
  }, "get");
  values = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().values(placeholderValues);
  }, "values");
  async execute() {
    return this.config.returning ? this.all() : this.run();
  }
  $dynamic() {
    return this;
  }
};

// node_modules/drizzle-orm/sqlite-core/query-builders/update.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SQLiteUpdateBuilder = class {
  static {
    __name(this, "SQLiteUpdateBuilder");
  }
  constructor(table3, session, dialect, withList) {
    this.table = table3;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  static [entityKind] = "SQLiteUpdateBuilder";
  set(values4) {
    return new SQLiteUpdateBase(
      this.table,
      mapUpdateSet(this.table, values4),
      this.session,
      this.dialect,
      this.withList
    );
  }
};
var SQLiteUpdateBase = class extends QueryPromise {
  static {
    __name(this, "SQLiteUpdateBase");
  }
  constructor(table3, set10, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { set: set10, table: table3, withList, joins: [] };
  }
  static [entityKind] = "SQLiteUpdate";
  /** @internal */
  config;
  from(source2) {
    this.config.from = source2;
    return this;
  }
  createJoin(joinType) {
    return (table3, on2) => {
      const tableName = getTableLikeName(table3);
      if (typeof tableName === "string" && this.config.joins.some((join4) => join4.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (typeof on2 === "function") {
        const from2 = this.config.from ? is2(table3, SQLiteTable) ? table3[Table.Symbol.Columns] : is2(table3, Subquery) ? table3._.selectedFields : is2(table3, SQLiteViewBase) ? table3[ViewBaseConfig].selectedFields : void 0 : void 0;
        on2 = on2(
          new Proxy(
            this.config.table[Table.Symbol.Columns],
            new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
          ),
          from2 && new Proxy(
            from2,
            new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })
          )
        );
      }
      this.config.joins.push({ on: on2, table: table3, joinType, alias: tableName });
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  /**
   * Adds a 'where' clause to the query.
   *
   * Calling this method will update only those rows that fulfill a specified condition.
   *
   * See docs: {@link https://orm.drizzle.team/docs/update}
   *
   * @param where the 'where' clause.
   *
   * @example
   * You can use conditional operators and `sql function` to filter the rows to be updated.
   *
   * ```ts
   * // Update all cars with green color
   * db.update(cars).set({ color: 'red' })
   *   .where(eq(cars.color, 'green'));
   * // or
   * db.update(cars).set({ color: 'red' })
   *   .where(sql`${cars.color} = 'green'`)
   * ```
   *
   * You can logically combine conditional operators with `and()` and `or()` operators:
   *
   * ```ts
   * // Update all BMW cars with a green color
   * db.update(cars).set({ color: 'red' })
   *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));
   *
   * // Update all cars with the green or blue color
   * db.update(cars).set({ color: 'red' })
   *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));
   * ```
   */
  where(where) {
    this.config.where = where;
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](
        new Proxy(
          this.config.table[Table.Symbol.Columns],
          new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })
        )
      );
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      this.config.orderBy = orderByArray;
    } else {
      const orderByArray = columns;
      this.config.orderBy = orderByArray;
    }
    return this;
  }
  limit(limit) {
    this.config.limit = limit;
    return this;
  }
  returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  /** @internal */
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  /** @internal */
  _prepare(isOneTimeQuery = true) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
      this.dialect.sqlToQuery(this.getSQL()),
      this.config.returning,
      this.config.returning ? "all" : "run",
      true,
      void 0,
      {
        type: "insert",
        tables: extractUsedTable(this.config.table)
      }
    );
  }
  prepare() {
    return this._prepare(false);
  }
  run = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().run(placeholderValues);
  }, "run");
  all = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().all(placeholderValues);
  }, "all");
  get = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().get(placeholderValues);
  }, "get");
  values = /* @__PURE__ */ __name((placeholderValues) => {
    return this._prepare().values(placeholderValues);
  }, "values");
  async execute() {
    return this.config.returning ? this.all() : this.run();
  }
  $dynamic() {
    return this;
  }
};

// node_modules/drizzle-orm/sqlite-core/query-builders/count.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SQLiteCountBuilder = class _SQLiteCountBuilder extends SQL {
  static {
    __name(this, "SQLiteCountBuilder");
  }
  constructor(params) {
    super(_SQLiteCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
    this.params = params;
    this.session = params.session;
    this.sql = _SQLiteCountBuilder.buildCount(
      params.source,
      params.filters
    );
  }
  sql;
  static [entityKind] = "SQLiteCountBuilderAsync";
  [Symbol.toStringTag] = "SQLiteCountBuilderAsync";
  session;
  static buildEmbeddedCount(source2, filters) {
    return sql`(select count(*) from ${source2}${sql.raw(" where ").if(filters)}${filters})`;
  }
  static buildCount(source2, filters) {
    return sql`select count(*) from ${source2}${sql.raw(" where ").if(filters)}${filters}`;
  }
  then(onfulfilled, onrejected) {
    return Promise.resolve(this.session.count(this.sql)).then(
      onfulfilled,
      onrejected
    );
  }
  catch(onRejected) {
    return this.then(void 0, onRejected);
  }
  finally(onFinally) {
    return this.then(
      (value3) => {
        onFinally?.();
        return value3;
      },
      (reason) => {
        onFinally?.();
        throw reason;
      }
    );
  }
};

// node_modules/drizzle-orm/sqlite-core/query-builders/query.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var RelationalQueryBuilder = class {
  static {
    __name(this, "RelationalQueryBuilder");
  }
  constructor(mode, fullSchema, schema, tableNamesMap, table3, tableConfig, dialect, session) {
    this.mode = mode;
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table3;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
  }
  static [entityKind] = "SQLiteAsyncRelationalQueryBuilder";
  findMany(config5) {
    return this.mode === "sync" ? new SQLiteSyncRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config5 ? config5 : {},
      "many"
    ) : new SQLiteRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config5 ? config5 : {},
      "many"
    );
  }
  findFirst(config5) {
    return this.mode === "sync" ? new SQLiteSyncRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config5 ? { ...config5, limit: 1 } : { limit: 1 },
      "first"
    ) : new SQLiteRelationalQuery(
      this.fullSchema,
      this.schema,
      this.tableNamesMap,
      this.table,
      this.tableConfig,
      this.dialect,
      this.session,
      config5 ? { ...config5, limit: 1 } : { limit: 1 },
      "first"
    );
  }
};
var SQLiteRelationalQuery = class extends QueryPromise {
  static {
    __name(this, "SQLiteRelationalQuery");
  }
  constructor(fullSchema, schema, tableNamesMap, table3, tableConfig, dialect, session, config5, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table3;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.config = config5;
    this.mode = mode;
  }
  static [entityKind] = "SQLiteAsyncRelationalQuery";
  /** @internal */
  mode;
  /** @internal */
  getSQL() {
    return this.dialect.buildRelationalQuery({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    }).sql;
  }
  /** @internal */
  _prepare(isOneTimeQuery = false) {
    const { query, builtQuery } = this._toSQL();
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](
      builtQuery,
      void 0,
      this.mode === "first" ? "get" : "all",
      true,
      (rawRows, mapColumnValue) => {
        const rows = rawRows.map(
          (row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)
        );
        if (this.mode === "first") {
          return rows[0];
        }
        return rows;
      }
    );
  }
  prepare() {
    return this._prepare(false);
  }
  _toSQL() {
    const query = this.dialect.buildRelationalQuery({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  /** @internal */
  executeRaw() {
    if (this.mode === "first") {
      return this._prepare(false).get();
    }
    return this._prepare(false).all();
  }
  async execute() {
    return this.executeRaw();
  }
};
var SQLiteSyncRelationalQuery = class extends SQLiteRelationalQuery {
  static {
    __name(this, "SQLiteSyncRelationalQuery");
  }
  static [entityKind] = "SQLiteSyncRelationalQuery";
  sync() {
    return this.executeRaw();
  }
};

// node_modules/drizzle-orm/sqlite-core/query-builders/raw.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SQLiteRaw = class extends QueryPromise {
  static {
    __name(this, "SQLiteRaw");
  }
  constructor(execute3, getSQL, action, dialect, mapBatchResult) {
    super();
    this.execute = execute3;
    this.getSQL = getSQL;
    this.dialect = dialect;
    this.mapBatchResult = mapBatchResult;
    this.config = { action };
  }
  static [entityKind] = "SQLiteRaw";
  /** @internal */
  config;
  getQuery() {
    return { ...this.dialect.sqlToQuery(this.getSQL()), method: this.config.action };
  }
  mapResult(result, isFromBatch) {
    return isFromBatch ? this.mapBatchResult(result) : result;
  }
  _prepare() {
    return this;
  }
  /** @internal */
  isResponseInArrayMode() {
    return false;
  }
};

// node_modules/drizzle-orm/sqlite-core/db.js
var BaseSQLiteDatabase = class {
  static {
    __name(this, "BaseSQLiteDatabase");
  }
  constructor(resultKind, dialect, session, schema) {
    this.resultKind = resultKind;
    this.dialect = dialect;
    this.session = session;
    this._ = schema ? {
      schema: schema.schema,
      fullSchema: schema.fullSchema,
      tableNamesMap: schema.tableNamesMap
    } : {
      schema: void 0,
      fullSchema: {},
      tableNamesMap: {}
    };
    this.query = {};
    const query = this.query;
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        query[tableName] = new RelationalQueryBuilder(
          resultKind,
          schema.fullSchema,
          this._.schema,
          this._.tableNamesMap,
          schema.fullSchema[tableName],
          columns,
          dialect,
          session
        );
      }
    }
    this.$cache = { invalidate: /* @__PURE__ */ __name(async (_params) => {
    }, "invalidate") };
  }
  static [entityKind] = "BaseSQLiteDatabase";
  query;
  /**
   * Creates a subquery that defines a temporary named result set as a CTE.
   *
   * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
   *
   * @param alias The alias for the subquery.
   *
   * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.
   *
   * @example
   *
   * ```ts
   * // Create a subquery with alias 'sq' and use it in the select query
   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
   *
   * const result = await db.with(sq).select().from(sq);
   * ```
   *
   * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:
   *
   * ```ts
   * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query
   * const sq = db.$with('sq').as(db.select({
   *   name: sql<string>`upper(${users.name})`.as('name'),
   * })
   * .from(users));
   *
   * const result = await db.with(sq).select({ name: sq.name }).from(sq);
   * ```
   */
  $with = /* @__PURE__ */ __name((alias, selection) => {
    const self2 = this;
    const as12 = /* @__PURE__ */ __name((qb) => {
      if (typeof qb === "function") {
        qb = qb(new QueryBuilder(self2.dialect));
      }
      return new Proxy(
        new WithSubquery(
          qb.getSQL(),
          selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}),
          alias,
          true
        ),
        new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
      );
    }, "as");
    return { as: as12 };
  }, "$with");
  $count(source2, filters) {
    return new SQLiteCountBuilder({ source: source2, filters, session: this.session });
  }
  /**
   * Incorporates a previously defined CTE (using `$with`) into the main query.
   *
   * This method allows the main query to reference a temporary named result set.
   *
   * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}
   *
   * @param queries The CTEs to incorporate into the main query.
   *
   * @example
   *
   * ```ts
   * // Define a subquery 'sq' as a CTE using $with
   * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));
   *
   * // Incorporate the CTE 'sq' into the main query and select from it
   * const result = await db.with(sq).select().from(sq);
   * ```
   */
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    __name(select, "select");
    function selectDistinct(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: true
      });
    }
    __name(selectDistinct, "selectDistinct");
    function update6(table3) {
      return new SQLiteUpdateBuilder(table3, self2.session, self2.dialect, queries);
    }
    __name(update6, "update");
    function insert3(into) {
      return new SQLiteInsertBuilder(into, self2.session, self2.dialect, queries);
    }
    __name(insert3, "insert");
    function delete_3(from2) {
      return new SQLiteDeleteBase(from2, self2.session, self2.dialect, queries);
    }
    __name(delete_3, "delete_");
    return { select, selectDistinct, update: update6, insert: insert3, delete: delete_3 };
  }
  select(fields) {
    return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: this.session, dialect: this.dialect });
  }
  selectDistinct(fields) {
    return new SQLiteSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  /**
   * Creates an update query.
   *
   * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.
   *
   * Use `.set()` method to specify which values to update.
   *
   * See docs: {@link https://orm.drizzle.team/docs/update}
   *
   * @param table The table to update.
   *
   * @example
   *
   * ```ts
   * // Update all rows in the 'cars' table
   * await db.update(cars).set({ color: 'red' });
   *
   * // Update rows with filters and conditions
   * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));
   *
   * // Update with returning clause
   * const updatedCar: Car[] = await db.update(cars)
   *   .set({ color: 'red' })
   *   .where(eq(cars.id, 1))
   *   .returning();
   * ```
   */
  update(table3) {
    return new SQLiteUpdateBuilder(table3, this.session, this.dialect);
  }
  $cache;
  /**
   * Creates an insert query.
   *
   * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.
   *
   * See docs: {@link https://orm.drizzle.team/docs/insert}
   *
   * @param table The table to insert into.
   *
   * @example
   *
   * ```ts
   * // Insert one row
   * await db.insert(cars).values({ brand: 'BMW' });
   *
   * // Insert multiple rows
   * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);
   *
   * // Insert with returning clause
   * const insertedCar: Car[] = await db.insert(cars)
   *   .values({ brand: 'BMW' })
   *   .returning();
   * ```
   */
  insert(into) {
    return new SQLiteInsertBuilder(into, this.session, this.dialect);
  }
  /**
   * Creates a delete query.
   *
   * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.
   *
   * See docs: {@link https://orm.drizzle.team/docs/delete}
   *
   * @param table The table to delete from.
   *
   * @example
   *
   * ```ts
   * // Delete all rows in the 'cars' table
   * await db.delete(cars);
   *
   * // Delete rows with filters and conditions
   * await db.delete(cars).where(eq(cars.color, 'green'));
   *
   * // Delete with returning clause
   * const deletedCar: Car[] = await db.delete(cars)
   *   .where(eq(cars.id, 1))
   *   .returning();
   * ```
   */
  delete(from2) {
    return new SQLiteDeleteBase(from2, this.session, this.dialect);
  }
  run(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(
        async () => this.session.run(sequel),
        () => sequel,
        "run",
        this.dialect,
        this.session.extractRawRunValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.run(sequel);
  }
  all(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(
        async () => this.session.all(sequel),
        () => sequel,
        "all",
        this.dialect,
        this.session.extractRawAllValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.all(sequel);
  }
  get(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(
        async () => this.session.get(sequel),
        () => sequel,
        "get",
        this.dialect,
        this.session.extractRawGetValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.get(sequel);
  }
  values(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(
        async () => this.session.values(sequel),
        () => sequel,
        "values",
        this.dialect,
        this.session.extractRawValuesValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.values(sequel);
  }
  transaction(transaction, config5) {
    return this.session.transaction(transaction, config5);
  }
};

// node_modules/drizzle-orm/d1/session.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/drizzle-orm/cache/core/cache.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Cache = class {
  static {
    __name(this, "Cache");
  }
  static [entityKind] = "Cache";
};
var NoopCache = class extends Cache {
  static {
    __name(this, "NoopCache");
  }
  strategy() {
    return "all";
  }
  static [entityKind] = "NoopCache";
  async get(_key) {
    return void 0;
  }
  async put(_hashedQuery, _response, _tables, _config) {
  }
  async onMutate(_params) {
  }
};
async function hashQuery(sql2, params) {
  const dataToHash = `${sql2}-${JSON.stringify(params)}`;
  const encoder2 = new TextEncoder();
  const data = encoder2.encode(dataToHash);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = [...new Uint8Array(hashBuffer)];
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}
__name(hashQuery, "hashQuery");

// node_modules/drizzle-orm/sqlite-core/session.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ExecuteResultSync = class extends QueryPromise {
  static {
    __name(this, "ExecuteResultSync");
  }
  constructor(resultCb) {
    super();
    this.resultCb = resultCb;
  }
  static [entityKind] = "ExecuteResultSync";
  async execute() {
    return this.resultCb();
  }
  sync() {
    return this.resultCb();
  }
};
var SQLitePreparedQuery = class {
  static {
    __name(this, "SQLitePreparedQuery");
  }
  constructor(mode, executeMethod, query, cache, queryMetadata, cacheConfig) {
    this.mode = mode;
    this.executeMethod = executeMethod;
    this.query = query;
    this.cache = cache;
    this.queryMetadata = queryMetadata;
    this.cacheConfig = cacheConfig;
    if (cache && cache.strategy() === "all" && cacheConfig === void 0) {
      this.cacheConfig = { enable: true, autoInvalidate: true };
    }
    if (!this.cacheConfig?.enable) {
      this.cacheConfig = void 0;
    }
  }
  static [entityKind] = "PreparedQuery";
  /** @internal */
  joinsNotNullableMap;
  /** @internal */
  async queryWithCache(queryString, params, query) {
    if (this.cache === void 0 || is2(this.cache, NoopCache) || this.queryMetadata === void 0) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.cacheConfig && !this.cacheConfig.enable) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if ((this.queryMetadata.type === "insert" || this.queryMetadata.type === "update" || this.queryMetadata.type === "delete") && this.queryMetadata.tables.length > 0) {
      try {
        const [res] = await Promise.all([
          query(),
          this.cache.onMutate({ tables: this.queryMetadata.tables })
        ]);
        return res;
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (!this.cacheConfig) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.queryMetadata.type === "select") {
      const fromCache = await this.cache.get(
        this.cacheConfig.tag ?? await hashQuery(queryString, params),
        this.queryMetadata.tables,
        this.cacheConfig.tag !== void 0,
        this.cacheConfig.autoInvalidate
      );
      if (fromCache === void 0) {
        let result;
        try {
          result = await query();
        } catch (e) {
          throw new DrizzleQueryError(queryString, params, e);
        }
        await this.cache.put(
          this.cacheConfig.tag ?? await hashQuery(queryString, params),
          result,
          // make sure we send tables that were used in a query only if user wants to invalidate it on each write
          this.cacheConfig.autoInvalidate ? this.queryMetadata.tables : [],
          this.cacheConfig.tag !== void 0,
          this.cacheConfig.config
        );
        return result;
      }
      return fromCache;
    }
    try {
      return await query();
    } catch (e) {
      throw new DrizzleQueryError(queryString, params, e);
    }
  }
  getQuery() {
    return this.query;
  }
  mapRunResult(result, _isFromBatch) {
    return result;
  }
  mapAllResult(_result, _isFromBatch) {
    throw new Error("Not implemented");
  }
  mapGetResult(_result, _isFromBatch) {
    throw new Error("Not implemented");
  }
  execute(placeholderValues) {
    if (this.mode === "async") {
      return this[this.executeMethod](placeholderValues);
    }
    return new ExecuteResultSync(() => this[this.executeMethod](placeholderValues));
  }
  mapResult(response, isFromBatch) {
    switch (this.executeMethod) {
      case "run": {
        return this.mapRunResult(response, isFromBatch);
      }
      case "all": {
        return this.mapAllResult(response, isFromBatch);
      }
      case "get": {
        return this.mapGetResult(response, isFromBatch);
      }
    }
  }
};
var SQLiteSession = class {
  static {
    __name(this, "SQLiteSession");
  }
  constructor(dialect) {
    this.dialect = dialect;
  }
  static [entityKind] = "SQLiteSession";
  prepareOneTimeQuery(query, fields, executeMethod, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {
    return this.prepareQuery(
      query,
      fields,
      executeMethod,
      isResponseInArrayMode,
      customResultMapper,
      queryMetadata,
      cacheConfig
    );
  }
  run(query) {
    const staticQuery = this.dialect.sqlToQuery(query);
    try {
      return this.prepareOneTimeQuery(staticQuery, void 0, "run", false).run();
    } catch (err) {
      throw new DrizzleError({ cause: err, message: `Failed to run the query '${staticQuery.sql}'` });
    }
  }
  /** @internal */
  extractRawRunValueFromBatchResult(result) {
    return result;
  }
  all(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).all();
  }
  /** @internal */
  extractRawAllValueFromBatchResult(_result) {
    throw new Error("Not implemented");
  }
  get(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).get();
  }
  /** @internal */
  extractRawGetValueFromBatchResult(_result) {
    throw new Error("Not implemented");
  }
  values(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), void 0, "run", false).values();
  }
  async count(sql2) {
    const result = await this.values(sql2);
    return result[0][0];
  }
  /** @internal */
  extractRawValuesValueFromBatchResult(_result) {
    throw new Error("Not implemented");
  }
};
var SQLiteTransaction = class extends BaseSQLiteDatabase {
  static {
    __name(this, "SQLiteTransaction");
  }
  constructor(resultType, dialect, session, schema, nestedIndex = 0) {
    super(resultType, dialect, session, schema);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  static [entityKind] = "SQLiteTransaction";
  rollback() {
    throw new TransactionRollbackError();
  }
};

// node_modules/drizzle-orm/d1/session.js
var SQLiteD1Session = class extends SQLiteSession {
  static {
    __name(this, "SQLiteD1Session");
  }
  constructor(client, dialect, schema, options = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger();
    this.cache = options.cache ?? new NoopCache();
  }
  static [entityKind] = "SQLiteD1Session";
  logger;
  cache;
  prepareQuery(query, fields, executeMethod, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {
    const stmt = this.client.prepare(query.sql);
    return new D1PreparedQuery(
      stmt,
      query,
      this.logger,
      this.cache,
      queryMetadata,
      cacheConfig,
      fields,
      executeMethod,
      isResponseInArrayMode,
      customResultMapper
    );
  }
  async batch(queries) {
    const preparedQueries = [];
    const builtQueries = [];
    for (const query of queries) {
      const preparedQuery = query._prepare();
      const builtQuery = preparedQuery.getQuery();
      preparedQueries.push(preparedQuery);
      if (builtQuery.params.length > 0) {
        builtQueries.push(preparedQuery.stmt.bind(...builtQuery.params));
      } else {
        const builtQuery2 = preparedQuery.getQuery();
        builtQueries.push(
          this.client.prepare(builtQuery2.sql).bind(...builtQuery2.params)
        );
      }
    }
    const batchResults = await this.client.batch(builtQueries);
    return batchResults.map((result, i) => preparedQueries[i].mapResult(result, true));
  }
  extractRawAllValueFromBatchResult(result) {
    return result.results;
  }
  extractRawGetValueFromBatchResult(result) {
    return result.results[0];
  }
  extractRawValuesValueFromBatchResult(result) {
    return d1ToRawMapping(result.results);
  }
  async transaction(transaction, config5) {
    const tx = new D1Transaction("async", this.dialect, this, this.schema);
    await this.run(sql.raw(`begin${config5?.behavior ? " " + config5.behavior : ""}`));
    try {
      const result = await transaction(tx);
      await this.run(sql`commit`);
      return result;
    } catch (err) {
      await this.run(sql`rollback`);
      throw err;
    }
  }
};
var D1Transaction = class _D1Transaction extends SQLiteTransaction {
  static {
    __name(this, "D1Transaction");
  }
  static [entityKind] = "D1Transaction";
  async transaction(transaction) {
    const savepointName = `sp${this.nestedIndex}`;
    const tx = new _D1Transaction("async", this.dialect, this.session, this.schema, this.nestedIndex + 1);
    await this.session.run(sql.raw(`savepoint ${savepointName}`));
    try {
      const result = await transaction(tx);
      await this.session.run(sql.raw(`release savepoint ${savepointName}`));
      return result;
    } catch (err) {
      await this.session.run(sql.raw(`rollback to savepoint ${savepointName}`));
      throw err;
    }
  }
};
function d1ToRawMapping(results) {
  const rows = [];
  for (const row of results) {
    const entry = Object.keys(row).map((k) => row[k]);
    rows.push(entry);
  }
  return rows;
}
__name(d1ToRawMapping, "d1ToRawMapping");
var D1PreparedQuery = class extends SQLitePreparedQuery {
  static {
    __name(this, "D1PreparedQuery");
  }
  constructor(stmt, query, logger, cache, queryMetadata, cacheConfig, fields, executeMethod, _isResponseInArrayMode, customResultMapper) {
    super("async", executeMethod, query, cache, queryMetadata, cacheConfig);
    this.logger = logger;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
    this.fields = fields;
    this.stmt = stmt;
  }
  static [entityKind] = "D1PreparedQuery";
  /** @internal */
  customResultMapper;
  /** @internal */
  fields;
  /** @internal */
  stmt;
  async run(placeholderValues) {
    const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
    this.logger.logQuery(this.query.sql, params);
    return await this.queryWithCache(this.query.sql, params, async () => {
      return this.stmt.bind(...params).run();
    });
  }
  async all(placeholderValues) {
    const { fields, query, logger, stmt, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      const params = fillPlaceholders(query.params, placeholderValues ?? {});
      logger.logQuery(query.sql, params);
      return await this.queryWithCache(query.sql, params, async () => {
        return stmt.bind(...params).all().then(({ results }) => this.mapAllResult(results));
      });
    }
    const rows = await this.values(placeholderValues);
    return this.mapAllResult(rows);
  }
  mapAllResult(rows, isFromBatch) {
    if (isFromBatch) {
      rows = d1ToRawMapping(rows.results);
    }
    if (!this.fields && !this.customResultMapper) {
      return rows;
    }
    if (this.customResultMapper) {
      return this.customResultMapper(rows);
    }
    return rows.map((row) => mapResultRow(this.fields, row, this.joinsNotNullableMap));
  }
  async get(placeholderValues) {
    const { fields, joinsNotNullableMap, query, logger, stmt, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      const params = fillPlaceholders(query.params, placeholderValues ?? {});
      logger.logQuery(query.sql, params);
      return await this.queryWithCache(query.sql, params, async () => {
        return stmt.bind(...params).all().then(({ results }) => results[0]);
      });
    }
    const rows = await this.values(placeholderValues);
    if (!rows[0]) {
      return void 0;
    }
    if (customResultMapper) {
      return customResultMapper(rows);
    }
    return mapResultRow(fields, rows[0], joinsNotNullableMap);
  }
  mapGetResult(result, isFromBatch) {
    if (isFromBatch) {
      result = d1ToRawMapping(result.results)[0];
    }
    if (!this.fields && !this.customResultMapper) {
      return result;
    }
    if (this.customResultMapper) {
      return this.customResultMapper([result]);
    }
    return mapResultRow(this.fields, result, this.joinsNotNullableMap);
  }
  async values(placeholderValues) {
    const params = fillPlaceholders(this.query.params, placeholderValues ?? {});
    this.logger.logQuery(this.query.sql, params);
    return await this.queryWithCache(this.query.sql, params, async () => {
      return this.stmt.bind(...params).raw();
    });
  }
  /** @internal */
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
};

// node_modules/drizzle-orm/d1/driver.js
var DrizzleD1Database = class extends BaseSQLiteDatabase {
  static {
    __name(this, "DrizzleD1Database");
  }
  static [entityKind] = "D1Database";
  async batch(batch) {
    return this.session.batch(batch);
  }
};
function drizzle(client, config5 = {}) {
  const dialect = new SQLiteAsyncDialect({ casing: config5.casing });
  let logger;
  if (config5.logger === true) {
    logger = new DefaultLogger();
  } else if (config5.logger !== false) {
    logger = config5.logger;
  }
  let schema;
  if (config5.schema) {
    const tablesConfig = extractTablesRelationalConfig(
      config5.schema,
      createTableRelationsHelpers
    );
    schema = {
      fullSchema: config5.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session = new SQLiteD1Session(client, dialect, schema, { logger, cache: config5.cache });
  const db = new DrizzleD1Database("async", dialect, session, schema);
  db.$client = client;
  db.$cache = config5.cache;
  if (db.$cache) {
    db.$cache["invalidate"] = config5.cache?.onMutate;
  }
  return db;
}
__name(drizzle, "drizzle");

// src/db/schema.ts
var schema_exports = {};
__export(schema_exports, {
  directoryEndpoints: () => directoryEndpoints,
  endpoints: () => endpoints,
  fingerprints: () => fingerprints,
  gallery: () => gallery,
  galleryFts: () => galleryFts,
  galleryFtsSyncTriggers: () => galleryFtsSyncTriggers,
  paths: () => paths,
  runs: () => runs,
  sites: () => sites
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var sites = sqliteTable("sites", {
  id: text("id").primaryKey(),
  url: text("url").notNull(),
  domain: text("domain").notNull(),
  firstScoutedAt: text("first_scouted_at").notNull(),
  lastScoutedAt: text("last_scouted_at").notNull()
});
var endpoints = sqliteTable(
  "endpoints",
  {
    id: text("id").primaryKey(),
    siteId: text("site_id").notNull().references(() => sites.id),
    method: text("method").notNull(),
    pathPattern: text("path_pattern").notNull(),
    requestSchema: text("request_schema"),
    responseSchema: text("response_schema"),
    requestHeaders: text("request_headers"),
    responseHeaders: text("response_headers"),
    sampleCount: integer3("sample_count").notNull().default(1),
    firstSeenAt: text("first_seen_at").notNull(),
    lastSeenAt: text("last_seen_at").notNull()
  },
  (table3) => [
    uniqueIndex("endpoints_site_method_path").on(table3.siteId, table3.method, table3.pathPattern)
  ]
);
var paths = sqliteTable("paths", {
  id: text("id").primaryKey(),
  siteId: text("site_id").notNull().references(() => sites.id),
  task: text("task").notNull(),
  steps: text("steps").notNull().default("[]"),
  endpointIds: text("endpoint_ids").notNull().default("[]"),
  status: text("status").notNull().default("active"),
  createdAt: text("created_at").notNull(),
  lastUsedAt: text("last_used_at"),
  failCount: integer3("fail_count").notNull().default(0),
  healCount: integer3("heal_count").notNull().default(0)
});
var runs = sqliteTable("runs", {
  id: text("id").primaryKey(),
  pathId: text("path_id").references(() => paths.id),
  tool: text("tool").notNull(),
  status: text("status").notNull(),
  input: text("input").notNull(),
  output: text("output"),
  error: text("error"),
  durationMs: integer3("duration_ms"),
  harKey: text("har_key"),
  createdAt: text("created_at").notNull()
});
var gallery = sqliteTable(
  "gallery",
  {
    id: text("id").primaryKey(),
    domain: text("domain").notNull(),
    url: text("url").notNull(),
    task: text("task").notNull(),
    endpointCount: integer3("endpoint_count").notNull(),
    endpointsSummary: text("endpoints_summary").notNull(),
    specKey: text("spec_key").notNull(),
    contributor: text("contributor").default("anonymous"),
    createdAt: text("created_at").notNull(),
    updatedAt: text("updated_at").notNull(),
    version: integer3("version").notNull().default(1)
  },
  (table3) => [index("idx_gallery_domain").on(table3.domain)]
);
var fingerprints = sqliteTable(
  "fingerprints",
  {
    id: text("id").primaryKey(),
    domain: text("domain").notNull().unique(),
    url: text("url").notNull(),
    endpointCount: integer3("endpoint_count").notNull(),
    capabilities: text("capabilities").notNull(),
    // JSON array
    methods: text("methods").notNull(),
    // JSON object {"GET": 5, "POST": 3}
    auth: text("auth").notNull(),
    // none|bearer|cookie|api-key|oauth|basic|unknown
    confidence: integer3("confidence").notNull(),
    // 0-100 stored as int
    specKey: text("spec_key").notNull(),
    // R2 key for full OpenAPI
    contributor: text("contributor").default("anonymous"),
    createdAt: text("created_at").notNull(),
    updatedAt: text("updated_at").notNull(),
    version: integer3("version").notNull().default(1)
  },
  (table3) => [index("idx_fingerprints_domain").on(table3.domain)]
);
var directoryEndpoints = sqliteTable(
  "directory_endpoints",
  {
    id: text("id").primaryKey(),
    fingerprintId: text("fingerprint_id").notNull().references(() => fingerprints.id),
    method: text("method").notNull(),
    path: text("path").notNull(),
    summary: text("summary").notNull(),
    capability: text("capability").notNull(),
    // auth|payments|content|crud|...
    requestSchema: text("request_schema"),
    // JSON Schema as string
    responseSchema: text("response_schema"),
    // JSON Schema as string
    auth: integer3("auth").notNull(),
    // 0 or 1
    exampleRequest: text("example_request"),
    // JSON
    exampleResponse: text("example_response"),
    // JSON
    vectorId: text("vector_id")
    // ID in Vectorize for semantic search
  },
  (table3) => [
    index("idx_directory_endpoints_fingerprint").on(table3.fingerprintId),
    index("idx_directory_endpoints_capability").on(table3.capability),
    uniqueIndex("idx_directory_endpoints_unique").on(table3.fingerprintId, table3.method, table3.path)
  ]
);
var galleryFts = sql`
CREATE VIRTUAL TABLE IF NOT EXISTS gallery_fts USING fts5(
	domain,
	url,
	task,
	endpoints_summary,
	content='gallery',
	content_rowid='rowid'
);
`;
var galleryFtsSyncTriggers = [
  sql`
CREATE TRIGGER IF NOT EXISTS gallery_ai AFTER INSERT ON gallery BEGIN
	INSERT INTO gallery_fts(rowid, domain, url, task, endpoints_summary)
	VALUES (NEW.rowid, NEW.domain, NEW.url, NEW.task, NEW.endpoints_summary);
END;
`,
  sql`
CREATE TRIGGER IF NOT EXISTS gallery_ad AFTER DELETE ON gallery BEGIN
	INSERT INTO gallery_fts(gallery_fts, rowid, domain, url, task, endpoints_summary)
	VALUES ('delete', OLD.rowid, OLD.domain, OLD.url, OLD.task, OLD.endpoints_summary);
END;
`,
  sql`
CREATE TRIGGER IF NOT EXISTS gallery_au AFTER UPDATE ON gallery BEGIN
	INSERT INTO gallery_fts(gallery_fts, rowid, domain, url, task, endpoints_summary)
	VALUES ('delete', OLD.rowid, OLD.domain, OLD.url, OLD.task, OLD.endpoints_summary);
	INSERT INTO gallery_fts(rowid, domain, url, task, endpoints_summary)
	VALUES (NEW.rowid, NEW.domain, NEW.url, NEW.task, NEW.endpoints_summary);
END;
`
];

// src/db/queries.ts
function createDb(d1) {
  return drizzle(d1, { schema: schema_exports });
}
__name(createDb, "createDb");
function getSite(db, id2) {
  return db.select().from(sites).where(eq(sites.id, id2)).get();
}
__name(getSite, "getSite");
function upsertSite(db, site) {
  return db.insert(sites).values(site).onConflictDoUpdate({
    target: sites.id,
    set: { lastScoutedAt: site.lastScoutedAt }
  }).run();
}
__name(upsertSite, "upsertSite");
function getEndpointsBySite(db, siteId) {
  return db.select().from(endpoints).where(eq(endpoints.siteId, siteId)).all();
}
__name(getEndpointsBySite, "getEndpointsBySite");
function upsertEndpoint(db, endpoint) {
  return db.insert(endpoints).values(endpoint).onConflictDoUpdate({
    target: endpoints.id,
    set: {
      requestSchema: endpoint.requestSchema,
      responseSchema: endpoint.responseSchema,
      requestHeaders: endpoint.requestHeaders,
      responseHeaders: endpoint.responseHeaders,
      sampleCount: endpoint.sampleCount,
      lastSeenAt: endpoint.lastSeenAt
    }
  }).run();
}
__name(upsertEndpoint, "upsertEndpoint");
function getPath(db, id2) {
  return db.select().from(paths).where(eq(paths.id, id2)).get();
}
__name(getPath, "getPath");
function getPathsBySite(db, siteId) {
  return db.select().from(paths).where(eq(paths.siteId, siteId)).all();
}
__name(getPathsBySite, "getPathsBySite");
function upsertPath(db, path) {
  return db.insert(paths).values(path).onConflictDoUpdate({
    target: paths.id,
    set: {
      steps: path.steps,
      endpointIds: path.endpointIds,
      status: path.status,
      lastUsedAt: path.lastUsedAt,
      failCount: path.failCount,
      healCount: path.healCount
    }
  }).run();
}
__name(upsertPath, "upsertPath");
function insertRun(db, run6) {
  return db.insert(runs).values(run6).run();
}
__name(insertRun, "insertRun");

// src/mcp.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/mcp.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-compat.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/external.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/locales/en.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/ZodError.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/helpers/util.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs2(_arg) {
  }
  __name(assertIs2, "assertIs");
  util2.assertIs = assertIs2;
  function assertNever2(_x) {
    throw new Error();
  }
  __name(assertNever2, "assertNever");
  util2.assertNever = assertNever2;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object4) => {
    const keys5 = [];
    for (const key in object4) {
      if (Object.prototype.hasOwnProperty.call(object4, key)) {
        keys5.push(key);
      }
    }
    return keys5;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues2(array7, separator = " | ") {
    return array7.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  __name(joinValues2, "joinValues");
  util2.joinValues = joinValues2;
  util2.jsonStringifyReplacer = (_, value3) => {
    if (typeof value3 === "bigint") {
      return value3.toString();
    }
    return value3;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first3, second) => {
    return {
      ...first3,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
}, "getParsedType");

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var ZodError = class _ZodError extends Error {
  static {
    __name(this, "ZodError");
  }
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue2) {
      return issue2.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = /* @__PURE__ */ __name((error50) => {
      for (const issue2 of error50.issues) {
        if (issue2.code === "invalid_union") {
          issue2.unionErrors.map(processError);
        } else if (issue2.code === "invalid_return_type") {
          processError(issue2.returnTypeError);
        } else if (issue2.code === "invalid_arguments") {
          processError(issue2.argumentsError);
        } else if (issue2.path.length === 0) {
          fieldErrors._errors.push(mapper(issue2));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue2.path.length) {
            const el = issue2.path[i];
            const terminal = i === issue2.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue2));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    }, "processError");
    processError(this);
    return fieldErrors;
  }
  static assert(value3) {
    if (!(value3 instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value3}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    const fieldErrors = /* @__PURE__ */ Object.create(null);
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error50 = new ZodError(issues);
  return error50;
};

// node_modules/zod/v3/locales/en.js
var errorMap = /* @__PURE__ */ __name((issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode.invalid_type:
      if (issue2.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue2.expected}, received ${issue2.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue2.validation === "object") {
        if ("includes" in issue2.validation) {
          message = `Invalid input: must include "${issue2.validation.includes}"`;
          if (typeof issue2.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
          }
        } else if ("startsWith" in issue2.validation) {
          message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
        } else if ("endsWith" in issue2.validation) {
          message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
        } else {
          util.assertNever(issue2.validation);
        }
      } else if (issue2.validation !== "regex") {
        message = `Invalid ${issue2.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "bigint")
        message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue2.type === "array")
        message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
      else if (issue2.type === "string")
        message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
      else if (issue2.type === "number")
        message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "bigint")
        message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
      else if (issue2.type === "date")
        message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue2);
  }
  return { message };
}, "errorMap");
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function getErrorMap() {
  return overrideErrorMap;
}
__name(getErrorMap, "getErrorMap");

// node_modules/zod/v3/helpers/parseUtil.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeIssue = /* @__PURE__ */ __name((params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map31 of maps) {
    errorMessage = map31(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, "makeIssue");
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue2);
}
__name(addIssueToContext, "addIssueToContext");
var ParseStatus = class _ParseStatus {
  static {
    __name(this, "ParseStatus");
  }
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status2, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status2.dirty();
      arrayValue.push(s.value);
    }
    return { status: status2.value, value: arrayValue };
  }
  static async mergeObjectAsync(status2, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value3 = await pair.value;
      syncPairs.push({
        key,
        value: value3
      });
    }
    return _ParseStatus.mergeObjectSync(status2, syncPairs);
  }
  static mergeObjectSync(status2, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value: value3 } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value3.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status2.dirty();
      if (value3.status === "dirty")
        status2.dirty();
      if (key.value !== "__proto__" && (typeof value3.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value3.value;
      }
    }
    return { status: status2.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = /* @__PURE__ */ __name((value3) => ({ status: "dirty", value: value3 }), "DIRTY");
var OK = /* @__PURE__ */ __name((value3) => ({ status: "valid", value: value3 }), "OK");
var isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
var isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
var isValid2 = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
var isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");

// node_modules/zod/v3/helpers/typeAliases.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/types.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v3/helpers/errorUtil.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  static {
    __name(this, "ParseInputLazyPath");
  }
  constructor(parent, value3, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value3;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = /* @__PURE__ */ __name((ctx, result) => {
  if (isValid2(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error50 = new ZodError(ctx.common.issues);
        this._error = error50;
        return this._error;
      }
    };
  }
}, "handleResult");
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
__name(processCreateParams, "processCreateParams");
var ZodType = class {
  static {
    __name(this, "ZodType");
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid2(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid2(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check5, message) {
    const getIssueProperties = /* @__PURE__ */ __name((val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    }, "getIssueProperties");
    return this._refinement((val, ctx) => {
      const result = check5(val);
      const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      }), "setError");
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check5, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check5(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: /* @__PURE__ */ __name((data) => this["~validate"](data), "validate")
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option5) {
    return ZodUnion.create([this, option5], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform4) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform4 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args2) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args2.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args2.precision}}`;
  } else if (args2.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args2.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
__name(timeRegexSource, "timeRegexSource");
function timeRegex(args2) {
  return new RegExp(`^${timeRegexSource(args2)}$`);
}
__name(timeRegex, "timeRegex");
function datetimeRegex(args2) {
  let regex = `${dateRegexSource}T${timeRegexSource(args2)}`;
  const opts = [];
  opts.push(args2.local ? `Z?` : `Z`);
  if (args2.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
__name(datetimeRegex, "datetimeRegex");
function isValidIP(ip, version4) {
  if ((version4 === "v4" || !version4) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version4 === "v6" || !version4) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidIP, "isValidIP");
function isValidJWT(jwt2, alg) {
  if (!jwtRegex.test(jwt2))
    return false;
  try {
    const [header] = jwt2.split(".");
    if (!header)
      return false;
    const base644 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base644));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
__name(isValidJWT, "isValidJWT");
function isValidCidr(ip, version4) {
  if ((version4 === "v4" || !version4) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version4 === "v6" || !version4) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
__name(isValidCidr, "isValidCidr");
var ZodString = class _ZodString2 extends ZodType {
  static {
    __name(this, "ZodString");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status2 = new ParseStatus();
    let ctx = void 0;
    for (const check5 of this._def.checks) {
      if (check5.kind === "min") {
        if (input.data.length < check5.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check5.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "max") {
        if (input.data.length > check5.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check5.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "length") {
        const tooBig = input.data.length > check5.value;
        const tooSmall = input.data.length < check5.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check5.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check5.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check5.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check5.message
            });
          }
          status2.dirty();
        }
      } else if (check5.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "regex") {
        check5.regex.lastIndex = 0;
        const testResult = check5.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "trim") {
        input.data = input.data.trim();
      } else if (check5.kind === "includes") {
        if (!input.data.includes(check5.value, check5.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check5.value, position: check5.position },
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check5.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check5.kind === "startsWith") {
        if (!input.data.startsWith(check5.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check5.value },
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "endsWith") {
        if (!input.data.endsWith(check5.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check5.value },
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "datetime") {
        const regex = datetimeRegex(check5);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "time") {
        const regex = timeRegex(check5);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "ip") {
        if (!isValidIP(input.data, check5.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "jwt") {
        if (!isValidJWT(input.data, check5.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "cidr") {
        if (!isValidCidr(input.data, check5.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check5.message
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check5);
      }
    }
    return { status: status2.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check5) {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, check5]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value3, options) {
    return this._addCheck({
      kind: "includes",
      value: value3,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value3, message) {
    return this._addCheck({
      kind: "startsWith",
      value: value3,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value3, message) {
    return this._addCheck({
      kind: "endsWith",
      value: value3,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength2, message) {
    return this._addCheck({
      kind: "min",
      value: minLength2,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength2, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength2,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min4 === null || ch.value > min4)
          min4 = ch.value;
      }
    }
    return min4;
  }
  get maxLength() {
    let max6 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max6 === null || ch.value < max6)
          max6 = ch.value;
      }
    }
    return max6;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step4) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step4.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step4.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
__name(floatSafeRemainder, "floatSafeRemainder");
var ZodNumber = class _ZodNumber extends ZodType {
  static {
    __name(this, "ZodNumber");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status2 = new ParseStatus();
    for (const check5 of this._def.checks) {
      if (check5.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "min") {
        const tooSmall = check5.inclusive ? input.data < check5.value : input.data <= check5.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check5.value,
            type: "number",
            inclusive: check5.inclusive,
            exact: false,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "max") {
        const tooBig = check5.inclusive ? input.data > check5.value : input.data >= check5.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check5.value,
            type: "number",
            inclusive: check5.inclusive,
            exact: false,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check5.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check5.value,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check5.message
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check5);
      }
    }
    return { status: status2.value, value: input.data };
  }
  gte(value3, message) {
    return this.setLimit("min", value3, true, errorUtil.toString(message));
  }
  gt(value3, message) {
    return this.setLimit("min", value3, false, errorUtil.toString(message));
  }
  lte(value3, message) {
    return this.setLimit("max", value3, true, errorUtil.toString(message));
  }
  lt(value3, message) {
    return this.setLimit("max", value3, false, errorUtil.toString(message));
  }
  setLimit(kind, value3, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value3,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check5) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check5]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value3, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value3,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min4 === null || ch.value > min4)
          min4 = ch.value;
      }
    }
    return min4;
  }
  get maxValue() {
    let max6 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max6 === null || ch.value < max6)
          max6 = ch.value;
      }
    }
    return max6;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max6 = null;
    let min4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min4 === null || ch.value > min4)
          min4 = ch.value;
      } else if (ch.kind === "max") {
        if (max6 === null || ch.value < max6)
          max6 = ch.value;
      }
    }
    return Number.isFinite(min4) && Number.isFinite(max6);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  static {
    __name(this, "ZodBigInt");
  }
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status2 = new ParseStatus();
    for (const check5 of this._def.checks) {
      if (check5.kind === "min") {
        const tooSmall = check5.inclusive ? input.data < check5.value : input.data <= check5.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check5.value,
            inclusive: check5.inclusive,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "max") {
        const tooBig = check5.inclusive ? input.data > check5.value : input.data >= check5.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check5.value,
            inclusive: check5.inclusive,
            message: check5.message
          });
          status2.dirty();
        }
      } else if (check5.kind === "multipleOf") {
        if (input.data % check5.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check5.value,
            message: check5.message
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check5);
      }
    }
    return { status: status2.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value3, message) {
    return this.setLimit("min", value3, true, errorUtil.toString(message));
  }
  gt(value3, message) {
    return this.setLimit("min", value3, false, errorUtil.toString(message));
  }
  lte(value3, message) {
    return this.setLimit("max", value3, true, errorUtil.toString(message));
  }
  lt(value3, message) {
    return this.setLimit("max", value3, false, errorUtil.toString(message));
  }
  setLimit(kind, value3, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value3,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check5) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check5]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value3, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value3,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min4 === null || ch.value > min4)
          min4 = ch.value;
      }
    }
    return min4;
  }
  get maxValue() {
    let max6 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max6 === null || ch.value < max6)
          max6 = ch.value;
      }
    }
    return max6;
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  static {
    __name(this, "ZodBoolean");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  static {
    __name(this, "ZodDate");
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status2 = new ParseStatus();
    let ctx = void 0;
    for (const check5 of this._def.checks) {
      if (check5.kind === "min") {
        if (input.data.getTime() < check5.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check5.message,
            inclusive: true,
            exact: false,
            minimum: check5.value,
            type: "date"
          });
          status2.dirty();
        }
      } else if (check5.kind === "max") {
        if (input.data.getTime() > check5.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check5.message,
            inclusive: true,
            exact: false,
            maximum: check5.value,
            type: "date"
          });
          status2.dirty();
        }
      } else {
        util.assertNever(check5);
      }
    }
    return {
      status: status2.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check5) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check5]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min4 === null || ch.value > min4)
          min4 = ch.value;
      }
    }
    return min4 != null ? new Date(min4) : null;
  }
  get maxDate() {
    let max6 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max6 === null || ch.value < max6)
          max6 = ch.value;
      }
    }
    return max6 != null ? new Date(max6) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  static {
    __name(this, "ZodSymbol");
  }
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  static {
    __name(this, "ZodUndefined");
  }
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  static {
    __name(this, "ZodNull");
  }
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  static {
    __name(this, "ZodAny");
  }
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  static {
    __name(this, "ZodUnknown");
  }
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  static {
    __name(this, "ZodNever");
  }
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  static {
    __name(this, "ZodVoid");
  }
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  static {
    __name(this, "ZodArray");
  }
  _parse(input) {
    const { ctx, status: status2 } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status2.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status2.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status2.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status2, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status2, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength2, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength2, message: errorUtil.toString(message) }
    });
  }
  max(maxLength2, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength2, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
__name(deepPartialify, "deepPartialify");
var ZodObject = class _ZodObject extends ZodType {
  static {
    __name(this, "ZodObject");
  }
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys5 = util.objectKeys(shape);
    this._cached = { shape, keys: keys5 };
    return this._cached;
  }
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status: status2, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value3 = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value3, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status2.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value3 = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value3, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value3 = await pair.value;
          syncPairs.push({
            key,
            value: value3,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status2, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status2, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: /* @__PURE__ */ __name((issue2, ctx) => {
          const defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;
          if (issue2.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }, "errorMap")
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...augmentation
      }), "shape")
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: /* @__PURE__ */ __name(() => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }), "shape"),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new _ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => shape, "shape")
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: /* @__PURE__ */ __name(() => shape, "shape"),
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  static {
    __name(this, "ZodUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    __name(handleResults, "handleResults");
    if (ctx.common.async) {
      return Promise.all(options.map(async (option5) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option5._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option5 of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option5._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = /* @__PURE__ */ __name((type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, "getDiscriminator");
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  static {
    __name(this, "ZodDiscriminatedUnion");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option5 = this.optionsMap.get(discriminatorValue);
    if (!option5) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option5._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option5._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value3 of discriminatorValues) {
        if (optionsMap.has(value3)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value3)}`);
        }
        optionsMap.set(value3, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
__name(mergeValues, "mergeValues");
var ZodIntersection = class extends ZodType {
  static {
    __name(this, "ZodIntersection");
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status2.dirty();
      }
      return { status: status2.value, value: merged.data };
    }, "handleParsed");
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left3, right3]) => handleParsed(left3, right3));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left3, right3, params) => {
  return new ZodIntersection({
    left: left3,
    right: right3,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  static {
    __name(this, "ZodTuple");
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status2.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status2, results);
      });
    } else {
      return ParseStatus.mergeArray(status2, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  static {
    __name(this, "ZodRecord");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status2, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status2, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first3, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first3,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first3,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  static {
    __name(this, "ZodMap");
  }
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value3], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value3, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value3 = await pair.value;
          if (key.status === "aborted" || value3.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value3.status === "dirty") {
            status2.dirty();
          }
          finalMap.set(key.value, value3.value);
        }
        return { status: status2.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value3 = pair.value;
        if (key.status === "aborted" || value3.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value3.status === "dirty") {
          status2.dirty();
        }
        finalMap.set(key.value, value3.value);
      }
      return { status: status2.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  static {
    __name(this, "ZodSet");
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status2.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status2.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element2 of elements2) {
        if (element2.status === "aborted")
          return INVALID;
        if (element2.status === "dirty")
          status2.dirty();
        parsedSet.add(element2.value);
      }
      return { status: status2.value, value: parsedSet };
    }
    __name(finalizeSet, "finalizeSet");
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size15, message) {
    return this.min(size15, message).max(size15, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  static {
    __name(this, "ZodFunction");
  }
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args2, error50) {
      return makeIssue({
        data: args2,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error50
        }
      });
    }
    __name(makeArgsIssue, "makeArgsIssue");
    function makeReturnsIssue(returns, error50) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error50
        }
      });
    }
    __name(makeReturnsIssue, "makeReturnsIssue");
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args2) {
        const error50 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args2, params).catch((e) => {
          error50.addIssue(makeArgsIssue(args2, e));
          throw error50;
        });
        const result = await Reflect.apply(fn2, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error50.addIssue(makeReturnsIssue(result, e));
          throw error50;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args2) {
        const parsedArgs = me._def.args.safeParse(args2, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args2, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn2, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func2) {
    const validatedFunc = this.parse(func2);
    return validatedFunc;
  }
  strictImplement(func2) {
    const validatedFunc = this.parse(func2);
    return validatedFunc;
  }
  static create(args2, returns, params) {
    return new _ZodFunction({
      args: args2 ? args2 : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  static {
    __name(this, "ZodLazy");
  }
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  static {
    __name(this, "ZodLiteral");
  }
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value3, params) => {
  return new ZodLiteral({
    value: value3,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values4, params) {
  return new ZodEnum({
    values: values4,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
__name(createZodEnum, "createZodEnum");
var ZodEnum = class _ZodEnum extends ZodType {
  static {
    __name(this, "ZodEnum");
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values4, newDef = this._def) {
    return _ZodEnum.create(values4, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values4, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values4.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  static {
    __name(this, "ZodNativeEnum");
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values4, params) => {
  return new ZodNativeEnum({
    values: values4,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  static {
    __name(this, "ZodPromise");
  }
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  static {
    __name(this, "ZodEffects");
  }
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    const effect4 = this._def.effect || null;
    const checkCtx = {
      addIssue: /* @__PURE__ */ __name((arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status2.abort();
        } else {
          status2.dirty();
        }
      }, "addIssue"),
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect4.type === "preprocess") {
      const processed = effect4.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status2.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status2.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status2.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status2.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect4.type === "refinement") {
      const executeRefinement = /* @__PURE__ */ __name((acc) => {
        const result = effect4.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      }, "executeRefinement");
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status2.dirty();
        executeRefinement(inner.value);
        return { status: status2.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status2.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status2.value, value: inner.value };
          });
        });
      }
    }
    if (effect4.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid2(base))
          return INVALID;
        const result = effect4.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status2.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid2(base))
            return INVALID;
          return Promise.resolve(effect4.transform(base.value, checkCtx)).then((result) => ({
            status: status2.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect4);
  }
};
ZodEffects.create = (schema, effect4, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect: effect4,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess2, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess2 },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  static {
    __name(this, "ZodOptional");
  }
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  static {
    __name(this, "ZodNullable");
  }
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  static {
    __name(this, "ZodDefault");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  static {
    __name(this, "ZodCatch");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  static {
    __name(this, "ZodNaN");
  }
  _parse(input) {
    const parsedType2 = this._getType(input);
    if (parsedType2 !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  static {
    __name(this, "ZodBranded");
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  static {
    __name(this, "ZodPipeline");
  }
  _parse(input) {
    const { status: status2, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = /* @__PURE__ */ __name(async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status2.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }, "handleAsync");
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status2.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  static {
    __name(this, "ZodReadonly");
  }
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = /* @__PURE__ */ __name((data) => {
      if (isValid2(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    }, "freeze");
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind3) {
  ZodFirstPartyTypeKind3["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind3["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind3["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind3["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind3["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind3["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind3["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind3["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind3["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind3["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind3["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind3["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind3["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind3["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind3["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind3["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind3["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind3["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind3["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind3["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind3["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind3["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind3["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind3["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind3["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind3["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind3["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind3["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind3["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind3["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind3["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind3["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind3["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind3["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind3["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind3["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;

// node_modules/zod/v4-mini/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/mini/external.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/index.js
var core_exports4 = {};
__export(core_exports4, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMAC: () => $ZodMAC,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $ZodXor: () => $ZodXor,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch3,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _mac: () => _mac,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never2,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _slugify: () => _slugify,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void2,
  _xid: () => _xid,
  _xor: () => _xor,
  clone: () => clone3,
  config: () => config3,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  decode: () => decode6,
  decodeAsync: () => decodeAsync,
  describe: () => describe,
  encode: () => encode5,
  encodeAsync: () => encodeAsync,
  extractDefs: () => extractDefs,
  finalize: () => finalize,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  initializeContext: () => initializeContext,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT2,
  locales: () => locales_exports,
  meta: () => meta,
  parse: () => parse3,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  process: () => process2,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports2,
  version: () => version3
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/core.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer3(inst, def);
    const proto14 = _.prototype;
    const keys5 = Object.keys(proto14);
    for (let i = 0; i < keys5.length; i++) {
      const k = keys5[i];
      if (!(k in inst)) {
        inst[k] = proto14[k].bind(inst);
      }
    }
  }
  __name(init, "init");
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
    static {
      __name(this, "Definition");
    }
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn2 of inst._zod.deferred) {
      fn2();
    }
    return inst;
  }
  __name(_, "_");
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: /* @__PURE__ */ __name((inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }, "value")
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
__name($constructor, "$constructor");
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  static {
    __name(this, "$ZodAsyncError");
  }
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var $ZodEncodeError = class extends Error {
  static {
    __name(this, "$ZodEncodeError");
  }
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig = {};
function config3(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
__name(config3, "config");

// node_modules/zod/v4/core/parse.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/util.js
var util_exports2 = {};
__export(util_exports2, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class8,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert4,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached4,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone3,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend4,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder2,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType2,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject2,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge11,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit6,
  optionalKeys: () => optionalKeys,
  parsedType: () => parsedType,
  partial: () => partial3,
  pick: () => pick6,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required3,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function assertEqual(val) {
  return val;
}
__name(assertEqual, "assertEqual");
function assertNotEqual(val) {
  return val;
}
__name(assertNotEqual, "assertNotEqual");
function assertIs(_arg) {
}
__name(assertIs, "assertIs");
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
__name(assertNever, "assertNever");
function assert4(_) {
}
__name(assert4, "assert");
function getEnumValues(entries2) {
  const numericValues = Object.values(entries2).filter((v) => typeof v === "number");
  const values4 = Object.entries(entries2).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values4;
}
__name(getEnumValues, "getEnumValues");
function joinValues(array7, separator = "|") {
  return array7.map((val) => stringifyPrimitive(val)).join(separator);
}
__name(joinValues, "joinValues");
function jsonStringifyReplacer(_, value3) {
  if (typeof value3 === "bigint")
    return value3.toString();
  return value3;
}
__name(jsonStringifyReplacer, "jsonStringifyReplacer");
function cached4(getter) {
  const set10 = false;
  return {
    get value() {
      if (!set10) {
        const value3 = getter();
        Object.defineProperty(this, "value", { value: value3 });
        return value3;
      }
      throw new Error("cached value already set");
    }
  };
}
__name(cached4, "cached");
function nullish(input) {
  return input === null || input === void 0;
}
__name(nullish, "nullish");
function cleanRegex(source2) {
  const start5 = source2.startsWith("^") ? 1 : 0;
  const end6 = source2.endsWith("$") ? source2.length - 1 : source2.length;
  return source2.slice(start5, end6);
}
__name(cleanRegex, "cleanRegex");
function floatSafeRemainder2(val, step4) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step4.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match20 = stepString.match(/\d?e-(\d?)/);
    if (match20?.[1]) {
      stepDecCount = Number.parseInt(match20[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step4.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
__name(floatSafeRemainder2, "floatSafeRemainder");
var EVALUATING = Symbol("evaluating");
function defineLazy(object4, key, getter) {
  let value3 = void 0;
  Object.defineProperty(object4, key, {
    get() {
      if (value3 === EVALUATING) {
        return void 0;
      }
      if (value3 === void 0) {
        value3 = EVALUATING;
        value3 = getter();
      }
      return value3;
    },
    set(v) {
      Object.defineProperty(object4, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
__name(defineLazy, "defineLazy");
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
__name(objectClone, "objectClone");
function assignProp(target, prop, value3) {
  Object.defineProperty(target, prop, {
    value: value3,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
__name(assignProp, "assignProp");
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
__name(mergeDefs, "mergeDefs");
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
__name(cloneDef, "cloneDef");
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
__name(getElementAtPath, "getElementAtPath");
function promiseAllObject(promisesObj) {
  const keys5 = Object.keys(promisesObj);
  const promises = keys5.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys5.length; i++) {
      resolvedObj[keys5[i]] = results[i];
    }
    return resolvedObj;
  });
}
__name(promiseAllObject, "promiseAllObject");
function randomString(length4 = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length4; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
__name(randomString, "randomString");
function esc(str) {
  return JSON.stringify(str);
}
__name(esc, "esc");
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
__name(slugify, "slugify");
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
__name(isObject2, "isObject");
var allowsEval = cached4(() => {
  if (typeof navigator !== "undefined" && "Cloudflare-Workers"?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject2(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
__name(isPlainObject, "isPlainObject");
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
__name(shallowClone, "shallowClone");
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
__name(numKeys, "numKeys");
var getParsedType2 = /* @__PURE__ */ __name((data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, "getParsedType");
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
__name(escapeRegex, "escapeRegex");
function clone3(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
__name(clone3, "clone");
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: /* @__PURE__ */ __name(() => params, "error") };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: /* @__PURE__ */ __name(() => params.error, "error") };
  return params;
}
__name(normalizeParams, "normalizeParams");
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value3, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value3, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor3) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor3);
    }
  });
}
__name(createTransparentProxy, "createTransparentProxy");
function stringifyPrimitive(value3) {
  if (typeof value3 === "bigint")
    return value3.toString() + "n";
  if (typeof value3 === "string")
    return `"${value3}"`;
  return `${value3}`;
}
__name(stringifyPrimitive, "stringifyPrimitive");
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
__name(optionalKeys, "optionalKeys");
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick6(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone3(schema, def);
}
__name(pick6, "pick");
function omit6(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone3(schema, def);
}
__name(omit6, "omit");
function extend4(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone3(schema, def);
}
__name(extend4, "extend");
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone3(schema, def);
}
__name(safeExtend, "safeExtend");
function merge11(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone3(a, def);
}
__name(merge11, "merge");
function partial3(Class9, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class9 ? new Class9({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class9 ? new Class9({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone3(schema, def);
}
__name(partial3, "partial");
function required3(Class9, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class9({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class9({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone3(schema, def);
}
__name(required3, "required");
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
__name(aborted, "aborted");
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
__name(prefixIssues, "prefixIssues");
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
__name(unwrapMessage, "unwrapMessage");
function finalizeIssue(iss, ctx, config5) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config5.customError?.(iss)) ?? unwrapMessage(config5.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
__name(finalizeIssue, "finalizeIssue");
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
__name(getSizableOrigin, "getSizableOrigin");
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
__name(getLengthableOrigin, "getLengthableOrigin");
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
__name(parsedType, "parsedType");
function issue(...args2) {
  const [iss, input, inst] = args2;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
__name(issue, "issue");
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
__name(cleanEnum, "cleanEnum");
function base64ToUint8Array(base644) {
  const binaryString = atob(base644);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
__name(base64ToUint8Array, "base64ToUint8Array");
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
__name(uint8ArrayToBase64, "uint8ArrayToBase64");
function base64urlToUint8Array(base64url3) {
  const base644 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base644.length % 4) % 4);
  return base64ToUint8Array(base644 + padding);
}
__name(base64urlToUint8Array, "base64urlToUint8Array");
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
__name(uint8ArrayToBase64url, "uint8ArrayToBase64url");
function hexToUint8Array(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
__name(hexToUint8Array, "hexToUint8Array");
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
__name(uint8ArrayToHex, "uint8ArrayToHex");
var Class8 = class {
  static {
    __name(this, "Class");
  }
  constructor(..._args) {
  }
};

// node_modules/zod/v4/core/errors.js
var initializer = /* @__PURE__ */ __name((inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: /* @__PURE__ */ __name(() => inst.message, "value"),
    enumerable: false
  });
}, "initializer");
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error50, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error50.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
__name(flattenError, "flattenError");
function formatError(error50, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = /* @__PURE__ */ __name((error51) => {
    for (const issue2 of error51.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  }, "processError");
  processError(error50);
  return fieldErrors;
}
__name(formatError, "formatError");
function treeifyError(error50, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = /* @__PURE__ */ __name((error51, path = []) => {
    var _a2, _b;
    for (const issue2 of error51.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  }, "processError");
  processError(error50);
  return result;
}
__name(treeifyError, "treeifyError");
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
__name(toDotPath, "toDotPath");
function prettifyError(error50) {
  const lines = [];
  const issues = [...error50.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}
__name(prettifyError, "prettifyError");

// node_modules/zod/v4/core/parse.js
var _parse = /* @__PURE__ */ __name((_Err) => (schema, value3, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value: value3, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config3())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
}, "_parse");
var parse3 = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = /* @__PURE__ */ __name((_Err) => async (schema, value3, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value: value3, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config3())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
}, "_parseAsync");
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = /* @__PURE__ */ __name((_Err) => (schema, value3, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value: value3, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config3())))
  } : { success: true, data: result.value };
}, "_safeParse");
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = /* @__PURE__ */ __name((_Err) => async (schema, value3, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value: value3, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config3())))
  } : { success: true, data: result.value };
}, "_safeParseAsync");
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var _encode = /* @__PURE__ */ __name((_Err) => (schema, value3, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value3, ctx);
}, "_encode");
var encode5 = /* @__PURE__ */ _encode($ZodRealError);
var _decode = /* @__PURE__ */ __name((_Err) => (schema, value3, _ctx) => {
  return _parse(_Err)(schema, value3, _ctx);
}, "_decode");
var decode6 = /* @__PURE__ */ _decode($ZodRealError);
var _encodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value3, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value3, ctx);
}, "_encodeAsync");
var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
var _decodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value3, _ctx) => {
  return _parseAsync(_Err)(schema, value3, _ctx);
}, "_decodeAsync");
var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
var _safeEncode = /* @__PURE__ */ __name((_Err) => (schema, value3, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value3, ctx);
}, "_safeEncode");
var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
var _safeDecode = /* @__PURE__ */ __name((_Err) => (schema, value3, _ctx) => {
  return _safeParse(_Err)(schema, value3, _ctx);
}, "_safeDecode");
var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
var _safeEncodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value3, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value3, ctx);
}, "_safeEncodeAsync");
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value3, _ctx) => {
  return _safeParseAsync(_Err)(schema, value3, _ctx);
}, "_safeDecodeAsync");
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

// node_modules/zod/v4/core/schemas.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/checks.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base642,
  base64url: () => base64url,
  bigint: () => bigint3,
  boolean: () => boolean3,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date3,
  datetime: () => datetime,
  domain: () => domain3,
  duration: () => duration4,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer4,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number5,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string5,
  time: () => time3,
  ulid: () => ulid2,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid2,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid2 = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration4 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid2 = /* @__PURE__ */ __name((version4) => {
  if (!version4)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version4}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
}, "uuid");
var uuid4 = /* @__PURE__ */ uuid2(4);
var uuid6 = /* @__PURE__ */ uuid2(6);
var uuid7 = /* @__PURE__ */ uuid2(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
__name(emoji, "emoji");
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var mac = /* @__PURE__ */ __name((delimiter) => {
  const escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
}, "mac");
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base642 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain3 = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+[1-9]\d{6,14}$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date3 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args2) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args2.precision === "number" ? args2.precision === -1 ? `${hhmm}` : args2.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args2.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
__name(timeSource, "timeSource");
function time3(args2) {
  return new RegExp(`^${timeSource(args2)}$`);
}
__name(time3, "time");
function datetime(args2) {
  const time5 = timeSource({ precision: args2.precision });
  const opts = ["Z"];
  if (args2.local)
    opts.push("");
  if (args2.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex2 = `${time5}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
}
__name(datetime, "datetime");
var string5 = /* @__PURE__ */ __name((params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
}, "string");
var bigint3 = /^-?\d+n?$/;
var integer4 = /^-?\d+$/;
var number5 = /^-?\d+(?:\.\d+)?$/;
var boolean3 = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
__name(fixedBase64, "fixedBase64");
function fixedBase64url(length4) {
  return new RegExp(`^[A-Za-z0-9_-]{${length4}}$`);
}
__name(fixedBase64url, "fixedBase64url");
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer4;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size15 = input.size;
    if (size15 <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size15 = input.size;
    if (size15 >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size15 = input.size;
    if (size15 === def.size)
      return;
    const tooBig = size15 > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length4 = input.length;
    if (length4 <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length4 = input.length;
    if (length4 >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length4 = input.length;
    if (length4 === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length4 > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern2 = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern2;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern2);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern2 = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern2);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern2);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern2 = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern2);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern2);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property2) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property2, result.issues));
  }
}
__name(handleCheckPropertyResult, "handleCheckPropertyResult");
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Doc = class {
  static {
    __name(this, "Doc");
  }
  constructor(args2 = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args2;
  }
  indented(fn2) {
    this.indent += 1;
    fn2(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args2 = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args2, lines.join("\n"));
  }
};

// node_modules/zod/v4/core/versions.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var version3 = {
  major: 4,
  minor: 3,
  patch: 6
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version3;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn2 of ch._zod.onattach) {
      fn2(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = /* @__PURE__ */ __name((payload, checks2, ctx) => {
      let isAborted2 = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted2) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted2)
              isAborted2 = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted2)
            isAborted2 = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    }, "runChecks");
    const handleCanaryResult = /* @__PURE__ */ __name((canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    }, "handleCanaryResult");
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: /* @__PURE__ */ __name((value3) => {
      try {
        const r = safeParse(inst, value3);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value3).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    }, "validate"),
    vendor: "zod",
    version: 1
  }));
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string5(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid2(v));
  } else
    def.pattern ?? (def.pattern = uuid2());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed2 = payload.value.trim();
      const url3 = new URL(trimmed2);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url3.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url3.protocol.endsWith(":") ? url3.protocol.slice(0, -1) : url3.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url3.href;
      } else {
        payload.value = trimmed2;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date3);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time3(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration4);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter));
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `mac`;
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts2 = payload.value.split("/");
    try {
      if (parts2.length !== 2)
        throw new Error();
      const [address, prefix] = parts2;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
__name(isValidBase64, "isValidBase64");
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base642);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base644 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base644.padEnd(Math.ceil(base644.length / 4) * 4, "=");
  return isValidBase64(padded);
}
__name(isValidBase64URL, "isValidBase64URL");
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT2(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
__name(isValidJWT2, "isValidJWT");
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT2(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number5;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean3;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint3;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate2 = input instanceof Date;
    const isValidDate2 = isDate2 && !Number.isNaN(input.getTime());
    if (isValidDate2)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate2 ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index2) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index2, result.issues));
  }
  final.value[index2] = result.value;
}
__name(handleArrayResult, "handleArrayResult");
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
__name(handlePropertyResult, "handlePropertyResult");
function normalizeDef(def) {
  const keys5 = Object.keys(def.shape);
  for (const k of keys5) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys: keys5,
    keySet: new Set(keys5),
    numKeys: keys5.length,
    optionalKeys: new Set(okeys)
  };
}
__name(normalizeDef, "normalizeDef");
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
__name(handleCatchall, "handleCatchall");
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc2 = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc2?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: /* @__PURE__ */ __name(() => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }, "get")
    });
  }
  const _normalized = cached4(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject3 = isObject2;
  const catchall = def.catchall;
  let value3;
  inst._zod.parse = (payload, ctx) => {
    value3 ?? (value3 = _normalized.value);
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value3.shape;
    for (const key of value3.keys) {
      const el = shape[key];
      const isOptionalOut = el._zod.optout === "optional";
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult(r, payload, key, input, isOptionalOut);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached4(() => normalizeDef(def));
  const generateFastpass = /* @__PURE__ */ __name((shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = /* @__PURE__ */ __name((key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    }, "parseStr");
    doc.write(`const input = payload.value;`);
    const ids3 = /* @__PURE__ */ Object.create(null);
    let counter6 = 0;
    for (const key of normalized.keys) {
      ids3[key] = `key_${counter6++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id2 = ids3[key];
      const k = esc(key);
      const schema = shape[key];
      const isOptionalOut = schema?._zod?.optout === "optional";
      doc.write(`const ${id2} = ${parseStr(key)};`);
      if (isOptionalOut) {
        doc.write(`
        if (${id2}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id2}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id2}.value;
        }
        
      `);
      } else {
        doc.write(`
        if (${id2}.issues.length) {
          payload.issues = payload.issues.concat(${id2}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id2}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id2}.value;
        }
        
      `);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn2 = doc.compile();
    return (payload, ctx) => fn2(shape, payload, ctx);
  }, "generateFastpass");
  let fastpass;
  const isObject3 = isObject2;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value3;
  inst._zod.parse = (payload, ctx) => {
    value3 ?? (value3 = _normalized.value);
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value3, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config3())))
  });
  return final;
}
__name(handleUnionResults, "handleUnionResults");
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option5) => Array.from(option5._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  const single2 = def.options.length === 1;
  const first3 = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single2) {
      return first3(payload, ctx);
    }
    let async4 = false;
    const results = [];
    for (const option5 of def.options) {
      const result = option5._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async4 = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async4)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config3())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
__name(handleExclusiveUnionResults, "handleExclusiveUnionResults");
var $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
  $ZodUnion.init(inst, def);
  def.inclusive = false;
  const single2 = def.options.length === 1;
  const first3 = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single2) {
      return first3(payload, ctx);
    }
    let async4 = false;
    const results = [];
    for (const option5 of def.options) {
      const result = option5._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async4 = true;
      } else {
        results.push(result);
      }
    }
    if (!async4)
      return handleExclusiveUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleExclusiveUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = false;
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option5 of def.options) {
      const pv = option5._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option5)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached4(() => {
    const opts = def.options;
    const map31 = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values4 = o._zod.propValues?.[def.discriminator];
      if (!values4 || values4.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values4) {
        if (map31.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map31.set(v, o);
      }
    }
    return map31;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left3 = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right3 = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async4 = left3 instanceof Promise || right3 instanceof Promise;
    if (async4) {
      return Promise.all([left3, right3]).then(([left4, right4]) => {
        return handleIntersectionResults(payload, left4, right4);
      });
    }
    return handleIntersectionResults(payload, left3, right3);
  };
});
function mergeValues2(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index2, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
__name(mergeValues2, "mergeValues");
function handleIntersectionResults(result, left3, right3) {
  const unrecKeys = /* @__PURE__ */ new Map();
  let unrecIssue;
  for (const iss of left3.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right3.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues2(left3.value, right3.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
__name(handleIntersectionResults, "handleIntersectionResults");
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index2) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index2, result.issues));
  }
  final.value[index2] = result.value;
}
__name(handleTupleResult, "handleTupleResult");
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    const values4 = def.keyType._zod.values;
    if (values4) {
      payload.value = {};
      const recordKeys = /* @__PURE__ */ new Set();
      for (const key of values4) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          recordKeys.add(typeof key === "number" ? key.toString() : key);
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!recordKeys.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        const checkNumericKey = typeof key === "string" && number5.test(key) && keyResult.issues.length;
        if (checkNumericKey) {
          const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (retryResult.issues.length === 0) {
            keyResult = retryResult;
          }
        }
        if (keyResult.issues.length) {
          if (def.mode === "loose") {
            payload.value[key] = input[key];
          } else {
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config3())),
              input: key,
              path: [key],
              inst
            });
          }
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value3] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value: value3, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config3()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config3()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
__name(handleMapResult, "handleMapResult");
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
__name(handleSetResult, "handleSetResult");
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values4 = getEnumValues(def.entries);
  const valuesSet = new Set(values4);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values4.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: values4,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  const values4 = new Set(def.values);
  inst._zod.values = values4;
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (values4.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
__name(handleOptionalResult, "handleOptionalResult");
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern2 = def.innerType._zod.pattern;
    return pattern2 ? new RegExp(`^(${cleanRegex(pattern2.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
  inst._zod.parse = (payload, ctx) => {
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern2 = def.innerType._zod.pattern;
    return pattern2 ? new RegExp(`^(${cleanRegex(pattern2.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
__name(handleDefaultResult, "handleDefaultResult");
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
__name(handleNonOptionalResult, "handleNonOptionalResult");
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config3()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config3()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right3 = def.out._zod.run(payload, ctx);
      if (right3 instanceof Promise) {
        return right3.then((right4) => handlePipeResult(right4, def.in, ctx));
      }
      return handlePipeResult(right3, def.in, ctx);
    }
    const left3 = def.in._zod.run(payload, ctx);
    if (left3 instanceof Promise) {
      return left3.then((left4) => handlePipeResult(left4, def.out, ctx));
    }
    return handlePipeResult(left3, def.out, ctx);
  };
});
function handlePipeResult(left3, next4, ctx) {
  if (left3.issues.length) {
    left3.aborted = true;
    return left3;
  }
  return next4._zod.run({ value: left3.value, issues: left3.issues }, ctx);
}
__name(handlePipeResult, "handlePipeResult");
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left3 = def.in._zod.run(payload, ctx);
      if (left3 instanceof Promise) {
        return left3.then((left4) => handleCodecAResult(left4, def, ctx));
      }
      return handleCodecAResult(left3, def, ctx);
    } else {
      const right3 = def.out._zod.run(payload, ctx);
      if (right3 instanceof Promise) {
        return right3.then((right4) => handleCodecAResult(right4, def, ctx));
      }
      return handleCodecAResult(right3, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value3) => handleCodecTxResult(result, value3, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value3) => handleCodecTxResult(result, value3, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
__name(handleCodecAResult, "handleCodecAResult");
function handleCodecTxResult(left3, value3, nextSchema, ctx) {
  if (left3.issues.length) {
    left3.aborted = true;
    return left3;
  }
  return nextSchema._zod.run({ value: value3, issues: left3.issues }, ctx);
}
__name(handleCodecTxResult, "handleCodecTxResult");
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
  defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
__name(handleReadonlyResult, "handleReadonlyResult");
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source2 = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source2)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start5 = source2.startsWith("^") ? 1 : 0;
      const end6 = source2.endsWith("$") ? source2.length - 1 : source2.length;
      regexParts.push(source2.slice(start5, end6));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "string",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func2) => {
    if (typeof func2 !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args2) {
      const parsedArgs = inst._def.input ? parse3(inst._def.input, args2) : args2;
      const result = Reflect.apply(func2, this, parsedArgs);
      if (inst._def.output) {
        return parse3(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func2) => {
    if (typeof func2 !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args2) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args2) : args2;
      const result = await Reflect.apply(func2, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args2) => {
    const F = inst.constructor;
    if (Array.isArray(args2[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args2[0],
          rest: args2[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args2[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
__name(handleRefineResult, "handleRefineResult");

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  bg: () => bg_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default2,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  hy: () => hy_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  uz: () => uz_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/locales/ar.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error3 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 instanceof ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
        }
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
}, "error");
function ar_default() {
  return {
    localeError: error3()
  };
}
__name(ar_default, "default");

// node_modules/zod/v4/locales/az.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error4 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n instanceof ${issue2.expected}, daxil olan ${received}`;
        }
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${expected}, daxil olan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
}, "error");
function az_default() {
  return {
    localeError: error4()
  };
}
__name(az_default, "default");

// node_modules/zod/v4/locales/be.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getBelarusianPlural(count6, one, few, many) {
  const absCount = Math.abs(count6);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
__name(getBelarusianPlural, "getBelarusianPlural");
var error5 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u043B\u0456\u043A",
    array: "\u043C\u0430\u0441\u0456\u045E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F instanceof ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
        }
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
}, "error");
function be_default() {
  return {
    localeError: error5()
  };
}
__name(be_default, "default");

// node_modules/zod/v4/locales/bg.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error6 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0432\u0445\u043E\u0434",
    email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
    json_string: "JSON \u043D\u0438\u0437",
    e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
        }
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
        let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
        if (_issue.format === "emoji")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "datetime")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "date")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        if (_issue.format === "time")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
        if (_issue.format === "duration")
          invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
    }
  };
}, "error");
function bg_default() {
  return {
    localeError: error6()
  };
}
__name(bg_default, "default");

// node_modules/zod/v4/locales/ca.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error7 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipus inv\xE0lid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
        }
        return `Tipus inv\xE0lid: s'esperava ${expected}, s'ha rebut ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
}, "error");
function ca_default() {
  return {
    localeError: error7()
  };
}
__name(ca_default, "default");

// node_modules/zod/v4/locales/cs.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error8 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u010D\xEDslo",
    string: "\u0159et\u011Bzec",
    function: "funkce",
    array: "pole"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no instanceof ${issue2.expected}, obdr\u017Eeno ${received}`;
        }
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${expected}, obdr\u017Eeno ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
}, "error");
function cs_default() {
  return {
    localeError: error8()
  };
}
__name(cs_default, "default");

// node_modules/zod/v4/locales/da.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error9 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
        }
        return `Ugyldigt input: forventede ${expected}, fik ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
}, "error");
function da_default() {
  return {
    localeError: error9()
  };
}
__name(da_default, "default");

// node_modules/zod/v4/locales/de.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error10 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "Zahl",
    array: "Array"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ung\xFCltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
        }
        return `Ung\xFCltige Eingabe: erwartet ${expected}, erhalten ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
}, "error");
function de_default() {
  return {
    localeError: error10()
  };
}
__name(de_default, "default");

// node_modules/zod/v4/locales/en.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error11 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    // Compatibility: "nan" -> "NaN" for display
    nan: "NaN"
    // All other type names omitted - they fall back to raw values via ?? operator
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
}, "error");
function en_default2() {
  return {
    localeError: error11()
  };
}
__name(en_default2, "default");

// node_modules/zod/v4/locales/eo.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error12 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombro",
    array: "tabelo",
    null: "senvalora"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nevalida enigo: atendi\u011Dis instanceof ${issue2.expected}, ricevi\u011Dis ${received}`;
        }
        return `Nevalida enigo: atendi\u011Dis ${expected}, ricevi\u011Dis ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
}, "error");
function eo_default() {
  return {
    localeError: error12()
  };
}
__name(eo_default, "default");

// node_modules/zod/v4/locales/es.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error13 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entrada inv\xE1lida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
        }
        return `Entrada inv\xE1lida: se esperaba ${expected}, recibido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
}, "error");
function es_default() {
  return {
    localeError: error13()
  };
}
__name(es_default, "default");

// node_modules/zod/v4/locales/fa.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error14 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0622\u0631\u0627\u06CC\u0647"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A instanceof ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
        }
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${received} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
}, "error");
function fa_default() {
  return {
    localeError: error14()
  };
}
__name(fa_default, "default");

// node_modules/zod/v4/locales/fi.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error15 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
        }
        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
}, "error");
function fi_default() {
  return {
    localeError: error15()
  };
}
__name(fi_default, "default");

// node_modules/zod/v4/locales/fr.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error16 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombre",
    array: "tableau"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : instanceof ${issue2.expected} attendu, ${received} re\xE7u`;
        }
        return `Entr\xE9e invalide : ${expected} attendu, ${received} re\xE7u`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
}, "error");
function fr_default() {
  return {
    localeError: error16()
  };
}
__name(fr_default, "default");

// node_modules/zod/v4/locales/fr-CA.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error17 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entr\xE9e invalide : attendu instanceof ${issue2.expected}, re\xE7u ${received}`;
        }
        return `Entr\xE9e invalide : attendu ${expected}, re\xE7u ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
}, "error");
function fr_CA_default() {
  return {
    localeError: error17()
  };
}
__name(fr_CA_default, "default");

// node_modules/zod/v4/locales/he.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error18 = /* @__PURE__ */ __name(() => {
  const TypeNames = {
    string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
    number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
    boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
    array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
    object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
    null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
    undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
    symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
    function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
    map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
    set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
    file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
    value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
  };
  const Sizable = {
    string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
    number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
    // no unit
  };
  const typeEntry = /* @__PURE__ */ __name((t) => t ? TypeNames[t] : void 0, "typeEntry");
  const typeLabel = /* @__PURE__ */ __name((t) => {
    const e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  }, "typeLabel");
  const withDefinite = /* @__PURE__ */ __name((t) => `\u05D4${typeLabel(t)}`, "withDefinite");
  const verbFor = /* @__PURE__ */ __name((t) => {
    const e = typeEntry(t);
    const gender = e?.gender ?? "m";
    return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
  }, "verbFor");
  const getSizing = /* @__PURE__ */ __name((origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  }, "getSizing");
  const FormatDictionary = {
    regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
    url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
    date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
    time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
    duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
    ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
    ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
    cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
    cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
    base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
    base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
    json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
    e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
    uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expectedKey = issue2.expected;
        const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? TypeNames[receivedType]?.label ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA instanceof ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
        }
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
      }
      case "invalid_value": {
        if (issue2.values.length === 1) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue2.values[0])}`;
        }
        const stringified = issue2.values.map((v) => stringifyPrimitive(v));
        if (issue2.values.length === 2) {
          return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue2.maximum}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue2.maximum} ${sizing?.unit ?? ""}`;
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? "<=" : "<";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue2.minimum}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
          if (issue2.minimum === 1 && issue2.inclusive) {
            const singularPhrase = issue2.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
            return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
          }
          const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue2.minimum} ${sizing?.unit ?? ""}`;
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? ">=" : ">";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing?.unit) {
          return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        const nounEntry = FormatDictionary[_issue.format];
        const noun = nounEntry?.label ?? _issue.format;
        const gender = nounEntry?.gender ?? "m";
        const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
        return `${noun} \u05DC\u05D0 ${adjective}`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key": {
        return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
      }
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element": {
        const place = withDefinite(issue2.origin ?? "array");
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
      }
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
}, "error");
function he_default() {
  return {
    localeError: error18()
  };
}
__name(he_default, "default");

// node_modules/zod/v4/locales/hu.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error19 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "sz\xE1m",
    array: "t\xF6mb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k instanceof ${issue2.expected}, a kapott \xE9rt\xE9k ${received}`;
        }
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${expected}, a kapott \xE9rt\xE9k ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
}, "error");
function hu_default() {
  return {
    localeError: error19()
  };
}
__name(hu_default, "default");

// node_modules/zod/v4/locales/hy.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getArmenianPlural(count6, one, many) {
  return Math.abs(count6) === 1 ? one : many;
}
__name(getArmenianPlural, "getArmenianPlural");
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["\u0561", "\u0565", "\u0568", "\u056B", "\u0578", "\u0578\u0582", "\u0585"];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "\u0576" : "\u0568");
}
__name(withDefiniteArticle, "withDefiniteArticle");
var error20 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0576\u0577\u0561\u0576",
        many: "\u0576\u0577\u0561\u0576\u0576\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    file: {
      unit: {
        one: "\u0562\u0561\u0575\u0569",
        many: "\u0562\u0561\u0575\u0569\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    array: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    },
    set: {
      unit: {
        one: "\u057F\u0561\u0580\u0580",
        many: "\u057F\u0561\u0580\u0580\u0565\u0580"
      },
      verb: "\u0578\u0582\u0576\u0565\u0576\u0561\u056C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0574\u0578\u0582\u057F\u0584",
    email: "\u0567\u056C. \u0570\u0561\u057D\u0581\u0565",
    url: "URL",
    emoji: "\u0567\u0574\u0578\u057B\u056B",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E \u0587 \u056A\u0561\u0574",
    date: "ISO \u0561\u0574\u057D\u0561\u0569\u056B\u057E",
    time: "ISO \u056A\u0561\u0574",
    duration: "ISO \u057F\u0587\u0578\u0572\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
    ipv4: "IPv4 \u0570\u0561\u057D\u0581\u0565",
    ipv6: "IPv6 \u0570\u0561\u057D\u0581\u0565",
    cidrv4: "IPv4 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    cidrv6: "IPv6 \u0574\u056B\u057B\u0561\u056F\u0561\u0575\u0584",
    base64: "base64 \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    base64url: "base64url \u0571\u0587\u0561\u0579\u0561\u0583\u0578\u057E \u057F\u0578\u0572",
    json_string: "JSON \u057F\u0578\u0572",
    e164: "E.164 \u0570\u0561\u0574\u0561\u0580",
    jwt: "JWT",
    template_literal: "\u0574\u0578\u0582\u057F\u0584"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0569\u056B\u057E",
    array: "\u0566\u0561\u0576\u0563\u057E\u0561\u056E"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 instanceof ${issue2.expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
        }
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${expected}, \u057D\u057F\u0561\u0581\u057E\u0565\u056C \u0567 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 ${stringifyPrimitive(issue2.values[1])}`;
        return `\u054D\u056D\u0561\u056C \u057F\u0561\u0580\u0562\u0565\u0580\u0561\u056F\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567\u0580 \u0570\u0565\u057F\u0587\u0575\u0561\u056C\u0576\u0565\u0580\u056B\u0581 \u0574\u0565\u056F\u0568\u055D ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0574\u0565\u056E \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin ?? "\u0561\u0580\u056A\u0565\u0584")} \u056C\u056B\u0576\u056B ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
          return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056F\u0578\u0582\u0576\u0565\u0576\u0561 ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0549\u0561\u0583\u0561\u0566\u0561\u0576\u0581 \u0583\u0578\u0584\u0580 \u0561\u0580\u056A\u0565\u0584\u2024 \u057D\u057A\u0561\u057D\u057E\u0578\u0582\u0574 \u0567, \u0578\u0580 ${withDefiniteArticle(issue2.origin)} \u056C\u056B\u0576\u056B ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057D\u056F\u057D\u057E\u056B "${_issue.prefix}"-\u0578\u057E`;
        if (_issue.format === "ends_with")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0561\u057E\u0561\u0580\u057F\u057E\u056B "${_issue.suffix}"-\u0578\u057E`;
        if (_issue.format === "includes")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u057A\u0561\u0580\u0578\u0582\u0576\u0561\u056F\u056B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u054D\u056D\u0561\u056C \u057F\u0578\u0572\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0570\u0561\u0574\u0561\u057A\u0561\u057F\u0561\u057D\u056D\u0561\u0576\u056B ${_issue.pattern} \u0571\u0587\u0561\u0579\u0561\u0583\u056B\u0576`;
        return `\u054D\u056D\u0561\u056C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u054D\u056D\u0561\u056C \u0569\u056B\u057E\u2024 \u057A\u0565\u057F\u0584 \u0567 \u0562\u0561\u0566\u0574\u0561\u057A\u0561\u057F\u056B\u056F \u056C\u056B\u0576\u056B ${issue2.divisor}-\u056B`;
      case "unrecognized_keys":
        return `\u0549\u0573\u0561\u0576\u0561\u0579\u057E\u0561\u056E \u0562\u0561\u0576\u0561\u056C\u056B${issue2.keys.length > 1 ? "\u0576\u0565\u0580" : ""}. ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u054D\u056D\u0561\u056C \u0562\u0561\u0576\u0561\u056C\u056B ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      case "invalid_union":
        return "\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574";
      case "invalid_element":
        return `\u054D\u056D\u0561\u056C \u0561\u0580\u056A\u0565\u0584 ${withDefiniteArticle(issue2.origin)}-\u0578\u0582\u0574`;
      default:
        return `\u054D\u056D\u0561\u056C \u0574\u0578\u0582\u057F\u0584\u0561\u0563\u0580\u0578\u0582\u0574`;
    }
  };
}, "error");
function hy_default() {
  return {
    localeError: error20()
  };
}
__name(hy_default, "default");

// node_modules/zod/v4/locales/id.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error21 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
}, "error");
function id_default() {
  return {
    localeError: error21()
  };
}
__name(id_default, "default");

// node_modules/zod/v4/locales/is.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error22 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "stafi", verb: "a\xF0 hafa" },
    file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
    array: { unit: "hluti", verb: "a\xF0 hafa" },
    set: { unit: "hluti", verb: "a\xF0 hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmer",
    array: "fylki"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera instanceof ${issue2.expected}`;
        }
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${received} \xFEar sem \xE1 a\xF0 vera ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
}, "error");
function is_default() {
  return {
    localeError: error22()
  };
}
__name(is_default, "default");

// node_modules/zod/v4/locales/it.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error23 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numero",
    array: "vettore"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
        }
        return `Input non valido: atteso ${expected}, ricevuto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
}, "error");
function it_default() {
  return {
    localeError: error23()
  };
}
__name(it_default, "default");

// node_modules/zod/v4/locales/ja.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error24 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5024",
    array: "\u914D\u5217"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u52B9\u306A\u5165\u529B: instanceof ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
        }
        return `\u7121\u52B9\u306A\u5165\u529B: ${expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${received}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
}, "error");
function ja_default() {
  return {
    localeError: error24()
  };
}
__name(ja_default, "default");

// node_modules/zod/v4/locales/ka.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error25 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
    set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8",
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0",
    array: "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 instanceof ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
        }
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex")
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
}, "error");
function ka_default() {
  return {
    localeError: error25()
  };
}
__name(ka_default, "default");

// node_modules/zod/v4/locales/kh.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/locales/km.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error26 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u179B\u17C1\u1781",
    array: "\u17A2\u17B6\u179A\u17C1 (Array)",
    null: "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A instanceof ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
        }
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
}, "error");
function km_default() {
  return {
    localeError: error26()
  };
}
__name(km_default, "default");

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
__name(kh_default, "default");

// node_modules/zod/v4/locales/ko.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error27 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 instanceof ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
        }
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${received}\uC785\uB2C8\uB2E4`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
}, "error");
function ko_default() {
  return {
    localeError: error27()
  };
}
__name(ko_default, "default");

// node_modules/zod/v4/locales/lt.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var capitalizeFirstCharacter = /* @__PURE__ */ __name((text2) => {
  return text2.charAt(0).toUpperCase() + text2.slice(1);
}, "capitalizeFirstCharacter");
function getUnitTypeFromNumber(number8) {
  const abs2 = Math.abs(number8);
  const last6 = abs2 % 10;
  const last22 = abs2 % 100;
  if (last22 >= 11 && last22 <= 19 || last6 === 0)
    return "many";
  if (last6 === 1)
    return "one";
  return "few";
}
__name(getUnitTypeFromNumber, "getUnitTypeFromNumber");
var error28 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "skai\u010Dius",
    bigint: "sveikasis skai\u010Dius",
    string: "eilut\u0117",
    boolean: "login\u0117 reik\u0161m\u0117",
    undefined: "neapibr\u0117\u017Eta reik\u0161m\u0117",
    function: "funkcija",
    symbol: "simbolis",
    array: "masyvas",
    object: "objektas",
    null: "nulin\u0117 reik\u0161m\u0117"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Gautas tipas ${received}, o tik\u0117tasi - instanceof ${issue2.expected}`;
        }
        return `Gautas tipas ${received}, o tik\u0117tasi - ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
}, "error");
function lt_default() {
  return {
    localeError: error28()
  };
}
__name(lt_default, "default");

// node_modules/zod/v4/locales/mk.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error29 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0431\u0440\u043E\u0458",
    array: "\u043D\u0438\u0437\u0430"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 instanceof ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
        }
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
}, "error");
function mk_default() {
  return {
    localeError: error29()
  };
}
__name(mk_default, "default");

// node_modules/zod/v4/locales/ms.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error30 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombor"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
}, "error");
function ms_default() {
  return {
    localeError: error30()
  };
}
__name(ms_default, "default");

// node_modules/zod/v4/locales/nl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error31 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "tekens", verb: "heeft" },
    file: { unit: "bytes", verb: "heeft" },
    array: { unit: "elementen", verb: "heeft" },
    set: { unit: "elementen", verb: "heeft" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "getal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
        }
        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
        if (sizing)
          return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
        return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
        if (sizing) {
          return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
}, "error");
function nl_default() {
  return {
    localeError: error31()
  };
}
__name(nl_default, "default");

// node_modules/zod/v4/locales/no.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error32 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tall",
    array: "liste"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
        }
        return `Ugyldig input: forventet ${expected}, fikk ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
}, "error");
function no_default() {
  return {
    localeError: error32()
  };
}
__name(no_default, "default");

// node_modules/zod/v4/locales/ota.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error33 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numara",
    array: "saf",
    null: "gayb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `F\xE2sit giren: umulan instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `F\xE2sit giren: umulan ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
}, "error");
function ota_default() {
  return {
    localeError: error33()
  };
}
__name(ota_default, "default");

// node_modules/zod/v4/locales/ps.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error34 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0639\u062F\u062F",
    array: "\u0627\u0631\u06D0"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F instanceof ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
        }
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${received} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
}, "error");
function ps_default() {
  return {
    localeError: error34()
  };
}
__name(ps_default, "default");

// node_modules/zod/v4/locales/pl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error35 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "liczba",
    array: "tablica"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
        }
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${expected}, otrzymano ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
}, "error");
function pl_default() {
  return {
    localeError: error35()
  };
}
__name(pl_default, "default");

// node_modules/zod/v4/locales/pt.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error36 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\xFAmero",
    null: "nulo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipo inv\xE1lido: esperado instanceof ${issue2.expected}, recebido ${received}`;
        }
        return `Tipo inv\xE1lido: esperado ${expected}, recebido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
}, "error");
function pt_default() {
  return {
    localeError: error36()
  };
}
__name(pt_default, "default");

// node_modules/zod/v4/locales/ru.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function getRussianPlural(count6, one, few, many) {
  const absCount = Math.abs(count6);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
__name(getRussianPlural, "getRussianPlural");
var error37 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C instanceof ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
}, "error");
function ru_default() {
  return {
    localeError: error37()
  };
}
__name(ru_default, "default");

// node_modules/zod/v4/locales/sl.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error38 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0161tevilo",
    array: "tabela"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neveljaven vnos: pri\u010Dakovano instanceof ${issue2.expected}, prejeto ${received}`;
        }
        return `Neveljaven vnos: pri\u010Dakovano ${expected}, prejeto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
}, "error");
function sl_default() {
  return {
    localeError: error38()
  };
}
__name(sl_default, "default");

// node_modules/zod/v4/locales/sv.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error39 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "antal",
    array: "lista"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ogiltig inmatning: f\xF6rv\xE4ntat instanceof ${issue2.expected}, fick ${received}`;
        }
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${expected}, fick ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
}, "error");
function sv_default() {
  return {
    localeError: error39()
  };
}
__name(sv_default, "default");

// node_modules/zod/v4/locales/ta.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error40 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0B8E\u0BA3\u0BCD",
    array: "\u0B85\u0BA3\u0BBF",
    null: "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 instanceof ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
        }
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
}, "error");
function ta_default() {
  return {
    localeError: error40()
  };
}
__name(ta_default, "default");

// node_modules/zod/v4/locales/th.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error41 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02",
    array: "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)",
    null: "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 instanceof ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
        }
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
}, "error");
function th_default() {
  return {
    localeError: error41()
  };
}
__name(th_default, "default");

// node_modules/zod/v4/locales/tr.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error42 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ge\xE7ersiz de\u011Fer: beklenen instanceof ${issue2.expected}, al\u0131nan ${received}`;
        }
        return `Ge\xE7ersiz de\u011Fer: beklenen ${expected}, al\u0131nan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
}, "error");
function tr_default() {
  return {
    localeError: error42()
  };
}
__name(tr_default, "default");

// node_modules/zod/v4/locales/ua.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/locales/uk.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error43 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0447\u0438\u0441\u043B\u043E",
    array: "\u043C\u0430\u0441\u0438\u0432"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F instanceof ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
        }
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
}, "error");
function uk_default() {
  return {
    localeError: error43()
  };
}
__name(uk_default, "default");

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
__name(ua_default, "default");

// node_modules/zod/v4/locales/ur.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error44 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u0646\u0645\u0628\u0631",
    array: "\u0622\u0631\u06D2",
    null: "\u0646\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: instanceof ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
        }
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${received} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
}, "error");
function ur_default() {
  return {
    localeError: error44()
  };
}
__name(ur_default, "default");

// node_modules/zod/v4/locales/uz.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error45 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "belgi", verb: "bo\u2018lishi kerak" },
    file: { unit: "bayt", verb: "bo\u2018lishi kerak" },
    array: { unit: "element", verb: "bo\u2018lishi kerak" },
    set: { unit: "element", verb: "bo\u2018lishi kerak" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "kirish",
    email: "elektron pochta manzili",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO sana va vaqti",
    date: "ISO sana",
    time: "ISO vaqt",
    duration: "ISO davomiylik",
    ipv4: "IPv4 manzil",
    ipv6: "IPv6 manzil",
    mac: "MAC manzil",
    cidrv4: "IPv4 diapazon",
    cidrv6: "IPv6 diapazon",
    base64: "base64 kodlangan satr",
    base64url: "base64url kodlangan satr",
    json_string: "JSON satr",
    e164: "E.164 raqam",
    jwt: "JWT",
    template_literal: "kirish"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "raqam",
    array: "massiv"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Noto\u2018g\u2018ri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
        }
        return `Noto\u2018g\u2018ri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Noto\u2018g\u2018ri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
        return `Noto\u2018g\u2018ri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
        if (_issue.format === "ends_with")
          return `Noto\u2018g\u2018ri satr: "${_issue.suffix}" bilan tugashi kerak`;
        if (_issue.format === "includes")
          return `Noto\u2018g\u2018ri satr: "${_issue.includes}" ni o\u2018z ichiga olishi kerak`;
        if (_issue.format === "regex")
          return `Noto\u2018g\u2018ri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
        return `Noto\u2018g\u2018ri ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Noto\u2018g\u2018ri raqam: ${issue2.divisor} ning karralisi bo\u2018lishi kerak`;
      case "unrecognized_keys":
        return `Noma\u2019lum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} dagi kalit noto\u2018g\u2018ri`;
      case "invalid_union":
        return "Noto\u2018g\u2018ri kirish";
      case "invalid_element":
        return `${issue2.origin} da noto\u2018g\u2018ri qiymat`;
      default:
        return `Noto\u2018g\u2018ri kirish`;
    }
  };
}, "error");
function uz_default() {
  return {
    localeError: error45()
  };
}
__name(uz_default, "default");

// node_modules/zod/v4/locales/vi.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error46 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "s\u1ED1",
    array: "m\u1EA3ng"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i instanceof ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
        }
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
}, "error");
function vi_default() {
  return {
    localeError: error46()
  };
}
__name(vi_default, "default");

// node_modules/zod/v4/locales/zh-CN.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error47 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "\u6570\u5B57",
    array: "\u6570\u7EC4",
    null: "\u7A7A\u503C(null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B instanceof ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
        }
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
}, "error");
function zh_CN_default() {
  return {
    localeError: error47()
  };
}
__name(zh_CN_default, "default");

// node_modules/zod/v4/locales/zh-TW.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error48 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA instanceof ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
        }
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${expected}\uFF0C\u4F46\u6536\u5230 ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
}, "error");
function zh_TW_default() {
  return {
    localeError: error48()
  };
}
__name(zh_TW_default, "default");

// node_modules/zod/v4/locales/yo.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var error49 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: { unit: "\xE0mi", verb: "n\xED" },
    file: { unit: "bytes", verb: "n\xED" },
    array: { unit: "nkan", verb: "n\xED" },
    set: { unit: "nkan", verb: "n\xED" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const FormatDictionary = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "n\u1ECD\u0301mb\xE0",
    array: "akop\u1ECD"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi instanceof ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
        }
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${expected}, \xE0m\u1ECD\u0300 a r\xED ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
}, "error");
function yo_default() {
  return {
    localeError: error49()
  };
}
__name(yo_default, "default");

// node_modules/zod/v4/core/registries.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var _a;
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  static {
    __name(this, "$ZodRegistry");
  }
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta3 = _meta[0];
    this._map.set(schema, meta3);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.set(meta3.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta3 = this._map.get(schema);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.delete(meta3.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
__name(registry, "registry");
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;

// node_modules/zod/v4/core/api.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
// @__NO_SIDE_EFFECTS__
function _string(Class9, params) {
  return new Class9({
    type: "string",
    ...normalizeParams(params)
  });
}
__name(_string, "_string");
// @__NO_SIDE_EFFECTS__
function _coercedString(Class9, params) {
  return new Class9({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedString, "_coercedString");
// @__NO_SIDE_EFFECTS__
function _email(Class9, params) {
  return new Class9({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_email, "_email");
// @__NO_SIDE_EFFECTS__
function _guid(Class9, params) {
  return new Class9({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_guid, "_guid");
// @__NO_SIDE_EFFECTS__
function _uuid(Class9, params) {
  return new Class9({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_uuid, "_uuid");
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class9, params) {
  return new Class9({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
__name(_uuidv4, "_uuidv4");
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class9, params) {
  return new Class9({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
__name(_uuidv6, "_uuidv6");
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class9, params) {
  return new Class9({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
__name(_uuidv7, "_uuidv7");
// @__NO_SIDE_EFFECTS__
function _url(Class9, params) {
  return new Class9({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_url, "_url");
// @__NO_SIDE_EFFECTS__
function _emoji2(Class9, params) {
  return new Class9({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_emoji2, "_emoji");
// @__NO_SIDE_EFFECTS__
function _nanoid(Class9, params) {
  return new Class9({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_nanoid, "_nanoid");
// @__NO_SIDE_EFFECTS__
function _cuid(Class9, params) {
  return new Class9({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cuid, "_cuid");
// @__NO_SIDE_EFFECTS__
function _cuid2(Class9, params) {
  return new Class9({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cuid2, "_cuid2");
// @__NO_SIDE_EFFECTS__
function _ulid(Class9, params) {
  return new Class9({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ulid, "_ulid");
// @__NO_SIDE_EFFECTS__
function _xid(Class9, params) {
  return new Class9({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_xid, "_xid");
// @__NO_SIDE_EFFECTS__
function _ksuid(Class9, params) {
  return new Class9({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ksuid, "_ksuid");
// @__NO_SIDE_EFFECTS__
function _ipv4(Class9, params) {
  return new Class9({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ipv4, "_ipv4");
// @__NO_SIDE_EFFECTS__
function _ipv6(Class9, params) {
  return new Class9({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ipv6, "_ipv6");
// @__NO_SIDE_EFFECTS__
function _mac(Class9, params) {
  return new Class9({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_mac, "_mac");
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class9, params) {
  return new Class9({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cidrv4, "_cidrv4");
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class9, params) {
  return new Class9({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cidrv6, "_cidrv6");
// @__NO_SIDE_EFFECTS__
function _base64(Class9, params) {
  return new Class9({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_base64, "_base64");
// @__NO_SIDE_EFFECTS__
function _base64url(Class9, params) {
  return new Class9({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_base64url, "_base64url");
// @__NO_SIDE_EFFECTS__
function _e164(Class9, params) {
  return new Class9({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_e164, "_e164");
// @__NO_SIDE_EFFECTS__
function _jwt(Class9, params) {
  return new Class9({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_jwt, "_jwt");
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class9, params) {
  return new Class9({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
__name(_isoDateTime, "_isoDateTime");
// @__NO_SIDE_EFFECTS__
function _isoDate(Class9, params) {
  return new Class9({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
__name(_isoDate, "_isoDate");
// @__NO_SIDE_EFFECTS__
function _isoTime(Class9, params) {
  return new Class9({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
__name(_isoTime, "_isoTime");
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class9, params) {
  return new Class9({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
__name(_isoDuration, "_isoDuration");
// @__NO_SIDE_EFFECTS__
function _number(Class9, params) {
  return new Class9({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
__name(_number, "_number");
// @__NO_SIDE_EFFECTS__
function _coercedNumber(Class9, params) {
  return new Class9({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
__name(_coercedNumber, "_coercedNumber");
// @__NO_SIDE_EFFECTS__
function _int(Class9, params) {
  return new Class9({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
__name(_int, "_int");
// @__NO_SIDE_EFFECTS__
function _float32(Class9, params) {
  return new Class9({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
__name(_float32, "_float32");
// @__NO_SIDE_EFFECTS__
function _float64(Class9, params) {
  return new Class9({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
__name(_float64, "_float64");
// @__NO_SIDE_EFFECTS__
function _int32(Class9, params) {
  return new Class9({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
__name(_int32, "_int32");
// @__NO_SIDE_EFFECTS__
function _uint32(Class9, params) {
  return new Class9({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
__name(_uint32, "_uint32");
// @__NO_SIDE_EFFECTS__
function _boolean(Class9, params) {
  return new Class9({
    type: "boolean",
    ...normalizeParams(params)
  });
}
__name(_boolean, "_boolean");
// @__NO_SIDE_EFFECTS__
function _coercedBoolean(Class9, params) {
  return new Class9({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedBoolean, "_coercedBoolean");
// @__NO_SIDE_EFFECTS__
function _bigint(Class9, params) {
  return new Class9({
    type: "bigint",
    ...normalizeParams(params)
  });
}
__name(_bigint, "_bigint");
// @__NO_SIDE_EFFECTS__
function _coercedBigint(Class9, params) {
  return new Class9({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedBigint, "_coercedBigint");
// @__NO_SIDE_EFFECTS__
function _int64(Class9, params) {
  return new Class9({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
__name(_int64, "_int64");
// @__NO_SIDE_EFFECTS__
function _uint64(Class9, params) {
  return new Class9({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
__name(_uint64, "_uint64");
// @__NO_SIDE_EFFECTS__
function _symbol(Class9, params) {
  return new Class9({
    type: "symbol",
    ...normalizeParams(params)
  });
}
__name(_symbol, "_symbol");
// @__NO_SIDE_EFFECTS__
function _undefined2(Class9, params) {
  return new Class9({
    type: "undefined",
    ...normalizeParams(params)
  });
}
__name(_undefined2, "_undefined");
// @__NO_SIDE_EFFECTS__
function _null2(Class9, params) {
  return new Class9({
    type: "null",
    ...normalizeParams(params)
  });
}
__name(_null2, "_null");
// @__NO_SIDE_EFFECTS__
function _any(Class9) {
  return new Class9({
    type: "any"
  });
}
__name(_any, "_any");
// @__NO_SIDE_EFFECTS__
function _unknown(Class9) {
  return new Class9({
    type: "unknown"
  });
}
__name(_unknown, "_unknown");
// @__NO_SIDE_EFFECTS__
function _never2(Class9, params) {
  return new Class9({
    type: "never",
    ...normalizeParams(params)
  });
}
__name(_never2, "_never");
// @__NO_SIDE_EFFECTS__
function _void2(Class9, params) {
  return new Class9({
    type: "void",
    ...normalizeParams(params)
  });
}
__name(_void2, "_void");
// @__NO_SIDE_EFFECTS__
function _date(Class9, params) {
  return new Class9({
    type: "date",
    ...normalizeParams(params)
  });
}
__name(_date, "_date");
// @__NO_SIDE_EFFECTS__
function _coercedDate(Class9, params) {
  return new Class9({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedDate, "_coercedDate");
// @__NO_SIDE_EFFECTS__
function _nan(Class9, params) {
  return new Class9({
    type: "nan",
    ...normalizeParams(params)
  });
}
__name(_nan, "_nan");
// @__NO_SIDE_EFFECTS__
function _lt(value3, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value: value3,
    inclusive: false
  });
}
__name(_lt, "_lt");
// @__NO_SIDE_EFFECTS__
function _lte(value3, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value: value3,
    inclusive: true
  });
}
__name(_lte, "_lte");
// @__NO_SIDE_EFFECTS__
function _gt(value3, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value: value3,
    inclusive: false
  });
}
__name(_gt, "_gt");
// @__NO_SIDE_EFFECTS__
function _gte(value3, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value: value3,
    inclusive: true
  });
}
__name(_gte, "_gte");
// @__NO_SIDE_EFFECTS__
function _positive(params) {
  return /* @__PURE__ */ _gt(0, params);
}
__name(_positive, "_positive");
// @__NO_SIDE_EFFECTS__
function _negative(params) {
  return /* @__PURE__ */ _lt(0, params);
}
__name(_negative, "_negative");
// @__NO_SIDE_EFFECTS__
function _nonpositive(params) {
  return /* @__PURE__ */ _lte(0, params);
}
__name(_nonpositive, "_nonpositive");
// @__NO_SIDE_EFFECTS__
function _nonnegative(params) {
  return /* @__PURE__ */ _gte(0, params);
}
__name(_nonnegative, "_nonnegative");
// @__NO_SIDE_EFFECTS__
function _multipleOf(value3, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value: value3
  });
}
__name(_multipleOf, "_multipleOf");
// @__NO_SIDE_EFFECTS__
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
__name(_maxSize, "_maxSize");
// @__NO_SIDE_EFFECTS__
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
__name(_minSize, "_minSize");
// @__NO_SIDE_EFFECTS__
function _size(size15, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size: size15
  });
}
__name(_size, "_size");
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
__name(_maxLength, "_maxLength");
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
__name(_minLength, "_minLength");
// @__NO_SIDE_EFFECTS__
function _length(length4, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length: length4
  });
}
__name(_length, "_length");
// @__NO_SIDE_EFFECTS__
function _regex(pattern2, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern: pattern2
  });
}
__name(_regex, "_regex");
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
__name(_lowercase, "_lowercase");
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
__name(_uppercase, "_uppercase");
// @__NO_SIDE_EFFECTS__
function _includes(includes2, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes: includes2
  });
}
__name(_includes, "_includes");
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
__name(_startsWith, "_startsWith");
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
__name(_endsWith, "_endsWith");
// @__NO_SIDE_EFFECTS__
function _property(property2, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property: property2,
    schema,
    ...normalizeParams(params)
  });
}
__name(_property, "_property");
// @__NO_SIDE_EFFECTS__
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
__name(_mime, "_mime");
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
__name(_overwrite, "_overwrite");
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
__name(_normalize, "_normalize");
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
__name(_trim, "_trim");
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
__name(_toLowerCase, "_toLowerCase");
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
__name(_toUpperCase, "_toUpperCase");
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
__name(_slugify, "_slugify");
// @__NO_SIDE_EFFECTS__
function _array(Class9, element2, params) {
  return new Class9({
    type: "array",
    element: element2,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
__name(_array, "_array");
// @__NO_SIDE_EFFECTS__
function _union(Class9, options, params) {
  return new Class9({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
__name(_union, "_union");
function _xor(Class9, options, params) {
  return new Class9({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams(params)
  });
}
__name(_xor, "_xor");
// @__NO_SIDE_EFFECTS__
function _discriminatedUnion(Class9, discriminator, options, params) {
  return new Class9({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
__name(_discriminatedUnion, "_discriminatedUnion");
// @__NO_SIDE_EFFECTS__
function _intersection(Class9, left3, right3) {
  return new Class9({
    type: "intersection",
    left: left3,
    right: right3
  });
}
__name(_intersection, "_intersection");
// @__NO_SIDE_EFFECTS__
function _tuple(Class9, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class9({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
__name(_tuple, "_tuple");
// @__NO_SIDE_EFFECTS__
function _record(Class9, keyType, valueType, params) {
  return new Class9({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
__name(_record, "_record");
// @__NO_SIDE_EFFECTS__
function _map(Class9, keyType, valueType, params) {
  return new Class9({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
__name(_map, "_map");
// @__NO_SIDE_EFFECTS__
function _set(Class9, valueType, params) {
  return new Class9({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
__name(_set, "_set");
// @__NO_SIDE_EFFECTS__
function _enum(Class9, values4, params) {
  const entries2 = Array.isArray(values4) ? Object.fromEntries(values4.map((v) => [v, v])) : values4;
  return new Class9({
    type: "enum",
    entries: entries2,
    ...normalizeParams(params)
  });
}
__name(_enum, "_enum");
// @__NO_SIDE_EFFECTS__
function _nativeEnum(Class9, entries2, params) {
  return new Class9({
    type: "enum",
    entries: entries2,
    ...normalizeParams(params)
  });
}
__name(_nativeEnum, "_nativeEnum");
// @__NO_SIDE_EFFECTS__
function _literal(Class9, value3, params) {
  return new Class9({
    type: "literal",
    values: Array.isArray(value3) ? value3 : [value3],
    ...normalizeParams(params)
  });
}
__name(_literal, "_literal");
// @__NO_SIDE_EFFECTS__
function _file(Class9, params) {
  return new Class9({
    type: "file",
    ...normalizeParams(params)
  });
}
__name(_file, "_file");
// @__NO_SIDE_EFFECTS__
function _transform(Class9, fn2) {
  return new Class9({
    type: "transform",
    transform: fn2
  });
}
__name(_transform, "_transform");
// @__NO_SIDE_EFFECTS__
function _optional(Class9, innerType) {
  return new Class9({
    type: "optional",
    innerType
  });
}
__name(_optional, "_optional");
// @__NO_SIDE_EFFECTS__
function _nullable(Class9, innerType) {
  return new Class9({
    type: "nullable",
    innerType
  });
}
__name(_nullable, "_nullable");
// @__NO_SIDE_EFFECTS__
function _default(Class9, innerType, defaultValue) {
  return new Class9({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
__name(_default, "_default");
// @__NO_SIDE_EFFECTS__
function _nonoptional(Class9, innerType, params) {
  return new Class9({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
__name(_nonoptional, "_nonoptional");
// @__NO_SIDE_EFFECTS__
function _success(Class9, innerType) {
  return new Class9({
    type: "success",
    innerType
  });
}
__name(_success, "_success");
// @__NO_SIDE_EFFECTS__
function _catch3(Class9, innerType, catchValue) {
  return new Class9({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
__name(_catch3, "_catch");
// @__NO_SIDE_EFFECTS__
function _pipe(Class9, in_, out) {
  return new Class9({
    type: "pipe",
    in: in_,
    out
  });
}
__name(_pipe, "_pipe");
// @__NO_SIDE_EFFECTS__
function _readonly(Class9, innerType) {
  return new Class9({
    type: "readonly",
    innerType
  });
}
__name(_readonly, "_readonly");
// @__NO_SIDE_EFFECTS__
function _templateLiteral(Class9, parts2, params) {
  return new Class9({
    type: "template_literal",
    parts: parts2,
    ...normalizeParams(params)
  });
}
__name(_templateLiteral, "_templateLiteral");
// @__NO_SIDE_EFFECTS__
function _lazy(Class9, getter) {
  return new Class9({
    type: "lazy",
    getter
  });
}
__name(_lazy, "_lazy");
// @__NO_SIDE_EFFECTS__
function _promise(Class9, innerType) {
  return new Class9({
    type: "promise",
    innerType
  });
}
__name(_promise, "_promise");
// @__NO_SIDE_EFFECTS__
function _custom(Class9, fn2, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class9({
    type: "custom",
    check: "custom",
    fn: fn2,
    ...norm
  });
  return schema;
}
__name(_custom, "_custom");
// @__NO_SIDE_EFFECTS__
function _refine(Class9, fn2, _params) {
  const schema = new Class9({
    type: "custom",
    check: "custom",
    fn: fn2,
    ...normalizeParams(_params)
  });
  return schema;
}
__name(_refine, "_refine");
// @__NO_SIDE_EFFECTS__
function _superRefine(fn2) {
  const ch = /* @__PURE__ */ _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn2(payload.value, payload);
  });
  return ch;
}
__name(_superRefine, "_superRefine");
// @__NO_SIDE_EFFECTS__
function _check(fn2, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn2;
  return ch;
}
__name(_check, "_check");
// @__NO_SIDE_EFFECTS__
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
__name(describe, "describe");
// @__NO_SIDE_EFFECTS__
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
__name(meta, "meta");
// @__NO_SIDE_EFFECTS__
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: /* @__PURE__ */ __name(((input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    }), "transform"),
    reverseTransform: /* @__PURE__ */ __name(((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }), "reverseTransform"),
    error: params.error
  });
  return codec2;
}
__name(_stringbool, "_stringbool");
// @__NO_SIDE_EFFECTS__
function _stringFormat(Class9, format7, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format: format7,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class9(def);
  return inst;
}
__name(_stringFormat, "_stringFormat");

// node_modules/zod/v4/core/to-json-schema.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
__name(initializeContext, "initializeContext");
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta3 = ctx.metadataRegistry.get(schema);
  if (meta3)
    Object.assign(result.schema, meta3);
  if (ctx.io === "input" && isTransforming(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
__name(process2, "process");
function extractDefs(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = /* @__PURE__ */ new Map();
  for (const entry of ctx.seen.entries()) {
    const id2 = ctx.metadataRegistry.get(entry[0])?.id;
    if (id2) {
      const existing = idToSchema.get(id2);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id2}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id2, entry[0]);
    }
  }
  const makeURI = /* @__PURE__ */ __name((entry) => {
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = ctx.external.registry.get(entry[0])?.id;
      const uriGenerator = ctx.external.uri ?? ((id3) => id3);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id2 = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id2;
      return { defId: id2, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id2}` };
    }
    if (entry[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  }, "makeURI");
  const extractToDef = /* @__PURE__ */ __name((entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen = entry[1];
    const { ref: ref2, defId } = makeURI(entry);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref2;
  }, "extractToDef");
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.cycle) {
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id2 = ctx.metadataRegistry.get(entry[0])?.id;
    if (id2) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
__name(extractDefs, "extractDefs");
function finalize(ctx, schema) {
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = /* @__PURE__ */ __name((zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref2 = seen.ref;
    seen.ref = null;
    if (ref2) {
      flattenRef(ref2);
      const refSeen = ctx.seen.get(ref2);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref2;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref && refSeen.def) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref2) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  }, "flattenRef");
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {
  } else {
  }
  if (ctx.external?.uri) {
    const id2 = ctx.external.registry.get(schema)?.id;
    if (!id2)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id2);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ctx.external?.defs ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {
  } else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
__name(finalize, "finalize");
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option5 of def.options) {
      if (isTransforming(option5, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
__name(isTransforming, "isTransforming");
var createToJSONSchemaMethod = /* @__PURE__ */ __name((schema, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
}, "createToJSONSchemaMethod");
var createStandardJSONSchemaMethod = /* @__PURE__ */ __name((schema, io, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
}, "createStandardJSONSchemaMethod");

// node_modules/zod/v4/core/json-schema-processors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
};
var stringProcessor = /* @__PURE__ */ __name((schema, ctx, _json, _params) => {
  const json3 = _json;
  json3.type = "string";
  const { minimum, maximum, format: format7, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json3.minLength = minimum;
  if (typeof maximum === "number")
    json3.maxLength = maximum;
  if (format7) {
    json3.format = formatMap[format7] ?? format7;
    if (json3.format === "")
      delete json3.format;
    if (format7 === "time") {
      delete json3.format;
    }
  }
  if (contentEncoding)
    json3.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes = [...patterns];
    if (regexes.length === 1)
      json3.pattern = regexes[0].source;
    else if (regexes.length > 1) {
      json3.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
}, "stringProcessor");
var numberProcessor = /* @__PURE__ */ __name((schema, ctx, _json, _params) => {
  const json3 = _json;
  const { minimum, maximum, format: format7, multipleOf: multipleOf2, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format7 === "string" && format7.includes("int"))
    json3.type = "integer";
  else
    json3.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json3.minimum = exclusiveMinimum;
      json3.exclusiveMinimum = true;
    } else {
      json3.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json3.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json3.minimum;
      else
        delete json3.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json3.maximum = exclusiveMaximum;
      json3.exclusiveMaximum = true;
    } else {
      json3.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json3.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json3.maximum;
      else
        delete json3.exclusiveMaximum;
    }
  }
  if (typeof multipleOf2 === "number")
    json3.multipleOf = multipleOf2;
}, "numberProcessor");
var booleanProcessor = /* @__PURE__ */ __name((_schema, _ctx, json3, _params) => {
  json3.type = "boolean";
}, "booleanProcessor");
var bigintProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("BigInt cannot be represented in JSON Schema");
  }
}, "bigintProcessor");
var symbolProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Symbols cannot be represented in JSON Schema");
  }
}, "symbolProcessor");
var nullProcessor = /* @__PURE__ */ __name((_schema, ctx, json3, _params) => {
  if (ctx.target === "openapi-3.0") {
    json3.type = "string";
    json3.nullable = true;
    json3.enum = [null];
  } else {
    json3.type = "null";
  }
}, "nullProcessor");
var undefinedProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Undefined cannot be represented in JSON Schema");
  }
}, "undefinedProcessor");
var voidProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Void cannot be represented in JSON Schema");
  }
}, "voidProcessor");
var neverProcessor = /* @__PURE__ */ __name((_schema, _ctx, json3, _params) => {
  json3.not = {};
}, "neverProcessor");
var anyProcessor = /* @__PURE__ */ __name((_schema, _ctx, _json, _params) => {
}, "anyProcessor");
var unknownProcessor = /* @__PURE__ */ __name((_schema, _ctx, _json, _params) => {
}, "unknownProcessor");
var dateProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Date cannot be represented in JSON Schema");
  }
}, "dateProcessor");
var enumProcessor = /* @__PURE__ */ __name((schema, _ctx, json3, _params) => {
  const def = schema._zod.def;
  const values4 = getEnumValues(def.entries);
  if (values4.every((v) => typeof v === "number"))
    json3.type = "number";
  if (values4.every((v) => typeof v === "string"))
    json3.type = "string";
  json3.enum = values4;
}, "enumProcessor");
var literalProcessor = /* @__PURE__ */ __name((schema, ctx, json3, _params) => {
  const def = schema._zod.def;
  const vals = [];
  for (const val of def.values) {
    if (val === void 0) {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
      } else {
      }
    } else if (typeof val === "bigint") {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      } else {
        vals.push(Number(val));
      }
    } else {
      vals.push(val);
    }
  }
  if (vals.length === 0) {
  } else if (vals.length === 1) {
    const val = vals[0];
    json3.type = val === null ? "null" : typeof val;
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json3.enum = [val];
    } else {
      json3.const = val;
    }
  } else {
    if (vals.every((v) => typeof v === "number"))
      json3.type = "number";
    if (vals.every((v) => typeof v === "string"))
      json3.type = "string";
    if (vals.every((v) => typeof v === "boolean"))
      json3.type = "boolean";
    if (vals.every((v) => v === null))
      json3.type = "null";
    json3.enum = vals;
  }
}, "literalProcessor");
var nanProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("NaN cannot be represented in JSON Schema");
  }
}, "nanProcessor");
var templateLiteralProcessor = /* @__PURE__ */ __name((schema, _ctx, json3, _params) => {
  const _json = json3;
  const pattern2 = schema._zod.pattern;
  if (!pattern2)
    throw new Error("Pattern not found in template literal");
  _json.type = "string";
  _json.pattern = pattern2.source;
}, "templateLiteralProcessor");
var fileProcessor = /* @__PURE__ */ __name((schema, _ctx, json3, _params) => {
  const _json = json3;
  const file2 = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  };
  const { minimum, maximum, mime } = schema._zod.bag;
  if (minimum !== void 0)
    file2.minLength = minimum;
  if (maximum !== void 0)
    file2.maxLength = maximum;
  if (mime) {
    if (mime.length === 1) {
      file2.contentMediaType = mime[0];
      Object.assign(_json, file2);
    } else {
      Object.assign(_json, file2);
      _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
    }
  } else {
    Object.assign(_json, file2);
  }
}, "fileProcessor");
var successProcessor = /* @__PURE__ */ __name((_schema, _ctx, json3, _params) => {
  json3.type = "boolean";
}, "successProcessor");
var customProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
}, "customProcessor");
var functionProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Function types cannot be represented in JSON Schema");
  }
}, "functionProcessor");
var transformProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
}, "transformProcessor");
var mapProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Map cannot be represented in JSON Schema");
  }
}, "mapProcessor");
var setProcessor = /* @__PURE__ */ __name((_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Set cannot be represented in JSON Schema");
  }
}, "setProcessor");
var arrayProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const json3 = _json;
  const def = schema._zod.def;
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json3.minItems = minimum;
  if (typeof maximum === "number")
    json3.maxItems = maximum;
  json3.type = "array";
  json3.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
}, "arrayProcessor");
var objectProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const json3 = _json;
  const def = schema._zod.def;
  json3.type = "object";
  json3.properties = {};
  const shape = def.shape;
  for (const key in shape) {
    json3.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key) => {
    const v = def.shape[key]._zod;
    if (ctx.io === "input") {
      return v.optin === void 0;
    } else {
      return v.optout === void 0;
    }
  }));
  if (requiredKeys.size > 0) {
    json3.required = Array.from(requiredKeys);
  }
  if (def.catchall?._zod.def.type === "never") {
    json3.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json3.additionalProperties = false;
  } else if (def.catchall) {
    json3.additionalProperties = process2(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
}, "objectProcessor");
var unionProcessor = /* @__PURE__ */ __name((schema, ctx, json3, params) => {
  const def = schema._zod.def;
  const isExclusive = def.inclusive === false;
  const options = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  if (isExclusive) {
    json3.oneOf = options;
  } else {
    json3.anyOf = options;
  }
}, "unionProcessor");
var intersectionProcessor = /* @__PURE__ */ __name((schema, ctx, json3, params) => {
  const def = schema._zod.def;
  const a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = /* @__PURE__ */ __name((val) => "allOf" in val && Object.keys(val).length === 1, "isSimpleIntersection");
  const allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json3.allOf = allOf;
}, "intersectionProcessor");
var tupleProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const json3 = _json;
  const def = schema._zod.def;
  json3.type = "array";
  const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
  const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
  const prefixItems = def.items.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  }));
  const rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  if (ctx.target === "draft-2020-12") {
    json3.prefixItems = prefixItems;
    if (rest) {
      json3.items = rest;
    }
  } else if (ctx.target === "openapi-3.0") {
    json3.items = {
      anyOf: prefixItems
    };
    if (rest) {
      json3.items.anyOf.push(rest);
    }
    json3.minItems = prefixItems.length;
    if (!rest) {
      json3.maxItems = prefixItems.length;
    }
  } else {
    json3.items = prefixItems;
    if (rest) {
      json3.additionalItems = rest;
    }
  }
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json3.minItems = minimum;
  if (typeof maximum === "number")
    json3.maxItems = maximum;
}, "tupleProcessor");
var recordProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const json3 = _json;
  const def = schema._zod.def;
  json3.type = "object";
  const keyType = def.keyType;
  const keyBag = keyType._zod.bag;
  const patterns = keyBag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    const valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json3.patternProperties = {};
    for (const pattern2 of patterns) {
      json3.patternProperties[pattern2.source] = valueSchema;
    }
  } else {
    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
      json3.propertyNames = process2(def.keyType, ctx, {
        ...params,
        path: [...params.path, "propertyNames"]
      });
    }
    json3.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
  const keyValues = keyType._zod.values;
  if (keyValues) {
    const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
    if (validKeyValues.length > 0) {
      json3.required = validKeyValues;
    }
  }
}, "recordProcessor");
var nullableProcessor = /* @__PURE__ */ __name((schema, ctx, json3, params) => {
  const def = schema._zod.def;
  const inner = process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0") {
    seen.ref = def.innerType;
    json3.nullable = true;
  } else {
    json3.anyOf = [inner, { type: "null" }];
  }
}, "nullableProcessor");
var nonoptionalProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, "nonoptionalProcessor");
var defaultProcessor = /* @__PURE__ */ __name((schema, ctx, json3, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json3.default = JSON.parse(JSON.stringify(def.defaultValue));
}, "defaultProcessor");
var prefaultProcessor = /* @__PURE__ */ __name((schema, ctx, json3, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  if (ctx.io === "input")
    json3._prefault = JSON.parse(JSON.stringify(def.defaultValue));
}, "prefaultProcessor");
var catchProcessor = /* @__PURE__ */ __name((schema, ctx, json3, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json3.default = catchValue;
}, "catchProcessor");
var pipeProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const def = schema._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
}, "pipeProcessor");
var readonlyProcessor = /* @__PURE__ */ __name((schema, ctx, json3, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json3.readOnly = true;
}, "readonlyProcessor");
var promiseProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, "promiseProcessor");
var optionalProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, "optionalProcessor");
var lazyProcessor = /* @__PURE__ */ __name((schema, ctx, _json, params) => {
  const innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
}, "lazyProcessor");
var allProcessors = {
  string: stringProcessor,
  number: numberProcessor,
  boolean: booleanProcessor,
  bigint: bigintProcessor,
  symbol: symbolProcessor,
  null: nullProcessor,
  undefined: undefinedProcessor,
  void: voidProcessor,
  never: neverProcessor,
  any: anyProcessor,
  unknown: unknownProcessor,
  date: dateProcessor,
  enum: enumProcessor,
  literal: literalProcessor,
  nan: nanProcessor,
  template_literal: templateLiteralProcessor,
  file: fileProcessor,
  success: successProcessor,
  custom: customProcessor,
  function: functionProcessor,
  transform: transformProcessor,
  map: mapProcessor,
  set: setProcessor,
  array: arrayProcessor,
  object: objectProcessor,
  union: unionProcessor,
  intersection: intersectionProcessor,
  tuple: tupleProcessor,
  record: recordProcessor,
  nullable: nullableProcessor,
  nonoptional: nonoptionalProcessor,
  default: defaultProcessor,
  prefault: prefaultProcessor,
  catch: catchProcessor,
  pipe: pipeProcessor,
  readonly: readonlyProcessor,
  promise: promiseProcessor,
  optional: optionalProcessor,
  lazy: lazyProcessor
};
function toJSONSchema(input, params) {
  if ("_idmap" in input) {
    const registry2 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry of registry2._idmap.entries()) {
      const [_, schema] = entry;
      process2(schema, ctx2);
    }
    const schemas = {};
    const external = {
      registry: registry2,
      uri: params?.uri,
      defs
    };
    ctx2.external = external;
    for (const entry of registry2._idmap.entries()) {
      const [key, schema] = entry;
      extractDefs(ctx2, schema);
      schemas[key] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process2(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}
__name(toJSONSchema, "toJSONSchema");

// node_modules/zod/v4/core/json-schema-generator.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var JSONSchemaGenerator = class {
  static {
    __name(this, "JSONSchemaGenerator");
  }
  /** @deprecated Access via ctx instead */
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  /** @deprecated Access via ctx instead */
  get target() {
    return this.ctx.target;
  }
  /** @deprecated Access via ctx instead */
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  /** @deprecated Access via ctx instead */
  get override() {
    return this.ctx.override;
  }
  /** @deprecated Access via ctx instead */
  get io() {
    return this.ctx.io;
  }
  /** @deprecated Access via ctx instead */
  get counter() {
    return this.ctx.counter;
  }
  set counter(value3) {
    this.ctx.counter = value3;
  }
  /** @deprecated Access via ctx instead */
  get seen() {
    return this.ctx.seen;
  }
  constructor(params) {
    let normalizedTarget = params?.target ?? "draft-2020-12";
    if (normalizedTarget === "draft-4")
      normalizedTarget = "draft-04";
    if (normalizedTarget === "draft-7")
      normalizedTarget = "draft-07";
    this.ctx = initializeContext({
      processors: allProcessors,
      target: normalizedTarget,
      ...params?.metadata && { metadata: params.metadata },
      ...params?.unrepresentable && { unrepresentable: params.unrepresentable },
      ...params?.override && { override: params.override },
      ...params?.io && { io: params.io }
    });
  }
  /**
   * Process a schema to prepare it for JSON Schema generation.
   * This must be called before emit().
   */
  process(schema, _params = { path: [], schemaPath: [] }) {
    return process2(schema, this.ctx, _params);
  }
  /**
   * Emit the final JSON Schema after processing.
   * Must call process() first.
   */
  emit(schema, _params) {
    if (_params) {
      if (_params.cycles)
        this.ctx.cycles = _params.cycles;
      if (_params.reused)
        this.ctx.reused = _params.reused;
      if (_params.external)
        this.ctx.external = _params.external;
    }
    extractDefs(this.ctx, schema);
    const result = finalize(this.ctx, schema);
    const { "~standard": _, ...plainResult } = result;
    return plainResult;
  }
};

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/mini/parse.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/mini/schemas.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ZodMiniType = /* @__PURE__ */ $constructor("ZodMiniType", (inst, def) => {
  if (!inst._zod)
    throw new Error("Uninitialized schema in ZodMiniType.");
  $ZodType.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
  inst.check = (...checks) => {
    return inst.clone({
      ...def,
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }, { parent: true });
  };
  inst.with = inst.check;
  inst.clone = (_def, params) => clone3(inst, _def, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta3) => {
    reg.add(inst, meta3);
    return inst;
  });
  inst.apply = (fn2) => fn2(inst);
});
var ZodMiniObject = /* @__PURE__ */ $constructor("ZodMiniObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodMiniType.init(inst, def);
  defineLazy(inst, "shape", () => def.shape);
});
// @__NO_SIDE_EFFECTS__
function object2(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...normalizeParams(params)
  };
  return new ZodMiniObject(def);
}
__name(object2, "object");

// node_modules/zod/v4/mini/checks.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/mini/iso.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/mini/coerce.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-compat.js
function isZ4Schema(s) {
  const schema = s;
  return !!schema._zod;
}
__name(isZ4Schema, "isZ4Schema");
function objectFromShape(shape) {
  const values4 = Object.values(shape);
  if (values4.length === 0)
    return object2({});
  const allV4 = values4.every(isZ4Schema);
  const allV3 = values4.every((s) => !isZ4Schema(s));
  if (allV4)
    return object2(shape);
  if (allV3)
    return objectType(shape);
  throw new Error("Mixed Zod versions detected in object shape.");
}
__name(objectFromShape, "objectFromShape");
function safeParse2(schema, data) {
  if (isZ4Schema(schema)) {
    const result2 = safeParse(schema, data);
    return result2;
  }
  const v3Schema = schema;
  const result = v3Schema.safeParse(data);
  return result;
}
__name(safeParse2, "safeParse");
async function safeParseAsync2(schema, data) {
  if (isZ4Schema(schema)) {
    const result2 = await safeParseAsync(schema, data);
    return result2;
  }
  const v3Schema = schema;
  const result = await v3Schema.safeParseAsync(data);
  return result;
}
__name(safeParseAsync2, "safeParseAsync");
function getObjectShape(schema) {
  if (!schema)
    return void 0;
  let rawShape;
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    rawShape = v4Schema._zod?.def?.shape;
  } else {
    const v3Schema = schema;
    rawShape = v3Schema.shape;
  }
  if (!rawShape)
    return void 0;
  if (typeof rawShape === "function") {
    try {
      return rawShape();
    } catch {
      return void 0;
    }
  }
  return rawShape;
}
__name(getObjectShape, "getObjectShape");
function normalizeObjectSchema(schema) {
  if (!schema)
    return void 0;
  if (typeof schema === "object") {
    const asV3 = schema;
    const asV4 = schema;
    if (!asV3._def && !asV4._zod) {
      const values4 = Object.values(schema);
      if (values4.length > 0 && values4.every((v) => typeof v === "object" && v !== null && (v._def !== void 0 || v._zod !== void 0 || typeof v.parse === "function"))) {
        return objectFromShape(schema);
      }
    }
  }
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    const def = v4Schema._zod?.def;
    if (def && (def.type === "object" || def.shape !== void 0)) {
      return schema;
    }
  } else {
    const v3Schema = schema;
    if (v3Schema.shape !== void 0) {
      return schema;
    }
  }
  return void 0;
}
__name(normalizeObjectSchema, "normalizeObjectSchema");
function getParseErrorMessage(error50) {
  if (error50 && typeof error50 === "object") {
    if ("message" in error50 && typeof error50.message === "string") {
      return error50.message;
    }
    if ("issues" in error50 && Array.isArray(error50.issues) && error50.issues.length > 0) {
      const firstIssue = error50.issues[0];
      if (firstIssue && typeof firstIssue === "object" && "message" in firstIssue) {
        return String(firstIssue.message);
      }
    }
    try {
      return JSON.stringify(error50);
    } catch {
      return String(error50);
    }
  }
  return String(error50);
}
__name(getParseErrorMessage, "getParseErrorMessage");
function getSchemaDescription(schema) {
  return schema.description;
}
__name(getSchemaDescription, "getSchemaDescription");
function isSchemaOptional(schema) {
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    return v4Schema._zod?.def?.type === "optional";
  }
  const v3Schema = schema;
  if (typeof schema.isOptional === "function") {
    return schema.isOptional();
  }
  return v3Schema._def?.typeName === "ZodOptional";
}
__name(isSchemaOptional, "isSchemaOptional");
function getLiteralValue(schema) {
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    const def2 = v4Schema._zod?.def;
    if (def2) {
      if (def2.value !== void 0)
        return def2.value;
      if (Array.isArray(def2.values) && def2.values.length > 0) {
        return def2.values[0];
      }
    }
  }
  const v3Schema = schema;
  const def = v3Schema._def;
  if (def) {
    if (def.value !== void 0)
      return def.value;
    if (Array.isArray(def.values) && def.values.length > 0) {
      return def.values[0];
    }
  }
  const directValue = schema.value;
  if (directValue !== void 0)
    return directValue;
  return void 0;
}
__name(getLiteralValue, "getLiteralValue");

// node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/external.js
var external_exports3 = {};
__export(external_exports3, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny2,
  ZodArray: () => ZodArray2,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt2,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean2,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch2,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate2,
  ZodDefault: () => ZodDefault2,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum2,
  ZodError: () => ZodError2,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind2,
  ZodFunction: () => ZodFunction2,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection2,
  ZodIssueCode: () => ZodIssueCode2,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy2,
  ZodLiteral: () => ZodLiteral2,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap2,
  ZodNaN: () => ZodNaN2,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever2,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull2,
  ZodNullable: () => ZodNullable2,
  ZodNumber: () => ZodNumber2,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional2,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise2,
  ZodReadonly: () => ZodReadonly2,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord2,
  ZodSet: () => ZodSet2,
  ZodString: () => ZodString2,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol2,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple2,
  ZodType: () => ZodType2,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined2,
  ZodUnion: () => ZodUnion2,
  ZodUnknown: () => ZodUnknown2,
  ZodVoid: () => ZodVoid2,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array6,
  base64: () => base643,
  base64url: () => base64url2,
  bigint: () => bigint4,
  boolean: () => boolean4,
  catch: () => _catch4,
  check: () => check4,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone3,
  codec: () => codec,
  coerce: () => coerce_exports2,
  config: () => config3,
  core: () => core_exports4,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom3,
  date: () => date5,
  decode: () => decode7,
  decodeAsync: () => decodeAsync2,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode6,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  fromJSONSchema: () => fromJSONSchema,
  function: () => _function,
  getErrorMap: () => getErrorMap2,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash3,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int2,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection4,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports2,
  json: () => json2,
  jwt: () => jwt,
  keyof: () => keyof3,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal2,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  mac: () => mac2,
  map: () => map29,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  meta: () => meta2,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never6,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number6,
  object: () => object3,
  optional: () => optional2,
  overwrite: () => _overwrite,
  parse: () => parse4,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe2,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise3,
  property: () => _property,
  readonly: () => readonly,
  record: () => record3,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse3,
  safeParseAsync: () => safeParseAsync3,
  set: () => set9,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string6,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol3,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform3,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple3,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid3,
  undefined: () => _undefined3,
  union: () => union12,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url2,
  util: () => util_exports2,
  uuid: () => uuid3,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void3,
  xid: () => xid2,
  xor: () => xor
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/schemas.js
var schemas_exports3 = {};
__export(schemas_exports3, {
  ZodAny: () => ZodAny2,
  ZodArray: () => ZodArray2,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt2,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean2,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch2,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate2,
  ZodDefault: () => ZodDefault2,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum2,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFunction: () => ZodFunction2,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodIntersection: () => ZodIntersection2,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy2,
  ZodLiteral: () => ZodLiteral2,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap2,
  ZodNaN: () => ZodNaN2,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever2,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull2,
  ZodNullable: () => ZodNullable2,
  ZodNumber: () => ZodNumber2,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional2,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise2,
  ZodReadonly: () => ZodReadonly2,
  ZodRecord: () => ZodRecord2,
  ZodSet: () => ZodSet2,
  ZodString: () => ZodString2,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol2,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple2,
  ZodType: () => ZodType2,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined2,
  ZodUnion: () => ZodUnion2,
  ZodUnknown: () => ZodUnknown2,
  ZodVoid: () => ZodVoid2,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array6,
  base64: () => base643,
  base64url: () => base64url2,
  bigint: () => bigint4,
  boolean: () => boolean4,
  catch: () => _catch4,
  check: () => check4,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  codec: () => codec,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom3,
  date: () => date5,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  float32: () => float32,
  float64: () => float64,
  function: () => _function,
  guid: () => guid2,
  hash: () => hash3,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  instanceof: () => _instanceof,
  int: () => int2,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection4,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  json: () => json2,
  jwt: () => jwt,
  keyof: () => keyof3,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  literal: () => literal2,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  mac: () => mac2,
  map: () => map29,
  meta: () => meta2,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  never: () => never6,
  nonoptional: () => nonoptional,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number6,
  object: () => object3,
  optional: () => optional2,
  partialRecord: () => partialRecord,
  pipe: () => pipe2,
  prefault: () => prefault,
  preprocess: () => preprocess,
  promise: () => promise3,
  readonly: () => readonly,
  record: () => record3,
  refine: () => refine,
  set: () => set9,
  strictObject: () => strictObject,
  string: () => string6,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol3,
  templateLiteral: () => templateLiteral,
  transform: () => transform3,
  tuple: () => tuple3,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid3,
  undefined: () => _undefined3,
  union: () => union12,
  unknown: () => unknown,
  url: () => url2,
  uuid: () => uuid3,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void3,
  xid: () => xid2,
  xor: () => xor
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/checks.js
var checks_exports2 = {};
__export(checks_exports2, {
  endsWith: () => _endsWith,
  gt: () => _gt,
  gte: () => _gte,
  includes: () => _includes,
  length: () => _length,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  negative: () => _negative,
  nonnegative: () => _nonnegative,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  overwrite: () => _overwrite,
  positive: () => _positive,
  property: () => _property,
  regex: () => _regex,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  trim: () => _trim,
  uppercase: () => _uppercase
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/iso.js
var iso_exports2 = {};
__export(iso_exports2, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date4,
  datetime: () => datetime2,
  duration: () => duration5,
  time: () => time4
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
__name(datetime2, "datetime");
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date4(params) {
  return _isoDate(ZodISODate, params);
}
__name(date4, "date");
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time4(params) {
  return _isoTime(ZodISOTime, params);
}
__name(time4, "time");
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration5(params) {
  return _isoDuration(ZodISODuration, params);
}
__name(duration5, "duration");

// node_modules/zod/v4/classic/parse.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod/v4/classic/errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var initializer2 = /* @__PURE__ */ __name((inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: /* @__PURE__ */ __name((mapper) => formatError(inst, mapper), "value")
      // enumerable: false,
    },
    flatten: {
      value: /* @__PURE__ */ __name((mapper) => flattenError(inst, mapper), "value")
      // enumerable: false,
    },
    addIssue: {
      value: /* @__PURE__ */ __name((issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }, "value")
      // enumerable: false,
    },
    addIssues: {
      value: /* @__PURE__ */ __name((issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }, "value")
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, "initializer");
var ZodError2 = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse4 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse3 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync3 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var encode6 = /* @__PURE__ */ _encode(ZodRealError);
var decode7 = /* @__PURE__ */ _decode(ZodRealError);
var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType2 = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  Object.assign(inst["~standard"], {
    jsonSchema: {
      input: createStandardJSONSchemaMethod(inst, "input"),
      output: createStandardJSONSchemaMethod(inst, "output")
    }
  });
  inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(util_exports2.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }), {
      parent: true
    });
  };
  inst.with = inst.check;
  inst.clone = (def2, params) => clone3(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta3) => {
    reg.add(inst, meta3);
    return inst;
  });
  inst.parse = (data, params) => parse4(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse3(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync3(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode6(inst, data, params);
  inst.decode = (data, params) => decode7(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check5, params) => inst.check(refine(check5, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn2) => inst.check(_overwrite(fn2));
  inst.optional = () => optional2(inst);
  inst.exactOptional = () => exactOptional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional2(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array6(inst);
  inst.or = (arg) => union12([inst, arg]);
  inst.and = (arg) => intersection4(inst, arg);
  inst.transform = (tx) => pipe2(inst, transform3(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch4(inst, params);
  inst.pipe = (target) => pipe2(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args2) => {
    if (args2.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args2[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  inst.apply = (fn2) => fn2(inst);
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => stringProcessor(inst, ctx, json3, params);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args2) => inst.check(_regex(...args2));
  inst.includes = (...args2) => inst.check(_includes(...args2));
  inst.startsWith = (...args2) => inst.check(_startsWith(...args2));
  inst.endsWith = (...args2) => inst.check(_endsWith(...args2));
  inst.min = (...args2) => inst.check(_minLength(...args2));
  inst.max = (...args2) => inst.check(_maxLength(...args2));
  inst.length = (...args2) => inst.check(_length(...args2));
  inst.nonempty = (...args2) => inst.check(_minLength(1, ...args2));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args2) => inst.check(_normalize(...args2));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
  inst.slugify = () => inst.check(_slugify());
});
var ZodString2 = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date4(params));
  inst.time = (params) => inst.check(time4(params));
  inst.duration = (params) => inst.check(duration5(params));
});
function string6(params) {
  return _string(ZodString2, params);
}
__name(string6, "string");
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
__name(email2, "email");
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
__name(guid2, "guid");
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid3(params) {
  return _uuid(ZodUUID, params);
}
__name(uuid3, "uuid");
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
__name(uuidv4, "uuidv4");
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
__name(uuidv6, "uuidv6");
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
__name(uuidv7, "uuidv7");
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url2(params) {
  return _url(ZodURL, params);
}
__name(url2, "url");
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports2.normalizeParams(params)
  });
}
__name(httpUrl, "httpUrl");
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
__name(emoji2, "emoji");
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
__name(nanoid2, "nanoid");
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
__name(cuid3, "cuid");
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
__name(cuid22, "cuid2");
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid3(params) {
  return _ulid(ZodULID, params);
}
__name(ulid3, "ulid");
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
__name(xid2, "xid");
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
__name(ksuid2, "ksuid");
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
__name(ipv42, "ipv4");
var ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
__name(mac2, "mac");
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
__name(ipv62, "ipv6");
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
__name(cidrv42, "cidrv4");
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
__name(cidrv62, "cidrv6");
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base643(params) {
  return _base64(ZodBase64, params);
}
__name(base643, "base64");
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
__name(base64url2, "base64url");
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
__name(e1642, "e164");
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
__name(jwt, "jwt");
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format7, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format7, fnOrRegex, _params);
}
__name(stringFormat, "stringFormat");
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
__name(hostname2, "hostname");
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
__name(hex2, "hex");
function hash3(alg, params) {
  const enc = params?.enc ?? "hex";
  const format7 = `${alg}_${enc}`;
  const regex = regexes_exports[format7];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format7}`);
  return _stringFormat(ZodCustomStringFormat, format7, regex, params);
}
__name(hash3, "hash");
var ZodNumber2 = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => numberProcessor(inst, ctx, json3, params);
  inst.gt = (value3, params) => inst.check(_gt(value3, params));
  inst.gte = (value3, params) => inst.check(_gte(value3, params));
  inst.min = (value3, params) => inst.check(_gte(value3, params));
  inst.lt = (value3, params) => inst.check(_lt(value3, params));
  inst.lte = (value3, params) => inst.check(_lte(value3, params));
  inst.max = (value3, params) => inst.check(_lte(value3, params));
  inst.int = (params) => inst.check(int2(params));
  inst.safe = (params) => inst.check(int2(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value3, params) => inst.check(_multipleOf(value3, params));
  inst.step = (value3, params) => inst.check(_multipleOf(value3, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number6(params) {
  return _number(ZodNumber2, params);
}
__name(number6, "number");
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber2.init(inst, def);
});
function int2(params) {
  return _int(ZodNumberFormat, params);
}
__name(int2, "int");
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
__name(float32, "float32");
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
__name(float64, "float64");
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
__name(int32, "int32");
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
__name(uint32, "uint32");
var ZodBoolean2 = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => booleanProcessor(inst, ctx, json3, params);
});
function boolean4(params) {
  return _boolean(ZodBoolean2, params);
}
__name(boolean4, "boolean");
var ZodBigInt2 = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => bigintProcessor(inst, ctx, json3, params);
  inst.gte = (value3, params) => inst.check(_gte(value3, params));
  inst.min = (value3, params) => inst.check(_gte(value3, params));
  inst.gt = (value3, params) => inst.check(_gt(value3, params));
  inst.gte = (value3, params) => inst.check(_gte(value3, params));
  inst.min = (value3, params) => inst.check(_gte(value3, params));
  inst.lt = (value3, params) => inst.check(_lt(value3, params));
  inst.lte = (value3, params) => inst.check(_lte(value3, params));
  inst.max = (value3, params) => inst.check(_lte(value3, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value3, params) => inst.check(_multipleOf(value3, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint4(params) {
  return _bigint(ZodBigInt2, params);
}
__name(bigint4, "bigint");
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt2.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
__name(int64, "int64");
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
__name(uint64, "uint64");
var ZodSymbol2 = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => symbolProcessor(inst, ctx, json3, params);
});
function symbol3(params) {
  return _symbol(ZodSymbol2, params);
}
__name(symbol3, "symbol");
var ZodUndefined2 = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => undefinedProcessor(inst, ctx, json3, params);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined2, params);
}
__name(_undefined3, "_undefined");
var ZodNull2 = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nullProcessor(inst, ctx, json3, params);
});
function _null3(params) {
  return _null2(ZodNull2, params);
}
__name(_null3, "_null");
var ZodAny2 = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => anyProcessor(inst, ctx, json3, params);
});
function any() {
  return _any(ZodAny2);
}
__name(any, "any");
var ZodUnknown2 = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => unknownProcessor(inst, ctx, json3, params);
});
function unknown() {
  return _unknown(ZodUnknown2);
}
__name(unknown, "unknown");
var ZodNever2 = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => neverProcessor(inst, ctx, json3, params);
});
function never6(params) {
  return _never2(ZodNever2, params);
}
__name(never6, "never");
var ZodVoid2 = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => voidProcessor(inst, ctx, json3, params);
});
function _void3(params) {
  return _void2(ZodVoid2, params);
}
__name(_void3, "_void");
var ZodDate2 = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => dateProcessor(inst, ctx, json3, params);
  inst.min = (value3, params) => inst.check(_gte(value3, params));
  inst.max = (value3, params) => inst.check(_lte(value3, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date5(params) {
  return _date(ZodDate2, params);
}
__name(date5, "date");
var ZodArray2 = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => arrayProcessor(inst, ctx, json3, params);
  inst.element = def.element;
  inst.min = (minLength2, params) => inst.check(_minLength(minLength2, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength2, params) => inst.check(_maxLength(maxLength2, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array6(element2, params) {
  return _array(ZodArray2, element2, params);
}
__name(array6, "array");
function keyof3(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
__name(keyof3, "keyof");
var ZodObject2 = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => objectProcessor(inst, ctx, json3, params);
  util_exports2.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never6() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports2.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return util_exports2.safeExtend(inst, incoming);
  };
  inst.merge = (other) => util_exports2.merge(inst, other);
  inst.pick = (mask) => util_exports2.pick(inst, mask);
  inst.omit = (mask) => util_exports2.omit(inst, mask);
  inst.partial = (...args2) => util_exports2.partial(ZodOptional2, inst, args2[0]);
  inst.required = (...args2) => util_exports2.required(ZodNonOptional, inst, args2[0]);
});
function object3(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports2.normalizeParams(params)
  };
  return new ZodObject2(def);
}
__name(object3, "object");
function strictObject(shape, params) {
  return new ZodObject2({
    type: "object",
    shape,
    catchall: never6(),
    ...util_exports2.normalizeParams(params)
  });
}
__name(strictObject, "strictObject");
function looseObject(shape, params) {
  return new ZodObject2({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports2.normalizeParams(params)
  });
}
__name(looseObject, "looseObject");
var ZodUnion2 = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
  inst.options = def.options;
});
function union12(options, params) {
  return new ZodUnion2({
    type: "union",
    options,
    ...util_exports2.normalizeParams(params)
  });
}
__name(union12, "union");
var ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
  ZodUnion2.init(inst, def);
  $ZodXor.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => unionProcessor(inst, ctx, json3, params);
  inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: false,
    ...util_exports2.normalizeParams(params)
  });
}
__name(xor, "xor");
var ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion2.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options,
    discriminator,
    ...util_exports2.normalizeParams(params)
  });
}
__name(discriminatedUnion, "discriminatedUnion");
var ZodIntersection2 = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => intersectionProcessor(inst, ctx, json3, params);
});
function intersection4(left3, right3) {
  return new ZodIntersection2({
    type: "intersection",
    left: left3,
    right: right3
  });
}
__name(intersection4, "intersection");
var ZodTuple2 = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => tupleProcessor(inst, ctx, json3, params);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple3(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple2({
    type: "tuple",
    items,
    rest,
    ...util_exports2.normalizeParams(params)
  });
}
__name(tuple3, "tuple");
var ZodRecord2 = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => recordProcessor(inst, ctx, json3, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record3(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
__name(record3, "record");
function partialRecord(keyType, valueType, params) {
  const k = clone3(keyType);
  k._zod.values = void 0;
  return new ZodRecord2({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
__name(partialRecord, "partialRecord");
function looseRecord(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...util_exports2.normalizeParams(params)
  });
}
__name(looseRecord, "looseRecord");
var ZodMap2 = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => mapProcessor(inst, ctx, json3, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
  inst.min = (...args2) => inst.check(_minSize(...args2));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args2) => inst.check(_maxSize(...args2));
  inst.size = (...args2) => inst.check(_size(...args2));
});
function map29(keyType, valueType, params) {
  return new ZodMap2({
    type: "map",
    keyType,
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
__name(map29, "map");
var ZodSet2 = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => setProcessor(inst, ctx, json3, params);
  inst.min = (...args2) => inst.check(_minSize(...args2));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args2) => inst.check(_maxSize(...args2));
  inst.size = (...args2) => inst.check(_size(...args2));
});
function set9(valueType, params) {
  return new ZodSet2({
    type: "set",
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
__name(set9, "set");
var ZodEnum2 = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => enumProcessor(inst, ctx, json3, params);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys5 = new Set(Object.keys(def.entries));
  inst.extract = (values4, params) => {
    const newEntries = {};
    for (const value3 of values4) {
      if (keys5.has(value3)) {
        newEntries[value3] = def.entries[value3];
      } else
        throw new Error(`Key ${value3} not found in enum`);
    }
    return new ZodEnum2({
      ...def,
      checks: [],
      ...util_exports2.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values4, params) => {
    const newEntries = { ...def.entries };
    for (const value3 of values4) {
      if (keys5.has(value3)) {
        delete newEntries[value3];
      } else
        throw new Error(`Key ${value3} not found in enum`);
    }
    return new ZodEnum2({
      ...def,
      checks: [],
      ...util_exports2.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values4, params) {
  const entries2 = Array.isArray(values4) ? Object.fromEntries(values4.map((v) => [v, v])) : values4;
  return new ZodEnum2({
    type: "enum",
    entries: entries2,
    ...util_exports2.normalizeParams(params)
  });
}
__name(_enum2, "_enum");
function nativeEnum(entries2, params) {
  return new ZodEnum2({
    type: "enum",
    entries: entries2,
    ...util_exports2.normalizeParams(params)
  });
}
__name(nativeEnum, "nativeEnum");
var ZodLiteral2 = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => literalProcessor(inst, ctx, json3, params);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal2(value3, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value3) ? value3 : [value3],
    ...util_exports2.normalizeParams(params)
  });
}
__name(literal2, "literal");
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => fileProcessor(inst, ctx, json3, params);
  inst.min = (size15, params) => inst.check(_minSize(size15, params));
  inst.max = (size15, params) => inst.check(_maxSize(size15, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
__name(file, "file");
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => transformProcessor(inst, ctx, json3, params);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports2.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(util_exports2.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform3(fn2) {
  return new ZodTransform({
    type: "transform",
    transform: fn2
  });
}
__name(transform3, "transform");
var ZodOptional2 = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional2(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
__name(optional2, "optional");
var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => optionalProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
__name(exactOptional, "exactOptional");
var ZodNullable2 = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nullableProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
__name(nullable, "nullable");
function nullish2(innerType) {
  return optional2(nullable(innerType));
}
__name(nullish2, "nullish");
var ZodDefault2 = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => defaultProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports2.shallowClone(defaultValue);
    }
  });
}
__name(_default2, "_default");
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => prefaultProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports2.shallowClone(defaultValue);
    }
  });
}
__name(prefault, "prefault");
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nonoptionalProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports2.normalizeParams(params)
  });
}
__name(nonoptional, "nonoptional");
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => successProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
__name(success, "success");
var ZodCatch2 = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => catchProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch4(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
__name(_catch4, "_catch");
var ZodNaN2 = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => nanProcessor(inst, ctx, json3, params);
});
function nan(params) {
  return _nan(ZodNaN2, params);
}
__name(nan, "nan");
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => pipeProcessor(inst, ctx, json3, params);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe2(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
__name(pipe2, "pipe");
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
__name(codec, "codec");
var ZodReadonly2 = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => readonlyProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
__name(readonly, "readonly");
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => templateLiteralProcessor(inst, ctx, json3, params);
});
function templateLiteral(parts2, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts: parts2,
    ...util_exports2.normalizeParams(params)
  });
}
__name(templateLiteral, "templateLiteral");
var ZodLazy2 = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => lazyProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy2({
    type: "lazy",
    getter
  });
}
__name(lazy, "lazy");
var ZodPromise2 = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => promiseProcessor(inst, ctx, json3, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise3(innerType) {
  return new ZodPromise2({
    type: "promise",
    innerType
  });
}
__name(promise3, "promise");
var ZodFunction2 = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => functionProcessor(inst, ctx, json3, params);
});
function _function(params) {
  return new ZodFunction2({
    type: "function",
    input: Array.isArray(params?.input) ? tuple3(params?.input) : params?.input ?? array6(unknown()),
    output: params?.output ?? unknown()
  });
}
__name(_function, "_function");
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json3, params) => customProcessor(inst, ctx, json3, params);
});
function check4(fn2) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn2;
  return ch;
}
__name(check4, "check");
function custom3(fn2, _params) {
  return _custom(ZodCustom, fn2 ?? (() => true), _params);
}
__name(custom3, "custom");
function refine(fn2, _params = {}) {
  return _refine(ZodCustom, fn2, _params);
}
__name(refine, "refine");
function superRefine(fn2) {
  return _superRefine(fn2);
}
__name(superRefine, "superRefine");
var describe2 = describe;
var meta2 = meta;
function _instanceof(cls, params = {}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: /* @__PURE__ */ __name((data) => data instanceof cls, "fn"),
    abort: true,
    ...util_exports2.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
__name(_instanceof, "_instanceof");
var stringbool = /* @__PURE__ */ __name((...args2) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean2,
  String: ZodString2
}, ...args2), "stringbool");
function json2(params) {
  const jsonSchema = lazy(() => {
    return union12([string6(params), number6(), boolean4(), _null3(), array6(jsonSchema), record3(string6(), jsonSchema)]);
  });
  return jsonSchema;
}
__name(json2, "json");
function preprocess(fn2, schema) {
  return pipe2(transform3(fn2), schema);
}
__name(preprocess, "preprocess");

// node_modules/zod/v4/classic/compat.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ZodIssueCode2 = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map31) {
  config3({
    customError: map31
  });
}
__name(setErrorMap, "setErrorMap");
function getErrorMap2() {
  return config3().customError;
}
__name(getErrorMap2, "getErrorMap");
var ZodFirstPartyTypeKind2;
/* @__PURE__ */ (function(ZodFirstPartyTypeKind3) {
})(ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {}));

// node_modules/zod/v4/classic/from-json-schema.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var z = {
  ...schemas_exports3,
  ...checks_exports2,
  iso: iso_exports2
};
var RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
  // Schema identification
  "$schema",
  "$ref",
  "$defs",
  "definitions",
  // Core schema keywords
  "$id",
  "id",
  "$comment",
  "$anchor",
  "$vocabulary",
  "$dynamicRef",
  "$dynamicAnchor",
  // Type
  "type",
  "enum",
  "const",
  // Composition
  "anyOf",
  "oneOf",
  "allOf",
  "not",
  // Object
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "propertyNames",
  "minProperties",
  "maxProperties",
  // Array
  "items",
  "prefixItems",
  "additionalItems",
  "minItems",
  "maxItems",
  "uniqueItems",
  "contains",
  "minContains",
  "maxContains",
  // String
  "minLength",
  "maxLength",
  "pattern",
  "format",
  // Number
  "minimum",
  "maximum",
  "exclusiveMinimum",
  "exclusiveMaximum",
  "multipleOf",
  // Already handled metadata
  "description",
  "default",
  // Content
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  // Unsupported (error-throwing)
  "unevaluatedItems",
  "unevaluatedProperties",
  "if",
  "then",
  "else",
  "dependentSchemas",
  "dependentRequired",
  // OpenAPI
  "nullable",
  "readOnly"
]);
function detectVersion(schema, defaultTarget) {
  const $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
__name(detectVersion, "detectVersion");
function resolveRef(ref2, ctx) {
  if (!ref2.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path = ref2.slice(1).split("/").filter(Boolean);
  if (path.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path[0] === defsKey) {
    const key = path[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref2}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref2}`);
}
__name(resolveRef, "resolveRef");
function convertBaseSchema(schema, ctx) {
  if (schema.not !== void 0) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
      return z.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== void 0) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema.unevaluatedProperties !== void 0) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema.if !== void 0 || schema.then !== void 0 || schema.else !== void 0) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema.dependentSchemas !== void 0 || schema.dependentRequired !== void 0) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema.$ref) {
    const refPath = schema.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema.enum !== void 0) {
    const enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z.null();
    }
    if (enumValues.length === 0) {
      return z.never();
    }
    if (enumValues.length === 1) {
      return z.literal(enumValues[0]);
    }
    if (enumValues.every((v) => typeof v === "string")) {
      return z.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v) => z.literal(v));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== void 0) {
    return z.literal(schema.const);
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const typeSchemas = type.map((t) => {
      const typeSchema2 = { ...schema, type: t };
      return convertBaseSchema(typeSchema2, ctx);
    });
    if (typeSchemas.length === 0) {
      return z.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z.union(typeSchemas);
  }
  if (!type) {
    return z.any();
  }
  let zodSchema;
  switch (type) {
    case "string": {
      let stringSchema = z.string();
      if (schema.format) {
        const format7 = schema.format;
        if (format7 === "email") {
          stringSchema = stringSchema.check(z.email());
        } else if (format7 === "uri" || format7 === "uri-reference") {
          stringSchema = stringSchema.check(z.url());
        } else if (format7 === "uuid" || format7 === "guid") {
          stringSchema = stringSchema.check(z.uuid());
        } else if (format7 === "date-time") {
          stringSchema = stringSchema.check(z.iso.datetime());
        } else if (format7 === "date") {
          stringSchema = stringSchema.check(z.iso.date());
        } else if (format7 === "time") {
          stringSchema = stringSchema.check(z.iso.time());
        } else if (format7 === "duration") {
          stringSchema = stringSchema.check(z.iso.duration());
        } else if (format7 === "ipv4") {
          stringSchema = stringSchema.check(z.ipv4());
        } else if (format7 === "ipv6") {
          stringSchema = stringSchema.check(z.ipv6());
        } else if (format7 === "mac") {
          stringSchema = stringSchema.check(z.mac());
        } else if (format7 === "cidr") {
          stringSchema = stringSchema.check(z.cidrv4());
        } else if (format7 === "cidr-v6") {
          stringSchema = stringSchema.check(z.cidrv6());
        } else if (format7 === "base64") {
          stringSchema = stringSchema.check(z.base64());
        } else if (format7 === "base64url") {
          stringSchema = stringSchema.check(z.base64url());
        } else if (format7 === "e164") {
          stringSchema = stringSchema.check(z.e164());
        } else if (format7 === "jwt") {
          stringSchema = stringSchema.check(z.jwt());
        } else if (format7 === "emoji") {
          stringSchema = stringSchema.check(z.emoji());
        } else if (format7 === "nanoid") {
          stringSchema = stringSchema.check(z.nanoid());
        } else if (format7 === "cuid") {
          stringSchema = stringSchema.check(z.cuid());
        } else if (format7 === "cuid2") {
          stringSchema = stringSchema.check(z.cuid2());
        } else if (format7 === "ulid") {
          stringSchema = stringSchema.check(z.ulid());
        } else if (format7 === "xid") {
          stringSchema = stringSchema.check(z.xid());
        } else if (format7 === "ksuid") {
          stringSchema = stringSchema.check(z.ksuid());
        }
      }
      if (typeof schema.minLength === "number") {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === "number") {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      if (schema.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z.number().int() : z.number();
      if (typeof schema.minimum === "number") {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === "number") {
        numberSchema = numberSchema.max(schema.maximum);
      }
      if (typeof schema.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
        numberSchema = numberSchema.gt(schema.minimum);
      }
      if (typeof schema.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
        numberSchema = numberSchema.lt(schema.maximum);
      }
      if (typeof schema.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z.boolean();
      break;
    }
    case "null": {
      zodSchema = z.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema.properties || {};
      const requiredSet = new Set(schema.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        const keySchema = convertSchema(schema.propertyNames, ctx);
        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z.object(shape).passthrough();
        const recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        const patternProps = schema.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern2 of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern2], ctx);
          const keySchema = z.string().regex(new RegExp(pattern2));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2; i < schemasToIntersect.length; i++) {
            result = z.intersection(result, schemasToIntersect[i]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z.object(shape);
      if (schema.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema.prefixItems;
      const items = schema.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (items !== void 0) {
        const element2 = convertSchema(items, ctx);
        let arraySchema = z.array(element2);
        if (typeof schema.minItems === "number") {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (typeof schema.maxItems === "number") {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z.array(z.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type}`);
  }
  if (schema.description) {
    zodSchema = zodSchema.describe(schema.description);
  }
  if (schema.default !== void 0) {
    zodSchema = zodSchema.default(schema.default);
  }
  return zodSchema;
}
__name(convertBaseSchema, "convertBaseSchema");
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  let baseSchema = convertBaseSchema(schema, ctx);
  const hasExplicitType = schema.type || schema.enum !== void 0 || schema.const !== void 0;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const options = schema.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z.union(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const options = schema.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z.xor(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    if (schema.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx; i < schema.allOf.length; i++) {
        result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z.nullable(baseSchema);
  }
  if (schema.readOnly === true) {
    baseSchema = z.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  for (const key of Object.keys(schema)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
__name(convertSchema, "convertSchema");
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  const version4 = detectVersion(schema, params?.defaultTarget);
  const defs = schema.$defs || schema.definitions || {};
  const ctx = {
    version: version4,
    defs,
    refs: /* @__PURE__ */ new Map(),
    processing: /* @__PURE__ */ new Set(),
    rootSchema: schema,
    registry: params?.registry ?? globalRegistry
  };
  return convertSchema(schema, ctx);
}
__name(fromJSONSchema, "fromJSONSchema");

// node_modules/zod/v4/classic/coerce.js
var coerce_exports2 = {};
__export(coerce_exports2, {
  bigint: () => bigint5,
  boolean: () => boolean5,
  date: () => date6,
  number: () => number7,
  string: () => string7
});
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function string7(params) {
  return _coercedString(ZodString2, params);
}
__name(string7, "string");
function number7(params) {
  return _coercedNumber(ZodNumber2, params);
}
__name(number7, "number");
function boolean5(params) {
  return _coercedBoolean(ZodBoolean2, params);
}
__name(boolean5, "boolean");
function bigint5(params) {
  return _coercedBigint(ZodBigInt2, params);
}
__name(bigint5, "bigint");
function date6(params) {
  return _coercedDate(ZodDate2, params);
}
__name(date6, "date");

// node_modules/zod/v4/classic/external.js
config3(en_default2());

// node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
var LATEST_PROTOCOL_VERSION = "2025-11-25";
var DEFAULT_NEGOTIATED_PROTOCOL_VERSION = "2025-03-26";
var SUPPORTED_PROTOCOL_VERSIONS = [LATEST_PROTOCOL_VERSION, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"];
var RELATED_TASK_META_KEY = "io.modelcontextprotocol/related-task";
var JSONRPC_VERSION = "2.0";
var AssertObjectSchema = custom3((v) => v !== null && (typeof v === "object" || typeof v === "function"));
var ProgressTokenSchema = union12([string6(), number6().int()]);
var CursorSchema = string6();
var TaskCreationParamsSchema = looseObject({
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union12([number6(), _null3()]).optional(),
  /**
   * Time in milliseconds to wait between task status requests.
   */
  pollInterval: number6().optional()
});
var TaskMetadataSchema = object3({
  ttl: number6().optional()
});
var RelatedTaskMetadataSchema = object3({
  taskId: string6()
});
var RequestMetaSchema = looseObject({
  /**
   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
   */
  progressToken: ProgressTokenSchema.optional(),
  /**
   * If specified, this request is related to the provided task.
   */
  [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
});
var BaseRequestParamsSchema = object3({
  /**
   * See [General fields: `_meta`](/specification/draft/basic/index#meta) for notes on `_meta` usage.
   */
  _meta: RequestMetaSchema.optional()
});
var TaskAugmentedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * If specified, the caller is requesting task-augmented execution for this request.
   * The request will return a CreateTaskResult immediately, and the actual result can be
   * retrieved later via tasks/result.
   *
   * Task augmentation is subject to capability negotiation - receivers MUST declare support
   * for task augmentation of specific request types in their capabilities.
   */
  task: TaskMetadataSchema.optional()
});
var isTaskAugmentedRequestParams = /* @__PURE__ */ __name((value3) => TaskAugmentedRequestParamsSchema.safeParse(value3).success, "isTaskAugmentedRequestParams");
var RequestSchema = object3({
  method: string6(),
  params: BaseRequestParamsSchema.loose().optional()
});
var NotificationsParamsSchema = object3({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
});
var NotificationSchema = object3({
  method: string6(),
  params: NotificationsParamsSchema.loose().optional()
});
var ResultSchema = looseObject({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
});
var RequestIdSchema = union12([string6(), number6().int()]);
var JSONRPCRequestSchema = object3({
  jsonrpc: literal2(JSONRPC_VERSION),
  id: RequestIdSchema,
  ...RequestSchema.shape
}).strict();
var isJSONRPCRequest = /* @__PURE__ */ __name((value3) => JSONRPCRequestSchema.safeParse(value3).success, "isJSONRPCRequest");
var JSONRPCNotificationSchema = object3({
  jsonrpc: literal2(JSONRPC_VERSION),
  ...NotificationSchema.shape
}).strict();
var isJSONRPCNotification = /* @__PURE__ */ __name((value3) => JSONRPCNotificationSchema.safeParse(value3).success, "isJSONRPCNotification");
var JSONRPCResultResponseSchema = object3({
  jsonrpc: literal2(JSONRPC_VERSION),
  id: RequestIdSchema,
  result: ResultSchema
}).strict();
var isJSONRPCResultResponse = /* @__PURE__ */ __name((value3) => JSONRPCResultResponseSchema.safeParse(value3).success, "isJSONRPCResultResponse");
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["ConnectionClosed"] = -32e3] = "ConnectionClosed";
  ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
  ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
  ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
  ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
  ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
  ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
  ErrorCode2[ErrorCode2["UrlElicitationRequired"] = -32042] = "UrlElicitationRequired";
})(ErrorCode || (ErrorCode = {}));
var JSONRPCErrorResponseSchema = object3({
  jsonrpc: literal2(JSONRPC_VERSION),
  id: RequestIdSchema.optional(),
  error: object3({
    /**
     * The error type that occurred.
     */
    code: number6().int(),
    /**
     * A short description of the error. The message SHOULD be limited to a concise single sentence.
     */
    message: string6(),
    /**
     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
     */
    data: unknown().optional()
  })
}).strict();
var isJSONRPCErrorResponse = /* @__PURE__ */ __name((value3) => JSONRPCErrorResponseSchema.safeParse(value3).success, "isJSONRPCErrorResponse");
var JSONRPCMessageSchema = union12([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResultResponseSchema,
  JSONRPCErrorResponseSchema
]);
var JSONRPCResponseSchema = union12([JSONRPCResultResponseSchema, JSONRPCErrorResponseSchema]);
var EmptyResultSchema = ResultSchema.strict();
var CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the request to cancel.
   *
   * This MUST correspond to the ID of a request previously issued in the same direction.
   */
  requestId: RequestIdSchema.optional(),
  /**
   * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
   */
  reason: string6().optional()
});
var CancelledNotificationSchema = NotificationSchema.extend({
  method: literal2("notifications/cancelled"),
  params: CancelledNotificationParamsSchema
});
var IconSchema = object3({
  /**
   * URL or data URI for the icon.
   */
  src: string6(),
  /**
   * Optional MIME type for the icon.
   */
  mimeType: string6().optional(),
  /**
   * Optional array of strings that specify sizes at which the icon can be used.
   * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
   *
   * If not provided, the client should assume that the icon can be used at any size.
   */
  sizes: array6(string6()).optional(),
  /**
   * Optional specifier for the theme this icon is designed for. `light` indicates
   * the icon is designed to be used with a light background, and `dark` indicates
   * the icon is designed to be used with a dark background.
   *
   * If not provided, the client should assume the icon can be used with any theme.
   */
  theme: _enum2(["light", "dark"]).optional()
});
var IconsSchema = object3({
  /**
   * Optional set of sized icons that the client can display in a user interface.
   *
   * Clients that support rendering icons MUST support at least the following MIME types:
   * - `image/png` - PNG images (safe, universal compatibility)
   * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
   *
   * Clients that support rendering icons SHOULD also support:
   * - `image/svg+xml` - SVG images (scalable but requires security precautions)
   * - `image/webp` - WebP images (modern, efficient format)
   */
  icons: array6(IconSchema).optional()
});
var BaseMetadataSchema = object3({
  /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
  name: string6(),
  /**
   * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,
   * even by those unfamiliar with domain-specific terminology.
   *
   * If not provided, the name should be used for display (except for Tool,
   * where `annotations.title` should be given precedence over using `name`,
   * if present).
   */
  title: string6().optional()
});
var ImplementationSchema = BaseMetadataSchema.extend({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  version: string6(),
  /**
   * An optional URL of the website for this implementation.
   */
  websiteUrl: string6().optional(),
  /**
   * An optional human-readable description of what this implementation does.
   *
   * This can be used by clients or servers to provide context about their purpose
   * and capabilities. For example, a server might describe the types of resources
   * or tools it provides, while a client might describe its intended use case.
   */
  description: string6().optional()
});
var FormElicitationCapabilitySchema = intersection4(object3({
  applyDefaults: boolean4().optional()
}), record3(string6(), unknown()));
var ElicitationCapabilitySchema = preprocess((value3) => {
  if (value3 && typeof value3 === "object" && !Array.isArray(value3)) {
    if (Object.keys(value3).length === 0) {
      return { form: {} };
    }
  }
  return value3;
}, intersection4(object3({
  form: FormElicitationCapabilitySchema.optional(),
  url: AssertObjectSchema.optional()
}), record3(string6(), unknown()).optional()));
var ClientTasksCapabilitySchema = looseObject({
  /**
   * Present if the client supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the client supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for sampling requests.
     */
    sampling: looseObject({
      createMessage: AssertObjectSchema.optional()
    }).optional(),
    /**
     * Task support for elicitation requests.
     */
    elicitation: looseObject({
      create: AssertObjectSchema.optional()
    }).optional()
  }).optional()
});
var ServerTasksCapabilitySchema = looseObject({
  /**
   * Present if the server supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the server supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for tool requests.
     */
    tools: looseObject({
      call: AssertObjectSchema.optional()
    }).optional()
  }).optional()
});
var ClientCapabilitiesSchema = object3({
  /**
   * Experimental, non-standard capabilities that the client supports.
   */
  experimental: record3(string6(), AssertObjectSchema).optional(),
  /**
   * Present if the client supports sampling from an LLM.
   */
  sampling: object3({
    /**
     * Present if the client supports context inclusion via includeContext parameter.
     * If not declared, servers SHOULD only use `includeContext: "none"` (or omit it).
     */
    context: AssertObjectSchema.optional(),
    /**
     * Present if the client supports tool use via tools and toolChoice parameters.
     */
    tools: AssertObjectSchema.optional()
  }).optional(),
  /**
   * Present if the client supports eliciting user input.
   */
  elicitation: ElicitationCapabilitySchema.optional(),
  /**
   * Present if the client supports listing roots.
   */
  roots: object3({
    /**
     * Whether the client supports issuing notifications for changes to the roots list.
     */
    listChanged: boolean4().optional()
  }).optional(),
  /**
   * Present if the client supports task creation.
   */
  tasks: ClientTasksCapabilitySchema.optional()
});
var InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
   */
  protocolVersion: string6(),
  capabilities: ClientCapabilitiesSchema,
  clientInfo: ImplementationSchema
});
var InitializeRequestSchema = RequestSchema.extend({
  method: literal2("initialize"),
  params: InitializeRequestParamsSchema
});
var isInitializeRequest = /* @__PURE__ */ __name((value3) => InitializeRequestSchema.safeParse(value3).success, "isInitializeRequest");
var ServerCapabilitiesSchema = object3({
  /**
   * Experimental, non-standard capabilities that the server supports.
   */
  experimental: record3(string6(), AssertObjectSchema).optional(),
  /**
   * Present if the server supports sending log messages to the client.
   */
  logging: AssertObjectSchema.optional(),
  /**
   * Present if the server supports sending completions to the client.
   */
  completions: AssertObjectSchema.optional(),
  /**
   * Present if the server offers any prompt templates.
   */
  prompts: object3({
    /**
     * Whether this server supports issuing notifications for changes to the prompt list.
     */
    listChanged: boolean4().optional()
  }).optional(),
  /**
   * Present if the server offers any resources to read.
   */
  resources: object3({
    /**
     * Whether this server supports clients subscribing to resource updates.
     */
    subscribe: boolean4().optional(),
    /**
     * Whether this server supports issuing notifications for changes to the resource list.
     */
    listChanged: boolean4().optional()
  }).optional(),
  /**
   * Present if the server offers any tools to call.
   */
  tools: object3({
    /**
     * Whether this server supports issuing notifications for changes to the tool list.
     */
    listChanged: boolean4().optional()
  }).optional(),
  /**
   * Present if the server supports task creation.
   */
  tasks: ServerTasksCapabilitySchema.optional()
});
var InitializeResultSchema = ResultSchema.extend({
  /**
   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
   */
  protocolVersion: string6(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ImplementationSchema,
  /**
   * Instructions describing how to use the server and its features.
   *
   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
   */
  instructions: string6().optional()
});
var InitializedNotificationSchema = NotificationSchema.extend({
  method: literal2("notifications/initialized"),
  params: NotificationsParamsSchema.optional()
});
var PingRequestSchema = RequestSchema.extend({
  method: literal2("ping"),
  params: BaseRequestParamsSchema.optional()
});
var ProgressSchema = object3({
  /**
   * The progress thus far. This should increase every time progress is made, even if the total is unknown.
   */
  progress: number6(),
  /**
   * Total number of items to process (or total progress required), if known.
   */
  total: optional2(number6()),
  /**
   * An optional message describing the current progress.
   */
  message: optional2(string6())
});
var ProgressNotificationParamsSchema = object3({
  ...NotificationsParamsSchema.shape,
  ...ProgressSchema.shape,
  /**
   * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
   */
  progressToken: ProgressTokenSchema
});
var ProgressNotificationSchema = NotificationSchema.extend({
  method: literal2("notifications/progress"),
  params: ProgressNotificationParamsSchema
});
var PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * An opaque token representing the current pagination position.
   * If provided, the server should return results starting after this cursor.
   */
  cursor: CursorSchema.optional()
});
var PaginatedRequestSchema = RequestSchema.extend({
  params: PaginatedRequestParamsSchema.optional()
});
var PaginatedResultSchema = ResultSchema.extend({
  /**
   * An opaque token representing the pagination position after the last returned result.
   * If present, there may be more results available.
   */
  nextCursor: CursorSchema.optional()
});
var TaskStatusSchema = _enum2(["working", "input_required", "completed", "failed", "cancelled"]);
var TaskSchema = object3({
  taskId: string6(),
  status: TaskStatusSchema,
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union12([number6(), _null3()]),
  /**
   * ISO 8601 timestamp when the task was created.
   */
  createdAt: string6(),
  /**
   * ISO 8601 timestamp when the task was last updated.
   */
  lastUpdatedAt: string6(),
  pollInterval: optional2(number6()),
  /**
   * Optional diagnostic message for failed tasks or other status information.
   */
  statusMessage: optional2(string6())
});
var CreateTaskResultSchema = ResultSchema.extend({
  task: TaskSchema
});
var TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema);
var TaskStatusNotificationSchema = NotificationSchema.extend({
  method: literal2("notifications/tasks/status"),
  params: TaskStatusNotificationParamsSchema
});
var GetTaskRequestSchema = RequestSchema.extend({
  method: literal2("tasks/get"),
  params: BaseRequestParamsSchema.extend({
    taskId: string6()
  })
});
var GetTaskResultSchema = ResultSchema.merge(TaskSchema);
var GetTaskPayloadRequestSchema = RequestSchema.extend({
  method: literal2("tasks/result"),
  params: BaseRequestParamsSchema.extend({
    taskId: string6()
  })
});
var GetTaskPayloadResultSchema = ResultSchema.loose();
var ListTasksRequestSchema = PaginatedRequestSchema.extend({
  method: literal2("tasks/list")
});
var ListTasksResultSchema = PaginatedResultSchema.extend({
  tasks: array6(TaskSchema)
});
var CancelTaskRequestSchema = RequestSchema.extend({
  method: literal2("tasks/cancel"),
  params: BaseRequestParamsSchema.extend({
    taskId: string6()
  })
});
var CancelTaskResultSchema = ResultSchema.merge(TaskSchema);
var ResourceContentsSchema = object3({
  /**
   * The URI of this resource.
   */
  uri: string6(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional2(string6()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record3(string6(), unknown()).optional()
});
var TextResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
   */
  text: string6()
});
var Base64Schema = string6().refine((val) => {
  try {
    atob(val);
    return true;
  } catch {
    return false;
  }
}, { message: "Invalid Base64 string" });
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * A base64-encoded string representing the binary data of the item.
   */
  blob: Base64Schema
});
var RoleSchema = _enum2(["user", "assistant"]);
var AnnotationsSchema = object3({
  /**
   * Intended audience(s) for the resource.
   */
  audience: array6(RoleSchema).optional(),
  /**
   * Importance hint for the resource, from 0 (least) to 1 (most).
   */
  priority: number6().min(0).max(1).optional(),
  /**
   * ISO 8601 timestamp for the most recent modification.
   */
  lastModified: iso_exports2.datetime({ offset: true }).optional()
});
var ResourceSchema = object3({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * The URI of this resource.
   */
  uri: string6(),
  /**
   * A description of what this resource represents.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional2(string6()),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional2(string6()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional2(looseObject({}))
});
var ResourceTemplateSchema = object3({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A URI template (according to RFC 6570) that can be used to construct resource URIs.
   */
  uriTemplate: string6(),
  /**
   * A description of what this template is for.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional2(string6()),
  /**
   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
   */
  mimeType: optional2(string6()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional2(looseObject({}))
});
var ListResourcesRequestSchema = PaginatedRequestSchema.extend({
  method: literal2("resources/list")
});
var ListResourcesResultSchema = PaginatedResultSchema.extend({
  resources: array6(ResourceSchema)
});
var ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
  method: literal2("resources/templates/list")
});
var ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
  resourceTemplates: array6(ResourceTemplateSchema)
});
var ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
   *
   * @format uri
   */
  uri: string6()
});
var ReadResourceRequestParamsSchema = ResourceRequestParamsSchema;
var ReadResourceRequestSchema = RequestSchema.extend({
  method: literal2("resources/read"),
  params: ReadResourceRequestParamsSchema
});
var ReadResourceResultSchema = ResultSchema.extend({
  contents: array6(union12([TextResourceContentsSchema, BlobResourceContentsSchema]))
});
var ResourceListChangedNotificationSchema = NotificationSchema.extend({
  method: literal2("notifications/resources/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var SubscribeRequestParamsSchema = ResourceRequestParamsSchema;
var SubscribeRequestSchema = RequestSchema.extend({
  method: literal2("resources/subscribe"),
  params: SubscribeRequestParamsSchema
});
var UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema;
var UnsubscribeRequestSchema = RequestSchema.extend({
  method: literal2("resources/unsubscribe"),
  params: UnsubscribeRequestParamsSchema
});
var ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
   */
  uri: string6()
});
var ResourceUpdatedNotificationSchema = NotificationSchema.extend({
  method: literal2("notifications/resources/updated"),
  params: ResourceUpdatedNotificationParamsSchema
});
var PromptArgumentSchema = object3({
  /**
   * The name of the argument.
   */
  name: string6(),
  /**
   * A human-readable description of the argument.
   */
  description: optional2(string6()),
  /**
   * Whether this argument must be provided.
   */
  required: optional2(boolean4())
});
var PromptSchema = object3({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * An optional description of what this prompt provides
   */
  description: optional2(string6()),
  /**
   * A list of arguments to use for templating the prompt.
   */
  arguments: optional2(array6(PromptArgumentSchema)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional2(looseObject({}))
});
var ListPromptsRequestSchema = PaginatedRequestSchema.extend({
  method: literal2("prompts/list")
});
var ListPromptsResultSchema = PaginatedResultSchema.extend({
  prompts: array6(PromptSchema)
});
var GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The name of the prompt or prompt template.
   */
  name: string6(),
  /**
   * Arguments to use for templating the prompt.
   */
  arguments: record3(string6(), string6()).optional()
});
var GetPromptRequestSchema = RequestSchema.extend({
  method: literal2("prompts/get"),
  params: GetPromptRequestParamsSchema
});
var TextContentSchema = object3({
  type: literal2("text"),
  /**
   * The text content of the message.
   */
  text: string6(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record3(string6(), unknown()).optional()
});
var ImageContentSchema = object3({
  type: literal2("image"),
  /**
   * The base64-encoded image data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the image. Different providers may support different image types.
   */
  mimeType: string6(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record3(string6(), unknown()).optional()
});
var AudioContentSchema = object3({
  type: literal2("audio"),
  /**
   * The base64-encoded audio data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the audio. Different providers may support different audio types.
   */
  mimeType: string6(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record3(string6(), unknown()).optional()
});
var ToolUseContentSchema = object3({
  type: literal2("tool_use"),
  /**
   * The name of the tool to invoke.
   * Must match a tool name from the request's tools array.
   */
  name: string6(),
  /**
   * Unique identifier for this tool call.
   * Used to correlate with ToolResultContent in subsequent messages.
   */
  id: string6(),
  /**
   * Arguments to pass to the tool.
   * Must conform to the tool's inputSchema.
   */
  input: record3(string6(), unknown()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record3(string6(), unknown()).optional()
});
var EmbeddedResourceSchema = object3({
  type: literal2("resource"),
  resource: union12([TextResourceContentsSchema, BlobResourceContentsSchema]),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record3(string6(), unknown()).optional()
});
var ResourceLinkSchema = ResourceSchema.extend({
  type: literal2("resource_link")
});
var ContentBlockSchema = union12([
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ResourceLinkSchema,
  EmbeddedResourceSchema
]);
var PromptMessageSchema = object3({
  role: RoleSchema,
  content: ContentBlockSchema
});
var GetPromptResultSchema = ResultSchema.extend({
  /**
   * An optional description for the prompt.
   */
  description: string6().optional(),
  messages: array6(PromptMessageSchema)
});
var PromptListChangedNotificationSchema = NotificationSchema.extend({
  method: literal2("notifications/prompts/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var ToolAnnotationsSchema = object3({
  /**
   * A human-readable title for the tool.
   */
  title: string6().optional(),
  /**
   * If true, the tool does not modify its environment.
   *
   * Default: false
   */
  readOnlyHint: boolean4().optional(),
  /**
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: true
   */
  destructiveHint: boolean4().optional(),
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: false
   */
  idempotentHint: boolean4().optional(),
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   *
   * Default: true
   */
  openWorldHint: boolean4().optional()
});
var ToolExecutionSchema = object3({
  /**
   * Indicates the tool's preference for task-augmented execution.
   * - "required": Clients MUST invoke the tool as a task
   * - "optional": Clients MAY invoke the tool as a task or normal request
   * - "forbidden": Clients MUST NOT attempt to invoke the tool as a task
   *
   * If not present, defaults to "forbidden".
   */
  taskSupport: _enum2(["required", "optional", "forbidden"]).optional()
});
var ToolSchema = object3({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A human-readable description of the tool.
   */
  description: string6().optional(),
  /**
   * A JSON Schema 2020-12 object defining the expected parameters for the tool.
   * Must have type: 'object' at the root level per MCP spec.
   */
  inputSchema: object3({
    type: literal2("object"),
    properties: record3(string6(), AssertObjectSchema).optional(),
    required: array6(string6()).optional()
  }).catchall(unknown()),
  /**
   * An optional JSON Schema 2020-12 object defining the structure of the tool's output
   * returned in the structuredContent field of a CallToolResult.
   * Must have type: 'object' at the root level per MCP spec.
   */
  outputSchema: object3({
    type: literal2("object"),
    properties: record3(string6(), AssertObjectSchema).optional(),
    required: array6(string6()).optional()
  }).catchall(unknown()).optional(),
  /**
   * Optional additional tool information.
   */
  annotations: ToolAnnotationsSchema.optional(),
  /**
   * Execution-related properties for this tool.
   */
  execution: ToolExecutionSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record3(string6(), unknown()).optional()
});
var ListToolsRequestSchema = PaginatedRequestSchema.extend({
  method: literal2("tools/list")
});
var ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: array6(ToolSchema)
});
var CallToolResultSchema = ResultSchema.extend({
  /**
   * A list of content objects that represent the result of the tool call.
   *
   * If the Tool does not define an outputSchema, this field MUST be present in the result.
   * For backwards compatibility, this field is always present, but it may be empty.
   */
  content: array6(ContentBlockSchema).default([]),
  /**
   * An object containing structured tool output.
   *
   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
   */
  structuredContent: record3(string6(), unknown()).optional(),
  /**
   * Whether the tool call ended in an error.
   *
   * If not set, this is assumed to be false (the call was successful).
   *
   * Any errors that originate from the tool SHOULD be reported inside the result
   * object, with `isError` set to true, _not_ as an MCP protocol-level error
   * response. Otherwise, the LLM would not be able to see that an error occurred
   * and self-correct.
   *
   * However, any errors in _finding_ the tool, an error indicating that the
   * server does not support tool calls, or any other exceptional conditions,
   * should be reported as an MCP error response.
   */
  isError: boolean4().optional()
});
var CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
  toolResult: unknown()
}));
var CallToolRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The name of the tool to call.
   */
  name: string6(),
  /**
   * Arguments to pass to the tool.
   */
  arguments: record3(string6(), unknown()).optional()
});
var CallToolRequestSchema = RequestSchema.extend({
  method: literal2("tools/call"),
  params: CallToolRequestParamsSchema
});
var ToolListChangedNotificationSchema = NotificationSchema.extend({
  method: literal2("notifications/tools/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var ListChangedOptionsBaseSchema = object3({
  /**
   * If true, the list will be refreshed automatically when a list changed notification is received.
   * The callback will be called with the updated list.
   *
   * If false, the callback will be called with null items, allowing manual refresh.
   *
   * @default true
   */
  autoRefresh: boolean4().default(true),
  /**
   * Debounce time in milliseconds for list changed notification processing.
   *
   * Multiple notifications received within this timeframe will only trigger one refresh.
   * Set to 0 to disable debouncing.
   *
   * @default 300
   */
  debounceMs: number6().int().nonnegative().default(300)
});
var LoggingLevelSchema = _enum2(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
var SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
   */
  level: LoggingLevelSchema
});
var SetLevelRequestSchema = RequestSchema.extend({
  method: literal2("logging/setLevel"),
  params: SetLevelRequestParamsSchema
});
var LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The severity of this log message.
   */
  level: LoggingLevelSchema,
  /**
   * An optional name of the logger issuing this message.
   */
  logger: string6().optional(),
  /**
   * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
   */
  data: unknown()
});
var LoggingMessageNotificationSchema = NotificationSchema.extend({
  method: literal2("notifications/message"),
  params: LoggingMessageNotificationParamsSchema
});
var ModelHintSchema = object3({
  /**
   * A hint for a model name.
   */
  name: string6().optional()
});
var ModelPreferencesSchema = object3({
  /**
   * Optional hints to use for model selection.
   */
  hints: array6(ModelHintSchema).optional(),
  /**
   * How much to prioritize cost when selecting a model.
   */
  costPriority: number6().min(0).max(1).optional(),
  /**
   * How much to prioritize sampling speed (latency) when selecting a model.
   */
  speedPriority: number6().min(0).max(1).optional(),
  /**
   * How much to prioritize intelligence and capabilities when selecting a model.
   */
  intelligencePriority: number6().min(0).max(1).optional()
});
var ToolChoiceSchema = object3({
  /**
   * Controls when tools are used:
   * - "auto": Model decides whether to use tools (default)
   * - "required": Model MUST use at least one tool before completing
   * - "none": Model MUST NOT use any tools
   */
  mode: _enum2(["auto", "required", "none"]).optional()
});
var ToolResultContentSchema = object3({
  type: literal2("tool_result"),
  toolUseId: string6().describe("The unique identifier for the corresponding tool call."),
  content: array6(ContentBlockSchema).default([]),
  structuredContent: object3({}).loose().optional(),
  isError: boolean4().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record3(string6(), unknown()).optional()
});
var SamplingContentSchema = discriminatedUnion("type", [TextContentSchema, ImageContentSchema, AudioContentSchema]);
var SamplingMessageContentBlockSchema = discriminatedUnion("type", [
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ToolUseContentSchema,
  ToolResultContentSchema
]);
var SamplingMessageSchema = object3({
  role: RoleSchema,
  content: union12([SamplingMessageContentBlockSchema, array6(SamplingMessageContentBlockSchema)]),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record3(string6(), unknown()).optional()
});
var CreateMessageRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  messages: array6(SamplingMessageSchema),
  /**
   * The server's preferences for which model to select. The client MAY modify or omit this request.
   */
  modelPreferences: ModelPreferencesSchema.optional(),
  /**
   * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
   */
  systemPrompt: string6().optional(),
  /**
   * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.
   * The client MAY ignore this request.
   *
   * Default is "none". Values "thisServer" and "allServers" are soft-deprecated. Servers SHOULD only use these values if the client
   * declares ClientCapabilities.sampling.context. These values may be removed in future spec releases.
   */
  includeContext: _enum2(["none", "thisServer", "allServers"]).optional(),
  temperature: number6().optional(),
  /**
   * The requested maximum number of tokens to sample (to prevent runaway completions).
   *
   * The client MAY choose to sample fewer tokens than the requested maximum.
   */
  maxTokens: number6().int(),
  stopSequences: array6(string6()).optional(),
  /**
   * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
   */
  metadata: AssertObjectSchema.optional(),
  /**
   * Tools that the model may use during generation.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   */
  tools: array6(ToolSchema).optional(),
  /**
   * Controls how the model uses tools.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   * Default is `{ mode: "auto" }`.
   */
  toolChoice: ToolChoiceSchema.optional()
});
var CreateMessageRequestSchema = RequestSchema.extend({
  method: literal2("sampling/createMessage"),
  params: CreateMessageRequestParamsSchema
});
var CreateMessageResultSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string6(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional2(_enum2(["endTurn", "stopSequence", "maxTokens"]).or(string6())),
  role: RoleSchema,
  /**
   * Response content. Single content block (text, image, or audio).
   */
  content: SamplingContentSchema
});
var CreateMessageResultWithToolsSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string6(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   * - "toolUse": The model wants to use one or more tools
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional2(_enum2(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(string6())),
  role: RoleSchema,
  /**
   * Response content. May be a single block or array. May include ToolUseContent if stopReason is "toolUse".
   */
  content: union12([SamplingMessageContentBlockSchema, array6(SamplingMessageContentBlockSchema)])
});
var BooleanSchemaSchema = object3({
  type: literal2("boolean"),
  title: string6().optional(),
  description: string6().optional(),
  default: boolean4().optional()
});
var StringSchemaSchema = object3({
  type: literal2("string"),
  title: string6().optional(),
  description: string6().optional(),
  minLength: number6().optional(),
  maxLength: number6().optional(),
  format: _enum2(["email", "uri", "date", "date-time"]).optional(),
  default: string6().optional()
});
var NumberSchemaSchema = object3({
  type: _enum2(["number", "integer"]),
  title: string6().optional(),
  description: string6().optional(),
  minimum: number6().optional(),
  maximum: number6().optional(),
  default: number6().optional()
});
var UntitledSingleSelectEnumSchemaSchema = object3({
  type: literal2("string"),
  title: string6().optional(),
  description: string6().optional(),
  enum: array6(string6()),
  default: string6().optional()
});
var TitledSingleSelectEnumSchemaSchema = object3({
  type: literal2("string"),
  title: string6().optional(),
  description: string6().optional(),
  oneOf: array6(object3({
    const: string6(),
    title: string6()
  })),
  default: string6().optional()
});
var LegacyTitledEnumSchemaSchema = object3({
  type: literal2("string"),
  title: string6().optional(),
  description: string6().optional(),
  enum: array6(string6()),
  enumNames: array6(string6()).optional(),
  default: string6().optional()
});
var SingleSelectEnumSchemaSchema = union12([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]);
var UntitledMultiSelectEnumSchemaSchema = object3({
  type: literal2("array"),
  title: string6().optional(),
  description: string6().optional(),
  minItems: number6().optional(),
  maxItems: number6().optional(),
  items: object3({
    type: literal2("string"),
    enum: array6(string6())
  }),
  default: array6(string6()).optional()
});
var TitledMultiSelectEnumSchemaSchema = object3({
  type: literal2("array"),
  title: string6().optional(),
  description: string6().optional(),
  minItems: number6().optional(),
  maxItems: number6().optional(),
  items: object3({
    anyOf: array6(object3({
      const: string6(),
      title: string6()
    }))
  }),
  default: array6(string6()).optional()
});
var MultiSelectEnumSchemaSchema = union12([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]);
var EnumSchemaSchema = union12([LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema]);
var PrimitiveSchemaDefinitionSchema = union12([EnumSchemaSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema]);
var ElicitRequestFormParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   *
   * Optional for backward compatibility. Clients MUST treat missing mode as "form".
   */
  mode: literal2("form").optional(),
  /**
   * The message to present to the user describing what information is being requested.
   */
  message: string6(),
  /**
   * A restricted subset of JSON Schema.
   * Only top-level properties are allowed, without nesting.
   */
  requestedSchema: object3({
    type: literal2("object"),
    properties: record3(string6(), PrimitiveSchemaDefinitionSchema),
    required: array6(string6()).optional()
  })
});
var ElicitRequestURLParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   */
  mode: literal2("url"),
  /**
   * The message to present to the user explaining why the interaction is needed.
   */
  message: string6(),
  /**
   * The ID of the elicitation, which must be unique within the context of the server.
   * The client MUST treat this ID as an opaque value.
   */
  elicitationId: string6(),
  /**
   * The URL that the user should navigate to.
   */
  url: string6().url()
});
var ElicitRequestParamsSchema = union12([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]);
var ElicitRequestSchema = RequestSchema.extend({
  method: literal2("elicitation/create"),
  params: ElicitRequestParamsSchema
});
var ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the elicitation that completed.
   */
  elicitationId: string6()
});
var ElicitationCompleteNotificationSchema = NotificationSchema.extend({
  method: literal2("notifications/elicitation/complete"),
  params: ElicitationCompleteNotificationParamsSchema
});
var ElicitResultSchema = ResultSchema.extend({
  /**
   * The user action in response to the elicitation.
   * - "accept": User submitted the form/confirmed the action
   * - "decline": User explicitly decline the action
   * - "cancel": User dismissed without making an explicit choice
   */
  action: _enum2(["accept", "decline", "cancel"]),
  /**
   * The submitted form data, only present when action is "accept".
   * Contains values matching the requested schema.
   * Per MCP spec, content is "typically omitted" for decline/cancel actions.
   * We normalize null to undefined for leniency while maintaining type compatibility.
   */
  content: preprocess((val) => val === null ? void 0 : val, record3(string6(), union12([string6(), number6(), boolean4(), array6(string6())])).optional())
});
var ResourceTemplateReferenceSchema = object3({
  type: literal2("ref/resource"),
  /**
   * The URI or URI template of the resource.
   */
  uri: string6()
});
var PromptReferenceSchema = object3({
  type: literal2("ref/prompt"),
  /**
   * The name of the prompt or prompt template
   */
  name: string6()
});
var CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
  ref: union12([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
  /**
   * The argument's information
   */
  argument: object3({
    /**
     * The name of the argument
     */
    name: string6(),
    /**
     * The value of the argument to use for completion matching.
     */
    value: string6()
  }),
  context: object3({
    /**
     * Previously-resolved variables in a URI template or prompt.
     */
    arguments: record3(string6(), string6()).optional()
  }).optional()
});
var CompleteRequestSchema = RequestSchema.extend({
  method: literal2("completion/complete"),
  params: CompleteRequestParamsSchema
});
function assertCompleteRequestPrompt(request2) {
  if (request2.params.ref.type !== "ref/prompt") {
    throw new TypeError(`Expected CompleteRequestPrompt, but got ${request2.params.ref.type}`);
  }
  void request2;
}
__name(assertCompleteRequestPrompt, "assertCompleteRequestPrompt");
function assertCompleteRequestResourceTemplate(request2) {
  if (request2.params.ref.type !== "ref/resource") {
    throw new TypeError(`Expected CompleteRequestResourceTemplate, but got ${request2.params.ref.type}`);
  }
  void request2;
}
__name(assertCompleteRequestResourceTemplate, "assertCompleteRequestResourceTemplate");
var CompleteResultSchema = ResultSchema.extend({
  completion: looseObject({
    /**
     * An array of completion values. Must not exceed 100 items.
     */
    values: array6(string6()).max(100),
    /**
     * The total number of completion options available. This can exceed the number of values actually sent in the response.
     */
    total: optional2(number6().int()),
    /**
     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
     */
    hasMore: optional2(boolean4())
  })
});
var RootSchema = object3({
  /**
   * The URI identifying the root. This *must* start with file:// for now.
   */
  uri: string6().startsWith("file://"),
  /**
   * An optional name for the root.
   */
  name: string6().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record3(string6(), unknown()).optional()
});
var ListRootsRequestSchema = RequestSchema.extend({
  method: literal2("roots/list"),
  params: BaseRequestParamsSchema.optional()
});
var ListRootsResultSchema = ResultSchema.extend({
  roots: array6(RootSchema)
});
var RootsListChangedNotificationSchema = NotificationSchema.extend({
  method: literal2("notifications/roots/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var ClientRequestSchema = union12([
  PingRequestSchema,
  InitializeRequestSchema,
  CompleteRequestSchema,
  SetLevelRequestSchema,
  GetPromptRequestSchema,
  ListPromptsRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ReadResourceRequestSchema,
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
  CallToolRequestSchema,
  ListToolsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]);
var ClientNotificationSchema = union12([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  InitializedNotificationSchema,
  RootsListChangedNotificationSchema,
  TaskStatusNotificationSchema
]);
var ClientResultSchema = union12([
  EmptyResultSchema,
  CreateMessageResultSchema,
  CreateMessageResultWithToolsSchema,
  ElicitResultSchema,
  ListRootsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]);
var ServerRequestSchema = union12([
  PingRequestSchema,
  CreateMessageRequestSchema,
  ElicitRequestSchema,
  ListRootsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]);
var ServerNotificationSchema = union12([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  LoggingMessageNotificationSchema,
  ResourceUpdatedNotificationSchema,
  ResourceListChangedNotificationSchema,
  ToolListChangedNotificationSchema,
  PromptListChangedNotificationSchema,
  TaskStatusNotificationSchema,
  ElicitationCompleteNotificationSchema
]);
var ServerResultSchema = union12([
  EmptyResultSchema,
  InitializeResultSchema,
  CompleteResultSchema,
  GetPromptResultSchema,
  ListPromptsResultSchema,
  ListResourcesResultSchema,
  ListResourceTemplatesResultSchema,
  ReadResourceResultSchema,
  CallToolResultSchema,
  ListToolsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]);
var McpError = class _McpError extends Error {
  static {
    __name(this, "McpError");
  }
  constructor(code, message, data) {
    super(`MCP error ${code}: ${message}`);
    this.code = code;
    this.data = data;
    this.name = "McpError";
  }
  /**
   * Factory method to create the appropriate error type based on the error code and data
   */
  static fromError(code, message, data) {
    if (code === ErrorCode.UrlElicitationRequired && data) {
      const errorData = data;
      if (errorData.elicitations) {
        return new UrlElicitationRequiredError(errorData.elicitations, message);
      }
    }
    return new _McpError(code, message, data);
  }
};
var UrlElicitationRequiredError = class extends McpError {
  static {
    __name(this, "UrlElicitationRequiredError");
  }
  constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? "s" : ""} required`) {
    super(ErrorCode.UrlElicitationRequired, message, {
      elicitations
    });
  }
  get elicitations() {
    return this.data?.elicitations ?? [];
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/interfaces.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function isTerminal(status2) {
  return status2 === "completed" || status2 === "failed" || status2 === "cancelled";
}
__name(isTerminal, "isTerminal");

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/Options.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions = /* @__PURE__ */ __name((options) => typeof options === "string" ? {
  ...defaultOptions,
  name: options
} : {
  ...defaultOptions,
  ...options
}, "getDefaultOptions");

// node_modules/zod-to-json-schema/dist/esm/Refs.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var getRefs = /* @__PURE__ */ __name((options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
}, "getRefs");

// node_modules/zod-to-json-schema/dist/esm/errorMessages.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function addErrorMessage(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
__name(addErrorMessage, "addErrorMessage");
function setResponseValueAndErrors(res, key, value3, errorMessage, refs) {
  res[key] = value3;
  addErrorMessage(res, key, errorMessage, refs);
}
__name(setResponseValueAndErrors, "setResponseValueAndErrors");

// node_modules/zod-to-json-schema/dist/esm/getRelativePath.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var getRelativePath = /* @__PURE__ */ __name((pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
}, "getRelativePath");

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/selectParser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/parsers/any.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseAnyDef(refs) {
  if (refs.target !== "openAi") {
    return {};
  }
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref: refs.$refStrategy === "relative" ? getRelativePath(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
  };
}
__name(parseAnyDef, "parseAnyDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/array.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseArrayDef(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}
__name(parseArrayDef, "parseArrayDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check5 of def.checks) {
    switch (check5.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check5.inclusive) {
            setResponseValueAndErrors(res, "minimum", check5.value, check5.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check5.value, check5.message, refs);
          }
        } else {
          if (!check5.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check5.value, check5.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check5.inclusive) {
            setResponseValueAndErrors(res, "maximum", check5.value, check5.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check5.value, check5.message, refs);
          }
        } else {
          if (!check5.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check5.value, check5.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check5.value, check5.message, refs);
        break;
    }
  }
  return res;
}
__name(parseBigintDef, "parseBigintDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}
__name(parseBooleanDef, "parseBooleanDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}
__name(parseBrandedDef, "parseBrandedDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parseCatchDef = /* @__PURE__ */ __name((def, refs) => {
  return parseDef(def.innerType._def, refs);
}, "parseCatchDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/date.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
__name(parseDateDef, "parseDateDef");
var integerDateParser = /* @__PURE__ */ __name((def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check5 of def.checks) {
    switch (check5.kind) {
      case "min":
        setResponseValueAndErrors(
          res,
          "minimum",
          check5.value,
          // This is in milliseconds
          check5.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors(
          res,
          "maximum",
          check5.value,
          // This is in milliseconds
          check5.message,
          refs
        );
        break;
    }
  }
  return res;
}, "integerDateParser");

// node_modules/zod-to-json-schema/dist/esm/parsers/default.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}
__name(parseDefaultDef, "parseDefaultDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef(refs);
}
__name(parseEffectsDef, "parseEffectsDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}
__name(parseEnumDef, "parseEnumDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isJsonSchema7AllOfType = /* @__PURE__ */ __name((type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
}, "isJsonSchema7AllOfType");
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}
__name(parseIntersectionDef, "parseIntersectionDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseLiteralDef(def, refs) {
  const parsedType2 = typeof def.value;
  if (parsedType2 !== "bigint" && parsedType2 !== "number" && parsedType2 !== "boolean" && parsedType2 !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType2 === "bigint" ? "integer" : parsedType2,
      enum: [def.value]
    };
  }
  return {
    type: parsedType2 === "bigint" ? "integer" : parsedType2,
    const: def.value
  };
}
__name(parseLiteralDef, "parseLiteralDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var emojiRegex2 = void 0;
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: /* @__PURE__ */ __name(() => {
    if (emojiRegex2 === void 0) {
      emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex2;
  }, "emoji"),
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check5 of def.checks) {
      switch (check5.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check5.value) : check5.value, check5.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check5.value) : check5.value, check5.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check5.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check5.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check5.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check5.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check5.message, refs);
          break;
        case "regex":
          addPattern(res, check5.regex, check5.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check5.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check5.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check5.value, refs)}`), check5.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check5.value, refs)}$`), check5.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check5.message, refs);
          break;
        case "date":
          addFormat(res, "date", check5.message, refs);
          break;
        case "time":
          addFormat(res, "time", check5.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check5.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check5.value) : check5.value, check5.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check5.value) : check5.value, check5.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(escapeLiteralCheckValue(check5.value, refs)), check5.message, refs);
          break;
        }
        case "ip": {
          if (check5.version !== "v6") {
            addFormat(res, "ipv4", check5.message, refs);
          }
          if (check5.version !== "v4") {
            addFormat(res, "ipv6", check5.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check5.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check5.message, refs);
          break;
        case "cidr": {
          if (check5.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check5.message, refs);
          }
          if (check5.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check5.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check5.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check5.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check5.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check5.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check5.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check5.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check5);
      }
    }
  }
  return res;
}
__name(parseStringDef, "parseStringDef");
function escapeLiteralCheckValue(literal3, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal3) : literal3;
}
__name(escapeLiteralCheckValue, "escapeLiteralCheckValue");
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source2) {
  let result = "";
  for (let i = 0; i < source2.length; i++) {
    if (!ALPHA_NUMERIC.has(source2[i])) {
      result += "\\";
    }
    result += source2[i];
  }
  return result;
}
__name(escapeNonAlphaNumeric, "escapeNonAlphaNumeric");
function addFormat(schema, value3, message, refs) {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value3,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value3, message, refs);
  }
}
__name(addFormat, "addFormat");
function addPattern(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
  }
}
__name(addPattern, "addPattern");
function stringifyRegExpWithFlags(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source2 = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern2 = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source2.length; i++) {
    if (isEscaped) {
      pattern2 += source2[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source2[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern2 += source2[i];
            pattern2 += `${source2[i - 2]}-${source2[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source2[i + 1] === "-" && source2[i + 2]?.match(/[a-z]/)) {
            pattern2 += source2[i];
            inCharRange = true;
          } else {
            pattern2 += `${source2[i]}${source2[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source2[i].match(/[a-z]/)) {
        pattern2 += `[${source2[i]}${source2[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source2[i] === "^") {
        pattern2 += `(^|(?<=[\r
]))`;
        continue;
      } else if (source2[i] === "$") {
        pattern2 += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source2[i] === ".") {
      pattern2 += inCharGroup ? `${source2[i]}\r
` : `[${source2[i]}\r
]`;
      continue;
    }
    pattern2 += source2[i];
    if (source2[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source2[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source2[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern2);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex.source;
  }
  return pattern2;
}
__name(stringifyRegExpWithFlags, "stringifyRegExpWithFlags");

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef(def, refs) {
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? parseAnyDef(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}
__name(parseRecordDef, "parseRecordDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys5 = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef(refs);
  const values4 = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys5, values4],
      minItems: 2,
      maxItems: 2
    }
  };
}
__name(parseMapDef, "parseMapDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseNativeEnumDef(def) {
  const object4 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object4[object4[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object4[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values4) => typeof values4)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}
__name(parseNativeEnumDef, "parseNativeEnumDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/never.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseNeverDef(refs) {
  return refs.target === "openAi" ? void 0 : {
    not: parseAnyDef({
      ...refs,
      currentPath: [...refs.currentPath, "not"]
    })
  };
}
__name(parseNeverDef, "parseNeverDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/null.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}
__name(parseNullDef, "parseNullDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/parsers/union.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
__name(parseUnionDef, "parseUnionDef");
var asAnyOf = /* @__PURE__ */ __name((def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
}, "asAnyOf");

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}
__name(parseNullableDef, "parseNullableDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/number.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check5 of def.checks) {
    switch (check5.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check5.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check5.inclusive) {
            setResponseValueAndErrors(res, "minimum", check5.value, check5.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check5.value, check5.message, refs);
          }
        } else {
          if (!check5.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check5.value, check5.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check5.inclusive) {
            setResponseValueAndErrors(res, "maximum", check5.value, check5.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check5.value, check5.message, refs);
          }
        } else {
          if (!check5.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check5.value, check5.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check5.value, check5.message, refs);
        break;
    }
  }
  return res;
}
__name(parseNumberDef, "parseNumberDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/object.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseObjectDef(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required4 = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    let propOptional = safeIsOptional(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required4.push(propName);
    }
  }
  if (required4.length) {
    result.required = required4;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
__name(parseObjectDef, "parseObjectDef");
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
__name(decideAdditionalProperties, "decideAdditionalProperties");
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}
__name(safeIsOptional, "safeIsOptional");

// node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parseOptionalDef = /* @__PURE__ */ __name((def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: parseAnyDef(refs)
      },
      innerSchema
    ]
  } : parseAnyDef(refs);
}, "parseOptionalDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parsePipelineDef = /* @__PURE__ */ __name((def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
}, "parsePipelineDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}
__name(parsePromiseDef, "parsePromiseDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/set.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}
__name(parseSetDef, "parseSetDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}
__name(parseTupleDef, "parseTupleDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseUndefinedDef(refs) {
  return {
    not: parseAnyDef(refs)
  };
}
__name(parseUndefinedDef, "parseUndefinedDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function parseUnknownDef(refs) {
  return parseAnyDef(refs);
}
__name(parseUnknownDef, "parseUnknownDef");

// node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var parseReadonlyDef = /* @__PURE__ */ __name((def, refs) => {
  return parseDef(def.innerType._def, refs);
}, "parseReadonlyDef");

// node_modules/zod-to-json-schema/dist/esm/selectParser.js
var selectParser = /* @__PURE__ */ __name((def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef(refs);
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef(refs);
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef(refs);
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef(refs);
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
}, "selectParser");

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema, def, refs);
    newItem.jsonSchema = jsonSchema;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
__name(parseDef, "parseDef");
var get$ref = /* @__PURE__ */ __name((item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value3, index2) => refs.currentPath[index2] === value3)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef(refs) : void 0;
    }
  }
}, "get$ref");
var addMeta = /* @__PURE__ */ __name((def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  return jsonSchema;
}, "addMeta");

// node_modules/zod-to-json-schema/dist/esm/parseTypes.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var zodToJsonSchema = /* @__PURE__ */ __name((schema, options) => {
  const refs = getRefs(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name2, schema2]) => ({
    ...acc,
    [name2]: parseDef(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name2]
    }, true) ?? parseAnyDef(refs)
  }), {}) : void 0;
  const name = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
  const main = parseDef(schema._def, name === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name]
  }, false) ?? parseAnyDef(refs);
  const title2 = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title2 !== void 0) {
    main.title = title2;
  }
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) {
      definitions = {};
    }
    if (!definitions[refs.openAiAnyTypeName]) {
      definitions[refs.openAiAnyTypeName] = {
        // Skipping "object" as no properties can be defined and additionalProperties must be "false"
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/")
        }
      };
    }
  }
  const combined = name === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
}, "zodToJsonSchema");

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js
function mapMiniTarget(t) {
  if (!t)
    return "draft-7";
  if (t === "jsonSchema7" || t === "draft-7")
    return "draft-7";
  if (t === "jsonSchema2019-09" || t === "draft-2020-12")
    return "draft-2020-12";
  return "draft-7";
}
__name(mapMiniTarget, "mapMiniTarget");
function toJsonSchemaCompat(schema, opts) {
  if (isZ4Schema(schema)) {
    return toJSONSchema(schema, {
      target: mapMiniTarget(opts?.target),
      io: opts?.pipeStrategy ?? "input"
    });
  }
  return zodToJsonSchema(schema, {
    strictUnions: opts?.strictUnions ?? true,
    pipeStrategy: opts?.pipeStrategy ?? "input"
  });
}
__name(toJsonSchemaCompat, "toJsonSchemaCompat");
function getMethodLiteral(schema) {
  const shape = getObjectShape(schema);
  const methodSchema = shape?.method;
  if (!methodSchema) {
    throw new Error("Schema is missing a method literal");
  }
  const value3 = getLiteralValue(methodSchema);
  if (typeof value3 !== "string") {
    throw new Error("Schema method literal must be a string");
  }
  return value3;
}
__name(getMethodLiteral, "getMethodLiteral");
function parseWithCompat(schema, data) {
  const result = safeParse2(schema, data);
  if (!result.success) {
    throw result.error;
  }
  return result.data;
}
__name(parseWithCompat, "parseWithCompat");

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
var DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;
var Protocol = class {
  static {
    __name(this, "Protocol");
  }
  constructor(_options) {
    this._options = _options;
    this._requestMessageId = 0;
    this._requestHandlers = /* @__PURE__ */ new Map();
    this._requestHandlerAbortControllers = /* @__PURE__ */ new Map();
    this._notificationHandlers = /* @__PURE__ */ new Map();
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers = /* @__PURE__ */ new Map();
    this._timeoutInfo = /* @__PURE__ */ new Map();
    this._pendingDebouncedNotifications = /* @__PURE__ */ new Set();
    this._taskProgressTokens = /* @__PURE__ */ new Map();
    this._requestResolvers = /* @__PURE__ */ new Map();
    this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      this._oncancel(notification);
    });
    this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    });
    this.setRequestHandler(
      PingRequestSchema,
      // Automatic pong by default.
      (_request) => ({})
    );
    this._taskStore = _options?.taskStore;
    this._taskMessageQueue = _options?.taskMessageQueue;
    if (this._taskStore) {
      this.setRequestHandler(GetTaskRequestSchema, async (request2, extra) => {
        const task = await this._taskStore.getTask(request2.params.taskId, extra.sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return {
          ...task
        };
      });
      this.setRequestHandler(GetTaskPayloadRequestSchema, async (request2, extra) => {
        const handleTaskResult = /* @__PURE__ */ __name(async () => {
          const taskId = request2.params.taskId;
          if (this._taskMessageQueue) {
            let queuedMessage;
            while (queuedMessage = await this._taskMessageQueue.dequeue(taskId, extra.sessionId)) {
              if (queuedMessage.type === "response" || queuedMessage.type === "error") {
                const message = queuedMessage.message;
                const requestId = message.id;
                const resolver = this._requestResolvers.get(requestId);
                if (resolver) {
                  this._requestResolvers.delete(requestId);
                  if (queuedMessage.type === "response") {
                    resolver(message);
                  } else {
                    const errorMessage = message;
                    const error50 = new McpError(errorMessage.error.code, errorMessage.error.message, errorMessage.error.data);
                    resolver(error50);
                  }
                } else {
                  const messageType = queuedMessage.type === "response" ? "Response" : "Error";
                  this._onerror(new Error(`${messageType} handler missing for request ${requestId}`));
                }
                continue;
              }
              await this._transport?.send(queuedMessage.message, { relatedRequestId: extra.requestId });
            }
          }
          const task = await this._taskStore.getTask(taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${taskId}`);
          }
          if (!isTerminal(task.status)) {
            await this._waitForTaskUpdate(taskId, extra.signal);
            return await handleTaskResult();
          }
          if (isTerminal(task.status)) {
            const result = await this._taskStore.getTaskResult(taskId, extra.sessionId);
            this._clearTaskQueue(taskId);
            return {
              ...result,
              _meta: {
                ...result._meta,
                [RELATED_TASK_META_KEY]: {
                  taskId
                }
              }
            };
          }
          return await handleTaskResult();
        }, "handleTaskResult");
        return await handleTaskResult();
      });
      this.setRequestHandler(ListTasksRequestSchema, async (request2, extra) => {
        try {
          const { tasks, nextCursor } = await this._taskStore.listTasks(request2.params?.cursor, extra.sessionId);
          return {
            tasks,
            nextCursor,
            _meta: {}
          };
        } catch (error50) {
          throw new McpError(ErrorCode.InvalidParams, `Failed to list tasks: ${error50 instanceof Error ? error50.message : String(error50)}`);
        }
      });
      this.setRequestHandler(CancelTaskRequestSchema, async (request2, extra) => {
        try {
          const task = await this._taskStore.getTask(request2.params.taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${request2.params.taskId}`);
          }
          if (isTerminal(task.status)) {
            throw new McpError(ErrorCode.InvalidParams, `Cannot cancel task in terminal status: ${task.status}`);
          }
          await this._taskStore.updateTaskStatus(request2.params.taskId, "cancelled", "Client cancelled task execution.", extra.sessionId);
          this._clearTaskQueue(request2.params.taskId);
          const cancelledTask = await this._taskStore.getTask(request2.params.taskId, extra.sessionId);
          if (!cancelledTask) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found after cancellation: ${request2.params.taskId}`);
          }
          return {
            _meta: {},
            ...cancelledTask
          };
        } catch (error50) {
          if (error50 instanceof McpError) {
            throw error50;
          }
          throw new McpError(ErrorCode.InvalidRequest, `Failed to cancel task: ${error50 instanceof Error ? error50.message : String(error50)}`);
        }
      });
    }
  }
  async _oncancel(notification) {
    if (!notification.params.requestId) {
      return;
    }
    const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
    controller?.abort(notification.params.reason);
  }
  _setupTimeout(messageId, timeout6, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout6),
      startTime: Date.now(),
      timeout: timeout6,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    const info3 = this._timeoutInfo.get(messageId);
    if (!info3)
      return false;
    const totalElapsed = Date.now() - info3.startTime;
    if (info3.maxTotalTimeout && totalElapsed >= info3.maxTotalTimeout) {
      this._timeoutInfo.delete(messageId);
      throw McpError.fromError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
        maxTotalTimeout: info3.maxTotalTimeout,
        totalElapsed
      });
    }
    clearTimeout(info3.timeoutId);
    info3.timeoutId = setTimeout(info3.onTimeout, info3.timeout);
    return true;
  }
  _cleanupTimeout(messageId) {
    const info3 = this._timeoutInfo.get(messageId);
    if (info3) {
      clearTimeout(info3.timeoutId);
      this._timeoutInfo.delete(messageId);
    }
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(transport) {
    if (this._transport) {
      throw new Error("Already connected to a transport. Call close() before connecting to a new transport, or use a separate Protocol instance per connection.");
    }
    this._transport = transport;
    const _onclose = this.transport?.onclose;
    this._transport.onclose = () => {
      _onclose?.();
      this._onclose();
    };
    const _onerror = this.transport?.onerror;
    this._transport.onerror = (error50) => {
      _onerror?.(error50);
      this._onerror(error50);
    };
    const _onmessage = this._transport?.onmessage;
    this._transport.onmessage = (message, extra) => {
      _onmessage?.(message, extra);
      if (isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message)) {
        this._onresponse(message);
      } else if (isJSONRPCRequest(message)) {
        this._onrequest(message, extra);
      } else if (isJSONRPCNotification(message)) {
        this._onnotification(message);
      } else {
        this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
      }
    };
    await this._transport.start();
  }
  _onclose() {
    const responseHandlers = this._responseHandlers;
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers.clear();
    this._taskProgressTokens.clear();
    this._pendingDebouncedNotifications.clear();
    for (const controller of this._requestHandlerAbortControllers.values()) {
      controller.abort();
    }
    this._requestHandlerAbortControllers.clear();
    const error50 = McpError.fromError(ErrorCode.ConnectionClosed, "Connection closed");
    this._transport = void 0;
    this.onclose?.();
    for (const handler of responseHandlers.values()) {
      handler(error50);
    }
  }
  _onerror(error50) {
    this.onerror?.(error50);
  }
  _onnotification(notification) {
    const handler = this._notificationHandlers.get(notification.method) ?? this.fallbackNotificationHandler;
    if (handler === void 0) {
      return;
    }
    Promise.resolve().then(() => handler(notification)).catch((error50) => this._onerror(new Error(`Uncaught error in notification handler: ${error50}`)));
  }
  _onrequest(request2, extra) {
    const handler = this._requestHandlers.get(request2.method) ?? this.fallbackRequestHandler;
    const capturedTransport = this._transport;
    const relatedTaskId = request2.params?._meta?.[RELATED_TASK_META_KEY]?.taskId;
    if (handler === void 0) {
      const errorResponse2 = {
        jsonrpc: "2.0",
        id: request2.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse2,
          timestamp: Date.now()
        }, capturedTransport?.sessionId).catch((error50) => this._onerror(new Error(`Failed to enqueue error response: ${error50}`)));
      } else {
        capturedTransport?.send(errorResponse2).catch((error50) => this._onerror(new Error(`Failed to send an error response: ${error50}`)));
      }
      return;
    }
    const abortController = new AbortController();
    this._requestHandlerAbortControllers.set(request2.id, abortController);
    const taskCreationParams = isTaskAugmentedRequestParams(request2.params) ? request2.params.task : void 0;
    const taskStore = this._taskStore ? this.requestTaskStore(request2, capturedTransport?.sessionId) : void 0;
    const fullExtra = {
      signal: abortController.signal,
      sessionId: capturedTransport?.sessionId,
      _meta: request2.params?._meta,
      sendNotification: /* @__PURE__ */ __name(async (notification) => {
        if (abortController.signal.aborted)
          return;
        const notificationOptions = { relatedRequestId: request2.id };
        if (relatedTaskId) {
          notificationOptions.relatedTask = { taskId: relatedTaskId };
        }
        await this.notification(notification, notificationOptions);
      }, "sendNotification"),
      sendRequest: /* @__PURE__ */ __name(async (r, resultSchema, options) => {
        if (abortController.signal.aborted) {
          throw new McpError(ErrorCode.ConnectionClosed, "Request was cancelled");
        }
        const requestOptions = { ...options, relatedRequestId: request2.id };
        if (relatedTaskId && !requestOptions.relatedTask) {
          requestOptions.relatedTask = { taskId: relatedTaskId };
        }
        const effectiveTaskId = requestOptions.relatedTask?.taskId ?? relatedTaskId;
        if (effectiveTaskId && taskStore) {
          await taskStore.updateTaskStatus(effectiveTaskId, "input_required");
        }
        return await this.request(r, resultSchema, requestOptions);
      }, "sendRequest"),
      authInfo: extra?.authInfo,
      requestId: request2.id,
      requestInfo: extra?.requestInfo,
      taskId: relatedTaskId,
      taskStore,
      taskRequestedTtl: taskCreationParams?.ttl,
      closeSSEStream: extra?.closeSSEStream,
      closeStandaloneSSEStream: extra?.closeStandaloneSSEStream
    };
    Promise.resolve().then(() => {
      if (taskCreationParams) {
        this.assertTaskHandlerCapability(request2.method);
      }
    }).then(() => handler(request2, fullExtra)).then(async (result) => {
      if (abortController.signal.aborted) {
        return;
      }
      const response = {
        result,
        jsonrpc: "2.0",
        id: request2.id
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "response",
          message: response,
          timestamp: Date.now()
        }, capturedTransport?.sessionId);
      } else {
        await capturedTransport?.send(response);
      }
    }, async (error50) => {
      if (abortController.signal.aborted) {
        return;
      }
      const errorResponse2 = {
        jsonrpc: "2.0",
        id: request2.id,
        error: {
          code: Number.isSafeInteger(error50["code"]) ? error50["code"] : ErrorCode.InternalError,
          message: error50.message ?? "Internal error",
          ...error50["data"] !== void 0 && { data: error50["data"] }
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse2,
          timestamp: Date.now()
        }, capturedTransport?.sessionId);
      } else {
        await capturedTransport?.send(errorResponse2);
      }
    }).catch((error50) => this._onerror(new Error(`Failed to send response: ${error50}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request2.id);
    });
  }
  _onprogress(notification) {
    const { progressToken, ...params } = notification.params;
    const messageId = Number(progressToken);
    const handler = this._progressHandlers.get(messageId);
    if (!handler) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    const responseHandler = this._responseHandlers.get(messageId);
    const timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
      try {
        this._resetTimeout(messageId);
      } catch (error50) {
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        responseHandler(error50);
        return;
      }
    }
    handler(params);
  }
  _onresponse(response) {
    const messageId = Number(response.id);
    const resolver = this._requestResolvers.get(messageId);
    if (resolver) {
      this._requestResolvers.delete(messageId);
      if (isJSONRPCResultResponse(response)) {
        resolver(response);
      } else {
        const error50 = new McpError(response.error.code, response.error.message, response.error.data);
        resolver(error50);
      }
      return;
    }
    const handler = this._responseHandlers.get(messageId);
    if (handler === void 0) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId);
    this._cleanupTimeout(messageId);
    let isTaskResponse = false;
    if (isJSONRPCResultResponse(response) && response.result && typeof response.result === "object") {
      const result = response.result;
      if (result.task && typeof result.task === "object") {
        const task = result.task;
        if (typeof task.taskId === "string") {
          isTaskResponse = true;
          this._taskProgressTokens.set(task.taskId, messageId);
        }
      }
    }
    if (!isTaskResponse) {
      this._progressHandlers.delete(messageId);
    }
    if (isJSONRPCResultResponse(response)) {
      handler(response);
    } else {
      const error50 = McpError.fromError(response.error.code, response.error.message, response.error.data);
      handler(error50);
    }
  }
  get transport() {
    return this._transport;
  }
  /**
   * Closes the connection.
   */
  async close() {
    await this._transport?.close();
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * @example
   * ```typescript
   * const stream = protocol.requestStream(request, resultSchema, options);
   * for await (const message of stream) {
   *   switch (message.type) {
   *     case 'taskCreated':
   *       console.log('Task created:', message.task.taskId);
   *       break;
   *     case 'taskStatus':
   *       console.log('Task status:', message.task.status);
   *       break;
   *     case 'result':
   *       console.log('Final result:', message.result);
   *       break;
   *     case 'error':
   *       console.error('Error:', message.error);
   *       break;
   *   }
   * }
   * ```
   *
   * @experimental Use `client.experimental.tasks.requestStream()` to access this method.
   */
  async *requestStream(request2, resultSchema, options) {
    const { task } = options ?? {};
    if (!task) {
      try {
        const result = await this.request(request2, resultSchema, options);
        yield { type: "result", result };
      } catch (error50) {
        yield {
          type: "error",
          error: error50 instanceof McpError ? error50 : new McpError(ErrorCode.InternalError, String(error50))
        };
      }
      return;
    }
    let taskId;
    try {
      const createResult = await this.request(request2, CreateTaskResultSchema, options);
      if (createResult.task) {
        taskId = createResult.task.taskId;
        yield { type: "taskCreated", task: createResult.task };
      } else {
        throw new McpError(ErrorCode.InternalError, "Task creation did not return a task");
      }
      while (true) {
        const task2 = await this.getTask({ taskId }, options);
        yield { type: "taskStatus", task: task2 };
        if (isTerminal(task2.status)) {
          if (task2.status === "completed") {
            const result = await this.getTaskResult({ taskId }, resultSchema, options);
            yield { type: "result", result };
          } else if (task2.status === "failed") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} failed`)
            };
          } else if (task2.status === "cancelled") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} was cancelled`)
            };
          }
          return;
        }
        if (task2.status === "input_required") {
          const result = await this.getTaskResult({ taskId }, resultSchema, options);
          yield { type: "result", result };
          return;
        }
        const pollInterval = task2.pollInterval ?? this._options?.defaultTaskPollInterval ?? 1e3;
        await new Promise((resolve) => setTimeout(resolve, pollInterval));
        options?.signal?.throwIfAborted();
      }
    } catch (error50) {
      yield {
        type: "error",
        error: error50 instanceof McpError ? error50 : new McpError(ErrorCode.InternalError, String(error50))
      };
    }
  }
  /**
   * Sends a request and waits for a response.
   *
   * Do not use this method to emit notifications! Use notification() instead.
   */
  request(request2, resultSchema, options) {
    const { relatedRequestId, resumptionToken, onresumptiontoken, task, relatedTask } = options ?? {};
    return new Promise((resolve, reject) => {
      const earlyReject = /* @__PURE__ */ __name((error50) => {
        reject(error50);
      }, "earlyReject");
      if (!this._transport) {
        earlyReject(new Error("Not connected"));
        return;
      }
      if (this._options?.enforceStrictCapabilities === true) {
        try {
          this.assertCapabilityForMethod(request2.method);
          if (task) {
            this.assertTaskCapability(request2.method);
          }
        } catch (e) {
          earlyReject(e);
          return;
        }
      }
      options?.signal?.throwIfAborted();
      const messageId = this._requestMessageId++;
      const jsonrpcRequest = {
        ...request2,
        jsonrpc: "2.0",
        id: messageId
      };
      if (options?.onprogress) {
        this._progressHandlers.set(messageId, options.onprogress);
        jsonrpcRequest.params = {
          ...request2.params,
          _meta: {
            ...request2.params?._meta || {},
            progressToken: messageId
          }
        };
      }
      if (task) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          task
        };
      }
      if (relatedTask) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          _meta: {
            ...jsonrpcRequest.params?._meta || {},
            [RELATED_TASK_META_KEY]: relatedTask
          }
        };
      }
      const cancel = /* @__PURE__ */ __name((reason) => {
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        this._transport?.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error51) => this._onerror(new Error(`Failed to send cancellation: ${error51}`)));
        const error50 = reason instanceof McpError ? reason : new McpError(ErrorCode.RequestTimeout, String(reason));
        reject(error50);
      }, "cancel");
      this._responseHandlers.set(messageId, (response) => {
        if (options?.signal?.aborted) {
          return;
        }
        if (response instanceof Error) {
          return reject(response);
        }
        try {
          const parseResult = safeParse2(resultSchema, response.result);
          if (!parseResult.success) {
            reject(parseResult.error);
          } else {
            resolve(parseResult.data);
          }
        } catch (error50) {
          reject(error50);
        }
      });
      options?.signal?.addEventListener("abort", () => {
        cancel(options?.signal?.reason);
      });
      const timeout6 = options?.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;
      const timeoutHandler = /* @__PURE__ */ __name(() => cancel(McpError.fromError(ErrorCode.RequestTimeout, "Request timed out", { timeout: timeout6 })), "timeoutHandler");
      this._setupTimeout(messageId, timeout6, options?.maxTotalTimeout, timeoutHandler, options?.resetTimeoutOnProgress ?? false);
      const relatedTaskId = relatedTask?.taskId;
      if (relatedTaskId) {
        const responseResolver = /* @__PURE__ */ __name((response) => {
          const handler = this._responseHandlers.get(messageId);
          if (handler) {
            handler(response);
          } else {
            this._onerror(new Error(`Response handler missing for side-channeled request ${messageId}`));
          }
        }, "responseResolver");
        this._requestResolvers.set(messageId, responseResolver);
        this._enqueueTaskMessage(relatedTaskId, {
          type: "request",
          message: jsonrpcRequest,
          timestamp: Date.now()
        }).catch((error50) => {
          this._cleanupTimeout(messageId);
          reject(error50);
        });
      } else {
        this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error50) => {
          this._cleanupTimeout(messageId);
          reject(error50);
        });
      }
    });
  }
  /**
   * Gets the current status of a task.
   *
   * @experimental Use `client.experimental.tasks.getTask()` to access this method.
   */
  async getTask(params, options) {
    return this.request({ method: "tasks/get", params }, GetTaskResultSchema, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @experimental Use `client.experimental.tasks.getTaskResult()` to access this method.
   */
  async getTaskResult(params, resultSchema, options) {
    return this.request({ method: "tasks/result", params }, resultSchema, options);
  }
  /**
   * Lists tasks, optionally starting from a pagination cursor.
   *
   * @experimental Use `client.experimental.tasks.listTasks()` to access this method.
   */
  async listTasks(params, options) {
    return this.request({ method: "tasks/list", params }, ListTasksResultSchema, options);
  }
  /**
   * Cancels a specific task.
   *
   * @experimental Use `client.experimental.tasks.cancelTask()` to access this method.
   */
  async cancelTask(params, options) {
    return this.request({ method: "tasks/cancel", params }, CancelTaskResultSchema, options);
  }
  /**
   * Emits a notification, which is a one-way message that does not expect a response.
   */
  async notification(notification, options) {
    if (!this._transport) {
      throw new Error("Not connected");
    }
    this.assertNotificationCapability(notification.method);
    const relatedTaskId = options?.relatedTask?.taskId;
    if (relatedTaskId) {
      const jsonrpcNotification2 = {
        ...notification,
        jsonrpc: "2.0",
        params: {
          ...notification.params,
          _meta: {
            ...notification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
      await this._enqueueTaskMessage(relatedTaskId, {
        type: "notification",
        message: jsonrpcNotification2,
        timestamp: Date.now()
      });
      return;
    }
    const debouncedMethods = this._options?.debouncedNotificationMethods ?? [];
    const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !options?.relatedRequestId && !options?.relatedTask;
    if (canDebounce) {
      if (this._pendingDebouncedNotifications.has(notification.method)) {
        return;
      }
      this._pendingDebouncedNotifications.add(notification.method);
      Promise.resolve().then(() => {
        this._pendingDebouncedNotifications.delete(notification.method);
        if (!this._transport) {
          return;
        }
        let jsonrpcNotification2 = {
          ...notification,
          jsonrpc: "2.0"
        };
        if (options?.relatedTask) {
          jsonrpcNotification2 = {
            ...jsonrpcNotification2,
            params: {
              ...jsonrpcNotification2.params,
              _meta: {
                ...jsonrpcNotification2.params?._meta || {},
                [RELATED_TASK_META_KEY]: options.relatedTask
              }
            }
          };
        }
        this._transport?.send(jsonrpcNotification2, options).catch((error50) => this._onerror(error50));
      });
      return;
    }
    let jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    if (options?.relatedTask) {
      jsonrpcNotification = {
        ...jsonrpcNotification,
        params: {
          ...jsonrpcNotification.params,
          _meta: {
            ...jsonrpcNotification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
    }
    await this._transport.send(jsonrpcNotification, options);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a request with the given method.
   *
   * Note that this will replace any previous request handler for the same method.
   */
  setRequestHandler(requestSchema, handler) {
    const method = getMethodLiteral(requestSchema);
    this.assertRequestHandlerCapability(method);
    this._requestHandlers.set(method, (request2, extra) => {
      const parsed = parseWithCompat(requestSchema, request2);
      return Promise.resolve(handler(parsed, extra));
    });
  }
  /**
   * Removes the request handler for the given method.
   */
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  /**
   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
   */
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method)) {
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
    }
  }
  /**
   * Registers a handler to invoke when this protocol object receives a notification with the given method.
   *
   * Note that this will replace any previous notification handler for the same method.
   */
  setNotificationHandler(notificationSchema, handler) {
    const method = getMethodLiteral(notificationSchema);
    this._notificationHandlers.set(method, (notification) => {
      const parsed = parseWithCompat(notificationSchema, notification);
      return Promise.resolve(handler(parsed));
    });
  }
  /**
   * Removes the notification handler for the given method.
   */
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
  /**
   * Cleans up the progress handler associated with a task.
   * This should be called when a task reaches a terminal status.
   */
  _cleanupTaskProgressHandler(taskId) {
    const progressToken = this._taskProgressTokens.get(taskId);
    if (progressToken !== void 0) {
      this._progressHandlers.delete(progressToken);
      this._taskProgressTokens.delete(taskId);
    }
  }
  /**
   * Enqueues a task-related message for side-channel delivery via tasks/result.
   * @param taskId The task ID to associate the message with
   * @param message The message to enqueue
   * @param sessionId Optional session ID for binding the operation to a specific session
   * @throws Error if taskStore is not configured or if enqueue fails (e.g., queue overflow)
   *
   * Note: If enqueue fails, it's the TaskMessageQueue implementation's responsibility to handle
   * the error appropriately (e.g., by failing the task, logging, etc.). The Protocol layer
   * simply propagates the error.
   */
  async _enqueueTaskMessage(taskId, message, sessionId) {
    if (!this._taskStore || !this._taskMessageQueue) {
      throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
    }
    const maxQueueSize = this._options?.maxTaskQueueSize;
    await this._taskMessageQueue.enqueue(taskId, message, sessionId, maxQueueSize);
  }
  /**
   * Clears the message queue for a task and rejects any pending request resolvers.
   * @param taskId The task ID whose queue should be cleared
   * @param sessionId Optional session ID for binding the operation to a specific session
   */
  async _clearTaskQueue(taskId, sessionId) {
    if (this._taskMessageQueue) {
      const messages = await this._taskMessageQueue.dequeueAll(taskId, sessionId);
      for (const message of messages) {
        if (message.type === "request" && isJSONRPCRequest(message.message)) {
          const requestId = message.message.id;
          const resolver = this._requestResolvers.get(requestId);
          if (resolver) {
            resolver(new McpError(ErrorCode.InternalError, "Task cancelled or completed"));
            this._requestResolvers.delete(requestId);
          } else {
            this._onerror(new Error(`Resolver missing for request ${requestId} during task ${taskId} cleanup`));
          }
        }
      }
    }
  }
  /**
   * Waits for a task update (new messages or status change) with abort signal support.
   * Uses polling to check for updates at the task's configured poll interval.
   * @param taskId The task ID to wait for
   * @param signal Abort signal to cancel the wait
   * @returns Promise that resolves when an update occurs or rejects if aborted
   */
  async _waitForTaskUpdate(taskId, signal) {
    let interval = this._options?.defaultTaskPollInterval ?? 1e3;
    try {
      const task = await this._taskStore?.getTask(taskId);
      if (task?.pollInterval) {
        interval = task.pollInterval;
      }
    } catch {
    }
    return new Promise((resolve, reject) => {
      if (signal.aborted) {
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
        return;
      }
      const timeoutId = setTimeout(resolve, interval);
      signal.addEventListener("abort", () => {
        clearTimeout(timeoutId);
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
      }, { once: true });
    });
  }
  requestTaskStore(request2, sessionId) {
    const taskStore = this._taskStore;
    if (!taskStore) {
      throw new Error("No task store configured");
    }
    return {
      createTask: /* @__PURE__ */ __name(async (taskParams) => {
        if (!request2) {
          throw new Error("No request provided");
        }
        return await taskStore.createTask(taskParams, request2.id, {
          method: request2.method,
          params: request2.params
        }, sessionId);
      }, "createTask"),
      getTask: /* @__PURE__ */ __name(async (taskId) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return task;
      }, "getTask"),
      storeTaskResult: /* @__PURE__ */ __name(async (taskId, status2, result) => {
        await taskStore.storeTaskResult(taskId, status2, result, sessionId);
        const task = await taskStore.getTask(taskId, sessionId);
        if (task) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: task
          });
          await this.notification(notification);
          if (isTerminal(task.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      }, "storeTaskResult"),
      getTaskResult: /* @__PURE__ */ __name((taskId) => {
        return taskStore.getTaskResult(taskId, sessionId);
      }, "getTaskResult"),
      updateTaskStatus: /* @__PURE__ */ __name(async (taskId, status2, statusMessage) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, `Task "${taskId}" not found - it may have been cleaned up`);
        }
        if (isTerminal(task.status)) {
          throw new McpError(ErrorCode.InvalidParams, `Cannot update task "${taskId}" from terminal status "${task.status}" to "${status2}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
        }
        await taskStore.updateTaskStatus(taskId, status2, statusMessage, sessionId);
        const updatedTask = await taskStore.getTask(taskId, sessionId);
        if (updatedTask) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: updatedTask
          });
          await this.notification(notification);
          if (isTerminal(updatedTask.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      }, "updateTaskStatus"),
      listTasks: /* @__PURE__ */ __name((cursor) => {
        return taskStore.listTasks(cursor, sessionId);
      }, "listTasks")
    };
  }
};
function isPlainObject2(value3) {
  return value3 !== null && typeof value3 === "object" && !Array.isArray(value3);
}
__name(isPlainObject2, "isPlainObject");
function mergeCapabilities(base, additional) {
  const result = { ...base };
  for (const key in additional) {
    const k = key;
    const addValue = additional[k];
    if (addValue === void 0)
      continue;
    const baseValue = result[k];
    if (isPlainObject2(baseValue) && isPlainObject2(addValue)) {
      result[k] = { ...baseValue, ...addValue };
    } else {
      result[k] = addValue;
    }
  }
  return result;
}
__name(mergeCapabilities, "mergeCapabilities");

// node_modules/@modelcontextprotocol/sdk/dist/esm/validation/ajv-provider.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_ajv = __toESM(require_ajv(), 1);
var import_ajv_formats = __toESM(require_dist(), 1);
function createDefaultAjvInstance() {
  const ajv = new import_ajv.default({
    strict: false,
    validateFormats: true,
    validateSchema: false,
    allErrors: true
  });
  const addFormats = import_ajv_formats.default;
  addFormats(ajv);
  return ajv;
}
__name(createDefaultAjvInstance, "createDefaultAjvInstance");
var AjvJsonSchemaValidator = class {
  static {
    __name(this, "AjvJsonSchemaValidator");
  }
  /**
   * Create an AJV validator
   *
   * @param ajv - Optional pre-configured AJV instance. If not provided, a default instance will be created.
   *
   * @example
   * ```typescript
   * // Use default configuration (recommended for most cases)
   * import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';
   * const validator = new AjvJsonSchemaValidator();
   *
   * // Or provide custom AJV instance for advanced configuration
   * import { Ajv } from 'ajv';
   * import addFormats from 'ajv-formats';
   *
   * const ajv = new Ajv({ validateFormats: true });
   * addFormats(ajv);
   * const validator = new AjvJsonSchemaValidator(ajv);
   * ```
   */
  constructor(ajv) {
    this._ajv = ajv ?? createDefaultAjvInstance();
  }
  /**
   * Create a validator for the given JSON Schema
   *
   * The validator is compiled once and can be reused multiple times.
   * If the schema has an $id, it will be cached by AJV automatically.
   *
   * @param schema - Standard JSON Schema object
   * @returns A validator function that validates input data
   */
  getValidator(schema) {
    const ajvValidator = "$id" in schema && typeof schema.$id === "string" ? this._ajv.getSchema(schema.$id) ?? this._ajv.compile(schema) : this._ajv.compile(schema);
    return (input) => {
      const valid = ajvValidator(input);
      if (valid) {
        return {
          valid: true,
          data: input,
          errorMessage: void 0
        };
      } else {
        return {
          valid: false,
          data: void 0,
          errorMessage: this._ajv.errorsText(ajvValidator.errors)
        };
      }
    };
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/server.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ExperimentalServerTasks = class {
  static {
    __name(this, "ExperimentalServerTasks");
  }
  constructor(_server) {
    this._server = _server;
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * This method provides streaming access to request processing, allowing you to
   * observe intermediate task status updates for task-augmented requests.
   *
   * @param request - The request to send
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options (timeout, signal, task creation params, etc.)
   * @returns AsyncGenerator that yields ResponseMessage objects
   *
   * @experimental
   */
  requestStream(request2, resultSchema, options) {
    return this._server.requestStream(request2, resultSchema, options);
  }
  /**
   * Gets the current status of a task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   * @returns The task status
   *
   * @experimental
   */
  async getTask(taskId, options) {
    return this._server.getTask({ taskId }, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @param taskId - The task identifier
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options
   * @returns The task result
   *
   * @experimental
   */
  async getTaskResult(taskId, resultSchema, options) {
    return this._server.getTaskResult({ taskId }, resultSchema, options);
  }
  /**
   * Lists tasks with optional pagination.
   *
   * @param cursor - Optional pagination cursor
   * @param options - Optional request options
   * @returns List of tasks with optional next cursor
   *
   * @experimental
   */
  async listTasks(cursor, options) {
    return this._server.listTasks(cursor ? { cursor } : void 0, options);
  }
  /**
   * Cancels a running task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   *
   * @experimental
   */
  async cancelTask(taskId, options) {
    return this._server.cancelTask({ taskId }, options);
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/helpers.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function assertToolsCallTaskCapability(requests, method, entityName) {
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "tools/call":
      if (!requests.tools?.call) {
        throw new Error(`${entityName} does not support task creation for tools/call (required for ${method})`);
      }
      break;
    default:
      break;
  }
}
__name(assertToolsCallTaskCapability, "assertToolsCallTaskCapability");
function assertClientRequestTaskCapability(requests, method, entityName) {
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "sampling/createMessage":
      if (!requests.sampling?.createMessage) {
        throw new Error(`${entityName} does not support task creation for sampling/createMessage (required for ${method})`);
      }
      break;
    case "elicitation/create":
      if (!requests.elicitation?.create) {
        throw new Error(`${entityName} does not support task creation for elicitation/create (required for ${method})`);
      }
      break;
    default:
      break;
  }
}
__name(assertClientRequestTaskCapability, "assertClientRequestTaskCapability");

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js
var Server = class extends Protocol {
  static {
    __name(this, "Server");
  }
  /**
   * Initializes this server with the given name and version information.
   */
  constructor(_serverInfo, options) {
    super(options);
    this._serverInfo = _serverInfo;
    this._loggingLevels = /* @__PURE__ */ new Map();
    this.LOG_LEVEL_SEVERITY = new Map(LoggingLevelSchema.options.map((level, index2) => [level, index2]));
    this.isMessageIgnored = (level, sessionId) => {
      const currentLevel = this._loggingLevels.get(sessionId);
      return currentLevel ? this.LOG_LEVEL_SEVERITY.get(level) < this.LOG_LEVEL_SEVERITY.get(currentLevel) : false;
    };
    this._capabilities = options?.capabilities ?? {};
    this._instructions = options?.instructions;
    this._jsonSchemaValidator = options?.jsonSchemaValidator ?? new AjvJsonSchemaValidator();
    this.setRequestHandler(InitializeRequestSchema, (request2) => this._oninitialize(request2));
    this.setNotificationHandler(InitializedNotificationSchema, () => this.oninitialized?.());
    if (this._capabilities.logging) {
      this.setRequestHandler(SetLevelRequestSchema, async (request2, extra) => {
        const transportSessionId = extra.sessionId || extra.requestInfo?.headers["mcp-session-id"] || void 0;
        const { level } = request2.params;
        const parseResult = LoggingLevelSchema.safeParse(level);
        if (parseResult.success) {
          this._loggingLevels.set(transportSessionId, parseResult.data);
        }
        return {};
      });
    }
  }
  /**
   * Access experimental features.
   *
   * WARNING: These APIs are experimental and may change without notice.
   *
   * @experimental
   */
  get experimental() {
    if (!this._experimental) {
      this._experimental = {
        tasks: new ExperimentalServerTasks(this)
      };
    }
    return this._experimental;
  }
  /**
   * Registers new capabilities. This can only be called before connecting to a transport.
   *
   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
   */
  registerCapabilities(capabilities) {
    if (this.transport) {
      throw new Error("Cannot register capabilities after connecting to transport");
    }
    this._capabilities = mergeCapabilities(this._capabilities, capabilities);
  }
  /**
   * Override request handler registration to enforce server-side validation for tools/call.
   */
  setRequestHandler(requestSchema, handler) {
    const shape = getObjectShape(requestSchema);
    const methodSchema = shape?.method;
    if (!methodSchema) {
      throw new Error("Schema is missing a method literal");
    }
    let methodValue;
    if (isZ4Schema(methodSchema)) {
      const v4Schema = methodSchema;
      const v4Def = v4Schema._zod?.def;
      methodValue = v4Def?.value ?? v4Schema.value;
    } else {
      const v3Schema = methodSchema;
      const legacyDef = v3Schema._def;
      methodValue = legacyDef?.value ?? v3Schema.value;
    }
    if (typeof methodValue !== "string") {
      throw new Error("Schema method literal must be a string");
    }
    const method = methodValue;
    if (method === "tools/call") {
      const wrappedHandler = /* @__PURE__ */ __name(async (request2, extra) => {
        const validatedRequest = safeParse2(CallToolRequestSchema, request2);
        if (!validatedRequest.success) {
          const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid tools/call request: ${errorMessage}`);
        }
        const { params } = validatedRequest.data;
        const result = await Promise.resolve(handler(request2, extra));
        if (params.task) {
          const taskValidationResult = safeParse2(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        const validationResult = safeParse2(CallToolResultSchema, result);
        if (!validationResult.success) {
          const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid tools/call result: ${errorMessage}`);
        }
        return validationResult.data;
      }, "wrappedHandler");
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    return super.setRequestHandler(requestSchema, handler);
  }
  assertCapabilityForMethod(method) {
    switch (method) {
      case "sampling/createMessage":
        if (!this._clientCapabilities?.sampling) {
          throw new Error(`Client does not support sampling (required for ${method})`);
        }
        break;
      case "elicitation/create":
        if (!this._clientCapabilities?.elicitation) {
          throw new Error(`Client does not support elicitation (required for ${method})`);
        }
        break;
      case "roots/list":
        if (!this._clientCapabilities?.roots) {
          throw new Error(`Client does not support listing roots (required for ${method})`);
        }
        break;
      case "ping":
        break;
    }
  }
  assertNotificationCapability(method) {
    switch (method) {
      case "notifications/message":
        if (!this._capabilities.logging) {
          throw new Error(`Server does not support logging (required for ${method})`);
        }
        break;
      case "notifications/resources/updated":
      case "notifications/resources/list_changed":
        if (!this._capabilities.resources) {
          throw new Error(`Server does not support notifying about resources (required for ${method})`);
        }
        break;
      case "notifications/tools/list_changed":
        if (!this._capabilities.tools) {
          throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);
        }
        break;
      case "notifications/prompts/list_changed":
        if (!this._capabilities.prompts) {
          throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);
        }
        break;
      case "notifications/elicitation/complete":
        if (!this._clientCapabilities?.elicitation?.url) {
          throw new Error(`Client does not support URL elicitation (required for ${method})`);
        }
        break;
      case "notifications/cancelled":
        break;
      case "notifications/progress":
        break;
    }
  }
  assertRequestHandlerCapability(method) {
    if (!this._capabilities) {
      return;
    }
    switch (method) {
      case "completion/complete":
        if (!this._capabilities.completions) {
          throw new Error(`Server does not support completions (required for ${method})`);
        }
        break;
      case "logging/setLevel":
        if (!this._capabilities.logging) {
          throw new Error(`Server does not support logging (required for ${method})`);
        }
        break;
      case "prompts/get":
      case "prompts/list":
        if (!this._capabilities.prompts) {
          throw new Error(`Server does not support prompts (required for ${method})`);
        }
        break;
      case "resources/list":
      case "resources/templates/list":
      case "resources/read":
        if (!this._capabilities.resources) {
          throw new Error(`Server does not support resources (required for ${method})`);
        }
        break;
      case "tools/call":
      case "tools/list":
        if (!this._capabilities.tools) {
          throw new Error(`Server does not support tools (required for ${method})`);
        }
        break;
      case "tasks/get":
      case "tasks/list":
      case "tasks/result":
      case "tasks/cancel":
        if (!this._capabilities.tasks) {
          throw new Error(`Server does not support tasks capability (required for ${method})`);
        }
        break;
      case "ping":
      case "initialize":
        break;
    }
  }
  assertTaskCapability(method) {
    assertClientRequestTaskCapability(this._clientCapabilities?.tasks?.requests, method, "Client");
  }
  assertTaskHandlerCapability(method) {
    if (!this._capabilities) {
      return;
    }
    assertToolsCallTaskCapability(this._capabilities.tasks?.requests, method, "Server");
  }
  async _oninitialize(request2) {
    const requestedVersion = request2.params.protocolVersion;
    this._clientCapabilities = request2.params.capabilities;
    this._clientVersion = request2.params.clientInfo;
    const protocolVersion = SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION;
    return {
      protocolVersion,
      capabilities: this.getCapabilities(),
      serverInfo: this._serverInfo,
      ...this._instructions && { instructions: this._instructions }
    };
  }
  /**
   * After initialization has completed, this will be populated with the client's reported capabilities.
   */
  getClientCapabilities() {
    return this._clientCapabilities;
  }
  /**
   * After initialization has completed, this will be populated with information about the client's name and version.
   */
  getClientVersion() {
    return this._clientVersion;
  }
  getCapabilities() {
    return this._capabilities;
  }
  async ping() {
    return this.request({ method: "ping" }, EmptyResultSchema);
  }
  // Implementation
  async createMessage(params, options) {
    if (params.tools || params.toolChoice) {
      if (!this._clientCapabilities?.sampling?.tools) {
        throw new Error("Client does not support sampling tools capability.");
      }
    }
    if (params.messages.length > 0) {
      const lastMessage = params.messages[params.messages.length - 1];
      const lastContent = Array.isArray(lastMessage.content) ? lastMessage.content : [lastMessage.content];
      const hasToolResults = lastContent.some((c) => c.type === "tool_result");
      const previousMessage = params.messages.length > 1 ? params.messages[params.messages.length - 2] : void 0;
      const previousContent = previousMessage ? Array.isArray(previousMessage.content) ? previousMessage.content : [previousMessage.content] : [];
      const hasPreviousToolUse = previousContent.some((c) => c.type === "tool_use");
      if (hasToolResults) {
        if (lastContent.some((c) => c.type !== "tool_result")) {
          throw new Error("The last message must contain only tool_result content if any is present");
        }
        if (!hasPreviousToolUse) {
          throw new Error("tool_result blocks are not matching any tool_use from the previous message");
        }
      }
      if (hasPreviousToolUse) {
        const toolUseIds = new Set(previousContent.filter((c) => c.type === "tool_use").map((c) => c.id));
        const toolResultIds = new Set(lastContent.filter((c) => c.type === "tool_result").map((c) => c.toolUseId));
        if (toolUseIds.size !== toolResultIds.size || ![...toolUseIds].every((id2) => toolResultIds.has(id2))) {
          throw new Error("ids of tool_result blocks and tool_use blocks from previous message do not match");
        }
      }
    }
    if (params.tools) {
      return this.request({ method: "sampling/createMessage", params }, CreateMessageResultWithToolsSchema, options);
    }
    return this.request({ method: "sampling/createMessage", params }, CreateMessageResultSchema, options);
  }
  /**
   * Creates an elicitation request for the given parameters.
   * For backwards compatibility, `mode` may be omitted for form requests and will default to `'form'`.
   * @param params The parameters for the elicitation request.
   * @param options Optional request options.
   * @returns The result of the elicitation request.
   */
  async elicitInput(params, options) {
    const mode = params.mode ?? "form";
    switch (mode) {
      case "url": {
        if (!this._clientCapabilities?.elicitation?.url) {
          throw new Error("Client does not support url elicitation.");
        }
        const urlParams = params;
        return this.request({ method: "elicitation/create", params: urlParams }, ElicitResultSchema, options);
      }
      case "form": {
        if (!this._clientCapabilities?.elicitation?.form) {
          throw new Error("Client does not support form elicitation.");
        }
        const formParams = params.mode === "form" ? params : { ...params, mode: "form" };
        const result = await this.request({ method: "elicitation/create", params: formParams }, ElicitResultSchema, options);
        if (result.action === "accept" && result.content && formParams.requestedSchema) {
          try {
            const validator = this._jsonSchemaValidator.getValidator(formParams.requestedSchema);
            const validationResult = validator(result.content);
            if (!validationResult.valid) {
              throw new McpError(ErrorCode.InvalidParams, `Elicitation response content does not match requested schema: ${validationResult.errorMessage}`);
            }
          } catch (error50) {
            if (error50 instanceof McpError) {
              throw error50;
            }
            throw new McpError(ErrorCode.InternalError, `Error validating elicitation response: ${error50 instanceof Error ? error50.message : String(error50)}`);
          }
        }
        return result;
      }
    }
  }
  /**
   * Creates a reusable callback that, when invoked, will send a `notifications/elicitation/complete`
   * notification for the specified elicitation ID.
   *
   * @param elicitationId The ID of the elicitation to mark as complete.
   * @param options Optional notification options. Useful when the completion notification should be related to a prior request.
   * @returns A function that emits the completion notification when awaited.
   */
  createElicitationCompletionNotifier(elicitationId, options) {
    if (!this._clientCapabilities?.elicitation?.url) {
      throw new Error("Client does not support URL elicitation (required for notifications/elicitation/complete)");
    }
    return () => this.notification({
      method: "notifications/elicitation/complete",
      params: {
        elicitationId
      }
    }, options);
  }
  async listRoots(params, options) {
    return this.request({ method: "roots/list", params }, ListRootsResultSchema, options);
  }
  /**
   * Sends a logging message to the client, if connected.
   * Note: You only need to send the parameters object, not the entire JSON RPC message
   * @see LoggingMessageNotification
   * @param params
   * @param sessionId optional for stateless and backward compatibility
   */
  async sendLoggingMessage(params, sessionId) {
    if (this._capabilities.logging) {
      if (!this.isMessageIgnored(params.level, sessionId)) {
        return this.notification({ method: "notifications/message", params });
      }
    }
  }
  async sendResourceUpdated(params) {
    return this.notification({
      method: "notifications/resources/updated",
      params
    });
  }
  async sendResourceListChanged() {
    return this.notification({
      method: "notifications/resources/list_changed"
    });
  }
  async sendToolListChanged() {
    return this.notification({ method: "notifications/tools/list_changed" });
  }
  async sendPromptListChanged() {
    return this.notification({ method: "notifications/prompts/list_changed" });
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/completable.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var COMPLETABLE_SYMBOL = Symbol.for("mcp.completable");
function isCompletable(schema) {
  return !!schema && typeof schema === "object" && COMPLETABLE_SYMBOL in schema;
}
__name(isCompletable, "isCompletable");
function getCompleter(schema) {
  const meta3 = schema[COMPLETABLE_SYMBOL];
  return meta3?.complete;
}
__name(getCompleter, "getCompleter");
var McpZodTypeKind;
(function(McpZodTypeKind2) {
  McpZodTypeKind2["Completable"] = "McpCompletable";
})(McpZodTypeKind || (McpZodTypeKind = {}));

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/uriTemplate.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/toolNameValidation.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TOOL_NAME_REGEX = /^[A-Za-z0-9._-]{1,128}$/;
function validateToolName(name) {
  const warnings = [];
  if (name.length === 0) {
    return {
      isValid: false,
      warnings: ["Tool name cannot be empty"]
    };
  }
  if (name.length > 128) {
    return {
      isValid: false,
      warnings: [`Tool name exceeds maximum length of 128 characters (current: ${name.length})`]
    };
  }
  if (name.includes(" ")) {
    warnings.push("Tool name contains spaces, which may cause parsing issues");
  }
  if (name.includes(",")) {
    warnings.push("Tool name contains commas, which may cause parsing issues");
  }
  if (name.startsWith("-") || name.endsWith("-")) {
    warnings.push("Tool name starts or ends with a dash, which may cause parsing issues in some contexts");
  }
  if (name.startsWith(".") || name.endsWith(".")) {
    warnings.push("Tool name starts or ends with a dot, which may cause parsing issues in some contexts");
  }
  if (!TOOL_NAME_REGEX.test(name)) {
    const invalidChars = name.split("").filter((char2) => !/[A-Za-z0-9._-]/.test(char2)).filter((char2, index2, arr) => arr.indexOf(char2) === index2);
    warnings.push(`Tool name contains invalid characters: ${invalidChars.map((c) => `"${c}"`).join(", ")}`, "Allowed characters are: A-Z, a-z, 0-9, underscore (_), dash (-), and dot (.)");
    return {
      isValid: false,
      warnings
    };
  }
  return {
    isValid: true,
    warnings
  };
}
__name(validateToolName, "validateToolName");
function issueToolNameWarning(name, warnings) {
  if (warnings.length > 0) {
    console.warn(`Tool name validation warning for "${name}":`);
    for (const warning2 of warnings) {
      console.warn(`  - ${warning2}`);
    }
    console.warn("Tool registration will proceed, but this may cause compatibility issues.");
    console.warn("Consider updating the tool name to conform to the MCP tool naming standard.");
    console.warn("See SEP: Specify Format for Tool Names (https://github.com/modelcontextprotocol/modelcontextprotocol/issues/986) for more details.");
  }
}
__name(issueToolNameWarning, "issueToolNameWarning");
function validateAndWarnToolName(name) {
  const result = validateToolName(name);
  issueToolNameWarning(name, result.warnings);
  return result.isValid;
}
__name(validateAndWarnToolName, "validateAndWarnToolName");

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/mcp-server.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ExperimentalMcpServerTasks = class {
  static {
    __name(this, "ExperimentalMcpServerTasks");
  }
  constructor(_mcpServer) {
    this._mcpServer = _mcpServer;
  }
  registerToolTask(name, config5, handler) {
    const execution = { taskSupport: "required", ...config5.execution };
    if (execution.taskSupport === "forbidden") {
      throw new Error(`Cannot register task-based tool '${name}' with taskSupport 'forbidden'. Use registerTool() instead.`);
    }
    const mcpServerInternal = this._mcpServer;
    return mcpServerInternal._createRegisteredTool(name, config5.title, config5.description, config5.inputSchema, config5.outputSchema, config5.annotations, execution, config5._meta, handler);
  }
};

// node_modules/zod/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/mcp.js
var McpServer = class {
  static {
    __name(this, "McpServer");
  }
  constructor(serverInfo, options) {
    this._registeredResources = {};
    this._registeredResourceTemplates = {};
    this._registeredTools = {};
    this._registeredPrompts = {};
    this._toolHandlersInitialized = false;
    this._completionHandlerInitialized = false;
    this._resourceHandlersInitialized = false;
    this._promptHandlersInitialized = false;
    this.server = new Server(serverInfo, options);
  }
  /**
   * Access experimental features.
   *
   * WARNING: These APIs are experimental and may change without notice.
   *
   * @experimental
   */
  get experimental() {
    if (!this._experimental) {
      this._experimental = {
        tasks: new ExperimentalMcpServerTasks(this)
      };
    }
    return this._experimental;
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The `server` object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(transport) {
    return await this.server.connect(transport);
  }
  /**
   * Closes the connection.
   */
  async close() {
    await this.server.close();
  }
  setToolRequestHandlers() {
    if (this._toolHandlersInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(getMethodValue(ListToolsRequestSchema));
    this.server.assertCanSetRequestHandler(getMethodValue(CallToolRequestSchema));
    this.server.registerCapabilities({
      tools: {
        listChanged: true
      }
    });
    this.server.setRequestHandler(ListToolsRequestSchema, () => ({
      tools: Object.entries(this._registeredTools).filter(([, tool]) => tool.enabled).map(([name, tool]) => {
        const toolDefinition = {
          name,
          title: tool.title,
          description: tool.description,
          inputSchema: (() => {
            const obj = normalizeObjectSchema(tool.inputSchema);
            return obj ? toJsonSchemaCompat(obj, {
              strictUnions: true,
              pipeStrategy: "input"
            }) : EMPTY_OBJECT_JSON_SCHEMA;
          })(),
          annotations: tool.annotations,
          execution: tool.execution,
          _meta: tool._meta
        };
        if (tool.outputSchema) {
          const obj = normalizeObjectSchema(tool.outputSchema);
          if (obj) {
            toolDefinition.outputSchema = toJsonSchemaCompat(obj, {
              strictUnions: true,
              pipeStrategy: "output"
            });
          }
        }
        return toolDefinition;
      })
    }));
    this.server.setRequestHandler(CallToolRequestSchema, async (request2, extra) => {
      try {
        const tool = this._registeredTools[request2.params.name];
        if (!tool) {
          throw new McpError(ErrorCode.InvalidParams, `Tool ${request2.params.name} not found`);
        }
        if (!tool.enabled) {
          throw new McpError(ErrorCode.InvalidParams, `Tool ${request2.params.name} disabled`);
        }
        const isTaskRequest = !!request2.params.task;
        const taskSupport = tool.execution?.taskSupport;
        const isTaskHandler = "createTask" in tool.handler;
        if ((taskSupport === "required" || taskSupport === "optional") && !isTaskHandler) {
          throw new McpError(ErrorCode.InternalError, `Tool ${request2.params.name} has taskSupport '${taskSupport}' but was not registered with registerToolTask`);
        }
        if (taskSupport === "required" && !isTaskRequest) {
          throw new McpError(ErrorCode.MethodNotFound, `Tool ${request2.params.name} requires task augmentation (taskSupport: 'required')`);
        }
        if (taskSupport === "optional" && !isTaskRequest && isTaskHandler) {
          return await this.handleAutomaticTaskPolling(tool, request2, extra);
        }
        const args2 = await this.validateToolInput(tool, request2.params.arguments, request2.params.name);
        const result = await this.executeToolHandler(tool, args2, extra);
        if (isTaskRequest) {
          return result;
        }
        await this.validateToolOutput(tool, result, request2.params.name);
        return result;
      } catch (error50) {
        if (error50 instanceof McpError) {
          if (error50.code === ErrorCode.UrlElicitationRequired) {
            throw error50;
          }
        }
        return this.createToolError(error50 instanceof Error ? error50.message : String(error50));
      }
    });
    this._toolHandlersInitialized = true;
  }
  /**
   * Creates a tool error result.
   *
   * @param errorMessage - The error message.
   * @returns The tool error result.
   */
  createToolError(errorMessage) {
    return {
      content: [
        {
          type: "text",
          text: errorMessage
        }
      ],
      isError: true
    };
  }
  /**
   * Validates tool input arguments against the tool's input schema.
   */
  async validateToolInput(tool, args2, toolName) {
    if (!tool.inputSchema) {
      return void 0;
    }
    const inputObj = normalizeObjectSchema(tool.inputSchema);
    const schemaToParse = inputObj ?? tool.inputSchema;
    const parseResult = await safeParseAsync2(schemaToParse, args2);
    if (!parseResult.success) {
      const error50 = "error" in parseResult ? parseResult.error : "Unknown error";
      const errorMessage = getParseErrorMessage(error50);
      throw new McpError(ErrorCode.InvalidParams, `Input validation error: Invalid arguments for tool ${toolName}: ${errorMessage}`);
    }
    return parseResult.data;
  }
  /**
   * Validates tool output against the tool's output schema.
   */
  async validateToolOutput(tool, result, toolName) {
    if (!tool.outputSchema) {
      return;
    }
    if (!("content" in result)) {
      return;
    }
    if (result.isError) {
      return;
    }
    if (!result.structuredContent) {
      throw new McpError(ErrorCode.InvalidParams, `Output validation error: Tool ${toolName} has an output schema but no structured content was provided`);
    }
    const outputObj = normalizeObjectSchema(tool.outputSchema);
    const parseResult = await safeParseAsync2(outputObj, result.structuredContent);
    if (!parseResult.success) {
      const error50 = "error" in parseResult ? parseResult.error : "Unknown error";
      const errorMessage = getParseErrorMessage(error50);
      throw new McpError(ErrorCode.InvalidParams, `Output validation error: Invalid structured content for tool ${toolName}: ${errorMessage}`);
    }
  }
  /**
   * Executes a tool handler (either regular or task-based).
   */
  async executeToolHandler(tool, args2, extra) {
    const handler = tool.handler;
    const isTaskHandler = "createTask" in handler;
    if (isTaskHandler) {
      if (!extra.taskStore) {
        throw new Error("No task store provided.");
      }
      const taskExtra = { ...extra, taskStore: extra.taskStore };
      if (tool.inputSchema) {
        const typedHandler = handler;
        return await Promise.resolve(typedHandler.createTask(args2, taskExtra));
      } else {
        const typedHandler = handler;
        return await Promise.resolve(typedHandler.createTask(taskExtra));
      }
    }
    if (tool.inputSchema) {
      const typedHandler = handler;
      return await Promise.resolve(typedHandler(args2, extra));
    } else {
      const typedHandler = handler;
      return await Promise.resolve(typedHandler(extra));
    }
  }
  /**
   * Handles automatic task polling for tools with taskSupport 'optional'.
   */
  async handleAutomaticTaskPolling(tool, request2, extra) {
    if (!extra.taskStore) {
      throw new Error("No task store provided for task-capable tool.");
    }
    const args2 = await this.validateToolInput(tool, request2.params.arguments, request2.params.name);
    const handler = tool.handler;
    const taskExtra = { ...extra, taskStore: extra.taskStore };
    const createTaskResult = args2 ? await Promise.resolve(handler.createTask(args2, taskExtra)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      await Promise.resolve(handler.createTask(taskExtra))
    );
    const taskId = createTaskResult.task.taskId;
    let task = createTaskResult.task;
    const pollInterval = task.pollInterval ?? 5e3;
    while (task.status !== "completed" && task.status !== "failed" && task.status !== "cancelled") {
      await new Promise((resolve) => setTimeout(resolve, pollInterval));
      const updatedTask = await extra.taskStore.getTask(taskId);
      if (!updatedTask) {
        throw new McpError(ErrorCode.InternalError, `Task ${taskId} not found during polling`);
      }
      task = updatedTask;
    }
    return await extra.taskStore.getTaskResult(taskId);
  }
  setCompletionRequestHandler() {
    if (this._completionHandlerInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(getMethodValue(CompleteRequestSchema));
    this.server.registerCapabilities({
      completions: {}
    });
    this.server.setRequestHandler(CompleteRequestSchema, async (request2) => {
      switch (request2.params.ref.type) {
        case "ref/prompt":
          assertCompleteRequestPrompt(request2);
          return this.handlePromptCompletion(request2, request2.params.ref);
        case "ref/resource":
          assertCompleteRequestResourceTemplate(request2);
          return this.handleResourceCompletion(request2, request2.params.ref);
        default:
          throw new McpError(ErrorCode.InvalidParams, `Invalid completion reference: ${request2.params.ref}`);
      }
    });
    this._completionHandlerInitialized = true;
  }
  async handlePromptCompletion(request2, ref2) {
    const prompt = this._registeredPrompts[ref2.name];
    if (!prompt) {
      throw new McpError(ErrorCode.InvalidParams, `Prompt ${ref2.name} not found`);
    }
    if (!prompt.enabled) {
      throw new McpError(ErrorCode.InvalidParams, `Prompt ${ref2.name} disabled`);
    }
    if (!prompt.argsSchema) {
      return EMPTY_COMPLETION_RESULT;
    }
    const promptShape = getObjectShape(prompt.argsSchema);
    const field = promptShape?.[request2.params.argument.name];
    if (!isCompletable(field)) {
      return EMPTY_COMPLETION_RESULT;
    }
    const completer = getCompleter(field);
    if (!completer) {
      return EMPTY_COMPLETION_RESULT;
    }
    const suggestions = await completer(request2.params.argument.value, request2.params.context);
    return createCompletionResult(suggestions);
  }
  async handleResourceCompletion(request2, ref2) {
    const template = Object.values(this._registeredResourceTemplates).find((t) => t.resourceTemplate.uriTemplate.toString() === ref2.uri);
    if (!template) {
      if (this._registeredResources[ref2.uri]) {
        return EMPTY_COMPLETION_RESULT;
      }
      throw new McpError(ErrorCode.InvalidParams, `Resource template ${request2.params.ref.uri} not found`);
    }
    const completer = template.resourceTemplate.completeCallback(request2.params.argument.name);
    if (!completer) {
      return EMPTY_COMPLETION_RESULT;
    }
    const suggestions = await completer(request2.params.argument.value, request2.params.context);
    return createCompletionResult(suggestions);
  }
  setResourceRequestHandlers() {
    if (this._resourceHandlersInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(getMethodValue(ListResourcesRequestSchema));
    this.server.assertCanSetRequestHandler(getMethodValue(ListResourceTemplatesRequestSchema));
    this.server.assertCanSetRequestHandler(getMethodValue(ReadResourceRequestSchema));
    this.server.registerCapabilities({
      resources: {
        listChanged: true
      }
    });
    this.server.setRequestHandler(ListResourcesRequestSchema, async (request2, extra) => {
      const resources = Object.entries(this._registeredResources).filter(([_, resource]) => resource.enabled).map(([uri, resource]) => ({
        uri,
        name: resource.name,
        ...resource.metadata
      }));
      const templateResources = [];
      for (const template of Object.values(this._registeredResourceTemplates)) {
        if (!template.resourceTemplate.listCallback) {
          continue;
        }
        const result = await template.resourceTemplate.listCallback(extra);
        for (const resource of result.resources) {
          templateResources.push({
            ...template.metadata,
            // the defined resource metadata should override the template metadata if present
            ...resource
          });
        }
      }
      return { resources: [...resources, ...templateResources] };
    });
    this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () => {
      const resourceTemplates = Object.entries(this._registeredResourceTemplates).map(([name, template]) => ({
        name,
        uriTemplate: template.resourceTemplate.uriTemplate.toString(),
        ...template.metadata
      }));
      return { resourceTemplates };
    });
    this.server.setRequestHandler(ReadResourceRequestSchema, async (request2, extra) => {
      const uri = new URL(request2.params.uri);
      const resource = this._registeredResources[uri.toString()];
      if (resource) {
        if (!resource.enabled) {
          throw new McpError(ErrorCode.InvalidParams, `Resource ${uri} disabled`);
        }
        return resource.readCallback(uri, extra);
      }
      for (const template of Object.values(this._registeredResourceTemplates)) {
        const variables = template.resourceTemplate.uriTemplate.match(uri.toString());
        if (variables) {
          return template.readCallback(uri, variables, extra);
        }
      }
      throw new McpError(ErrorCode.InvalidParams, `Resource ${uri} not found`);
    });
    this._resourceHandlersInitialized = true;
  }
  setPromptRequestHandlers() {
    if (this._promptHandlersInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(getMethodValue(ListPromptsRequestSchema));
    this.server.assertCanSetRequestHandler(getMethodValue(GetPromptRequestSchema));
    this.server.registerCapabilities({
      prompts: {
        listChanged: true
      }
    });
    this.server.setRequestHandler(ListPromptsRequestSchema, () => ({
      prompts: Object.entries(this._registeredPrompts).filter(([, prompt]) => prompt.enabled).map(([name, prompt]) => {
        return {
          name,
          title: prompt.title,
          description: prompt.description,
          arguments: prompt.argsSchema ? promptArgumentsFromSchema(prompt.argsSchema) : void 0
        };
      })
    }));
    this.server.setRequestHandler(GetPromptRequestSchema, async (request2, extra) => {
      const prompt = this._registeredPrompts[request2.params.name];
      if (!prompt) {
        throw new McpError(ErrorCode.InvalidParams, `Prompt ${request2.params.name} not found`);
      }
      if (!prompt.enabled) {
        throw new McpError(ErrorCode.InvalidParams, `Prompt ${request2.params.name} disabled`);
      }
      if (prompt.argsSchema) {
        const argsObj = normalizeObjectSchema(prompt.argsSchema);
        const parseResult = await safeParseAsync2(argsObj, request2.params.arguments);
        if (!parseResult.success) {
          const error50 = "error" in parseResult ? parseResult.error : "Unknown error";
          const errorMessage = getParseErrorMessage(error50);
          throw new McpError(ErrorCode.InvalidParams, `Invalid arguments for prompt ${request2.params.name}: ${errorMessage}`);
        }
        const args2 = parseResult.data;
        const cb = prompt.callback;
        return await Promise.resolve(cb(args2, extra));
      } else {
        const cb = prompt.callback;
        return await Promise.resolve(cb(extra));
      }
    });
    this._promptHandlersInitialized = true;
  }
  resource(name, uriOrTemplate, ...rest) {
    let metadata;
    if (typeof rest[0] === "object") {
      metadata = rest.shift();
    }
    const readCallback = rest[0];
    if (typeof uriOrTemplate === "string") {
      if (this._registeredResources[uriOrTemplate]) {
        throw new Error(`Resource ${uriOrTemplate} is already registered`);
      }
      const registeredResource = this._createRegisteredResource(name, void 0, uriOrTemplate, metadata, readCallback);
      this.setResourceRequestHandlers();
      this.sendResourceListChanged();
      return registeredResource;
    } else {
      if (this._registeredResourceTemplates[name]) {
        throw new Error(`Resource template ${name} is already registered`);
      }
      const registeredResourceTemplate = this._createRegisteredResourceTemplate(name, void 0, uriOrTemplate, metadata, readCallback);
      this.setResourceRequestHandlers();
      this.sendResourceListChanged();
      return registeredResourceTemplate;
    }
  }
  registerResource(name, uriOrTemplate, config5, readCallback) {
    if (typeof uriOrTemplate === "string") {
      if (this._registeredResources[uriOrTemplate]) {
        throw new Error(`Resource ${uriOrTemplate} is already registered`);
      }
      const registeredResource = this._createRegisteredResource(name, config5.title, uriOrTemplate, config5, readCallback);
      this.setResourceRequestHandlers();
      this.sendResourceListChanged();
      return registeredResource;
    } else {
      if (this._registeredResourceTemplates[name]) {
        throw new Error(`Resource template ${name} is already registered`);
      }
      const registeredResourceTemplate = this._createRegisteredResourceTemplate(name, config5.title, uriOrTemplate, config5, readCallback);
      this.setResourceRequestHandlers();
      this.sendResourceListChanged();
      return registeredResourceTemplate;
    }
  }
  _createRegisteredResource(name, title2, uri, metadata, readCallback) {
    const registeredResource = {
      name,
      title: title2,
      metadata,
      readCallback,
      enabled: true,
      disable: /* @__PURE__ */ __name(() => registeredResource.update({ enabled: false }), "disable"),
      enable: /* @__PURE__ */ __name(() => registeredResource.update({ enabled: true }), "enable"),
      remove: /* @__PURE__ */ __name(() => registeredResource.update({ uri: null }), "remove"),
      update: /* @__PURE__ */ __name((updates) => {
        if (typeof updates.uri !== "undefined" && updates.uri !== uri) {
          delete this._registeredResources[uri];
          if (updates.uri)
            this._registeredResources[updates.uri] = registeredResource;
        }
        if (typeof updates.name !== "undefined")
          registeredResource.name = updates.name;
        if (typeof updates.title !== "undefined")
          registeredResource.title = updates.title;
        if (typeof updates.metadata !== "undefined")
          registeredResource.metadata = updates.metadata;
        if (typeof updates.callback !== "undefined")
          registeredResource.readCallback = updates.callback;
        if (typeof updates.enabled !== "undefined")
          registeredResource.enabled = updates.enabled;
        this.sendResourceListChanged();
      }, "update")
    };
    this._registeredResources[uri] = registeredResource;
    return registeredResource;
  }
  _createRegisteredResourceTemplate(name, title2, template, metadata, readCallback) {
    const registeredResourceTemplate = {
      resourceTemplate: template,
      title: title2,
      metadata,
      readCallback,
      enabled: true,
      disable: /* @__PURE__ */ __name(() => registeredResourceTemplate.update({ enabled: false }), "disable"),
      enable: /* @__PURE__ */ __name(() => registeredResourceTemplate.update({ enabled: true }), "enable"),
      remove: /* @__PURE__ */ __name(() => registeredResourceTemplate.update({ name: null }), "remove"),
      update: /* @__PURE__ */ __name((updates) => {
        if (typeof updates.name !== "undefined" && updates.name !== name) {
          delete this._registeredResourceTemplates[name];
          if (updates.name)
            this._registeredResourceTemplates[updates.name] = registeredResourceTemplate;
        }
        if (typeof updates.title !== "undefined")
          registeredResourceTemplate.title = updates.title;
        if (typeof updates.template !== "undefined")
          registeredResourceTemplate.resourceTemplate = updates.template;
        if (typeof updates.metadata !== "undefined")
          registeredResourceTemplate.metadata = updates.metadata;
        if (typeof updates.callback !== "undefined")
          registeredResourceTemplate.readCallback = updates.callback;
        if (typeof updates.enabled !== "undefined")
          registeredResourceTemplate.enabled = updates.enabled;
        this.sendResourceListChanged();
      }, "update")
    };
    this._registeredResourceTemplates[name] = registeredResourceTemplate;
    const variableNames = template.uriTemplate.variableNames;
    const hasCompleter = Array.isArray(variableNames) && variableNames.some((v) => !!template.completeCallback(v));
    if (hasCompleter) {
      this.setCompletionRequestHandler();
    }
    return registeredResourceTemplate;
  }
  _createRegisteredPrompt(name, title2, description, argsSchema, callback) {
    const registeredPrompt = {
      title: title2,
      description,
      argsSchema: argsSchema === void 0 ? void 0 : objectFromShape(argsSchema),
      callback,
      enabled: true,
      disable: /* @__PURE__ */ __name(() => registeredPrompt.update({ enabled: false }), "disable"),
      enable: /* @__PURE__ */ __name(() => registeredPrompt.update({ enabled: true }), "enable"),
      remove: /* @__PURE__ */ __name(() => registeredPrompt.update({ name: null }), "remove"),
      update: /* @__PURE__ */ __name((updates) => {
        if (typeof updates.name !== "undefined" && updates.name !== name) {
          delete this._registeredPrompts[name];
          if (updates.name)
            this._registeredPrompts[updates.name] = registeredPrompt;
        }
        if (typeof updates.title !== "undefined")
          registeredPrompt.title = updates.title;
        if (typeof updates.description !== "undefined")
          registeredPrompt.description = updates.description;
        if (typeof updates.argsSchema !== "undefined")
          registeredPrompt.argsSchema = objectFromShape(updates.argsSchema);
        if (typeof updates.callback !== "undefined")
          registeredPrompt.callback = updates.callback;
        if (typeof updates.enabled !== "undefined")
          registeredPrompt.enabled = updates.enabled;
        this.sendPromptListChanged();
      }, "update")
    };
    this._registeredPrompts[name] = registeredPrompt;
    if (argsSchema) {
      const hasCompletable = Object.values(argsSchema).some((field) => {
        const inner = field instanceof ZodOptional2 ? field._def?.innerType : field;
        return isCompletable(inner);
      });
      if (hasCompletable) {
        this.setCompletionRequestHandler();
      }
    }
    return registeredPrompt;
  }
  _createRegisteredTool(name, title2, description, inputSchema, outputSchema, annotations3, execution, _meta, handler) {
    validateAndWarnToolName(name);
    const registeredTool = {
      title: title2,
      description,
      inputSchema: getZodSchemaObject(inputSchema),
      outputSchema: getZodSchemaObject(outputSchema),
      annotations: annotations3,
      execution,
      _meta,
      handler,
      enabled: true,
      disable: /* @__PURE__ */ __name(() => registeredTool.update({ enabled: false }), "disable"),
      enable: /* @__PURE__ */ __name(() => registeredTool.update({ enabled: true }), "enable"),
      remove: /* @__PURE__ */ __name(() => registeredTool.update({ name: null }), "remove"),
      update: /* @__PURE__ */ __name((updates) => {
        if (typeof updates.name !== "undefined" && updates.name !== name) {
          if (typeof updates.name === "string") {
            validateAndWarnToolName(updates.name);
          }
          delete this._registeredTools[name];
          if (updates.name)
            this._registeredTools[updates.name] = registeredTool;
        }
        if (typeof updates.title !== "undefined")
          registeredTool.title = updates.title;
        if (typeof updates.description !== "undefined")
          registeredTool.description = updates.description;
        if (typeof updates.paramsSchema !== "undefined")
          registeredTool.inputSchema = objectFromShape(updates.paramsSchema);
        if (typeof updates.outputSchema !== "undefined")
          registeredTool.outputSchema = objectFromShape(updates.outputSchema);
        if (typeof updates.callback !== "undefined")
          registeredTool.handler = updates.callback;
        if (typeof updates.annotations !== "undefined")
          registeredTool.annotations = updates.annotations;
        if (typeof updates._meta !== "undefined")
          registeredTool._meta = updates._meta;
        if (typeof updates.enabled !== "undefined")
          registeredTool.enabled = updates.enabled;
        this.sendToolListChanged();
      }, "update")
    };
    this._registeredTools[name] = registeredTool;
    this.setToolRequestHandlers();
    this.sendToolListChanged();
    return registeredTool;
  }
  /**
   * tool() implementation. Parses arguments passed to overrides defined above.
   */
  tool(name, ...rest) {
    if (this._registeredTools[name]) {
      throw new Error(`Tool ${name} is already registered`);
    }
    let description;
    let inputSchema;
    let outputSchema;
    let annotations3;
    if (typeof rest[0] === "string") {
      description = rest.shift();
    }
    if (rest.length > 1) {
      const firstArg = rest[0];
      if (isZodRawShapeCompat(firstArg)) {
        inputSchema = rest.shift();
        if (rest.length > 1 && typeof rest[0] === "object" && rest[0] !== null && !isZodRawShapeCompat(rest[0])) {
          annotations3 = rest.shift();
        }
      } else if (typeof firstArg === "object" && firstArg !== null) {
        annotations3 = rest.shift();
      }
    }
    const callback = rest[0];
    return this._createRegisteredTool(name, void 0, description, inputSchema, outputSchema, annotations3, { taskSupport: "forbidden" }, void 0, callback);
  }
  /**
   * Registers a tool with a config object and callback.
   */
  registerTool(name, config5, cb) {
    if (this._registeredTools[name]) {
      throw new Error(`Tool ${name} is already registered`);
    }
    const { title: title2, description, inputSchema, outputSchema, annotations: annotations3, _meta } = config5;
    return this._createRegisteredTool(name, title2, description, inputSchema, outputSchema, annotations3, { taskSupport: "forbidden" }, _meta, cb);
  }
  prompt(name, ...rest) {
    if (this._registeredPrompts[name]) {
      throw new Error(`Prompt ${name} is already registered`);
    }
    let description;
    if (typeof rest[0] === "string") {
      description = rest.shift();
    }
    let argsSchema;
    if (rest.length > 1) {
      argsSchema = rest.shift();
    }
    const cb = rest[0];
    const registeredPrompt = this._createRegisteredPrompt(name, void 0, description, argsSchema, cb);
    this.setPromptRequestHandlers();
    this.sendPromptListChanged();
    return registeredPrompt;
  }
  /**
   * Registers a prompt with a config object and callback.
   */
  registerPrompt(name, config5, cb) {
    if (this._registeredPrompts[name]) {
      throw new Error(`Prompt ${name} is already registered`);
    }
    const { title: title2, description, argsSchema } = config5;
    const registeredPrompt = this._createRegisteredPrompt(name, title2, description, argsSchema, cb);
    this.setPromptRequestHandlers();
    this.sendPromptListChanged();
    return registeredPrompt;
  }
  /**
   * Checks if the server is connected to a transport.
   * @returns True if the server is connected
   */
  isConnected() {
    return this.server.transport !== void 0;
  }
  /**
   * Sends a logging message to the client, if connected.
   * Note: You only need to send the parameters object, not the entire JSON RPC message
   * @see LoggingMessageNotification
   * @param params
   * @param sessionId optional for stateless and backward compatibility
   */
  async sendLoggingMessage(params, sessionId) {
    return this.server.sendLoggingMessage(params, sessionId);
  }
  /**
   * Sends a resource list changed event to the client, if connected.
   */
  sendResourceListChanged() {
    if (this.isConnected()) {
      this.server.sendResourceListChanged();
    }
  }
  /**
   * Sends a tool list changed event to the client, if connected.
   */
  sendToolListChanged() {
    if (this.isConnected()) {
      this.server.sendToolListChanged();
    }
  }
  /**
   * Sends a prompt list changed event to the client, if connected.
   */
  sendPromptListChanged() {
    if (this.isConnected()) {
      this.server.sendPromptListChanged();
    }
  }
};
var EMPTY_OBJECT_JSON_SCHEMA = {
  type: "object",
  properties: {}
};
function isZodTypeLike(value3) {
  return value3 !== null && typeof value3 === "object" && "parse" in value3 && typeof value3.parse === "function" && "safeParse" in value3 && typeof value3.safeParse === "function";
}
__name(isZodTypeLike, "isZodTypeLike");
function isZodSchemaInstance(obj) {
  return "_def" in obj || "_zod" in obj || isZodTypeLike(obj);
}
__name(isZodSchemaInstance, "isZodSchemaInstance");
function isZodRawShapeCompat(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  if (isZodSchemaInstance(obj)) {
    return false;
  }
  if (Object.keys(obj).length === 0) {
    return true;
  }
  return Object.values(obj).some(isZodTypeLike);
}
__name(isZodRawShapeCompat, "isZodRawShapeCompat");
function getZodSchemaObject(schema) {
  if (!schema) {
    return void 0;
  }
  if (isZodRawShapeCompat(schema)) {
    return objectFromShape(schema);
  }
  return schema;
}
__name(getZodSchemaObject, "getZodSchemaObject");
function promptArgumentsFromSchema(schema) {
  const shape = getObjectShape(schema);
  if (!shape)
    return [];
  return Object.entries(shape).map(([name, field]) => {
    const description = getSchemaDescription(field);
    const isOptional = isSchemaOptional(field);
    return {
      name,
      description,
      required: !isOptional
    };
  });
}
__name(promptArgumentsFromSchema, "promptArgumentsFromSchema");
function getMethodValue(schema) {
  const shape = getObjectShape(schema);
  const methodSchema = shape?.method;
  if (!methodSchema) {
    throw new Error("Schema is missing a method literal");
  }
  const value3 = getLiteralValue(methodSchema);
  if (typeof value3 === "string") {
    return value3;
  }
  throw new Error("Schema method literal must be a string");
}
__name(getMethodValue, "getMethodValue");
function createCompletionResult(suggestions) {
  return {
    completion: {
      values: suggestions.slice(0, 100),
      total: suggestions.length,
      hasMore: suggestions.length > 100
    }
  };
}
__name(createCompletionResult, "createCompletionResult");
var EMPTY_COMPLETION_RESULT = {
  completion: {
    values: [],
    hasMore: false
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/webStandardStreamableHttp.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var WebStandardStreamableHTTPServerTransport = class {
  static {
    __name(this, "WebStandardStreamableHTTPServerTransport");
  }
  constructor(options = {}) {
    this._started = false;
    this._hasHandledRequest = false;
    this._streamMapping = /* @__PURE__ */ new Map();
    this._requestToStreamMapping = /* @__PURE__ */ new Map();
    this._requestResponseMap = /* @__PURE__ */ new Map();
    this._initialized = false;
    this._enableJsonResponse = false;
    this._standaloneSseStreamId = "_GET_stream";
    this.sessionIdGenerator = options.sessionIdGenerator;
    this._enableJsonResponse = options.enableJsonResponse ?? false;
    this._eventStore = options.eventStore;
    this._onsessioninitialized = options.onsessioninitialized;
    this._onsessionclosed = options.onsessionclosed;
    this._allowedHosts = options.allowedHosts;
    this._allowedOrigins = options.allowedOrigins;
    this._enableDnsRebindingProtection = options.enableDnsRebindingProtection ?? false;
    this._retryInterval = options.retryInterval;
  }
  /**
   * Starts the transport. This is required by the Transport interface but is a no-op
   * for the Streamable HTTP transport as connections are managed per-request.
   */
  async start() {
    if (this._started) {
      throw new Error("Transport already started");
    }
    this._started = true;
  }
  /**
   * Helper to create a JSON error response
   */
  createJsonErrorResponse(status2, code, message, options) {
    const error50 = { code, message };
    if (options?.data !== void 0) {
      error50.data = options.data;
    }
    return new Response(JSON.stringify({
      jsonrpc: "2.0",
      error: error50,
      id: null
    }), {
      status: status2,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  /**
   * Validates request headers for DNS rebinding protection.
   * @returns Error response if validation fails, undefined if validation passes.
   */
  validateRequestHeaders(req) {
    if (!this._enableDnsRebindingProtection) {
      return void 0;
    }
    if (this._allowedHosts && this._allowedHosts.length > 0) {
      const hostHeader = req.headers.get("host");
      if (!hostHeader || !this._allowedHosts.includes(hostHeader)) {
        const error50 = `Invalid Host header: ${hostHeader}`;
        this.onerror?.(new Error(error50));
        return this.createJsonErrorResponse(403, -32e3, error50);
      }
    }
    if (this._allowedOrigins && this._allowedOrigins.length > 0) {
      const originHeader = req.headers.get("origin");
      if (originHeader && !this._allowedOrigins.includes(originHeader)) {
        const error50 = `Invalid Origin header: ${originHeader}`;
        this.onerror?.(new Error(error50));
        return this.createJsonErrorResponse(403, -32e3, error50);
      }
    }
    return void 0;
  }
  /**
   * Handles an incoming HTTP request, whether GET, POST, or DELETE
   * Returns a Response object (Web Standard)
   */
  async handleRequest(req, options) {
    if (!this.sessionIdGenerator && this._hasHandledRequest) {
      throw new Error("Stateless transport cannot be reused across requests. Create a new transport per request.");
    }
    this._hasHandledRequest = true;
    const validationError = this.validateRequestHeaders(req);
    if (validationError) {
      return validationError;
    }
    switch (req.method) {
      case "POST":
        return this.handlePostRequest(req, options);
      case "GET":
        return this.handleGetRequest(req);
      case "DELETE":
        return this.handleDeleteRequest(req);
      default:
        return this.handleUnsupportedRequest();
    }
  }
  /**
   * Writes a priming event to establish resumption capability.
   * Only sends if eventStore is configured (opt-in for resumability) and
   * the client's protocol version supports empty SSE data (>= 2025-11-25).
   */
  async writePrimingEvent(controller, encoder2, streamId, protocolVersion) {
    if (!this._eventStore) {
      return;
    }
    if (protocolVersion < "2025-11-25") {
      return;
    }
    const primingEventId = await this._eventStore.storeEvent(streamId, {});
    let primingEvent = `id: ${primingEventId}
data: 

`;
    if (this._retryInterval !== void 0) {
      primingEvent = `id: ${primingEventId}
retry: ${this._retryInterval}
data: 

`;
    }
    controller.enqueue(encoder2.encode(primingEvent));
  }
  /**
   * Handles GET requests for SSE stream
   */
  async handleGetRequest(req) {
    const acceptHeader = req.headers.get("accept");
    if (!acceptHeader?.includes("text/event-stream")) {
      return this.createJsonErrorResponse(406, -32e3, "Not Acceptable: Client must accept text/event-stream");
    }
    const sessionError = this.validateSession(req);
    if (sessionError) {
      return sessionError;
    }
    const protocolError = this.validateProtocolVersion(req);
    if (protocolError) {
      return protocolError;
    }
    if (this._eventStore) {
      const lastEventId = req.headers.get("last-event-id");
      if (lastEventId) {
        return this.replayEvents(lastEventId);
      }
    }
    if (this._streamMapping.get(this._standaloneSseStreamId) !== void 0) {
      return this.createJsonErrorResponse(409, -32e3, "Conflict: Only one SSE stream is allowed per session");
    }
    const encoder2 = new TextEncoder();
    let streamController;
    const readable = new ReadableStream({
      start: /* @__PURE__ */ __name((controller) => {
        streamController = controller;
      }, "start"),
      cancel: /* @__PURE__ */ __name(() => {
        this._streamMapping.delete(this._standaloneSseStreamId);
      }, "cancel")
    });
    const headers = {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive"
    };
    if (this.sessionId !== void 0) {
      headers["mcp-session-id"] = this.sessionId;
    }
    this._streamMapping.set(this._standaloneSseStreamId, {
      controller: streamController,
      encoder: encoder2,
      cleanup: /* @__PURE__ */ __name(() => {
        this._streamMapping.delete(this._standaloneSseStreamId);
        try {
          streamController.close();
        } catch {
        }
      }, "cleanup")
    });
    return new Response(readable, { headers });
  }
  /**
   * Replays events that would have been sent after the specified event ID
   * Only used when resumability is enabled
   */
  async replayEvents(lastEventId) {
    if (!this._eventStore) {
      return this.createJsonErrorResponse(400, -32e3, "Event store not configured");
    }
    try {
      let streamId;
      if (this._eventStore.getStreamIdForEventId) {
        streamId = await this._eventStore.getStreamIdForEventId(lastEventId);
        if (!streamId) {
          return this.createJsonErrorResponse(400, -32e3, "Invalid event ID format");
        }
        if (this._streamMapping.get(streamId) !== void 0) {
          return this.createJsonErrorResponse(409, -32e3, "Conflict: Stream already has an active connection");
        }
      }
      const headers = {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache, no-transform",
        Connection: "keep-alive"
      };
      if (this.sessionId !== void 0) {
        headers["mcp-session-id"] = this.sessionId;
      }
      const encoder2 = new TextEncoder();
      let streamController;
      const readable = new ReadableStream({
        start: /* @__PURE__ */ __name((controller) => {
          streamController = controller;
        }, "start"),
        cancel: /* @__PURE__ */ __name(() => {
        }, "cancel")
      });
      const replayedStreamId = await this._eventStore.replayEventsAfter(lastEventId, {
        send: /* @__PURE__ */ __name(async (eventId, message) => {
          const success2 = this.writeSSEEvent(streamController, encoder2, message, eventId);
          if (!success2) {
            this.onerror?.(new Error("Failed replay events"));
            try {
              streamController.close();
            } catch {
            }
          }
        }, "send")
      });
      this._streamMapping.set(replayedStreamId, {
        controller: streamController,
        encoder: encoder2,
        cleanup: /* @__PURE__ */ __name(() => {
          this._streamMapping.delete(replayedStreamId);
          try {
            streamController.close();
          } catch {
          }
        }, "cleanup")
      });
      return new Response(readable, { headers });
    } catch (error50) {
      this.onerror?.(error50);
      return this.createJsonErrorResponse(500, -32e3, "Error replaying events");
    }
  }
  /**
   * Writes an event to an SSE stream via controller with proper formatting
   */
  writeSSEEvent(controller, encoder2, message, eventId) {
    try {
      let eventData = `event: message
`;
      if (eventId) {
        eventData += `id: ${eventId}
`;
      }
      eventData += `data: ${JSON.stringify(message)}

`;
      controller.enqueue(encoder2.encode(eventData));
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Handles unsupported requests (PUT, PATCH, etc.)
   */
  handleUnsupportedRequest() {
    return new Response(JSON.stringify({
      jsonrpc: "2.0",
      error: {
        code: -32e3,
        message: "Method not allowed."
      },
      id: null
    }), {
      status: 405,
      headers: {
        Allow: "GET, POST, DELETE",
        "Content-Type": "application/json"
      }
    });
  }
  /**
   * Handles POST requests containing JSON-RPC messages
   */
  async handlePostRequest(req, options) {
    try {
      const acceptHeader = req.headers.get("accept");
      if (!acceptHeader?.includes("application/json") || !acceptHeader.includes("text/event-stream")) {
        return this.createJsonErrorResponse(406, -32e3, "Not Acceptable: Client must accept both application/json and text/event-stream");
      }
      const ct = req.headers.get("content-type");
      if (!ct || !ct.includes("application/json")) {
        return this.createJsonErrorResponse(415, -32e3, "Unsupported Media Type: Content-Type must be application/json");
      }
      const requestInfo = {
        headers: Object.fromEntries(req.headers.entries())
      };
      let rawMessage;
      if (options?.parsedBody !== void 0) {
        rawMessage = options.parsedBody;
      } else {
        try {
          rawMessage = await req.json();
        } catch {
          return this.createJsonErrorResponse(400, -32700, "Parse error: Invalid JSON");
        }
      }
      let messages;
      try {
        if (Array.isArray(rawMessage)) {
          messages = rawMessage.map((msg) => JSONRPCMessageSchema.parse(msg));
        } else {
          messages = [JSONRPCMessageSchema.parse(rawMessage)];
        }
      } catch {
        return this.createJsonErrorResponse(400, -32700, "Parse error: Invalid JSON-RPC message");
      }
      const isInitializationRequest = messages.some(isInitializeRequest);
      if (isInitializationRequest) {
        if (this._initialized && this.sessionId !== void 0) {
          return this.createJsonErrorResponse(400, -32600, "Invalid Request: Server already initialized");
        }
        if (messages.length > 1) {
          return this.createJsonErrorResponse(400, -32600, "Invalid Request: Only one initialization request is allowed");
        }
        this.sessionId = this.sessionIdGenerator?.();
        this._initialized = true;
        if (this.sessionId && this._onsessioninitialized) {
          await Promise.resolve(this._onsessioninitialized(this.sessionId));
        }
      }
      if (!isInitializationRequest) {
        const sessionError = this.validateSession(req);
        if (sessionError) {
          return sessionError;
        }
        const protocolError = this.validateProtocolVersion(req);
        if (protocolError) {
          return protocolError;
        }
      }
      const hasRequests = messages.some(isJSONRPCRequest);
      if (!hasRequests) {
        for (const message of messages) {
          this.onmessage?.(message, { authInfo: options?.authInfo, requestInfo });
        }
        return new Response(null, { status: 202 });
      }
      const streamId = crypto.randomUUID();
      const initRequest = messages.find((m) => isInitializeRequest(m));
      const clientProtocolVersion = initRequest ? initRequest.params.protocolVersion : req.headers.get("mcp-protocol-version") ?? DEFAULT_NEGOTIATED_PROTOCOL_VERSION;
      if (this._enableJsonResponse) {
        return new Promise((resolve) => {
          this._streamMapping.set(streamId, {
            resolveJson: resolve,
            cleanup: /* @__PURE__ */ __name(() => {
              this._streamMapping.delete(streamId);
            }, "cleanup")
          });
          for (const message of messages) {
            if (isJSONRPCRequest(message)) {
              this._requestToStreamMapping.set(message.id, streamId);
            }
          }
          for (const message of messages) {
            this.onmessage?.(message, { authInfo: options?.authInfo, requestInfo });
          }
        });
      }
      const encoder2 = new TextEncoder();
      let streamController;
      const readable = new ReadableStream({
        start: /* @__PURE__ */ __name((controller) => {
          streamController = controller;
        }, "start"),
        cancel: /* @__PURE__ */ __name(() => {
          this._streamMapping.delete(streamId);
        }, "cancel")
      });
      const headers = {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive"
      };
      if (this.sessionId !== void 0) {
        headers["mcp-session-id"] = this.sessionId;
      }
      for (const message of messages) {
        if (isJSONRPCRequest(message)) {
          this._streamMapping.set(streamId, {
            controller: streamController,
            encoder: encoder2,
            cleanup: /* @__PURE__ */ __name(() => {
              this._streamMapping.delete(streamId);
              try {
                streamController.close();
              } catch {
              }
            }, "cleanup")
          });
          this._requestToStreamMapping.set(message.id, streamId);
        }
      }
      await this.writePrimingEvent(streamController, encoder2, streamId, clientProtocolVersion);
      for (const message of messages) {
        let closeSSEStream;
        let closeStandaloneSSEStream;
        if (isJSONRPCRequest(message) && this._eventStore && clientProtocolVersion >= "2025-11-25") {
          closeSSEStream = /* @__PURE__ */ __name(() => {
            this.closeSSEStream(message.id);
          }, "closeSSEStream");
          closeStandaloneSSEStream = /* @__PURE__ */ __name(() => {
            this.closeStandaloneSSEStream();
          }, "closeStandaloneSSEStream");
        }
        this.onmessage?.(message, { authInfo: options?.authInfo, requestInfo, closeSSEStream, closeStandaloneSSEStream });
      }
      return new Response(readable, { status: 200, headers });
    } catch (error50) {
      this.onerror?.(error50);
      return this.createJsonErrorResponse(400, -32700, "Parse error", { data: String(error50) });
    }
  }
  /**
   * Handles DELETE requests to terminate sessions
   */
  async handleDeleteRequest(req) {
    const sessionError = this.validateSession(req);
    if (sessionError) {
      return sessionError;
    }
    const protocolError = this.validateProtocolVersion(req);
    if (protocolError) {
      return protocolError;
    }
    await Promise.resolve(this._onsessionclosed?.(this.sessionId));
    await this.close();
    return new Response(null, { status: 200 });
  }
  /**
   * Validates session ID for non-initialization requests.
   * Returns Response error if invalid, undefined otherwise
   */
  validateSession(req) {
    if (this.sessionIdGenerator === void 0) {
      return void 0;
    }
    if (!this._initialized) {
      return this.createJsonErrorResponse(400, -32e3, "Bad Request: Server not initialized");
    }
    const sessionId = req.headers.get("mcp-session-id");
    if (!sessionId) {
      return this.createJsonErrorResponse(400, -32e3, "Bad Request: Mcp-Session-Id header is required");
    }
    if (sessionId !== this.sessionId) {
      return this.createJsonErrorResponse(404, -32001, "Session not found");
    }
    return void 0;
  }
  /**
   * Validates the MCP-Protocol-Version header on incoming requests.
   *
   * For initialization: Version negotiation handles unknown versions gracefully
   * (server responds with its supported version).
   *
   * For subsequent requests with MCP-Protocol-Version header:
   * - Accept if in supported list
   * - 400 if unsupported
   *
   * For HTTP requests without the MCP-Protocol-Version header:
   * - Accept and default to the version negotiated at initialization
   */
  validateProtocolVersion(req) {
    const protocolVersion = req.headers.get("mcp-protocol-version");
    if (protocolVersion !== null && !SUPPORTED_PROTOCOL_VERSIONS.includes(protocolVersion)) {
      return this.createJsonErrorResponse(400, -32e3, `Bad Request: Unsupported protocol version: ${protocolVersion} (supported versions: ${SUPPORTED_PROTOCOL_VERSIONS.join(", ")})`);
    }
    return void 0;
  }
  async close() {
    this._streamMapping.forEach(({ cleanup }) => {
      cleanup();
    });
    this._streamMapping.clear();
    this._requestResponseMap.clear();
    this.onclose?.();
  }
  /**
   * Close an SSE stream for a specific request, triggering client reconnection.
   * Use this to implement polling behavior during long-running operations -
   * client will reconnect after the retry interval specified in the priming event.
   */
  closeSSEStream(requestId) {
    const streamId = this._requestToStreamMapping.get(requestId);
    if (!streamId)
      return;
    const stream2 = this._streamMapping.get(streamId);
    if (stream2) {
      stream2.cleanup();
    }
  }
  /**
   * Close the standalone GET SSE stream, triggering client reconnection.
   * Use this to implement polling behavior for server-initiated notifications.
   */
  closeStandaloneSSEStream() {
    const stream2 = this._streamMapping.get(this._standaloneSseStreamId);
    if (stream2) {
      stream2.cleanup();
    }
  }
  async send(message, options) {
    let requestId = options?.relatedRequestId;
    if (isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message)) {
      requestId = message.id;
    }
    if (requestId === void 0) {
      if (isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message)) {
        throw new Error("Cannot send a response on a standalone SSE stream unless resuming a previous client request");
      }
      let eventId;
      if (this._eventStore) {
        eventId = await this._eventStore.storeEvent(this._standaloneSseStreamId, message);
      }
      const standaloneSse = this._streamMapping.get(this._standaloneSseStreamId);
      if (standaloneSse === void 0) {
        return;
      }
      if (standaloneSse.controller && standaloneSse.encoder) {
        this.writeSSEEvent(standaloneSse.controller, standaloneSse.encoder, message, eventId);
      }
      return;
    }
    const streamId = this._requestToStreamMapping.get(requestId);
    if (!streamId) {
      throw new Error(`No connection established for request ID: ${String(requestId)}`);
    }
    const stream2 = this._streamMapping.get(streamId);
    if (!this._enableJsonResponse && stream2?.controller && stream2?.encoder) {
      let eventId;
      if (this._eventStore) {
        eventId = await this._eventStore.storeEvent(streamId, message);
      }
      this.writeSSEEvent(stream2.controller, stream2.encoder, message, eventId);
    }
    if (isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message)) {
      this._requestResponseMap.set(requestId, message);
      const relatedIds = Array.from(this._requestToStreamMapping.entries()).filter(([_, sid]) => sid === streamId).map(([id2]) => id2);
      const allResponsesReady = relatedIds.every((id2) => this._requestResponseMap.has(id2));
      if (allResponsesReady) {
        if (!stream2) {
          throw new Error(`No connection established for request ID: ${String(requestId)}`);
        }
        if (this._enableJsonResponse && stream2.resolveJson) {
          const headers = {
            "Content-Type": "application/json"
          };
          if (this.sessionId !== void 0) {
            headers["mcp-session-id"] = this.sessionId;
          }
          const responses = relatedIds.map((id2) => this._requestResponseMap.get(id2));
          if (responses.length === 1) {
            stream2.resolveJson(new Response(JSON.stringify(responses[0]), { status: 200, headers }));
          } else {
            stream2.resolveJson(new Response(JSON.stringify(responses), { status: 200, headers }));
          }
        } else {
          stream2.cleanup();
        }
        for (const id2 of relatedIds) {
          this._requestResponseMap.delete(id2);
          this._requestToStreamMapping.delete(id2);
        }
      }
    }
  }
};

// src/mcp.ts
init_esm();

// src/ai/AnthropicProvider.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();
init_Errors();

// src/ai/ScoutAgent.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();
var MAX_AGENT_STEPS = 10;
function runScoutAgent(opts) {
  return Effect_exports.gen(function* () {
    const { browser, llm, url: url3, task } = opts;
    const steps = [];
    yield* browser.navigate(url3);
    for (let i = 0; i < MAX_AGENT_STEPS; i++) {
      const currentUrl = yield* browser.evaluate("window.location.href");
      const pageContent = yield* getPageSummary(browser);
      const events = yield* browser.getNetworkEvents();
      const action = yield* llm.decide({
        task,
        currentUrl: String(currentUrl),
        pageContent,
        stepsCompleted: steps,
        networkEventCount: events.length
      });
      yield* executeAction(browser, action);
      const postEvents = yield* browser.getNetworkEvents();
      steps.push({
        action,
        networkEventsCollected: postEvents.length,
        pageUrl: String(currentUrl)
      });
      if (action.type === "done") break;
    }
    const allEvents = yield* browser.getNetworkEvents();
    return { steps, events: allEvents };
  });
}
__name(runScoutAgent, "runScoutAgent");
var PAGE_SUMMARY_SCRIPT = `(() => {
	const links = Array.from(document.querySelectorAll('a[href]'))
		.slice(0, 20)
		.map(a => '<a href="' + a.getAttribute('href') + '">' + (a.textContent || '').trim() + '</a>');
	const forms = Array.from(document.querySelectorAll('form')).map(f => {
		const inputs = Array.from(f.querySelectorAll('input, textarea, select')).map(i =>
			'<' + i.tagName.toLowerCase() + ' name="' + (i.getAttribute('name') || '') + '" type="' + (i.getAttribute('type') || 'text') + '">'
		);
		return '<form action="' + f.action + '">' + inputs.join('') + '</form>';
	});
	const buttons = Array.from(document.querySelectorAll('button, [role=button]'))
		.slice(0, 10)
		.map(b => '<button>' + (b.textContent || '').trim() + '</button>');
	const title = document.title;
	const meta = (document.querySelector('meta[name="description"]') || {}).content || '';
	return [
		'Title: ' + title,
		meta ? 'Description: ' + meta : '',
		links.length ? 'Links:\\n' + links.join('\\n') : 'No links',
		forms.length ? 'Forms:\\n' + forms.join('\\n') : 'No forms',
		buttons.length ? 'Buttons:\\n' + buttons.join('\\n') : 'No buttons',
	].filter(Boolean).join('\\n\\n');
})()`;
function getPageSummary(browser) {
  return browser.evaluate(PAGE_SUMMARY_SCRIPT);
}
__name(getPageSummary, "getPageSummary");
function executeAction(browser, action) {
  switch (action.type) {
    case "navigate":
      return action.url ? browser.navigate(action.url) : Effect_exports.void;
    case "click":
      return action.selector ? browser.click(action.selector) : Effect_exports.void;
    case "type":
      return action.selector && action.value !== void 0 ? browser.type(action.selector, action.value) : Effect_exports.void;
    case "wait":
      return action.selector ? browser.waitForSelector(action.selector) : Effect_exports.void;
    case "evaluate":
      return action.value ? browser.evaluate(action.value).pipe(Effect_exports.asVoid) : Effect_exports.void;
    case "done":
      return Effect_exports.void;
  }
}
__name(executeAction, "executeAction");
var SCOUT_SYSTEM_PROMPT = `You are a web exploration agent. Your job is to navigate websites and trigger as many API calls as possible.

You will receive the current page state (URL, links, forms, buttons) and must decide the next action.

Respond with a JSON object:
{
  "type": "navigate" | "click" | "type" | "wait" | "evaluate" | "done",
  "selector": "CSS selector (for click, type, wait)",
  "value": "text to type (for type) or JS to evaluate (for evaluate)",
  "url": "URL to navigate to (for navigate)",
  "reason": "why you're taking this action"
}

Strategy:
- Click links that look like they load data (dashboard, list, detail pages)
- Submit forms to trigger POST requests
- Click buttons that trigger AJAX calls
- Navigate to different sections of the site
- When you've explored enough or can't find more API calls, respond with type "done"
- Be efficient \u2014 don't revisit pages you've already seen
`;

// src/ai/AnthropicProvider.ts
function makeAnthropicProvider(config5) {
  const model = config5.model ?? "claude-sonnet-4-20250514";
  return {
    decide: /* @__PURE__ */ __name((context10) => Effect_exports.tryPromise({
      try: /* @__PURE__ */ __name(async () => {
        const userMessage = [
          `Task: ${context10.task}`,
          `Current URL: ${context10.currentUrl}`,
          `Network events captured so far: ${context10.networkEventCount}`,
          `Steps completed: ${context10.stepsCompleted.length}`,
          context10.stepsCompleted.length > 0 ? `Recent actions: ${context10.stepsCompleted.slice(-3).map((s) => `${s.action.type}: ${s.action.reason}`).join(", ")}` : "",
          `
Page content:
${context10.pageContent}`
        ].filter(Boolean).join("\n");
        const response = await fetch("https://api.anthropic.com/v1/messages", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "x-api-key": config5.apiKey,
            "anthropic-version": "2023-06-01"
          },
          body: JSON.stringify({
            model,
            max_tokens: 512,
            system: SCOUT_SYSTEM_PROMPT,
            messages: [{ role: "user", content: userMessage }]
          })
        });
        if (!response.ok) {
          const text3 = await response.text();
          throw new Error(`Anthropic API error ${response.status}: ${text3}`);
        }
        const data = await response.json();
        const text2 = data.content.find((c) => c.type === "text")?.text;
        if (!text2) throw new Error("No text in Anthropic response");
        const jsonMatch = text2.match(/\{[\s\S]*\}/);
        if (!jsonMatch) throw new Error(`No JSON found in LLM response: ${text2}`);
        return JSON.parse(jsonMatch[0]);
      }, "try"),
      catch: /* @__PURE__ */ __name((e) => new BrowserError({ message: `LLM decision failed: ${e}` }), "catch")
    }), "decide")
  };
}
__name(makeAnthropicProvider, "makeAnthropicProvider");

// src/services/Browser.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();

// src/domain/NetworkEvent.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();
var NetworkEvent = class extends Schema_exports.Class("NetworkEvent")({
  requestId: Schema_exports.String,
  url: Schema_exports.String,
  method: Schema_exports.String,
  resourceType: Schema_exports.String,
  requestHeaders: Schema_exports.Record({ key: Schema_exports.String, value: Schema_exports.String }),
  requestBody: Schema_exports.optional(Schema_exports.String),
  responseStatus: Schema_exports.Number,
  responseHeaders: Schema_exports.Record({ key: Schema_exports.String, value: Schema_exports.String }),
  responseBody: Schema_exports.optional(Schema_exports.String),
  timestamp: Schema_exports.Number
}) {
  static {
    __name(this, "NetworkEvent");
  }
};
var API_RESOURCE_TYPES = /* @__PURE__ */ new Set(["fetch", "xhr", "document", "websocket", "other"]);
var IGNORED_URL_PATTERNS = [
  /\.png$/i,
  /\.jpg$/i,
  /\.jpeg$/i,
  /\.gif$/i,
  /\.svg$/i,
  /\.webp$/i,
  /\.ico$/i,
  /\.css$/i,
  /\.woff2?$/i,
  /\.ttf$/i,
  /\.eot$/i,
  /fonts\.googleapis\.com/i,
  /google-analytics\.com/i,
  /googletagmanager\.com/i,
  /facebook\.net/i,
  /doubleclick\.net/i,
  /hotjar\.com/i,
  /sentry\.io/i
];
function isApiRequest(resourceType, url3) {
  if (!API_RESOURCE_TYPES.has(resourceType)) return false;
  return !IGNORED_URL_PATTERNS.some((p) => p.test(url3));
}
__name(isApiRequest, "isApiRequest");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/puppeteer-cloudflare.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cloudflare/PuppeteerWorkers.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cloudflare/globalPatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { Buffer as Buffer2 } from "node:buffer";
globalThis.Buffer = Buffer2;

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/Puppeteer.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/BrowserConnector.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/BrowserConnector.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/util.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { Buffer as Buffer3 } from "node:buffer";

// node_modules/@cloudflare/puppeteer/lib/esm/third_party/rxjs/rxjs.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var extendStatics = /* @__PURE__ */ __name(function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
}, "extendStatics");
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  __name(__, "__");
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
__name(__extends, "__extends");
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value3) {
    return value3 instanceof P ? value3 : new P(function(resolve) {
      resolve(value3);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value3) {
      try {
        step4(generator.next(value3));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value3) {
      try {
        step4(generator["throw"](value3));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step4(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step4, "step");
    step4((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
__name(__awaiter, "__awaiter");
function __generator(thisArg, body) {
  var _ = { label: 0, sent: /* @__PURE__ */ __name(function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, "sent"), trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step4([n, v]);
    };
  }
  __name(verb, "verb");
  function step4(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
  __name(step4, "step");
}
__name(__generator, "__generator");
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: /* @__PURE__ */ __name(function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }, "next")
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
__name(__values, "__values");
function __read2(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error50) {
    e = { error: error50 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
__name(__read2, "__read");
function __spreadArray2(to, from2, pack2) {
  if (pack2 || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
__name(__spreadArray2, "__spreadArray");
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
__name(__await, "__await");
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n) {
    if (g[n]) i[n] = function(v) {
      return new Promise(function(a, b) {
        q.push([n, v, a, b]) > 1 || resume2(n, v);
      });
    };
  }
  __name(verb, "verb");
  function resume2(n, v) {
    try {
      step4(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  __name(resume2, "resume");
  function step4(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  __name(step4, "step");
  function fulfill(value3) {
    resume2("next", value3);
  }
  __name(fulfill, "fulfill");
  function reject(value3) {
    resume2("throw", value3);
  }
  __name(reject, "reject");
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume2(q[0][0], q[0][1]);
  }
  __name(settle, "settle");
}
__name(__asyncGenerator, "__asyncGenerator");
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  __name(verb, "verb");
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
  __name(settle, "settle");
}
__name(__asyncValues, "__asyncValues");
function isFunction3(value3) {
  return typeof value3 === "function";
}
__name(isFunction3, "isFunction");
function createErrorClass(createImpl) {
  var _super = /* @__PURE__ */ __name(function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  }, "_super");
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
__name(createErrorClass, "createErrorClass");
var UnsubscriptionError = createErrorClass(function(_super) {
  return /* @__PURE__ */ __name(function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  }, "UnsubscriptionErrorImpl");
});
function arrRemove(arr, item) {
  if (arr) {
    var index2 = arr.indexOf(item);
    0 <= index2 && arr.splice(index2, 1);
  }
}
__name(arrRemove, "arrRemove");
var Subscription = (function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  __name(Subscription2, "Subscription2");
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a2, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a2 = _parentage_1.return)) _a2.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction3(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer3 = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer3);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray2(__spreadArray2([], __read2(errors)), __read2(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a2;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== void 0 ? _a2 : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = (function() {
    var empty36 = new Subscription2();
    empty36.closed = true;
    return empty36;
  })();
  return Subscription2;
})();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value3) {
  return value3 instanceof Subscription || value3 && "closed" in value3 && isFunction3(value3.remove) && isFunction3(value3.add) && isFunction3(value3.unsubscribe);
}
__name(isSubscription, "isSubscription");
function execFinalizer(finalizer3) {
  if (isFunction3(finalizer3)) {
    finalizer3();
  } else {
    finalizer3.unsubscribe();
  }
}
__name(execFinalizer, "execFinalizer");
var config4 = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider = {
  setTimeout: /* @__PURE__ */ __name(function(handler, timeout6) {
    var args2 = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args2[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray2([handler, timeout6], __read2(args2)));
    }
    return setTimeout.apply(void 0, __spreadArray2([handler, timeout6], __read2(args2)));
  }, "setTimeout"),
  clearTimeout: /* @__PURE__ */ __name(function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  }, "clearTimeout"),
  delegate: void 0
};
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config4.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}
__name(reportUnhandledError, "reportUnhandledError");
function noop() {
}
__name(noop, "noop");
var COMPLETE_NOTIFICATION = (function() {
  return createNotification("C", void 0, void 0);
})();
function errorNotification(error50) {
  return createNotification("E", void 0, error50);
}
__name(errorNotification, "errorNotification");
function nextNotification(value3) {
  return createNotification("N", value3, void 0);
}
__name(nextNotification, "nextNotification");
function createNotification(kind, value3, error50) {
  return {
    kind,
    value: value3,
    error: error50
  };
}
__name(createNotification, "createNotification");
var context9 = null;
function errorContext(cb) {
  if (config4.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context9;
    if (isRoot) {
      context9 = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a2 = context9, errorThrown = _a2.errorThrown, error50 = _a2.error;
      context9 = null;
      if (errorThrown) {
        throw error50;
      }
    }
  } else {
    cb();
  }
}
__name(errorContext, "errorContext");
function captureError(err) {
  if (config4.useDeprecatedSynchronousErrorHandling && context9) {
    context9.errorThrown = true;
    context9.error = err;
  }
}
__name(captureError, "captureError");
var Subscriber = (function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  __name(Subscriber2, "Subscriber2");
  Subscriber2.create = function(next4, error50, complete3) {
    return new SafeSubscriber(next4, error50, complete3);
  };
  Subscriber2.prototype.next = function(value3) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value3), this);
    } else {
      this._next(value3);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value3) {
    this.destination.next(value3);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
})(Subscription);
var _bind = Function.prototype.bind;
function bind7(fn2, thisArg) {
  return _bind.call(fn2, thisArg);
}
__name(bind7, "bind");
var ConsumerObserver = (function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  __name(ConsumerObserver2, "ConsumerObserver2");
  ConsumerObserver2.prototype.next = function(value3) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value3);
      } catch (error50) {
        handleUnhandledError(error50);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error50) {
        handleUnhandledError(error50);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error50) {
        handleUnhandledError(error50);
      }
    }
  };
  return ConsumerObserver2;
})();
var SafeSubscriber = (function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error50, complete3) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction3(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error50 !== null && error50 !== void 0 ? error50 : void 0,
        complete: complete3 !== null && complete3 !== void 0 ? complete3 : void 0
      };
    } else {
      var context_1;
      if (_this && config4.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind7(observerOrNext.next, context_1),
          error: observerOrNext.error && bind7(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind7(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  __name(SafeSubscriber2, "SafeSubscriber2");
  return SafeSubscriber2;
})(Subscriber);
function handleUnhandledError(error50) {
  if (config4.useDeprecatedSynchronousErrorHandling) {
    captureError(error50);
  } else {
    reportUnhandledError(error50);
  }
}
__name(handleUnhandledError, "handleUnhandledError");
function defaultErrorHandler(err) {
  throw err;
}
__name(defaultErrorHandler, "defaultErrorHandler");
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config4.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
__name(handleStoppedNotification, "handleStoppedNotification");
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};
var observable = (function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
})();
function identity6(x) {
  return x;
}
__name(identity6, "identity");
function pipe3() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
__name(pipe3, "pipe");
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity6;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return /* @__PURE__ */ __name(function piped(input) {
    return fns.reduce(function(prev, fn2) {
      return fn2(prev);
    }, input);
  }, "piped");
}
__name(pipeFromArray, "pipeFromArray");
var Observable = (function() {
  function Observable2(subscribe4) {
    if (subscribe4) {
      this._subscribe = subscribe4;
    }
  }
  __name(Observable2, "Observable2");
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error50, complete3) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error50, complete3);
    errorContext(function() {
      var _a2 = _this, operator = _a2.operator, source2 = _a2.source;
      subscriber.add(operator ? operator.call(subscriber, source2) : source2 ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next4, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: /* @__PURE__ */ __name(function(value3) {
          try {
            next4(value3);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        }, "next"),
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a2;
    return (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value3;
      _this.subscribe(function(x) {
        return value3 = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value3);
      });
    });
  };
  Observable2.create = function(subscribe4) {
    return new Observable2(subscribe4);
  };
  return Observable2;
})();
function getPromiseCtor(promiseCtor) {
  var _a2;
  return (_a2 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config4.Promise) !== null && _a2 !== void 0 ? _a2 : Promise;
}
__name(getPromiseCtor, "getPromiseCtor");
function isObserver(value3) {
  return value3 && isFunction3(value3.next) && isFunction3(value3.error) && isFunction3(value3.complete);
}
__name(isObserver, "isObserver");
function isSubscriber(value3) {
  return value3 && value3 instanceof Subscriber || isObserver(value3) && isSubscription(value3);
}
__name(isSubscriber, "isSubscriber");
function hasLift(source2) {
  return isFunction3(source2 === null || source2 === void 0 ? void 0 : source2.lift);
}
__name(hasLift, "hasLift");
function operate(init) {
  return function(source2) {
    if (hasLift(source2)) {
      return source2.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
__name(operate, "operate");
function createOperatorSubscriber(destination, onNext, onComplete, onError5, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError5, onFinalize);
}
__name(createOperatorSubscriber, "createOperatorSubscriber");
var OperatorSubscriber = (function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError5, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value3) {
      try {
        onNext(value3);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError5 ? function(err) {
      try {
        onError5(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  __name(OperatorSubscriber2, "OperatorSubscriber2");
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a2;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a2 = this.onFinalize) === null || _a2 === void 0 ? void 0 : _a2.call(this));
    }
  };
  return OperatorSubscriber2;
})(Subscriber);
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return /* @__PURE__ */ __name(function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  }, "ObjectUnsubscribedErrorImpl");
});
var Subject = (function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  __name(Subject2, "Subject2");
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value3) {
    var _this = this;
    errorContext(function() {
      var e_1, _a2;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value3);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: /* @__PURE__ */ __name(function() {
      var _a2;
      return ((_a2 = this.observers) === null || _a2 === void 0 ? void 0 : _a2.length) > 0;
    }, "get"),
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a2 = this, hasError = _a2.hasError, isStopped = _a2.isStopped, observers = _a2.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, isStopped = _a2.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source2) {
    return new AnonymousSubject(destination, source2);
  };
  return Subject2;
})(Observable);
var AnonymousSubject = (function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source2) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source2;
    return _this;
  }
  __name(AnonymousSubject2, "AnonymousSubject2");
  AnonymousSubject2.prototype.next = function(value3) {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.next) === null || _b === void 0 ? void 0 : _b.call(_a2, value3);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.error) === null || _b === void 0 ? void 0 : _b.call(_a2, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.complete) === null || _b === void 0 ? void 0 : _b.call(_a2);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a2, _b;
    return (_b = (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
})(Subject);
var dateTimestampProvider = {
  now: /* @__PURE__ */ __name(function() {
    return (dateTimestampProvider.delegate || Date).now();
  }, "now"),
  delegate: void 0
};
var ReplaySubject = (function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  __name(ReplaySubject2, "ReplaySubject2");
  ReplaySubject2.prototype.next = function(value3) {
    var _a2 = this, isStopped = _a2.isStopped, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow, _timestampProvider = _a2._timestampProvider, _windowTime = _a2._windowTime;
    if (!isStopped) {
      _buffer.push(value3);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value3);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a2 = this, _infiniteTimeWindow = _a2._infiniteTimeWindow, _buffer = _a2._buffer;
    var copy4 = _buffer.slice();
    for (var i = 0; i < copy4.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy4[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a2 = this, _bufferSize = _a2._bufferSize, _timestampProvider = _a2._timestampProvider, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now2 = _timestampProvider.now();
      var last22 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now2; i += 2) {
        last22 = i;
      }
      last22 && _buffer.splice(0, last22 + 1);
    }
  };
  return ReplaySubject2;
})(Subject);
var Action = (function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler2, work) {
    return _super.call(this) || this;
  }
  __name(Action2, "Action2");
  Action2.prototype.schedule = function(state, delay22) {
    if (delay22 === void 0) {
      delay22 = 0;
    }
    return this;
  };
  return Action2;
})(Subscription);
var intervalProvider = {
  setInterval: /* @__PURE__ */ __name(function(handler, timeout6) {
    var args2 = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args2[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray2([handler, timeout6], __read2(args2)));
    }
    return setInterval.apply(void 0, __spreadArray2([handler, timeout6], __read2(args2)));
  }, "setInterval"),
  clearInterval: /* @__PURE__ */ __name(function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  }, "clearInterval"),
  delegate: void 0
};
var AsyncAction = (function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler2, work) {
    var _this = _super.call(this, scheduler2, work) || this;
    _this.scheduler = scheduler2;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  __name(AsyncAction2, "AsyncAction2");
  AsyncAction2.prototype.schedule = function(state, delay22) {
    var _a2;
    if (delay22 === void 0) {
      delay22 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id2 = this.id;
    var scheduler2 = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler2, id2, delay22);
    }
    this.pending = true;
    this.delay = delay22;
    this.id = (_a2 = this.id) !== null && _a2 !== void 0 ? _a2 : this.requestAsyncId(scheduler2, this.id, delay22);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler2, _id, delay22) {
    if (delay22 === void 0) {
      delay22 = 0;
    }
    return intervalProvider.setInterval(scheduler2.flush.bind(scheduler2, this), delay22);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id2, delay22) {
    if (delay22 === void 0) {
      delay22 = 0;
    }
    if (delay22 != null && this.delay === delay22 && this.pending === false) {
      return id2;
    }
    if (id2 != null) {
      intervalProvider.clearInterval(id2);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay22) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error50 = this._execute(state, delay22);
    if (error50) {
      return error50;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a2 = this, id2 = _a2.id, scheduler2 = _a2.scheduler;
      var actions = scheduler2.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id2 != null) {
        this.id = this.recycleAsyncId(scheduler2, id2, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
})(Action);
var Scheduler = (function() {
  function Scheduler2(schedulerActionCtor, now2) {
    if (now2 === void 0) {
      now2 = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now2;
  }
  __name(Scheduler2, "Scheduler2");
  Scheduler2.prototype.schedule = function(work, delay22, state) {
    if (delay22 === void 0) {
      delay22 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay22);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
})();
var AsyncScheduler = (function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now2) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  __name(AsyncScheduler2, "AsyncScheduler2");
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error50;
    this._active = true;
    do {
      if (error50 = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error50) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error50;
    }
  };
  return AsyncScheduler2;
})(Scheduler);
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async3 = asyncScheduler;
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});
function isScheduler(value3) {
  return value3 && isFunction3(value3.schedule);
}
__name(isScheduler, "isScheduler");
function last5(arr) {
  return arr[arr.length - 1];
}
__name(last5, "last");
function popScheduler(args2) {
  return isScheduler(last5(args2)) ? args2.pop() : void 0;
}
__name(popScheduler, "popScheduler");
function popNumber(args2, defaultValue) {
  return typeof last5(args2) === "number" ? args2.pop() : defaultValue;
}
__name(popNumber, "popNumber");
var isArrayLike = /* @__PURE__ */ __name(function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
}, "isArrayLike");
function isPromise(value3) {
  return isFunction3(value3 === null || value3 === void 0 ? void 0 : value3.then);
}
__name(isPromise, "isPromise");
function isInteropObservable(input) {
  return isFunction3(input[observable]);
}
__name(isInteropObservable, "isInteropObservable");
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction3(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
__name(isAsyncIterable, "isAsyncIterable");
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
__name(createInvalidObservableTypeError, "createInvalidObservableTypeError");
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
__name(getSymbolIterator, "getSymbolIterator");
var iterator = getSymbolIterator();
function isIterable2(input) {
  return isFunction3(input === null || input === void 0 ? void 0 : input[iterator]);
}
__name(isIterable2, "isIterable");
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, /* @__PURE__ */ __name(function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a2, value3, done13;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a2 = _b.sent(), value3 = _a2.value, done13 = _a2.done;
          if (!done13) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value3)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  }, "readableStreamLikeToAsyncGenerator_1"));
}
__name(readableStreamLikeToAsyncGenerator, "readableStreamLikeToAsyncGenerator");
function isReadableStreamLike(obj) {
  return isFunction3(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
__name(isReadableStreamLike, "isReadableStreamLike");
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable3(input);
    }
    if (isIterable2(input)) {
      return fromIterable16(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
__name(innerFrom, "innerFrom");
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction3(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
__name(fromInteropObservable, "fromInteropObservable");
function fromArrayLike(array7) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array7.length && !subscriber.closed; i++) {
      subscriber.next(array7[i]);
    }
    subscriber.complete();
  });
}
__name(fromArrayLike, "fromArrayLike");
function fromPromise(promise4) {
  return new Observable(function(subscriber) {
    promise4.then(function(value3) {
      if (!subscriber.closed) {
        subscriber.next(value3);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
__name(fromPromise, "fromPromise");
function fromIterable16(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a2;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value3 = iterable_1_1.value;
        subscriber.next(value3);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a2 = iterable_1.return)) _a2.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
__name(fromIterable16, "fromIterable");
function fromAsyncIterable3(asyncIterable) {
  return new Observable(function(subscriber) {
    process3(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
__name(fromAsyncIterable3, "fromAsyncIterable");
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable3(readableStreamLikeToAsyncGenerator(readableStream));
}
__name(fromReadableStreamLike, "fromReadableStreamLike");
function process3(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a2;
  return __awaiter(this, void 0, void 0, function() {
    var value3, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value3 = asyncIterable_1_1.value;
          subscriber.next(value3);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a2 = asyncIterable_1.return))) return [3, 8];
          return [4, _a2.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
__name(process3, "process");
function executeSchedule(parentSubscription, scheduler2, work, delay22, repeat5) {
  if (delay22 === void 0) {
    delay22 = 0;
  }
  if (repeat5 === void 0) {
    repeat5 = false;
  }
  var scheduleSubscription = scheduler2.schedule(function() {
    work();
    if (repeat5) {
      parentSubscription.add(this.schedule(null, delay22));
    } else {
      this.unsubscribe();
    }
  }, delay22);
  parentSubscription.add(scheduleSubscription);
  if (!repeat5) {
    return scheduleSubscription;
  }
}
__name(executeSchedule, "executeSchedule");
function observeOn(scheduler2, delay22) {
  if (delay22 === void 0) {
    delay22 = 0;
  }
  return operate(function(source2, subscriber) {
    source2.subscribe(createOperatorSubscriber(subscriber, function(value3) {
      return executeSchedule(subscriber, scheduler2, function() {
        return subscriber.next(value3);
      }, delay22);
    }, function() {
      return executeSchedule(subscriber, scheduler2, function() {
        return subscriber.complete();
      }, delay22);
    }, function(err) {
      return executeSchedule(subscriber, scheduler2, function() {
        return subscriber.error(err);
      }, delay22);
    }));
  });
}
__name(observeOn, "observeOn");
function subscribeOn(scheduler2, delay22) {
  if (delay22 === void 0) {
    delay22 = 0;
  }
  return operate(function(source2, subscriber) {
    subscriber.add(scheduler2.schedule(function() {
      return source2.subscribe(subscriber);
    }, delay22));
  });
}
__name(subscribeOn, "subscribeOn");
function scheduleObservable(input, scheduler2) {
  return innerFrom(input).pipe(subscribeOn(scheduler2), observeOn(scheduler2));
}
__name(scheduleObservable, "scheduleObservable");
function schedulePromise(input, scheduler2) {
  return innerFrom(input).pipe(subscribeOn(scheduler2), observeOn(scheduler2));
}
__name(schedulePromise, "schedulePromise");
function scheduleArray(input, scheduler2) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler2.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
__name(scheduleArray, "scheduleArray");
function scheduleIterable(input, scheduler2) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler2, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler2, function() {
        var _a2;
        var value3;
        var done13;
        try {
          _a2 = iterator2.next(), value3 = _a2.value, done13 = _a2.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done13) {
          subscriber.complete();
        } else {
          subscriber.next(value3);
        }
      }, 0, true);
    });
    return function() {
      return isFunction3(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}
__name(scheduleIterable, "scheduleIterable");
function scheduleAsyncIterable(input, scheduler2) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler2, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler2, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
__name(scheduleAsyncIterable, "scheduleAsyncIterable");
function scheduleReadableStreamLike(input, scheduler2) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler2);
}
__name(scheduleReadableStreamLike, "scheduleReadableStreamLike");
function scheduled(input, scheduler2) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler2);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler2);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler2);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler2);
    }
    if (isIterable2(input)) {
      return scheduleIterable(input, scheduler2);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler2);
    }
  }
  throw createInvalidObservableTypeError(input);
}
__name(scheduled, "scheduled");
function from(input, scheduler2) {
  return scheduler2 ? scheduled(input, scheduler2) : innerFrom(input);
}
__name(from, "from");
function of6() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler2 = popScheduler(args2);
  return from(args2, scheduler2);
}
__name(of6, "of");
var EmptyError = createErrorClass(function(_super) {
  return /* @__PURE__ */ __name(function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  }, "EmptyErrorImpl");
});
function firstValueFrom(source2, config22) {
  var hasConfig = typeof config22 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: /* @__PURE__ */ __name(function(value3) {
        resolve(value3);
        subscriber.unsubscribe();
      }, "next"),
      error: reject,
      complete: /* @__PURE__ */ __name(function() {
        if (hasConfig) {
          resolve(config22.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }, "complete")
    });
    source2.subscribe(subscriber);
  });
}
__name(firstValueFrom, "firstValueFrom");
function isValidDate(value3) {
  return value3 instanceof Date && !isNaN(value3);
}
__name(isValidDate, "isValidDate");
function map30(project3, thisArg) {
  return operate(function(source2, subscriber) {
    var index2 = 0;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value3) {
      subscriber.next(project3.call(thisArg, value3, index2++));
    }));
  });
}
__name(map30, "map");
var isArray2 = Array.isArray;
function callOrApply(fn2, args2) {
  return isArray2(args2) ? fn2.apply(void 0, __spreadArray2([], __read2(args2))) : fn2(args2);
}
__name(callOrApply, "callOrApply");
function mapOneOrManyArgs(fn2) {
  return map30(function(args2) {
    return callOrApply(fn2, args2);
  });
}
__name(mapOneOrManyArgs, "mapOneOrManyArgs");
var objectProto = Object.prototype;
function mergeInternals(source2, subscriber, project3, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer3 = [];
  var active2 = 0;
  var index2 = 0;
  var isComplete = false;
  var checkComplete = /* @__PURE__ */ __name(function() {
    if (isComplete && !buffer3.length && !active2) {
      subscriber.complete();
    }
  }, "checkComplete");
  var outerNext = /* @__PURE__ */ __name(function(value3) {
    return active2 < concurrent ? doInnerSub(value3) : buffer3.push(value3);
  }, "outerNext");
  var doInnerSub = /* @__PURE__ */ __name(function(value3) {
    expand2 && subscriber.next(value3);
    active2++;
    var innerComplete = false;
    innerFrom(project3(value3, index2++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active2--;
          var _loop_1 = /* @__PURE__ */ __name(function() {
            var bufferedValue = buffer3.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          }, "_loop_1");
          while (buffer3.length && active2 < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  }, "doInnerSub");
  source2.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
__name(mergeInternals, "mergeInternals");
function mergeMap2(project3, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction3(resultSelector)) {
    return mergeMap2(function(a, i) {
      return map30(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project3(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source2, subscriber) {
    return mergeInternals(source2, subscriber, project3, concurrent);
  });
}
__name(mergeMap2, "mergeMap");
function mergeAll10(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap2(identity6, concurrent);
}
__name(mergeAll10, "mergeAll");
function concatAll4() {
  return mergeAll10(1);
}
__name(concatAll4, "concatAll");
function concat4() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  return concatAll4()(from(args2, popScheduler(args2)));
}
__name(concat4, "concat");
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}
__name(defer, "defer");
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction3(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a2 = __read2(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add7 = _a2[0], remove8 = _a2[1];
  if (!add7) {
    if (isArrayLike(target)) {
      return mergeMap2(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add7) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = /* @__PURE__ */ __name(function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      return subscriber.next(1 < args2.length ? args2 : args2[0]);
    }, "handler");
    add7(handler);
    return function() {
      return remove8(handler);
    };
  });
}
__name(fromEvent, "fromEvent");
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
__name(toCommonHandlerRegistry, "toCommonHandlerRegistry");
function isNodeStyleEventEmitter(target) {
  return isFunction3(target.addListener) && isFunction3(target.removeListener);
}
__name(isNodeStyleEventEmitter, "isNodeStyleEventEmitter");
function isJQueryStyleEventEmitter(target) {
  return isFunction3(target.on) && isFunction3(target.off);
}
__name(isJQueryStyleEventEmitter, "isJQueryStyleEventEmitter");
function isEventTarget(target) {
  return isFunction3(target.addEventListener) && isFunction3(target.removeEventListener);
}
__name(isEventTarget, "isEventTarget");
function timer(dueTime, intervalOrScheduler, scheduler2) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler2 === void 0) {
    scheduler2 = async3;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler2 = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler2.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler2.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}
__name(timer, "timer");
function merge12() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler2 = popScheduler(args2);
  var concurrent = popNumber(args2, Infinity);
  var sources = args2;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll10(concurrent)(from(sources, scheduler2));
}
__name(merge12, "merge");
var NEVER2 = new Observable(noop);
var isArray3 = Array.isArray;
function argsOrArgArray(args2) {
  return args2.length === 1 && isArray3(args2[0]) ? args2[0] : args2;
}
__name(argsOrArgArray, "argsOrArgArray");
function filter13(predicate, thisArg) {
  return operate(function(source2, subscriber) {
    var index2 = 0;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value3) {
      return predicate.call(thisArg, value3, index2++) && subscriber.next(value3);
    }));
  });
}
__name(filter13, "filter");
function race5() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  sources = argsOrArgArray(sources);
  return sources.length === 1 ? innerFrom(sources[0]) : new Observable(raceInit(sources));
}
__name(race5, "race");
function raceInit(sources) {
  return function(subscriber) {
    var subscriptions = [];
    var _loop_1 = /* @__PURE__ */ __name(function(i2) {
      subscriptions.push(innerFrom(sources[i2]).subscribe(createOperatorSubscriber(subscriber, function(value3) {
        if (subscriptions) {
          for (var s = 0; s < subscriptions.length; s++) {
            s !== i2 && subscriptions[s].unsubscribe();
          }
          subscriptions = null;
        }
        subscriber.next(value3);
      })));
    }, "_loop_1");
    for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
      _loop_1(i);
    }
  };
}
__name(raceInit, "raceInit");
function catchError(selector) {
  return operate(function(source2, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source2.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source2)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}
__name(catchError, "catchError");
function defaultIfEmpty(defaultValue) {
  return operate(function(source2, subscriber) {
    var hasValue = false;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value3) {
      hasValue = true;
      subscriber.next(value3);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}
__name(defaultIfEmpty, "defaultIfEmpty");
function take9(count6) {
  return count6 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source2, subscriber) {
    var seen = 0;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value3) {
      if (++seen <= count6) {
        subscriber.next(value3);
        if (count6 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
__name(take9, "take");
function ignoreElements() {
  return operate(function(source2, subscriber) {
    source2.subscribe(createOperatorSubscriber(subscriber, noop));
  });
}
__name(ignoreElements, "ignoreElements");
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return operate(function(source2, subscriber) {
    var hasValue = false;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value3) {
      hasValue = true;
      subscriber.next(value3);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
__name(throwIfEmpty, "throwIfEmpty");
function defaultErrorFactory() {
  return new EmptyError();
}
__name(defaultErrorFactory, "defaultErrorFactory");
function first2(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source2) {
    return source2.pipe(predicate ? filter13(function(v, i) {
      return predicate(v, i, source2);
    }) : identity6, take9(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
__name(first2, "first");
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return operate(function(source2, subscriber) {
    var state = seed;
    return mergeInternals(source2, subscriber, function(value3, index2) {
      return accumulator(state, value3, index2);
    }, concurrent, function(value3) {
      state = value3;
    }, false, void 0, function() {
      return state = null;
    });
  });
}
__name(mergeScan, "mergeScan");
function raceWith4() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return !otherSources.length ? identity6 : operate(function(source2, subscriber) {
    raceInit(__spreadArray2([source2], __read2(otherSources)))(subscriber);
  });
}
__name(raceWith4, "raceWith");
function retry8(configOrCount) {
  if (configOrCount === void 0) {
    configOrCount = Infinity;
  }
  var config22;
  if (configOrCount && typeof configOrCount === "object") {
    config22 = configOrCount;
  } else {
    config22 = {
      count: configOrCount
    };
  }
  var _a2 = config22.count, count6 = _a2 === void 0 ? Infinity : _a2, delay22 = config22.delay, _b = config22.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
  return count6 <= 0 ? identity6 : operate(function(source2, subscriber) {
    var soFar = 0;
    var innerSub;
    var subscribeForRetry = /* @__PURE__ */ __name(function() {
      var syncUnsub = false;
      innerSub = source2.subscribe(createOperatorSubscriber(subscriber, function(value3) {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value3);
      }, void 0, function(err) {
        if (soFar++ < count6) {
          var resub_1 = /* @__PURE__ */ __name(function() {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          }, "resub_1");
          if (delay22 != null) {
            var notifier = typeof delay22 === "number" ? timer(delay22) : innerFrom(delay22(err, soFar));
            var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              resub_1();
            }, function() {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            resub_1();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    }, "subscribeForRetry");
    subscribeForRetry();
  });
}
__name(retry8, "retry");
function startWith() {
  var values4 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values4[_i] = arguments[_i];
  }
  var scheduler2 = popScheduler(values4);
  return operate(function(source2, subscriber) {
    (scheduler2 ? concat4(values4, source2, scheduler2) : concat4(values4, source2)).subscribe(subscriber);
  });
}
__name(startWith, "startWith");
function switchMap(project3, resultSelector) {
  return operate(function(source2, subscriber) {
    var innerSubscriber = null;
    var index2 = 0;
    var isComplete = false;
    var checkComplete = /* @__PURE__ */ __name(function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    }, "checkComplete");
    source2.subscribe(createOperatorSubscriber(subscriber, function(value3) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index2++;
      innerFrom(project3(value3, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value3, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}
__name(switchMap, "switchMap");
function takeUntil5(notifier) {
  return operate(function(source2, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source2.subscribe(subscriber);
  });
}
__name(takeUntil5, "takeUntil");
function tap9(observerOrNext, error50, complete3) {
  var tapObserver = isFunction3(observerOrNext) || error50 || complete3 ? { next: observerOrNext, error: error50, complete: complete3 } : observerOrNext;
  return tapObserver ? operate(function(source2, subscriber) {
    var _a2;
    (_a2 = tapObserver.subscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
    var isUnsub = true;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value3) {
      var _a22;
      (_a22 = tapObserver.next) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver, value3);
      subscriber.next(value3);
    }, function() {
      var _a22;
      isUnsub = false;
      (_a22 = tapObserver.complete) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a22;
      isUnsub = false;
      (_a22 = tapObserver.error) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a22, _b;
      if (isUnsub) {
        (_a22 = tapObserver.unsubscribe) === null || _a22 === void 0 ? void 0 : _a22.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity6;
}
__name(tap9, "tap");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/util.js
init_version2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/util/assert.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var assert5 = /* @__PURE__ */ __name((value3, message) => {
  if (!value3) {
    throw new Error(message);
  }
}, "assert");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/Debug.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/environment.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isNode = !!(typeof process !== "undefined" && process.version);

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/Debug.js
var debugModule = null;
async function importDebug() {
  if (!debugModule) {
    debugModule = (await Promise.resolve().then(() => __toESM(require_src(), 1))).default;
  }
  return debugModule;
}
__name(importDebug, "importDebug");
var debug3 = /* @__PURE__ */ __name((prefix) => {
  if (isNode) {
    return async (...logArgs) => {
      if (captureLogs) {
        capturedLogs.push(prefix + logArgs);
      }
      const debugLevel = process.env["DEBUG"] || "";
      const everythingShouldBeLogged = debugLevel === "*";
      const prefixMatchesDebugLevel = everythingShouldBeLogged || (debugLevel.endsWith("*") ? prefix.startsWith(debugLevel) : prefix === debugLevel);
      if (!prefixMatchesDebugLevel) {
        return;
      }
      (await importDebug())(prefix)(logArgs);
    };
  }
  return (...logArgs) => {
    const debugLevel = globalThis.__PUPPETEER_DEBUG;
    if (!debugLevel) {
      return;
    }
    const everythingShouldBeLogged = debugLevel === "*";
    const prefixMatchesDebugLevel = everythingShouldBeLogged || /**
     * If the debug level is `foo*`, that means we match any prefix that
     * starts with `foo`. If the level is `foo`, we match only the prefix
     * `foo`.
     */
    (debugLevel.endsWith("*") ? prefix.startsWith(debugLevel) : prefix === debugLevel);
    if (!prefixMatchesDebugLevel) {
      return;
    }
    console.log(`${prefix}:`, ...logArgs);
  };
}, "debug");
var capturedLogs = [];
var captureLogs = false;

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/Errors.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var PuppeteerError = class extends Error {
  static {
    __name(this, "PuppeteerError");
  }
  /**
   * @internal
   */
  constructor(message, options) {
    super(message, options);
    this.name = this.constructor.name;
  }
  /**
   * @internal
   */
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
};
var TimeoutError = class extends PuppeteerError {
  static {
    __name(this, "TimeoutError");
  }
};
var ProtocolError = class extends PuppeteerError {
  static {
    __name(this, "ProtocolError");
  }
  #code;
  #originalMessage = "";
  set code(code) {
    this.#code = code;
  }
  /**
   * @readonly
   * @public
   */
  get code() {
    return this.#code;
  }
  set originalMessage(originalMessage) {
    this.#originalMessage = originalMessage;
  }
  /**
   * @readonly
   * @public
   */
  get originalMessage() {
    return this.#originalMessage;
  }
};
var UnsupportedOperation = class extends PuppeteerError {
  static {
    __name(this, "UnsupportedOperation");
  }
};
var TargetCloseError = class extends ProtocolError {
  static {
    __name(this, "TargetCloseError");
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/PDFOptions.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var paperFormats = {
  letter: { width: 8.5, height: 11 },
  legal: { width: 8.5, height: 14 },
  tabloid: { width: 11, height: 17 },
  ledger: { width: 17, height: 11 },
  a0: { width: 33.1, height: 46.8 },
  a1: { width: 23.4, height: 33.1 },
  a2: { width: 16.54, height: 23.4 },
  a3: { width: 11.7, height: 16.54 },
  a4: { width: 8.27, height: 11.7 },
  a5: { width: 5.83, height: 8.27 },
  a6: { width: 4.13, height: 5.83 }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/util.js
var debugError = debug3("puppeteer:error");
var DEFAULT_VIEWPORT = Object.freeze({ width: 800, height: 600 });
var SOURCE_URL = Symbol("Source URL for Puppeteer evaluation scripts");
var PuppeteerURL = class _PuppeteerURL {
  static {
    __name(this, "PuppeteerURL");
  }
  static INTERNAL_URL = "pptr:internal";
  static fromCallSite(functionName, site) {
    const url3 = new _PuppeteerURL();
    url3.#functionName = functionName;
    url3.#siteString = site.toString();
    return url3;
  }
  static parse = /* @__PURE__ */ __name((url3) => {
    url3 = url3.slice("pptr:".length);
    const [functionName = "", siteString = ""] = url3.split(";");
    const puppeteerUrl = new _PuppeteerURL();
    puppeteerUrl.#functionName = functionName;
    puppeteerUrl.#siteString = decodeURIComponent(siteString);
    return puppeteerUrl;
  }, "parse");
  static isPuppeteerURL = /* @__PURE__ */ __name((url3) => {
    return url3.startsWith("pptr:");
  }, "isPuppeteerURL");
  #functionName;
  #siteString;
  get functionName() {
    return this.#functionName;
  }
  get siteString() {
    return this.#siteString;
  }
  toString() {
    return `pptr:${[
      this.#functionName,
      encodeURIComponent(this.#siteString)
    ].join(";")}`;
  }
};
var withSourcePuppeteerURLIfNone = /* @__PURE__ */ __name((functionName, object4) => {
  if (Object.prototype.hasOwnProperty.call(object4, SOURCE_URL)) {
    return object4;
  }
  const original = Error.prepareStackTrace;
  Error.prepareStackTrace = (_, stack) => {
    return stack[2];
  };
  const site = new Error().stack;
  Error.prepareStackTrace = original;
  return Object.assign(object4, {
    [SOURCE_URL]: PuppeteerURL.fromCallSite(functionName, site)
  });
}, "withSourcePuppeteerURLIfNone");
var getSourcePuppeteerURLIfAvailable = /* @__PURE__ */ __name((object4) => {
  if (Object.prototype.hasOwnProperty.call(object4, SOURCE_URL)) {
    return object4[SOURCE_URL];
  }
  return void 0;
}, "getSourcePuppeteerURLIfAvailable");
var isString2 = /* @__PURE__ */ __name((obj) => {
  return typeof obj === "string" || obj instanceof String;
}, "isString");
var isNumber2 = /* @__PURE__ */ __name((obj) => {
  return typeof obj === "number" || obj instanceof Number;
}, "isNumber");
function evaluationString(fun, ...args2) {
  if (isString2(fun)) {
    assert5(args2.length === 0, "Cannot evaluate a string with arguments");
    return fun;
  }
  function serializeArgument(arg) {
    if (Object.is(arg, void 0)) {
      return "undefined";
    }
    return JSON.stringify(arg);
  }
  __name(serializeArgument, "serializeArgument");
  const script = `(${fun})(${args2.map(serializeArgument).join(",")})`;
  return globalThis.navigator?.userAgent === "Cloudflare-Workers" ? `((__name => (${script}))(t => t))` : script;
}
__name(evaluationString, "evaluationString");
var fs = null;
async function importFSPromises() {
  if (!fs) {
    try {
      fs = await import("fs/promises");
    } catch (error50) {
      if (error50 instanceof TypeError) {
        throw new Error("Cannot write to a path outside of a Node-like environment. fs");
      }
      throw error50;
    }
  }
  return fs;
}
__name(importFSPromises, "importFSPromises");
async function getReadableAsBuffer(readable, path) {
  const buffers = [];
  const reader = readable.getReader();
  if (path) {
    throw new Error("Cannot write to a path outside of a Node-like environment.");
  } else {
    while (true) {
      const { done: done13, value: value3 } = await reader.read();
      if (done13) {
        break;
      }
      buffers.push(value3);
    }
  }
  try {
    return Buffer3.concat(buffers);
  } catch (error50) {
    debugError(error50);
    return null;
  }
}
__name(getReadableAsBuffer, "getReadableAsBuffer");
async function getReadableFromProtocolStream(client, handle) {
  return new ReadableStream({
    async pull(controller) {
      function getUnit8Array(data2, isBase64) {
        if (isBase64) {
          if (typeof Buffer3 === "function") {
            return Buffer3.from(data2, "base64");
          }
          return Uint8Array.from(atob(data2), (m) => {
            return m.codePointAt(0);
          });
        }
        const encoder2 = new TextEncoder();
        return encoder2.encode(data2);
      }
      __name(getUnit8Array, "getUnit8Array");
      const { data, base64Encoded, eof } = await client.send("IO.read", {
        handle
      });
      controller.enqueue(getUnit8Array(data, base64Encoded ?? false));
      if (eof) {
        await client.send("IO.close", { handle });
        controller.close();
      }
    }
  });
}
__name(getReadableFromProtocolStream, "getReadableFromProtocolStream");
function validateDialogType(type) {
  let dialogType = null;
  const validDialogTypes = /* @__PURE__ */ new Set([
    "alert",
    "confirm",
    "prompt",
    "beforeunload"
  ]);
  if (validDialogTypes.has(type)) {
    dialogType = type;
  }
  assert5(dialogType, `Unknown javascript dialog type: ${type}`);
  return dialogType;
}
__name(validateDialogType, "validateDialogType");
function timeout5(ms, cause3) {
  return ms === 0 ? NEVER2 : timer(ms).pipe(map30(() => {
    throw new TimeoutError(`Timed out after waiting ${ms}ms`, { cause: cause3 });
  }));
}
__name(timeout5, "timeout");
var UTILITY_WORLD_NAME = "__puppeteer_utility_world__" + packageVersion;
var SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
function getSourceUrlComment(url3) {
  return `//# sourceURL=${url3}`;
}
__name(getSourceUrlComment, "getSourceUrlComment");
var NETWORK_IDLE_TIME = 500;
function parsePDFOptions(options = {}, lengthUnit = "in") {
  const defaults = {
    scale: 1,
    displayHeaderFooter: false,
    headerTemplate: "",
    footerTemplate: "",
    printBackground: false,
    landscape: false,
    pageRanges: "",
    preferCSSPageSize: false,
    omitBackground: false,
    outline: false,
    tagged: true,
    waitForFonts: true
  };
  let width = 8.5;
  let height = 11;
  if (options.format) {
    const format7 = paperFormats[options.format.toLowerCase()];
    assert5(format7, "Unknown paper format: " + options.format);
    width = format7.width;
    height = format7.height;
  } else {
    width = convertPrintParameterToInches(options.width, lengthUnit) ?? width;
    height = convertPrintParameterToInches(options.height, lengthUnit) ?? height;
  }
  const margin = {
    top: convertPrintParameterToInches(options.margin?.top, lengthUnit) || 0,
    left: convertPrintParameterToInches(options.margin?.left, lengthUnit) || 0,
    bottom: convertPrintParameterToInches(options.margin?.bottom, lengthUnit) || 0,
    right: convertPrintParameterToInches(options.margin?.right, lengthUnit) || 0
  };
  if (options.outline) {
    options.tagged = true;
  }
  return {
    ...defaults,
    ...options,
    width,
    height,
    margin
  };
}
__name(parsePDFOptions, "parsePDFOptions");
var unitToPixels = {
  px: 1,
  in: 96,
  cm: 37.8,
  mm: 3.78
};
function convertPrintParameterToInches(parameter, lengthUnit = "in") {
  if (typeof parameter === "undefined") {
    return void 0;
  }
  let pixels;
  if (isNumber2(parameter)) {
    pixels = parameter;
  } else if (isString2(parameter)) {
    const text2 = parameter;
    let unit = text2.substring(text2.length - 2).toLowerCase();
    let valueText = "";
    if (unit in unitToPixels) {
      valueText = text2.substring(0, text2.length - 2);
    } else {
      unit = "px";
      valueText = text2;
    }
    const value3 = Number(valueText);
    assert5(!isNaN(value3), "Failed to parse parameter value: " + text2);
    pixels = value3 * unitToPixels[unit];
  } else {
    throw new Error("page.pdf() Cannot handle parameter type: " + typeof parameter);
  }
  return pixels / unitToPixels[lengthUnit];
}
__name(convertPrintParameterToInches, "convertPrintParameterToInches");
function fromEmitterEvent(emitter, eventName) {
  return new Observable((subscriber) => {
    const listener = /* @__PURE__ */ __name((event) => {
      subscriber.next(event);
    }, "listener");
    emitter.on(eventName, listener);
    return () => {
      emitter.off(eventName, listener);
    };
  });
}
__name(fromEmitterEvent, "fromEmitterEvent");
function fromAbortSignal(signal, cause3) {
  return signal ? fromEvent(signal, "abort").pipe(map30(() => {
    if (signal.reason instanceof Error) {
      signal.reason.cause = cause3;
      throw signal.reason;
    }
    throw new Error(signal.reason, { cause: cause3 });
  })) : NEVER2;
}
__name(fromAbortSignal, "fromAbortSignal");
function filterAsync(predicate) {
  return mergeMap2((value3) => {
    return from(Promise.resolve(predicate(value3))).pipe(filter13((isMatch) => {
      return isMatch;
    }), map30(() => {
      return value3;
    }));
  });
}
__name(filterAsync, "filterAsync");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Browser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/Browser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/EventEmitter.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/third_party/mitt/mitt.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function mitt_default(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: /* @__PURE__ */ __name(function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, "on"), off: /* @__PURE__ */ __name(function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, "off"), emit: /* @__PURE__ */ __name(function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  }, "emit") };
}
__name(mitt_default, "mitt_default");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/util/disposable.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
Symbol.dispose ??= Symbol("dispose");
Symbol.asyncDispose ??= Symbol("asyncDispose");
var disposeSymbol = Symbol.dispose;
var asyncDisposeSymbol = Symbol.asyncDispose;
var DisposableStack = class _DisposableStack {
  static {
    __name(this, "DisposableStack");
  }
  #disposed = false;
  #stack = [];
  /**
   * Returns a value indicating whether this stack has been disposed.
   */
  get disposed() {
    return this.#disposed;
  }
  /**
   * Disposes each resource in the stack in the reverse order that they were added.
   */
  dispose() {
    if (this.#disposed) {
      return;
    }
    this.#disposed = true;
    for (const resource of this.#stack.reverse()) {
      resource[disposeSymbol]();
    }
  }
  /**
   * Adds a disposable resource to the stack, returning the resource.
   *
   * @param value - The resource to add. `null` and `undefined` will not be added,
   * but will be returned.
   * @returns The provided `value`.
   */
  use(value3) {
    if (value3) {
      this.#stack.push(value3);
    }
    return value3;
  }
  /**
   * Adds a value and associated disposal callback as a resource to the stack.
   *
   * @param value - The value to add.
   * @param onDispose - The callback to use in place of a `[disposeSymbol]()`
   * method. Will be invoked with `value` as the first parameter.
   * @returns The provided `value`.
   */
  adopt(value3, onDispose) {
    this.#stack.push({
      [disposeSymbol]() {
        onDispose(value3);
      }
    });
    return value3;
  }
  /**
   * Adds a callback to be invoked when the stack is disposed.
   */
  defer(onDispose) {
    this.#stack.push({
      [disposeSymbol]() {
        onDispose();
      }
    });
  }
  /**
   * Move all resources out of this stack and into a new `DisposableStack`, and
   * marks this stack as disposed.
   *
   * @example
   *
   * ```ts
   * class C {
   *   #res1: Disposable;
   *   #res2: Disposable;
   *   #disposables: DisposableStack;
   *   constructor() {
   *     // stack will be disposed when exiting constructor for any reason
   *     using stack = new DisposableStack();
   *
   *     // get first resource
   *     this.#res1 = stack.use(getResource1());
   *
   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
   *     this.#res2 = stack.use(getResource2());
   *
   *     // all operations succeeded, move resources out of `stack` so that
   *     // they aren't disposed when constructor exits
   *     this.#disposables = stack.move();
   *   }
   *
   *   [disposeSymbol]() {
   *     this.#disposables.dispose();
   *   }
   * }
   * ```
   */
  move() {
    if (this.#disposed) {
      throw new ReferenceError("a disposed stack can not use anything new");
    }
    const stack = new _DisposableStack();
    stack.#stack = this.#stack;
    this.#disposed = true;
    return stack;
  }
  [disposeSymbol] = this.dispose;
  [Symbol.toStringTag] = "DisposableStack";
};
var AsyncDisposableStack = class _AsyncDisposableStack {
  static {
    __name(this, "AsyncDisposableStack");
  }
  #disposed = false;
  #stack = [];
  /**
   * Returns a value indicating whether this stack has been disposed.
   */
  get disposed() {
    return this.#disposed;
  }
  /**
   * Disposes each resource in the stack in the reverse order that they were added.
   */
  async dispose() {
    if (this.#disposed) {
      return;
    }
    this.#disposed = true;
    for (const resource of this.#stack.reverse()) {
      await resource[asyncDisposeSymbol]();
    }
  }
  /**
   * Adds a disposable resource to the stack, returning the resource.
   *
   * @param value - The resource to add. `null` and `undefined` will not be added,
   * but will be returned.
   * @returns The provided `value`.
   */
  use(value3) {
    if (value3) {
      this.#stack.push(value3);
    }
    return value3;
  }
  /**
   * Adds a value and associated disposal callback as a resource to the stack.
   *
   * @param value - The value to add.
   * @param onDispose - The callback to use in place of a `[disposeSymbol]()`
   * method. Will be invoked with `value` as the first parameter.
   * @returns The provided `value`.
   */
  adopt(value3, onDispose) {
    this.#stack.push({
      [asyncDisposeSymbol]() {
        return onDispose(value3);
      }
    });
    return value3;
  }
  /**
   * Adds a callback to be invoked when the stack is disposed.
   */
  defer(onDispose) {
    this.#stack.push({
      [asyncDisposeSymbol]() {
        return onDispose();
      }
    });
  }
  /**
   * Move all resources out of this stack and into a new `DisposableStack`, and
   * marks this stack as disposed.
   *
   * @example
   *
   * ```ts
   * class C {
   *   #res1: Disposable;
   *   #res2: Disposable;
   *   #disposables: DisposableStack;
   *   constructor() {
   *     // stack will be disposed when exiting constructor for any reason
   *     using stack = new DisposableStack();
   *
   *     // get first resource
   *     this.#res1 = stack.use(getResource1());
   *
   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
   *     this.#res2 = stack.use(getResource2());
   *
   *     // all operations succeeded, move resources out of `stack` so that
   *     // they aren't disposed when constructor exits
   *     this.#disposables = stack.move();
   *   }
   *
   *   [disposeSymbol]() {
   *     this.#disposables.dispose();
   *   }
   * }
   * ```
   */
  move() {
    if (this.#disposed) {
      throw new ReferenceError("a disposed stack can not use anything new");
    }
    const stack = new _AsyncDisposableStack();
    stack.#stack = this.#stack;
    this.#disposed = true;
    return stack;
  }
  [asyncDisposeSymbol] = this.dispose;
  [Symbol.toStringTag] = "AsyncDisposableStack";
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/EventEmitter.js
var EventEmitter2 = class {
  static {
    __name(this, "EventEmitter");
  }
  #emitter;
  #handlers = /* @__PURE__ */ new Map();
  /**
   * If you pass an emitter, the returned emitter will wrap the passed emitter.
   *
   * @internal
   */
  constructor(emitter = mitt_default(/* @__PURE__ */ new Map())) {
    this.#emitter = emitter;
  }
  /**
   * Bind an event listener to fire when an event occurs.
   * @param type - the event type you'd like to listen to. Can be a string or symbol.
   * @param handler - the function to be called when the event occurs.
   * @returns `this` to enable you to chain method calls.
   */
  on(type, handler) {
    const handlers = this.#handlers.get(type);
    if (handlers === void 0) {
      this.#handlers.set(type, [handler]);
    } else {
      handlers.push(handler);
    }
    this.#emitter.on(type, handler);
    return this;
  }
  /**
   * Remove an event listener from firing.
   * @param type - the event type you'd like to stop listening to.
   * @param handler - the function that should be removed.
   * @returns `this` to enable you to chain method calls.
   */
  off(type, handler) {
    const handlers = this.#handlers.get(type) ?? [];
    if (handler === void 0) {
      for (const handler2 of handlers) {
        this.#emitter.off(type, handler2);
      }
      this.#handlers.delete(type);
      return this;
    }
    const index2 = handlers.lastIndexOf(handler);
    if (index2 > -1) {
      this.#emitter.off(type, ...handlers.splice(index2, 1));
    }
    return this;
  }
  /**
   * Emit an event and call any associated listeners.
   *
   * @param type - the event you'd like to emit
   * @param eventData - any data you'd like to emit with the event
   * @returns `true` if there are any listeners, `false` if there are not.
   */
  emit(type, event) {
    this.#emitter.emit(type, event);
    return this.listenerCount(type) > 0;
  }
  /**
   * Like `on` but the listener will only be fired once and then it will be removed.
   * @param type - the event you'd like to listen to
   * @param handler - the handler function to run when the event occurs
   * @returns `this` to enable you to chain method calls.
   */
  once(type, handler) {
    const onceHandler = /* @__PURE__ */ __name((eventData) => {
      handler(eventData);
      this.off(type, onceHandler);
    }, "onceHandler");
    return this.on(type, onceHandler);
  }
  /**
   * Gets the number of listeners for a given event.
   *
   * @param type - the event to get the listener count for
   * @returns the number of listeners bound to the given event
   */
  listenerCount(type) {
    return this.#handlers.get(type)?.length || 0;
  }
  /**
   * Removes all listeners. If given an event argument, it will remove only
   * listeners for that event.
   *
   * @param type - the event to remove listeners for.
   * @returns `this` to enable you to chain method calls.
   */
  removeAllListeners(type) {
    if (type !== void 0) {
      return this.off(type);
    }
    this[disposeSymbol]();
    return this;
  }
  /**
   * @internal
   */
  [disposeSymbol]() {
    for (const [type, handlers] of this.#handlers) {
      for (const handler of handlers) {
        this.#emitter.off(type, handler);
      }
    }
    this.#handlers.clear();
  }
};
var EventSubscription = class {
  static {
    __name(this, "EventSubscription");
  }
  #target;
  #type;
  #handler;
  constructor(target, type, handler) {
    this.#target = target;
    this.#type = type;
    this.#handler = handler;
    this.#target.on(this.#type, this.#handler);
  }
  [disposeSymbol]() {
    this.#target.off(this.#type, this.#handler);
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/Browser.js
var WEB_PERMISSION_TO_PROTOCOL_PERMISSION = /* @__PURE__ */ new Map([
  ["geolocation", "geolocation"],
  ["midi", "midi"],
  ["notifications", "notifications"],
  // TODO: push isn't a valid type?
  // ['push', 'push'],
  ["camera", "videoCapture"],
  ["microphone", "audioCapture"],
  ["background-sync", "backgroundSync"],
  ["ambient-light-sensor", "sensors"],
  ["accelerometer", "sensors"],
  ["gyroscope", "sensors"],
  ["magnetometer", "sensors"],
  ["accessibility-events", "accessibilityEvents"],
  ["clipboard-read", "clipboardReadWrite"],
  ["clipboard-write", "clipboardReadWrite"],
  ["clipboard-sanitized-write", "clipboardSanitizedWrite"],
  ["payment-handler", "paymentHandler"],
  ["persistent-storage", "durableStorage"],
  ["idle-detection", "idleDetection"],
  // chrome-specific permissions we have.
  ["midi-sysex", "midiSysex"]
]);
var Browser = class extends EventEmitter2 {
  static {
    __name(this, "Browser");
  }
  /**
   * @internal
   */
  constructor() {
    super();
  }
  /**
   * Waits until a {@link Target | target} matching the given `predicate`
   * appears and returns it.
   *
   * This will look all open {@link BrowserContext | browser contexts}.
   *
   * @example Finding a target for a page opened via `window.open`:
   *
   * ```ts
   * await page.evaluate(() => window.open('https://www.example.com/'));
   * const newWindowTarget = await browser.waitForTarget(
   *   target => target.url() === 'https://www.example.com/'
   * );
   * ```
   */
  async waitForTarget(predicate, options = {}) {
    const { timeout: ms = 3e4 } = options;
    return await firstValueFrom(merge12(fromEmitterEvent(
      this,
      "targetcreated"
      /* BrowserEvent.TargetCreated */
    ), fromEmitterEvent(
      this,
      "targetchanged"
      /* BrowserEvent.TargetChanged */
    ), from(this.targets())).pipe(filterAsync(predicate), raceWith4(timeout5(ms))));
  }
  /**
   * Gets a list of all open {@link Page | pages} inside this {@link Browser}.
   *
   * If there ar multiple {@link BrowserContext | browser contexts}, this
   * returns all {@link Page | pages} in all
   * {@link BrowserContext | browser contexts}.
   *
   * @remarks Non-visible {@link Page | pages}, such as `"background_page"`,
   * will not be listed here. You can find them using {@link Target.page}.
   */
  async pages() {
    const contextPages = await Promise.all(this.browserContexts().map((context10) => {
      return context10.pages();
    }));
    return contextPages.reduce((acc, x) => {
      return acc.concat(x);
    }, []);
  }
  /**
   * Whether Puppeteer is connected to this {@link Browser | browser}.
   *
   * @deprecated Use {@link Browser | Browser.connected}.
   */
  isConnected() {
    return this.connected;
  }
  /** @internal */
  [disposeSymbol]() {
    if (this.process()) {
      return void this.close().catch(debugError);
    }
    return void this.disconnect().catch(debugError);
  }
  /** @internal */
  [asyncDisposeSymbol]() {
    if (this.process()) {
      return this.close();
    }
    return this.disconnect();
  }
  /**
   * Get the BISO session ID associated with this browser
   *
   * @public
   */
  sessionId() {
    throw new Error("Not implemented");
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/CDPSession.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CDPSessionEvent;
(function(CDPSessionEvent2) {
  CDPSessionEvent2.Disconnected = Symbol("CDPSession.Disconnected");
  CDPSessionEvent2.Swapped = Symbol("CDPSession.Swapped");
  CDPSessionEvent2.Ready = Symbol("CDPSession.Ready");
  CDPSessionEvent2.SessionAttached = "sessionattached";
  CDPSessionEvent2.SessionDetached = "sessiondetached";
})(CDPSessionEvent || (CDPSessionEvent = {}));
var CDPSession = class extends EventEmitter2 {
  static {
    __name(this, "CDPSession");
  }
  /**
   * @internal
   */
  constructor() {
    super();
  }
  /**
   * Parent session in terms of CDP's auto-attach mechanism.
   *
   * @internal
   */
  parentSession() {
    return void 0;
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/BrowserContext.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/BrowserContext.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/util/Mutex.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/util/Deferred.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Deferred = class _Deferred {
  static {
    __name(this, "Deferred");
  }
  static create(opts) {
    return new _Deferred(opts);
  }
  static async race(awaitables) {
    const deferredWithTimeout = /* @__PURE__ */ new Set();
    try {
      const promises = awaitables.map((value3) => {
        if (value3 instanceof _Deferred) {
          if (value3.#timeoutId) {
            deferredWithTimeout.add(value3);
          }
          return value3.valueOrThrow();
        }
        return value3;
      });
      return await Promise.race(promises);
    } finally {
      for (const deferred of deferredWithTimeout) {
        deferred.reject(new Error("Timeout cleared"));
      }
    }
  }
  #isResolved = false;
  #isRejected = false;
  #value;
  // SAFETY: This is ensured by #taskPromise.
  #resolve;
  #taskPromise = new Promise((resolve) => {
    this.#resolve = resolve;
  });
  #timeoutId;
  #timeoutError;
  constructor(opts) {
    if (opts && opts.timeout > 0) {
      this.#timeoutError = new TimeoutError(opts.message);
      this.#timeoutId = setTimeout(() => {
        this.reject(this.#timeoutError);
      }, opts.timeout);
    }
  }
  #finish(value3) {
    clearTimeout(this.#timeoutId);
    this.#value = value3;
    this.#resolve();
  }
  resolve(value3) {
    if (this.#isRejected || this.#isResolved) {
      return;
    }
    this.#isResolved = true;
    this.#finish(value3);
  }
  reject(error50) {
    if (this.#isRejected || this.#isResolved) {
      return;
    }
    this.#isRejected = true;
    this.#finish(error50);
  }
  resolved() {
    return this.#isResolved;
  }
  finished() {
    return this.#isResolved || this.#isRejected;
  }
  value() {
    return this.#value;
  }
  #promise;
  valueOrThrow() {
    if (!this.#promise) {
      this.#promise = (async () => {
        await this.#taskPromise;
        if (this.#isRejected) {
          throw this.#value;
        }
        return this.#value;
      })();
    }
    return this.#promise;
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/util/Mutex.js
var Mutex = class _Mutex {
  static {
    __name(this, "Mutex");
  }
  static Guard = class Guard {
    static {
      __name(this, "Guard");
    }
    #mutex;
    #onRelease;
    constructor(mutex, onRelease) {
      this.#mutex = mutex;
      this.#onRelease = onRelease;
    }
    [disposeSymbol]() {
      this.#onRelease?.();
      return this.#mutex.release();
    }
  };
  #locked = false;
  #acquirers = [];
  // This is FIFO.
  async acquire(onRelease) {
    if (!this.#locked) {
      this.#locked = true;
      return new _Mutex.Guard(this);
    }
    const deferred = Deferred.create();
    this.#acquirers.push(deferred.resolve.bind(deferred));
    await deferred.valueOrThrow();
    return new _Mutex.Guard(this, onRelease);
  }
  release() {
    const resolve = this.#acquirers.shift();
    if (!resolve) {
      this.#locked = false;
      return;
    }
    resolve();
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/BrowserContext.js
var BrowserContext = class extends EventEmitter2 {
  static {
    __name(this, "BrowserContext");
  }
  /**
   * @internal
   */
  constructor() {
    super();
  }
  /**
   * If defined, indicates an ongoing screenshot opereation.
   */
  #pageScreenshotMutex;
  #screenshotOperationsCount = 0;
  /**
   * @internal
   */
  startScreenshot() {
    const mutex = this.#pageScreenshotMutex || new Mutex();
    this.#pageScreenshotMutex = mutex;
    this.#screenshotOperationsCount++;
    return mutex.acquire(() => {
      this.#screenshotOperationsCount--;
      if (this.#screenshotOperationsCount === 0) {
        this.#pageScreenshotMutex = void 0;
      }
    });
  }
  /**
   * @internal
   */
  waitForScreenshotOperations() {
    return this.#pageScreenshotMutex?.acquire();
  }
  /**
   * Waits until a {@link Target | target} matching the given `predicate`
   * appears and returns it.
   *
   * This will look all open {@link BrowserContext | browser contexts}.
   *
   * @example Finding a target for a page opened via `window.open`:
   *
   * ```ts
   * await page.evaluate(() => window.open('https://www.example.com/'));
   * const newWindowTarget = await browserContext.waitForTarget(
   *   target => target.url() === 'https://www.example.com/'
   * );
   * ```
   */
  async waitForTarget(predicate, options = {}) {
    const { timeout: ms = 3e4 } = options;
    return await firstValueFrom(merge12(fromEmitterEvent(
      this,
      "targetcreated"
      /* BrowserContextEvent.TargetCreated */
    ), fromEmitterEvent(
      this,
      "targetchanged"
      /* BrowserContextEvent.TargetChanged */
    ), from(this.targets())).pipe(filterAsync(predicate), raceWith4(timeout5(ms))));
  }
  /**
   * Whether this {@link BrowserContext | browser context} is closed.
   */
  get closed() {
    return !this.browser().browserContexts().includes(this);
  }
  /**
   * Identifier for this {@link BrowserContext | browser context}.
   */
  get id() {
    return void 0;
  }
  /** @internal */
  [disposeSymbol]() {
    return void this.close().catch(debugError);
  }
  /** @internal */
  [asyncDisposeSymbol]() {
    return this.close();
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/BrowserContext.js
var __addDisposableResource = function(env2, value3, async4) {
  if (value3 !== null && value3 !== void 0) {
    if (typeof value3 !== "object" && typeof value3 !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async4) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value3[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value3[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env2.stack.push({ value: value3, dispose, async: async4 });
  } else if (async4) {
    env2.stack.push({ async: true });
  }
  return value3;
};
var __disposeResources = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail19(e) {
      env2.error = env2.hasError ? new SuppressedError2(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    __name(fail19, "fail");
    function next4() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async) return Promise.resolve(result).then(next4, function(e) {
            fail19(e);
            return next4();
          });
        } catch (e) {
          fail19(e);
        }
      }
      if (env2.hasError) throw env2.error;
    }
    __name(next4, "next");
    return next4();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error50, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error50, e.suppressed = suppressed, e;
});
var CdpBrowserContext = class extends BrowserContext {
  static {
    __name(this, "CdpBrowserContext");
  }
  #connection;
  #browser;
  #id;
  constructor(connection, browser, contextId) {
    super();
    this.#connection = connection;
    this.#browser = browser;
    this.#id = contextId;
  }
  get id() {
    return this.#id;
  }
  targets() {
    return this.#browser.targets().filter((target) => {
      return target.browserContext() === this;
    });
  }
  async pages() {
    const pages = await Promise.all(this.targets().filter((target) => {
      return target.type() === "page" || target.type() === "other" && this.#browser._getIsPageTargetCallback()?.(target);
    }).map((target) => {
      return target.page();
    }));
    return pages.filter((page) => {
      return !!page;
    });
  }
  isIncognito() {
    return !!this.#id;
  }
  async overridePermissions(origin, permissions) {
    const protocolPermissions = permissions.map((permission2) => {
      const protocolPermission = WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission2);
      if (!protocolPermission) {
        throw new Error("Unknown permission: " + permission2);
      }
      return protocolPermission;
    });
    await this.#connection.send("Browser.grantPermissions", {
      origin,
      browserContextId: this.#id || void 0,
      permissions: protocolPermissions
    });
  }
  async clearPermissionOverrides() {
    await this.#connection.send("Browser.resetPermissions", {
      browserContextId: this.#id || void 0
    });
  }
  async newPage() {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const _guard = __addDisposableResource(env_1, await this.waitForScreenshotOperations(), false);
      return await this.#browser._createPageInContext(this.#id);
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources(env_1);
    }
  }
  browser() {
    return this.#browser;
  }
  async close() {
    assert5(this.#id, "Non-incognito profiles cannot be closed!");
    await this.#browser._disposeContext(this.#id);
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/ChromeTargetManager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Target.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/Target.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TargetType;
(function(TargetType2) {
  TargetType2["PAGE"] = "page";
  TargetType2["BACKGROUND_PAGE"] = "background_page";
  TargetType2["SERVICE_WORKER"] = "service_worker";
  TargetType2["SHARED_WORKER"] = "shared_worker";
  TargetType2["BROWSER"] = "browser";
  TargetType2["WEBVIEW"] = "webview";
  TargetType2["OTHER"] = "other";
  TargetType2["TAB"] = "tab";
})(TargetType || (TargetType = {}));
var Target = class {
  static {
    __name(this, "Target");
  }
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * If the target is not of type `"service_worker"` or `"shared_worker"`, returns `null`.
   */
  async worker() {
    return null;
  }
  /**
   * If the target is not of type `"page"`, `"webview"` or `"background_page"`,
   * returns `null`.
   */
  async page() {
    return null;
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/CDPSession.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/CallbackRegistry.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/util/ErrorLike.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function isErrorLike(obj) {
  return typeof obj === "object" && obj !== null && "name" in obj && "message" in obj;
}
__name(isErrorLike, "isErrorLike");
function rewriteError(error50, message, originalMessage) {
  error50.message = message;
  error50.originalMessage = originalMessage ?? error50.originalMessage;
  return error50;
}
__name(rewriteError, "rewriteError");
function createProtocolErrorMessage(object4) {
  let message = object4.error.message;
  if (object4.error && typeof object4.error === "object" && "data" in object4.error) {
    message += ` ${object4.error.data}`;
  }
  return message;
}
__name(createProtocolErrorMessage, "createProtocolErrorMessage");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/CallbackRegistry.js
var CallbackRegistry = class {
  static {
    __name(this, "CallbackRegistry");
  }
  #callbacks = /* @__PURE__ */ new Map();
  #idGenerator = createIncrementalIdGenerator();
  create(label, timeout6, request2) {
    const callback = new Callback(this.#idGenerator(), label, timeout6);
    this.#callbacks.set(callback.id, callback);
    try {
      request2(callback.id);
    } catch (error50) {
      callback.promise.catch(debugError).finally(() => {
        this.#callbacks.delete(callback.id);
      });
      callback.reject(error50);
      throw error50;
    }
    return callback.promise.finally(() => {
      this.#callbacks.delete(callback.id);
    });
  }
  reject(id2, message, originalMessage) {
    const callback = this.#callbacks.get(id2);
    if (!callback) {
      return;
    }
    this._reject(callback, message, originalMessage);
  }
  _reject(callback, errorMessage, originalMessage) {
    let error50;
    let message;
    if (errorMessage instanceof ProtocolError) {
      error50 = errorMessage;
      error50.cause = callback.error;
      message = errorMessage.message;
    } else {
      error50 = callback.error;
      message = errorMessage;
    }
    callback.reject(rewriteError(error50, `Protocol error (${callback.label}): ${message}`, originalMessage));
  }
  resolve(id2, value3) {
    const callback = this.#callbacks.get(id2);
    if (!callback) {
      return;
    }
    callback.resolve(value3);
  }
  clear() {
    for (const callback of this.#callbacks.values()) {
      this._reject(callback, new TargetCloseError("Target closed"));
    }
    this.#callbacks.clear();
  }
  /**
   * @internal
   */
  getPendingProtocolErrors() {
    const result = [];
    for (const callback of this.#callbacks.values()) {
      result.push(new Error(`${callback.label} timed out. Trace: ${callback.error.stack}`));
    }
    return result;
  }
};
var Callback = class {
  static {
    __name(this, "Callback");
  }
  #id;
  #error = new ProtocolError();
  #deferred = Deferred.create();
  #timer;
  #label;
  constructor(id2, label, timeout6) {
    this.#id = id2;
    this.#label = label;
    if (timeout6) {
      this.#timer = setTimeout(() => {
        this.#deferred.reject(rewriteError(this.#error, `${label} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`));
      }, timeout6);
    }
  }
  resolve(value3) {
    clearTimeout(this.#timer);
    this.#deferred.resolve(value3);
  }
  reject(error50) {
    clearTimeout(this.#timer);
    this.#deferred.reject(error50);
  }
  get id() {
    return this.#id;
  }
  get promise() {
    return this.#deferred.valueOrThrow();
  }
  get error() {
    return this.#error;
  }
  get label() {
    return this.#label;
  }
};
function createIncrementalIdGenerator() {
  let id2 = 0;
  return () => {
    return ++id2;
  };
}
__name(createIncrementalIdGenerator, "createIncrementalIdGenerator");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/CDPSession.js
var CdpCDPSession = class extends CDPSession {
  static {
    __name(this, "CdpCDPSession");
  }
  #sessionId;
  #targetType;
  #callbacks = new CallbackRegistry();
  #connection;
  #parentSessionId;
  #target;
  /**
   * @internal
   */
  constructor(connection, targetType, sessionId, parentSessionId) {
    super();
    this.#connection = connection;
    this.#targetType = targetType;
    this.#sessionId = sessionId;
    this.#parentSessionId = parentSessionId;
  }
  /**
   * Sets the {@link CdpTarget} associated with the session instance.
   *
   * @internal
   */
  _setTarget(target) {
    this.#target = target;
  }
  /**
   * Gets the {@link CdpTarget} associated with the session instance.
   *
   * @internal
   */
  _target() {
    assert5(this.#target, "Target must exist");
    return this.#target;
  }
  connection() {
    return this.#connection;
  }
  parentSession() {
    if (!this.#parentSessionId) {
      return this;
    }
    const parent = this.#connection?.session(this.#parentSessionId);
    return parent ?? void 0;
  }
  send(method, params, options) {
    if (!this.#connection) {
      return Promise.reject(new TargetCloseError(`Protocol error (${method}): Session closed. Most likely the ${this.#targetType} has been closed.`));
    }
    return this.#connection._rawSend(this.#callbacks, method, params, this.#sessionId, options);
  }
  /**
   * @internal
   */
  _onMessage(object4) {
    if (object4.id) {
      if (object4.error) {
        this.#callbacks.reject(object4.id, createProtocolErrorMessage(object4), object4.error.message);
      } else {
        this.#callbacks.resolve(object4.id, object4.result);
      }
    } else {
      assert5(!object4.id);
      this.emit(object4.method, object4.params);
    }
  }
  /**
   * Detaches the cdpSession from the target. Once detached, the cdpSession object
   * won't emit any events and can't be used to send messages.
   */
  async detach() {
    if (!this.#connection) {
      throw new Error(`Session already detached. Most likely the ${this.#targetType} has been closed.`);
    }
    await this.#connection.send("Target.detachFromTarget", {
      sessionId: this.#sessionId
    });
  }
  /**
   * @internal
   */
  _onClosed() {
    this.#callbacks.clear();
    this.#connection = void 0;
    this.emit(CDPSessionEvent.Disconnected, void 0);
  }
  /**
   * Returns the session's id.
   */
  id() {
    return this.#sessionId;
  }
  /**
   * @internal
   */
  getPendingProtocolErrors() {
    return this.#callbacks.getPendingProtocolErrors();
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Page.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/Page.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/TimeoutSettings.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DEFAULT_TIMEOUT = 3e4;
var TimeoutSettings = class {
  static {
    __name(this, "TimeoutSettings");
  }
  #defaultTimeout;
  #defaultNavigationTimeout;
  constructor() {
    this.#defaultTimeout = null;
    this.#defaultNavigationTimeout = null;
  }
  setDefaultTimeout(timeout6) {
    this.#defaultTimeout = timeout6;
  }
  setDefaultNavigationTimeout(timeout6) {
    this.#defaultNavigationTimeout = timeout6;
  }
  navigationTimeout() {
    if (this.#defaultNavigationTimeout !== null) {
      return this.#defaultNavigationTimeout;
    }
    if (this.#defaultTimeout !== null) {
      return this.#defaultTimeout;
    }
    return DEFAULT_TIMEOUT;
  }
  timeout() {
    if (this.#defaultTimeout !== null) {
      return this.#defaultTimeout;
    }
    return DEFAULT_TIMEOUT;
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/util/decorators.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __addDisposableResource2 = function(env2, value3, async4) {
  if (value3 !== null && value3 !== void 0) {
    if (typeof value3 !== "object" && typeof value3 !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async4) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value3[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value3[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env2.stack.push({ value: value3, dispose, async: async4 });
  } else if (async4) {
    env2.stack.push({ async: true });
  }
  return value3;
};
var __disposeResources2 = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail19(e) {
      env2.error = env2.hasError ? new SuppressedError2(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    __name(fail19, "fail");
    function next4() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async) return Promise.resolve(result).then(next4, function(e) {
            fail19(e);
            return next4();
          });
        } catch (e) {
          fail19(e);
        }
      }
      if (env2.hasError) throw env2.error;
    }
    __name(next4, "next");
    return next4();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error50, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error50, e.suppressed = suppressed, e;
});
var instances = /* @__PURE__ */ new WeakSet();
function moveable(Class9, _) {
  let hasDispose = false;
  if (Class9.prototype[disposeSymbol]) {
    const dispose = Class9.prototype[disposeSymbol];
    Class9.prototype[disposeSymbol] = function() {
      if (instances.has(this)) {
        instances.delete(this);
        return;
      }
      return dispose.call(this);
    };
    hasDispose = true;
  }
  if (Class9.prototype[asyncDisposeSymbol]) {
    const asyncDispose = Class9.prototype[asyncDisposeSymbol];
    Class9.prototype[asyncDisposeSymbol] = function() {
      if (instances.has(this)) {
        instances.delete(this);
        return;
      }
      return asyncDispose.call(this);
    };
    hasDispose = true;
  }
  if (hasDispose) {
    Class9.prototype.move = function() {
      instances.add(this);
      return this;
    };
  }
  return Class9;
}
__name(moveable, "moveable");
function throwIfDisposed(message = (value3) => {
  return `Attempted to use disposed ${value3.constructor.name}.`;
}) {
  return (target, _) => {
    return function(...args2) {
      if (this.disposed) {
        throw new Error(message(this));
      }
      return target.call(this, ...args2);
    };
  };
}
__name(throwIfDisposed, "throwIfDisposed");
function invokeAtMostOnceForArguments(target, _) {
  const cache = /* @__PURE__ */ new WeakMap();
  let cacheDepth = -1;
  return function(...args2) {
    if (cacheDepth === -1) {
      cacheDepth = args2.length;
    }
    if (cacheDepth !== args2.length) {
      throw new Error("Memoized method was called with the wrong number of arguments");
    }
    let freshArguments = false;
    let cacheIterator = cache;
    for (const arg of args2) {
      if (cacheIterator.has(arg)) {
        cacheIterator = cacheIterator.get(arg);
      } else {
        freshArguments = true;
        cacheIterator.set(arg, /* @__PURE__ */ new WeakMap());
        cacheIterator = cacheIterator.get(arg);
      }
    }
    if (!freshArguments) {
      return;
    }
    return target.call(this, ...args2);
  };
}
__name(invokeAtMostOnceForArguments, "invokeAtMostOnceForArguments");
function guarded(getKey = function() {
  return this;
}) {
  return (target, _) => {
    const mutexes = /* @__PURE__ */ new WeakMap();
    return async function(...args2) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const key = getKey.call(this);
        let mutex = mutexes.get(key);
        if (!mutex) {
          mutex = new Mutex();
          mutexes.set(key, mutex);
        }
        const _2 = __addDisposableResource2(env_1, await mutex.acquire(), true);
        return await target.call(this, ...args2);
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        const result_1 = __disposeResources2(env_1);
        if (result_1)
          await result_1;
      }
    };
  };
}
__name(guarded, "guarded");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/locators/locators.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __addDisposableResource3 = function(env2, value3, async4) {
  if (value3 !== null && value3 !== void 0) {
    if (typeof value3 !== "object" && typeof value3 !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async4) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value3[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value3[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env2.stack.push({ value: value3, dispose, async: async4 });
  } else if (async4) {
    env2.stack.push({ async: true });
  }
  return value3;
};
var __disposeResources3 = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail19(e) {
      env2.error = env2.hasError ? new SuppressedError2(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    __name(fail19, "fail");
    function next4() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async) return Promise.resolve(result).then(next4, function(e) {
            fail19(e);
            return next4();
          });
        } catch (e) {
          fail19(e);
        }
      }
      if (env2.hasError) throw env2.error;
    }
    __name(next4, "next");
    return next4();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error50, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error50, e.suppressed = suppressed, e;
});
var LocatorEvent;
(function(LocatorEvent2) {
  LocatorEvent2["Action"] = "action";
})(LocatorEvent || (LocatorEvent = {}));
var Locator = class extends EventEmitter2 {
  static {
    __name(this, "Locator");
  }
  /**
   * Creates a race between multiple locators trying to locate elements in
   * parallel but ensures that only a single element receives the action.
   *
   * @public
   */
  static race(locators) {
    return RaceLocator.create(locators);
  }
  /**
   * @internal
   */
  visibility = null;
  /**
   * @internal
   */
  _timeout = 3e4;
  #ensureElementIsInTheViewport = true;
  #waitForEnabled = true;
  #waitForStableBoundingBox = true;
  /**
   * @internal
   */
  operators = {
    conditions: /* @__PURE__ */ __name((conditions, signal) => {
      return mergeMap2((handle) => {
        return merge12(...conditions.map((condition) => {
          return condition(handle, signal);
        })).pipe(defaultIfEmpty(handle));
      });
    }, "conditions"),
    retryAndRaceWithSignalAndTimer: /* @__PURE__ */ __name((signal, cause3) => {
      const candidates = [];
      if (signal) {
        candidates.push(fromAbortSignal(signal, cause3));
      }
      candidates.push(timeout5(this._timeout, cause3));
      return pipe3(retry8({ delay: RETRY_DELAY }), raceWith4(...candidates));
    }, "retryAndRaceWithSignalAndTimer")
  };
  // Determines when the locator will timeout for actions.
  get timeout() {
    return this._timeout;
  }
  /**
   * Creates a new locator instance by cloning the current locator and setting
   * the total timeout for the locator actions.
   *
   * Pass `0` to disable timeout.
   *
   * @defaultValue `Page.getDefaultTimeout()`
   */
  setTimeout(timeout6) {
    const locator = this._clone();
    locator._timeout = timeout6;
    return locator;
  }
  /**
   * Creates a new locator instance by cloning the current locator with the
   * visibility property changed to the specified value.
   */
  setVisibility(visibility) {
    const locator = this._clone();
    locator.visibility = visibility;
    return locator;
  }
  /**
   * Creates a new locator instance by cloning the current locator and
   * specifying whether to wait for input elements to become enabled before the
   * action. Applicable to `click` and `fill` actions.
   *
   * @defaultValue `true`
   */
  setWaitForEnabled(value3) {
    const locator = this._clone();
    locator.#waitForEnabled = value3;
    return locator;
  }
  /**
   * Creates a new locator instance by cloning the current locator and
   * specifying whether the locator should scroll the element into viewport if
   * it is not in the viewport already.
   *
   * @defaultValue `true`
   */
  setEnsureElementIsInTheViewport(value3) {
    const locator = this._clone();
    locator.#ensureElementIsInTheViewport = value3;
    return locator;
  }
  /**
   * Creates a new locator instance by cloning the current locator and
   * specifying whether the locator has to wait for the element's bounding box
   * to be same between two consecutive animation frames.
   *
   * @defaultValue `true`
   */
  setWaitForStableBoundingBox(value3) {
    const locator = this._clone();
    locator.#waitForStableBoundingBox = value3;
    return locator;
  }
  /**
   * @internal
   */
  copyOptions(locator) {
    this._timeout = locator._timeout;
    this.visibility = locator.visibility;
    this.#waitForEnabled = locator.#waitForEnabled;
    this.#ensureElementIsInTheViewport = locator.#ensureElementIsInTheViewport;
    this.#waitForStableBoundingBox = locator.#waitForStableBoundingBox;
    return this;
  }
  /**
   * If the element has a "disabled" property, wait for the element to be
   * enabled.
   */
  #waitForEnabledIfNeeded = /* @__PURE__ */ __name((handle, signal) => {
    if (!this.#waitForEnabled) {
      return EMPTY;
    }
    return from(handle.frame.waitForFunction((element2) => {
      if (!(element2 instanceof HTMLElement)) {
        return true;
      }
      const isNativeFormControl = [
        "BUTTON",
        "INPUT",
        "SELECT",
        "TEXTAREA",
        "OPTION",
        "OPTGROUP"
      ].includes(element2.nodeName);
      return !isNativeFormControl || !element2.hasAttribute("disabled");
    }, {
      timeout: this._timeout,
      signal
    }, handle)).pipe(ignoreElements());
  }, "#waitForEnabledIfNeeded");
  /**
   * Compares the bounding box of the element for two consecutive animation
   * frames and waits till they are the same.
   */
  #waitForStableBoundingBoxIfNeeded = /* @__PURE__ */ __name((handle) => {
    if (!this.#waitForStableBoundingBox) {
      return EMPTY;
    }
    return defer(() => {
      return from(handle.evaluate((element2) => {
        return new Promise((resolve) => {
          window.requestAnimationFrame(() => {
            const rect1 = element2.getBoundingClientRect();
            window.requestAnimationFrame(() => {
              const rect2 = element2.getBoundingClientRect();
              resolve([
                {
                  x: rect1.x,
                  y: rect1.y,
                  width: rect1.width,
                  height: rect1.height
                },
                {
                  x: rect2.x,
                  y: rect2.y,
                  width: rect2.width,
                  height: rect2.height
                }
              ]);
            });
          });
        });
      }));
    }).pipe(first2(([rect1, rect2]) => {
      return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;
    }), retry8({ delay: RETRY_DELAY }), ignoreElements());
  }, "#waitForStableBoundingBoxIfNeeded");
  /**
   * Checks if the element is in the viewport and auto-scrolls it if it is not.
   */
  #ensureElementIsInTheViewportIfNeeded = /* @__PURE__ */ __name((handle) => {
    if (!this.#ensureElementIsInTheViewport) {
      return EMPTY;
    }
    return from(handle.isIntersectingViewport({ threshold: 0 })).pipe(filter13((isIntersectingViewport) => {
      return !isIntersectingViewport;
    }), mergeMap2(() => {
      return from(handle.scrollIntoView());
    }), mergeMap2(() => {
      return defer(() => {
        return from(handle.isIntersectingViewport({ threshold: 0 }));
      }).pipe(first2(identity6), retry8({ delay: RETRY_DELAY }), ignoreElements());
    }));
  }, "#ensureElementIsInTheViewportIfNeeded");
  #click(options) {
    const signal = options?.signal;
    const cause3 = new Error("Locator.click");
    return this._wait(options).pipe(this.operators.conditions([
      this.#ensureElementIsInTheViewportIfNeeded,
      this.#waitForStableBoundingBoxIfNeeded,
      this.#waitForEnabledIfNeeded
    ], signal), tap9(() => {
      return this.emit(LocatorEvent.Action, void 0);
    }), mergeMap2((handle) => {
      return from(handle.click(options)).pipe(catchError((err) => {
        void handle.dispose().catch(debugError);
        throw err;
      }));
    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause3));
  }
  #fill(value3, options) {
    const signal = options?.signal;
    const cause3 = new Error("Locator.fill");
    return this._wait(options).pipe(this.operators.conditions([
      this.#ensureElementIsInTheViewportIfNeeded,
      this.#waitForStableBoundingBoxIfNeeded,
      this.#waitForEnabledIfNeeded
    ], signal), tap9(() => {
      return this.emit(LocatorEvent.Action, void 0);
    }), mergeMap2((handle) => {
      return from(handle.evaluate((el) => {
        if (el instanceof HTMLSelectElement) {
          return "select";
        }
        if (el instanceof HTMLTextAreaElement) {
          return "typeable-input";
        }
        if (el instanceof HTMLInputElement) {
          if ((/* @__PURE__ */ new Set([
            "textarea",
            "text",
            "url",
            "tel",
            "search",
            "password",
            "number",
            "email"
          ])).has(el.type)) {
            return "typeable-input";
          } else {
            return "other-input";
          }
        }
        if (el.isContentEditable) {
          return "contenteditable";
        }
        return "unknown";
      })).pipe(mergeMap2((inputType) => {
        switch (inputType) {
          case "select":
            return from(handle.select(value3).then(noop));
          case "contenteditable":
          case "typeable-input":
            return from(handle.evaluate((input, newValue) => {
              const currentValue = input.isContentEditable ? input.innerText : input.value;
              if (newValue.length <= currentValue.length || !newValue.startsWith(input.value)) {
                if (input.isContentEditable) {
                  input.innerText = "";
                } else {
                  input.value = "";
                }
                return newValue;
              }
              const originalValue = input.isContentEditable ? input.innerText : input.value;
              if (input.isContentEditable) {
                input.innerText = "";
                input.innerText = originalValue;
              } else {
                input.value = "";
                input.value = originalValue;
              }
              return newValue.substring(originalValue.length);
            }, value3)).pipe(mergeMap2((textToType) => {
              return from(handle.type(textToType));
            }));
          case "other-input":
            return from(handle.focus()).pipe(mergeMap2(() => {
              return from(handle.evaluate((input, value4) => {
                input.value = value4;
                input.dispatchEvent(new Event("input", { bubbles: true }));
                input.dispatchEvent(new Event("change", { bubbles: true }));
              }, value3));
            }));
          case "unknown":
            throw new Error(`Element cannot be filled out.`);
        }
      })).pipe(catchError((err) => {
        void handle.dispose().catch(debugError);
        throw err;
      }));
    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause3));
  }
  #hover(options) {
    const signal = options?.signal;
    const cause3 = new Error("Locator.hover");
    return this._wait(options).pipe(this.operators.conditions([
      this.#ensureElementIsInTheViewportIfNeeded,
      this.#waitForStableBoundingBoxIfNeeded
    ], signal), tap9(() => {
      return this.emit(LocatorEvent.Action, void 0);
    }), mergeMap2((handle) => {
      return from(handle.hover()).pipe(catchError((err) => {
        void handle.dispose().catch(debugError);
        throw err;
      }));
    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause3));
  }
  #scroll(options) {
    const signal = options?.signal;
    const cause3 = new Error("Locator.scroll");
    return this._wait(options).pipe(this.operators.conditions([
      this.#ensureElementIsInTheViewportIfNeeded,
      this.#waitForStableBoundingBoxIfNeeded
    ], signal), tap9(() => {
      return this.emit(LocatorEvent.Action, void 0);
    }), mergeMap2((handle) => {
      return from(handle.evaluate((el, scrollTop, scrollLeft) => {
        if (scrollTop !== void 0) {
          el.scrollTop = scrollTop;
        }
        if (scrollLeft !== void 0) {
          el.scrollLeft = scrollLeft;
        }
      }, options?.scrollTop, options?.scrollLeft)).pipe(catchError((err) => {
        void handle.dispose().catch(debugError);
        throw err;
      }));
    }), this.operators.retryAndRaceWithSignalAndTimer(signal, cause3));
  }
  /**
   * Clones the locator.
   */
  clone() {
    return this._clone();
  }
  /**
   * Waits for the locator to get a handle from the page.
   *
   * @public
   */
  async waitHandle(options) {
    const cause3 = new Error("Locator.waitHandle");
    return await firstValueFrom(this._wait(options).pipe(this.operators.retryAndRaceWithSignalAndTimer(options?.signal, cause3)));
  }
  /**
   * Waits for the locator to get the serialized value from the page.
   *
   * Note this requires the value to be JSON-serializable.
   *
   * @public
   */
  async wait(options) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const handle = __addDisposableResource3(env_1, await this.waitHandle(options), false);
      return await handle.jsonValue();
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources3(env_1);
    }
  }
  /**
   * Maps the locator using the provided mapper.
   *
   * @public
   */
  map(mapper) {
    return new MappedLocator(this._clone(), (handle) => {
      return handle.evaluateHandle(mapper);
    });
  }
  /**
   * Creates an expectation that is evaluated against located values.
   *
   * If the expectations do not match, then the locator will retry.
   *
   * @public
   */
  filter(predicate) {
    return new FilteredLocator(this._clone(), async (handle, signal) => {
      await handle.frame.waitForFunction(predicate, { signal, timeout: this._timeout }, handle);
      return true;
    });
  }
  /**
   * Creates an expectation that is evaluated against located handles.
   *
   * If the expectations do not match, then the locator will retry.
   *
   * @internal
   */
  filterHandle(predicate) {
    return new FilteredLocator(this._clone(), predicate);
  }
  /**
   * Maps the locator using the provided mapper.
   *
   * @internal
   */
  mapHandle(mapper) {
    return new MappedLocator(this._clone(), mapper);
  }
  /**
   * Clicks the located element.
   */
  click(options) {
    return firstValueFrom(this.#click(options));
  }
  /**
   * Fills out the input identified by the locator using the provided value. The
   * type of the input is determined at runtime and the appropriate fill-out
   * method is chosen based on the type. `contenteditable`, select, textarea and
   * input elements are supported.
   */
  fill(value3, options) {
    return firstValueFrom(this.#fill(value3, options));
  }
  /**
   * Hovers over the located element.
   */
  hover(options) {
    return firstValueFrom(this.#hover(options));
  }
  /**
   * Scrolls the located element.
   */
  scroll(options) {
    return firstValueFrom(this.#scroll(options));
  }
};
var FunctionLocator = class _FunctionLocator extends Locator {
  static {
    __name(this, "FunctionLocator");
  }
  static create(pageOrFrame, func2) {
    return new _FunctionLocator(pageOrFrame, func2).setTimeout("getDefaultTimeout" in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
  }
  #pageOrFrame;
  #func;
  constructor(pageOrFrame, func2) {
    super();
    this.#pageOrFrame = pageOrFrame;
    this.#func = func2;
  }
  _clone() {
    return new _FunctionLocator(this.#pageOrFrame, this.#func);
  }
  _wait(options) {
    const signal = options?.signal;
    return defer(() => {
      return from(this.#pageOrFrame.waitForFunction(this.#func, {
        timeout: this.timeout,
        signal
      }));
    }).pipe(throwIfEmpty());
  }
};
var DelegatedLocator = class extends Locator {
  static {
    __name(this, "DelegatedLocator");
  }
  #delegate;
  constructor(delegate) {
    super();
    this.#delegate = delegate;
    this.copyOptions(this.#delegate);
  }
  get delegate() {
    return this.#delegate;
  }
  setTimeout(timeout6) {
    const locator = super.setTimeout(timeout6);
    locator.#delegate = this.#delegate.setTimeout(timeout6);
    return locator;
  }
  setVisibility(visibility) {
    const locator = super.setVisibility(visibility);
    locator.#delegate = locator.#delegate.setVisibility(visibility);
    return locator;
  }
  setWaitForEnabled(value3) {
    const locator = super.setWaitForEnabled(value3);
    locator.#delegate = this.#delegate.setWaitForEnabled(value3);
    return locator;
  }
  setEnsureElementIsInTheViewport(value3) {
    const locator = super.setEnsureElementIsInTheViewport(value3);
    locator.#delegate = this.#delegate.setEnsureElementIsInTheViewport(value3);
    return locator;
  }
  setWaitForStableBoundingBox(value3) {
    const locator = super.setWaitForStableBoundingBox(value3);
    locator.#delegate = this.#delegate.setWaitForStableBoundingBox(value3);
    return locator;
  }
};
var FilteredLocator = class _FilteredLocator extends DelegatedLocator {
  static {
    __name(this, "FilteredLocator");
  }
  #predicate;
  constructor(base, predicate) {
    super(base);
    this.#predicate = predicate;
  }
  _clone() {
    return new _FilteredLocator(this.delegate.clone(), this.#predicate).copyOptions(this);
  }
  _wait(options) {
    return this.delegate._wait(options).pipe(mergeMap2((handle) => {
      return from(Promise.resolve(this.#predicate(handle, options?.signal))).pipe(filter13((value3) => {
        return value3;
      }), map30(() => {
        return handle;
      }));
    }), throwIfEmpty());
  }
};
var MappedLocator = class _MappedLocator extends DelegatedLocator {
  static {
    __name(this, "MappedLocator");
  }
  #mapper;
  constructor(base, mapper) {
    super(base);
    this.#mapper = mapper;
  }
  _clone() {
    return new _MappedLocator(this.delegate.clone(), this.#mapper).copyOptions(this);
  }
  _wait(options) {
    return this.delegate._wait(options).pipe(mergeMap2((handle) => {
      return from(Promise.resolve(this.#mapper(handle, options?.signal)));
    }));
  }
};
var NodeLocator = class _NodeLocator extends Locator {
  static {
    __name(this, "NodeLocator");
  }
  static create(pageOrFrame, selector) {
    return new _NodeLocator(pageOrFrame, selector).setTimeout("getDefaultTimeout" in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
  }
  #pageOrFrame;
  #selector;
  constructor(pageOrFrame, selector) {
    super();
    this.#pageOrFrame = pageOrFrame;
    this.#selector = selector;
  }
  /**
   * Waits for the element to become visible or hidden. visibility === 'visible'
   * means that the element has a computed style, the visibility property other
   * than 'hidden' or 'collapse' and non-empty bounding box. visibility ===
   * 'hidden' means the opposite of that.
   */
  #waitForVisibilityIfNeeded = /* @__PURE__ */ __name((handle) => {
    if (!this.visibility) {
      return EMPTY;
    }
    return (() => {
      switch (this.visibility) {
        case "hidden":
          return defer(() => {
            return from(handle.isHidden());
          });
        case "visible":
          return defer(() => {
            return from(handle.isVisible());
          });
      }
    })().pipe(first2(identity6), retry8({ delay: RETRY_DELAY }), ignoreElements());
  }, "#waitForVisibilityIfNeeded");
  _clone() {
    return new _NodeLocator(this.#pageOrFrame, this.#selector).copyOptions(this);
  }
  _wait(options) {
    const signal = options?.signal;
    return defer(() => {
      return from(this.#pageOrFrame.waitForSelector(this.#selector, {
        visible: false,
        timeout: this._timeout,
        signal
      }));
    }).pipe(filter13((value3) => {
      return value3 !== null;
    }), throwIfEmpty(), this.operators.conditions([this.#waitForVisibilityIfNeeded], signal));
  }
};
function checkLocatorArray(locators) {
  for (const locator of locators) {
    if (!(locator instanceof Locator)) {
      throw new Error("Unknown locator for race candidate");
    }
  }
  return locators;
}
__name(checkLocatorArray, "checkLocatorArray");
var RaceLocator = class _RaceLocator extends Locator {
  static {
    __name(this, "RaceLocator");
  }
  static create(locators) {
    const array7 = checkLocatorArray(locators);
    return new _RaceLocator(array7);
  }
  #locators;
  constructor(locators) {
    super();
    this.#locators = locators;
  }
  _clone() {
    return new _RaceLocator(this.#locators.map((locator) => {
      return locator.clone();
    })).copyOptions(this);
  }
  _wait(options) {
    return race5(...this.#locators.map((locator) => {
      return locator._wait(options);
    }));
  }
};
var RETRY_DELAY = 100;

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/Page.js
var __runInitializers = function(thisArg, initializers, value3) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value3 = useValue ? initializers[i].call(thisArg, value3) : initializers[i].call(thisArg);
  }
  return useValue ? value3 : void 0;
};
var __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor3 = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done13 = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context10 = {};
    for (var p in contextIn) context10[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context10.access[p] = contextIn.access[p];
    context10.addInitializer = function(f) {
      if (done13) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor3.get, set: descriptor3.set } : descriptor3[key], context10);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor3.get = _;
      if (_ = accept(result.set)) descriptor3.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor3[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor3);
  done13 = true;
};
var __addDisposableResource4 = function(env2, value3, async4) {
  if (value3 !== null && value3 !== void 0) {
    if (typeof value3 !== "object" && typeof value3 !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async4) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value3[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value3[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env2.stack.push({ value: value3, dispose, async: async4 });
  } else if (async4) {
    env2.stack.push({ async: true });
  }
  return value3;
};
var __disposeResources4 = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail19(e) {
      env2.error = env2.hasError ? new SuppressedError2(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    __name(fail19, "fail");
    function next4() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async) return Promise.resolve(result).then(next4, function(e) {
            fail19(e);
            return next4();
          });
        } catch (e) {
          fail19(e);
        }
      }
      if (env2.hasError) throw env2.error;
    }
    __name(next4, "next");
    return next4();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error50, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error50, e.suppressed = suppressed, e;
});
function setDefaultScreenshotOptions(options) {
  options.optimizeForSpeed ??= false;
  options.type ??= "png";
  options.fromSurface ??= true;
  options.fullPage ??= false;
  options.omitBackground ??= false;
  options.encoding ??= "binary";
  options.captureBeyondViewport ??= true;
}
__name(setDefaultScreenshotOptions, "setDefaultScreenshotOptions");
var Page = (() => {
  let _classSuper = EventEmitter2;
  let _instanceExtraInitializers = [];
  let _screenshot_decorators;
  return class Page extends _classSuper {
    static {
      __name(this, "Page");
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      __esDecorate(this, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "screenshot" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.screenshot, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    }
    /**
     * @internal
     */
    _isDragging = (__runInitializers(this, _instanceExtraInitializers), false);
    /**
     * @internal
     */
    _timeoutSettings = new TimeoutSettings();
    #requestHandlers = /* @__PURE__ */ new WeakMap();
    #inflight$ = new ReplaySubject(1);
    /**
     * @internal
     */
    constructor() {
      super();
      fromEmitterEvent(
        this,
        "request"
        /* PageEvent.Request */
      ).pipe(mergeMap2((originalRequest) => {
        return concat4(of6(1), merge12(fromEmitterEvent(
          this,
          "requestfailed"
          /* PageEvent.RequestFailed */
        ), fromEmitterEvent(
          this,
          "requestfinished"
          /* PageEvent.RequestFinished */
        ), fromEmitterEvent(
          this,
          "response"
          /* PageEvent.Response */
        ).pipe(map30((response) => {
          return response.request();
        }))).pipe(filter13((request2) => {
          return request2.id === originalRequest.id;
        }), take9(1), map30(() => {
          return -1;
        })));
      }), mergeScan((acc, addend) => {
        return of6(acc + addend);
      }, 0), takeUntil5(fromEmitterEvent(
        this,
        "close"
        /* PageEvent.Close */
      )), startWith(0)).subscribe(this.#inflight$);
    }
    /**
     * Listen to page events.
     *
     * @remarks
     * This method exists to define event typings and handle proper wireup of
     * cooperative request interception. Actual event listening and dispatching is
     * delegated to {@link EventEmitter}.
     *
     * @internal
     */
    on(type, handler) {
      if (type !== "request") {
        return super.on(type, handler);
      }
      let wrapper = this.#requestHandlers.get(handler);
      if (wrapper === void 0) {
        wrapper = /* @__PURE__ */ __name((event) => {
          event.enqueueInterceptAction(() => {
            return handler(event);
          });
        }, "wrapper");
        this.#requestHandlers.set(handler, wrapper);
      }
      return super.on(type, wrapper);
    }
    /**
     * @internal
     */
    off(type, handler) {
      if (type === "request") {
        handler = this.#requestHandlers.get(handler) || handler;
      }
      return super.off(type, handler);
    }
    /**
     * {@inheritDoc Accessibility}
     */
    get accessibility() {
      return this.mainFrame().accessibility;
    }
    locator(selectorOrFunc) {
      if (typeof selectorOrFunc === "string") {
        return NodeLocator.create(this, selectorOrFunc);
      } else {
        return FunctionLocator.create(this, selectorOrFunc);
      }
    }
    /**
     * A shortcut for {@link Locator.race} that does not require static imports.
     *
     * @internal
     */
    locatorRace(locators) {
      return Locator.race(locators);
    }
    /**
     * Finds the first element that matches the selector. If no element matches
     * the selector, the return value resolves to `null`.
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows quering by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     *
     * @remarks
     *
     * Shortcut for {@link Frame.$ | Page.mainFrame().$(selector) }.
     */
    async $(selector) {
      return await this.mainFrame().$(selector);
    }
    /**
     * Finds elements on the page that match the selector. If no elements
     * match the selector, the return value resolves to `[]`.
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows quering by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     *
     * @remarks
     *
     * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.
     */
    async $$(selector, options) {
      return await this.mainFrame().$$(selector, options);
    }
    /**
     * @remarks
     *
     * The only difference between {@link Page.evaluate | page.evaluate} and
     * `page.evaluateHandle` is that `evaluateHandle` will return the value
     * wrapped in an in-page object.
     *
     * If the function passed to `page.evaluateHandle` returns a Promise, the
     * function will wait for the promise to resolve and return its value.
     *
     * You can pass a string instead of a function (although functions are
     * recommended as they are easier to debug and use with TypeScript):
     *
     * @example
     *
     * ```ts
     * const aHandle = await page.evaluateHandle('document');
     * ```
     *
     * @example
     * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:
     *
     * ```ts
     * const aHandle = await page.evaluateHandle(() => document.body);
     * const resultHandle = await page.evaluateHandle(
     *   body => body.innerHTML,
     *   aHandle
     * );
     * console.log(await resultHandle.jsonValue());
     * await resultHandle.dispose();
     * ```
     *
     * Most of the time this function returns a {@link JSHandle},
     * but if `pageFunction` returns a reference to an element,
     * you instead get an {@link ElementHandle} back:
     *
     * @example
     *
     * ```ts
     * const button = await page.evaluateHandle(() =>
     *   document.querySelector('button')
     * );
     * // can call `click` because `button` is an `ElementHandle`
     * await button.click();
     * ```
     *
     * The TypeScript definitions assume that `evaluateHandle` returns
     * a `JSHandle`, but if you know it's going to return an
     * `ElementHandle`, pass it as the generic argument:
     *
     * ```ts
     * const button = await page.evaluateHandle<ElementHandle>(...);
     * ```
     *
     * @param pageFunction - a function that is run within the page
     * @param args - arguments to be passed to the pageFunction
     */
    async evaluateHandle(pageFunction, ...args2) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      return await this.mainFrame().evaluateHandle(pageFunction, ...args2);
    }
    /**
     * This method finds the first element within the page that matches the selector
     * and passes the result as the first argument to the `pageFunction`.
     *
     * @remarks
     *
     * If no element is found matching `selector`, the method will throw an error.
     *
     * If `pageFunction` returns a promise `$eval` will wait for the promise to
     * resolve and then return its value.
     *
     * @example
     *
     * ```ts
     * const searchValue = await page.$eval('#search', el => el.value);
     * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);
     * const html = await page.$eval('.main-container', el => el.outerHTML);
     * ```
     *
     * If you are using TypeScript, you may have to provide an explicit type to the
     * first argument of the `pageFunction`.
     * By default it is typed as `Element`, but you may need to provide a more
     * specific sub-type:
     *
     * @example
     *
     * ```ts
     * // if you don't provide HTMLInputElement here, TS will error
     * // as `value` is not on `Element`
     * const searchValue = await page.$eval(
     *   '#search',
     *   (el: HTMLInputElement) => el.value
     * );
     * ```
     *
     * The compiler should be able to infer the return type
     * from the `pageFunction` you provide. If it is unable to, you can use the generic
     * type to tell the compiler what return type you expect from `$eval`:
     *
     * @example
     *
     * ```ts
     * // The compiler can infer the return type in this case, but if it can't
     * // or if you want to be more explicit, provide it as the generic type.
     * const searchValue = await page.$eval<string>(
     *   '#search',
     *   (el: HTMLInputElement) => el.value
     * );
     * ```
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows quering by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @param pageFunction - the function to be evaluated in the page context.
     * Will be passed the result of the element matching the selector as its
     * first argument.
     * @param args - any additional arguments to pass through to `pageFunction`.
     *
     * @returns The result of calling `pageFunction`. If it returns an element it
     * is wrapped in an {@link ElementHandle}, else the raw value itself is
     * returned.
     */
    async $eval(selector, pageFunction, ...args2) {
      pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
      return await this.mainFrame().$eval(selector, pageFunction, ...args2);
    }
    /**
     * This method returns all elements matching the selector and passes the
     * resulting array as the first argument to the `pageFunction`.
     *
     * @remarks
     * If `pageFunction` returns a promise `$$eval` will wait for the promise to
     * resolve and then return its value.
     *
     * @example
     *
     * ```ts
     * // get the amount of divs on the page
     * const divCount = await page.$$eval('div', divs => divs.length);
     *
     * // get the text content of all the `.options` elements:
     * const options = await page.$$eval('div > span.options', options => {
     *   return options.map(option => option.textContent);
     * });
     * ```
     *
     * If you are using TypeScript, you may have to provide an explicit type to the
     * first argument of the `pageFunction`.
     * By default it is typed as `Element[]`, but you may need to provide a more
     * specific sub-type:
     *
     * @example
     *
     * ```ts
     * await page.$$eval('input', elements => {
     *   return elements.map(e => e.value);
     * });
     * ```
     *
     * The compiler should be able to infer the return type
     * from the `pageFunction` you provide. If it is unable to, you can use the generic
     * type to tell the compiler what return type you expect from `$$eval`:
     *
     * @example
     *
     * ```ts
     * const allInputValues = await page.$$eval('input', elements =>
     *   elements.map(e => e.textContent)
     * );
     * ```
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows quering by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @param pageFunction - the function to be evaluated in the page context.
     * Will be passed an array of matching elements as its first argument.
     * @param args - any additional arguments to pass through to `pageFunction`.
     *
     * @returns The result of calling `pageFunction`. If it returns an element it
     * is wrapped in an {@link ElementHandle}, else the raw value itself is
     * returned.
     */
    async $$eval(selector, pageFunction, ...args2) {
      pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
      return await this.mainFrame().$$eval(selector, pageFunction, ...args2);
    }
    /**
     * Adds a `<script>` tag into the page with the desired URL or content.
     *
     * @remarks
     * Shortcut for
     * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.
     *
     * @param options - Options for the script.
     * @returns An {@link ElementHandle | element handle} to the injected
     * `<script>` element.
     */
    async addScriptTag(options) {
      return await this.mainFrame().addScriptTag(options);
    }
    async addStyleTag(options) {
      return await this.mainFrame().addStyleTag(options);
    }
    /**
     * The page's URL.
     *
     * @remarks
     *
     * Shortcut for {@link Frame.url | page.mainFrame().url()}.
     */
    url() {
      return this.mainFrame().url();
    }
    /**
     * The full HTML contents of the page, including the DOCTYPE.
     */
    async content() {
      return await this.mainFrame().content();
    }
    /**
     * Set the content of the page.
     *
     * @param html - HTML markup to assign to the page.
     * @param options - Parameters that has some properties.
     */
    async setContent(html, options) {
      await this.mainFrame().setContent(html, options);
    }
    /**
     * {@inheritDoc Frame.goto}
     */
    async goto(url3, options) {
      return await this.mainFrame().goto(url3, options);
    }
    /**
     * Waits for the page to navigate to a new URL or to reload. It is useful when
     * you run code that will indirectly cause the page to navigate.
     *
     * @example
     *
     * ```ts
     * const [response] = await Promise.all([
     *   page.waitForNavigation(), // The promise resolves after navigation has finished
     *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation
     * ]);
     * ```
     *
     * @remarks
     *
     * Usage of the
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}
     * to change the URL is considered a navigation.
     *
     * @param options - Navigation parameters which might have the following
     * properties:
     * @returns A `Promise` which resolves to the main resource response.
     *
     * - In case of multiple redirects, the navigation will resolve with the
     *   response of the last redirect.
     * - In case of navigation to a different anchor or navigation due to History
     *   API usage, the navigation will resolve with `null`.
     */
    async waitForNavigation(options = {}) {
      return await this.mainFrame().waitForNavigation(options);
    }
    /**
     * @param urlOrPredicate - A URL or predicate to wait for
     * @param options - Optional waiting parameters
     * @returns Promise which resolves to the matched request
     * @example
     *
     * ```ts
     * const firstRequest = await page.waitForRequest(
     *   'https://example.com/resource'
     * );
     * const finalRequest = await page.waitForRequest(
     *   request => request.url() === 'https://example.com'
     * );
     * return finalRequest.response()?.ok();
     * ```
     *
     * @remarks
     * Optional Waiting Parameters have:
     *
     * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds, pass
     *   `0` to disable the timeout. The default value can be changed by using the
     *   {@link Page.setDefaultTimeout} method.
     */
    waitForRequest(urlOrPredicate, options = {}) {
      const { timeout: ms = this._timeoutSettings.timeout(), signal } = options;
      if (typeof urlOrPredicate === "string") {
        const url3 = urlOrPredicate;
        urlOrPredicate = /* @__PURE__ */ __name((request2) => {
          return request2.url() === url3;
        }, "urlOrPredicate");
      }
      const observable$ = fromEmitterEvent(
        this,
        "request"
        /* PageEvent.Request */
      ).pipe(filterAsync(urlOrPredicate), raceWith4(timeout5(ms), fromAbortSignal(signal), fromEmitterEvent(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(map30(() => {
        throw new TargetCloseError("Page closed!");
      }))));
      return firstValueFrom(observable$);
    }
    /**
     * @param urlOrPredicate - A URL or predicate to wait for.
     * @param options - Optional waiting parameters
     * @returns Promise which resolves to the matched response.
     * @example
     *
     * ```ts
     * const firstResponse = await page.waitForResponse(
     *   'https://example.com/resource'
     * );
     * const finalResponse = await page.waitForResponse(
     *   response =>
     *     response.url() === 'https://example.com' && response.status() === 200
     * );
     * const finalResponse = await page.waitForResponse(async response => {
     *   return (await response.text()).includes('<html>');
     * });
     * return finalResponse.ok();
     * ```
     *
     * @remarks
     * Optional Parameter have:
     *
     * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,
     *   pass `0` to disable the timeout. The default value can be changed by using
     *   the {@link Page.setDefaultTimeout} method.
     */
    waitForResponse(urlOrPredicate, options = {}) {
      const { timeout: ms = this._timeoutSettings.timeout(), signal } = options;
      if (typeof urlOrPredicate === "string") {
        const url3 = urlOrPredicate;
        urlOrPredicate = /* @__PURE__ */ __name((response) => {
          return response.url() === url3;
        }, "urlOrPredicate");
      }
      const observable$ = fromEmitterEvent(
        this,
        "response"
        /* PageEvent.Response */
      ).pipe(filterAsync(urlOrPredicate), raceWith4(timeout5(ms), fromAbortSignal(signal), fromEmitterEvent(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(map30(() => {
        throw new TargetCloseError("Page closed!");
      }))));
      return firstValueFrom(observable$);
    }
    /**
     * Waits for the network to be idle.
     *
     * @param options - Options to configure waiting behavior.
     * @returns A promise which resolves once the network is idle.
     */
    waitForNetworkIdle(options = {}) {
      return firstValueFrom(this.waitForNetworkIdle$(options));
    }
    /**
     * @internal
     */
    waitForNetworkIdle$(options = {}) {
      const { timeout: ms = this._timeoutSettings.timeout(), idleTime = NETWORK_IDLE_TIME, concurrency = 0, signal } = options;
      return this.#inflight$.pipe(switchMap((inflight) => {
        if (inflight > concurrency) {
          return EMPTY;
        }
        return timer(idleTime);
      }), map30(() => {
      }), raceWith4(timeout5(ms), fromAbortSignal(signal), fromEmitterEvent(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(map30(() => {
        throw new TargetCloseError("Page closed!");
      }))));
    }
    /**
     * Waits for a frame matching the given conditions to appear.
     *
     * @example
     *
     * ```ts
     * const frame = await page.waitForFrame(async frame => {
     *   return frame.name() === 'Test';
     * });
     * ```
     */
    async waitForFrame(urlOrPredicate, options = {}) {
      const { timeout: ms = this.getDefaultTimeout(), signal } = options;
      if (isString2(urlOrPredicate)) {
        urlOrPredicate = /* @__PURE__ */ __name((frame) => {
          return urlOrPredicate === frame.url();
        }, "urlOrPredicate");
      }
      return await firstValueFrom(merge12(fromEmitterEvent(
        this,
        "frameattached"
        /* PageEvent.FrameAttached */
      ), fromEmitterEvent(
        this,
        "framenavigated"
        /* PageEvent.FrameNavigated */
      ), from(this.frames())).pipe(filterAsync(urlOrPredicate), first2(), raceWith4(timeout5(ms), fromAbortSignal(signal), fromEmitterEvent(
        this,
        "close"
        /* PageEvent.Close */
      ).pipe(map30(() => {
        throw new TargetCloseError("Page closed.");
      })))));
    }
    /**
     * Emulates a given device's metrics and user agent.
     *
     * To aid emulation, Puppeteer provides a list of known devices that can be
     * via {@link KnownDevices}.
     *
     * @remarks
     * This method is a shortcut for calling two methods:
     * {@link Page.setUserAgent} and {@link Page.setViewport}.
     *
     * This method will resize the page. A lot of websites don't expect phones to
     * change size, so you should emulate before navigating to the page.
     *
     * @example
     *
     * ```ts
     * import {KnownDevices} from 'puppeteer';
     * const iPhone = KnownDevices['iPhone 15 Pro'];
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   await page.emulate(iPhone);
     *   await page.goto('https://www.google.com');
     *   // other actions...
     *   await browser.close();
     * })();
     * ```
     */
    async emulate(device) {
      await Promise.all([
        this.setUserAgent(device.userAgent),
        this.setViewport(device.viewport)
      ]);
    }
    /**
     * Evaluates a function in the page's context and returns the result.
     *
     * If the function passed to `page.evaluate` returns a Promise, the
     * function will wait for the promise to resolve and return its value.
     *
     * @example
     *
     * ```ts
     * const result = await frame.evaluate(() => {
     *   return Promise.resolve(8 * 7);
     * });
     * console.log(result); // prints "56"
     * ```
     *
     * You can pass a string instead of a function (although functions are
     * recommended as they are easier to debug and use with TypeScript):
     *
     * @example
     *
     * ```ts
     * const aHandle = await page.evaluate('1 + 2');
     * ```
     *
     * To get the best TypeScript experience, you should pass in as the
     * generic the type of `pageFunction`:
     *
     * ```ts
     * const aHandle = await page.evaluate(() => 2);
     * ```
     *
     * @example
     *
     * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed
     * as arguments to the `pageFunction`:
     *
     * ```ts
     * const bodyHandle = await page.$('body');
     * const html = await page.evaluate(body => body.innerHTML, bodyHandle);
     * await bodyHandle.dispose();
     * ```
     *
     * @param pageFunction - a function that is run within the page
     * @param args - arguments to be passed to the pageFunction
     *
     * @returns the return value of `pageFunction`.
     */
    async evaluate(pageFunction, ...args2) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      return await this.mainFrame().evaluate(pageFunction, ...args2);
    }
    /**
     * @internal
     */
    async _maybeWriteBufferToFile(path, _) {
      if (!path) {
        return;
      }
      throw new Error("Cannot write to a path outside of a Node-like environment.");
    }
    /**
     * Captures a screencast of this {@link Page | page}.
     *
     * @example
     * Recording a {@link Page | page}:
     *
     * ```
     * import puppeteer from 'puppeteer';
     *
     * // Launch a browser
     * const browser = await puppeteer.launch();
     *
     * // Create a new page
     * const page = await browser.newPage();
     *
     * // Go to your site.
     * await page.goto("https://www.example.com");
     *
     * // Start recording.
     * const recorder = await page.screencast({path: 'recording.webm'});
     *
     * // Do something.
     *
     * // Stop recording.
     * await recorder.stop();
     *
     * browser.close();
     * ```
     *
     * @param options - Configures screencast behavior.
     *
     * @experimental
     *
     * @remarks
     *
     * All recordings will be {@link https://www.webmproject.org/ | WebM} format using
     * the {@link https://www.webmproject.org/vp9/ | VP9} video codec. The FPS is 30.
     *
     * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.
     */
    // async screencast(
    //   options: Readonly<ScreencastOptions> = {}
    // ): Promise<ScreenRecorder> {
    //   const [{ScreenRecorder}, [width, height, devicePixelRatio]] =
    //     await Promise.all([
    //       import('../node/ScreenRecorder.js'),
    //       this.#getNativePixelDimensions(),
    //     ]);
    //   let crop: BoundingBox | undefined;
    //   if (options.crop) {
    //     const {
    //       x,
    //       y,
    //       width: cropWidth,
    //       height: cropHeight,
    //     } = roundRectangle(normalizeRectangle(options.crop));
    //     if (x < 0 || y < 0) {
    //       throw new Error(
    //         `\`crop.x\` and \`crop.y\` must be greater than or equal to 0.`
    //       );
    //     }
    //     if (cropWidth <= 0 || cropHeight <= 0) {
    //       throw new Error(
    //         `\`crop.height\` and \`crop.width\` must be greater than or equal to 0.`
    //       );
    //     }
    //     const viewportWidth = width / devicePixelRatio;
    //     const viewportHeight = height / devicePixelRatio;
    //     if (x + cropWidth > viewportWidth) {
    //       throw new Error(
    //         `\`crop.width\` cannot be larger than the viewport width (${viewportWidth}).`
    //       );
    //     }
    //     if (y + cropHeight > viewportHeight) {
    //       throw new Error(
    //      `\`crop.height\` cannot be larger than the viewport height (${viewportHeight}).`
    //       );
    //     }
    //     crop = {
    //       x: x * devicePixelRatio,
    //       y: y * devicePixelRatio,
    //       width: cropWidth * devicePixelRatio,
    //       height: cropHeight * devicePixelRatio,
    //     };
    //   }
    //   if (options.speed !== undefined && options.speed <= 0) {
    //     throw new Error(`\`speed\` must be greater than 0.`);
    //   }
    //   if (options.scale !== undefined && options.scale <= 0) {
    //     throw new Error(`\`scale\` must be greater than 0.`);
    //   }
    //   const recorder = new ScreenRecorder(this, width, height, {
    //     ...options,
    //     path: options.ffmpegPath,
    //     crop,
    //   });
    //   try {
    //     await this._startScreencast();
    //   } catch (error) {
    //     void recorder.stop();
    //     throw error;
    //   }
    //   if (options.path) {
    //     const {createWriteStream} = await import('fs');
    //     const stream = createWriteStream(options.path, 'binary');
    //     recorder.pipe(stream);
    //   }
    //   return recorder;
    // }
    #screencastSessionCount = 0;
    #startScreencastPromise;
    /**
     * @internal
     */
    async _startScreencast() {
      ++this.#screencastSessionCount;
      if (!this.#startScreencastPromise) {
        this.#startScreencastPromise = this.mainFrame().client.send("Page.startScreencast", { format: "png" }).then(() => {
          return new Promise((resolve) => {
            return this.mainFrame().client.once("Page.screencastFrame", () => {
              return resolve();
            });
          });
        });
      }
      await this.#startScreencastPromise;
    }
    /**
     * @internal
     */
    async _stopScreencast() {
      --this.#screencastSessionCount;
      if (!this.#startScreencastPromise) {
        return;
      }
      this.#startScreencastPromise = void 0;
      if (this.#screencastSessionCount === 0) {
        await this.mainFrame().client.send("Page.stopScreencast");
      }
    }
    async screenshot(userOptions = {}) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const _guard = __addDisposableResource4(env_1, await this.browserContext().startScreenshot(), false);
        await this.bringToFront();
        const options = {
          ...userOptions,
          clip: userOptions.clip ? {
            ...userOptions.clip
          } : void 0
        };
        if (options.type === void 0 && options.path !== void 0) {
          const filePath = options.path;
          const extension = filePath.slice(filePath.lastIndexOf(".") + 1).toLowerCase();
          switch (extension) {
            case "png":
              options.type = "png";
              break;
            case "jpeg":
            case "jpg":
              options.type = "jpeg";
              break;
            case "webp":
              options.type = "webp";
              break;
          }
        }
        if (options.quality !== void 0) {
          if (options.quality < 0 || options.quality > 100) {
            throw new Error(`Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`);
          }
          if (options.type === void 0 || !["jpeg", "webp"].includes(options.type)) {
            throw new Error(`${options.type ?? "png"} screenshots do not support 'quality'.`);
          }
        }
        if (options.clip) {
          if (options.clip.width <= 0) {
            throw new Error("'width' in 'clip' must be positive.");
          }
          if (options.clip.height <= 0) {
            throw new Error("'height' in 'clip' must be positive.");
          }
        }
        setDefaultScreenshotOptions(options);
        const stack = __addDisposableResource4(env_1, new AsyncDisposableStack(), true);
        if (options.clip) {
          if (options.fullPage) {
            throw new Error("'clip' and 'fullPage' are mutually exclusive");
          }
          options.clip = roundRectangle(normalizeRectangle(options.clip));
        } else {
          if (options.fullPage) {
            if (!options.captureBeyondViewport) {
              const scrollDimensions = await this.mainFrame().isolatedRealm().evaluate(() => {
                const element2 = document.documentElement;
                return {
                  width: element2.scrollWidth,
                  height: element2.scrollHeight
                };
              });
              const viewport = this.viewport();
              await this.setViewport({
                ...viewport,
                ...scrollDimensions
              });
              stack.defer(async () => {
                await this.setViewport(viewport).catch(debugError);
              });
            }
          } else {
            options.captureBeyondViewport = false;
          }
        }
        const data = await this._screenshot(options);
        if (options.encoding === "base64") {
          return data;
        }
        const buffer3 = Buffer.from(data, "base64");
        await this._maybeWriteBufferToFile(options.path, buffer3);
        return buffer3;
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        const result_1 = __disposeResources4(env_1);
        if (result_1)
          await result_1;
      }
    }
    /**
     * The page's title
     *
     * @remarks
     *
     * Shortcut for {@link Frame.title | page.mainFrame().title()}.
     */
    async title() {
      return await this.mainFrame().title();
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.mouse} to click in the center of the
     * element. If there's no element matching `selector`, the method throws an
     * error.
     *
     * @remarks
     *
     * Bear in mind that if `click()` triggers a navigation event and
     * there's a separate `page.waitForNavigation()` promise to be resolved, you
     * may end up with a race condition that yields unexpected results. The
     * correct pattern for click and wait for navigation is the following:
     *
     * ```ts
     * const [response] = await Promise.all([
     *   page.waitForNavigation(waitOptions),
     *   page.click(selector, clickOptions),
     * ]);
     * ```
     *
     * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.
     * @param selector - A `selector` to search for element to click. If there are
     * multiple elements satisfying the `selector`, the first will be clicked
     * @param options - `Object`
     * @returns Promise which resolves when the element matching `selector` is
     * successfully clicked. The Promise will be rejected if there is no element
     * matching `selector`.
     */
    click(selector, options) {
      return this.mainFrame().click(selector, options);
    }
    /**
     * This method fetches an element with `selector` and focuses it. If there's no
     * element matching `selector`, the method throws an error.
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector }
     * of an element to focus. If there are multiple elements satisfying the
     * selector, the first will be focused.
     * @returns Promise which resolves when the element matching selector is
     * successfully focused. The promise will be rejected if there is no element
     * matching selector.
     *
     * @remarks
     *
     * Shortcut for {@link Frame.focus | page.mainFrame().focus(selector)}.
     */
    focus(selector) {
      return this.mainFrame().focus(selector);
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.mouse}
     * to hover over the center of the element.
     * If there's no element matching `selector`, the method throws an error.
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * to search for element to hover. If there are multiple elements satisfying
     * the selector, the first will be hovered.
     * @returns Promise which resolves when the element matching `selector` is
     * successfully hovered. Promise gets rejected if there's no element matching
     * `selector`.
     *
     * @remarks
     *
     * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.
     */
    hover(selector) {
      return this.mainFrame().hover(selector);
    }
    /**
     * Triggers a `change` and `input` event once all the provided options have been
     * selected. If there's no `<select>` element matching `selector`, the method
     * throws an error.
     *
     * @example
     *
     * ```ts
     * page.select('select#colors', 'blue'); // single selection
     * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections
     * ```
     *
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}
     * to query the page for
     * @param values - Values of options to select. If the `<select>` has the
     * `multiple` attribute, all values are considered, otherwise only the first one
     * is taken into account.
     * @returns
     *
     * @remarks
     *
     * Shortcut for {@link Frame.select | page.mainFrame().select()}
     */
    select(selector, ...values4) {
      return this.mainFrame().select(selector, ...values4);
    }
    /**
     * This method fetches an element with `selector`, scrolls it into view if
     * needed, and then uses {@link Page.touchscreen}
     * to tap in the center of the element.
     * If there's no element matching `selector`, the method throws an error.
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}
     * to search for element to tap. If there are multiple elements satisfying the
     * selector, the first will be tapped.
     *
     * @remarks
     *
     * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.
     */
    tap(selector) {
      return this.mainFrame().tap(selector);
    }
    /**
     * Sends a `keydown`, `keypress/input`, and `keyup` event for each character
     * in the text.
     *
     * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.
     * @example
     *
     * ```ts
     * await page.type('#mytextarea', 'Hello');
     * // Types instantly
     * await page.type('#mytextarea', 'World', {delay: 100});
     * // Types slower, like a user
     * ```
     *
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * of an element to type into. If there are multiple elements satisfying the
     * selector, the first will be used.
     * @param text - A text to type into a focused element.
     * @param options - have property `delay` which is the Time to wait between
     * key presses in milliseconds. Defaults to `0`.
     * @returns
     */
    type(selector, text2, options) {
      return this.mainFrame().type(selector, text2, options);
    }
    /**
     * Wait for the `selector` to appear in page. If at the moment of calling the
     * method the `selector` already exists, the method will return immediately. If
     * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the
     * function will throw.
     *
     * @example
     * This method works across navigations:
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   let currentURL;
     *   page
     *     .waitForSelector('img')
     *     .then(() => console.log('First URL with image: ' + currentURL));
     *   for (currentURL of [
     *     'https://example.com',
     *     'https://google.com',
     *     'https://bbc.com',
     *   ]) {
     *     await page.goto(currentURL);
     *   }
     *   await browser.close();
     * })();
     * ```
     *
     * @param selector - A
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
     * of an element to wait for
     * @param options - Optional waiting parameters
     * @returns Promise which resolves when element specified by selector string
     * is added to DOM. Resolves to `null` if waiting for hidden: `true` and
     * selector is not found in DOM.
     *
     * @remarks
     * The optional Parameter in Arguments `options` are:
     *
     * - `visible`: A boolean wait for element to be present in DOM and to be
     *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS
     *   properties. Defaults to `false`.
     *
     * - `hidden`: Wait for element to not be found in the DOM or to be hidden,
     *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to
     *   `false`.
     *
     * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`
     *   (30 seconds). Pass `0` to disable timeout. The default value can be changed
     *   by using the {@link Page.setDefaultTimeout} method.
     */
    async waitForSelector(selector, options = {}) {
      return await this.mainFrame().waitForSelector(selector, options);
    }
    /**
     * Waits for the provided function, `pageFunction`, to return a truthy value when
     * evaluated in the page's context.
     *
     * @example
     * {@link Page.waitForFunction} can be used to observe a viewport size change:
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   const watchDog = page.waitForFunction('window.innerWidth < 100');
     *   await page.setViewport({width: 50, height: 50});
     *   await watchDog;
     *   await browser.close();
     * })();
     * ```
     *
     * @example
     * Arguments can be passed from Node.js to `pageFunction`:
     *
     * ```ts
     * const selector = '.foo';
     * await page.waitForFunction(
     *   selector => !!document.querySelector(selector),
     *   {},
     *   selector
     * );
     * ```
     *
     * @example
     * The provided `pageFunction` can be asynchronous:
     *
     * ```ts
     * const username = 'github-username';
     * await page.waitForFunction(
     *   async username => {
     *     const githubResponse = await fetch(
     *       `https://api.github.com/users/${username}`
     *     );
     *     const githubUser = await githubResponse.json();
     *     // show the avatar
     *     const img = document.createElement('img');
     *     img.src = githubUser.avatar_url;
     *     // wait 3 seconds
     *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));
     *     img.remove();
     *   },
     *   {},
     *   username
     * );
     * ```
     *
     * @param pageFunction - Function to be evaluated in browser context until it returns a
     * truthy value.
     * @param options - Options for configuring waiting behavior.
     */
    waitForFunction(pageFunction, options, ...args2) {
      return this.mainFrame().waitForFunction(pageFunction, options, ...args2);
    }
    /** @internal */
    [(_screenshot_decorators = [guarded(function() {
      return this.browser();
    })], disposeSymbol)]() {
      return void this.close().catch(debugError);
    }
    /** @internal */
    [asyncDisposeSymbol]() {
      return this.close();
    }
  };
})();
function normalizeRectangle(clip) {
  return {
    ...clip,
    ...clip.width < 0 ? {
      x: clip.x + clip.width,
      width: -clip.width
    } : {
      x: clip.x,
      width: clip.width
    },
    ...clip.height < 0 ? {
      y: clip.y + clip.height,
      height: -clip.height
    } : {
      y: clip.y,
      height: clip.height
    }
  };
}
__name(normalizeRectangle, "normalizeRectangle");
function roundRectangle(clip) {
  const x = Math.round(clip.x);
  const y = Math.round(clip.y);
  const width = Math.round(clip.width + clip.x - x);
  const height = Math.round(clip.height + clip.y - y);
  return { ...clip, x, y, width, height };
}
__name(roundRectangle, "roundRectangle");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/ConsoleMessage.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ConsoleMessage = class {
  static {
    __name(this, "ConsoleMessage");
  }
  #type;
  #text;
  #args;
  #stackTraceLocations;
  /**
   * @internal
   */
  constructor(type, text2, args2, stackTraceLocations) {
    this.#type = type;
    this.#text = text2;
    this.#args = args2;
    this.#stackTraceLocations = stackTraceLocations;
  }
  /**
   * The type of the console message.
   */
  type() {
    return this.#type;
  }
  /**
   * The text of the console message.
   */
  text() {
    return this.#text;
  }
  /**
   * An array of arguments passed to the console.
   */
  args() {
    return this.#args;
  }
  /**
   * The location of the console message.
   */
  location() {
    return this.#stackTraceLocations[0] ?? {};
  }
  /**
   * The array of locations on the stack of the console message.
   */
  stackTrace() {
    return this.#stackTraceLocations;
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/FileChooser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FileChooser = class {
  static {
    __name(this, "FileChooser");
  }
  #element;
  #multiple;
  #handled = false;
  /**
   * @internal
   */
  constructor(element2, event) {
    this.#element = element2;
    this.#multiple = event.mode !== "selectSingle";
  }
  /**
   * Whether file chooser allow for
   * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#attr-multiple | multiple}
   * file selection.
   */
  isMultiple() {
    return this.#multiple;
  }
  /**
   * Accept the file chooser request with the given file paths.
   *
   * @remarks This will not validate whether the file paths exists. Also, if a
   * path is relative, then it is resolved against the
   * {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.
   * For locals script connecting to remote chrome environments, paths must be
   * absolute.
   */
  async accept(paths2) {
    assert5(!this.#handled, "Cannot accept FileChooser which is already handled!");
    this.#handled = true;
    await this.#element.uploadFile(...paths2);
  }
  /**
   * Closes the file chooser without selecting any files.
   */
  async cancel() {
    assert5(!this.#handled, "Cannot cancel FileChooser which is already handled!");
    this.#handled = true;
    await this.#element.evaluate((element2) => {
      element2.dispatchEvent(new Event("cancel", { bubbles: true }));
    });
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/NetworkManagerEvents.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var NetworkManagerEvent;
(function(NetworkManagerEvent2) {
  NetworkManagerEvent2.Request = Symbol("NetworkManager.Request");
  NetworkManagerEvent2.RequestServedFromCache = Symbol("NetworkManager.RequestServedFromCache");
  NetworkManagerEvent2.Response = Symbol("NetworkManager.Response");
  NetworkManagerEvent2.RequestFailed = Symbol("NetworkManager.RequestFailed");
  NetworkManagerEvent2.RequestFinished = Symbol("NetworkManager.RequestFinished");
})(NetworkManagerEvent || (NetworkManagerEvent = {}));

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Binding.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/JSHandle.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __runInitializers2 = function(thisArg, initializers, value3) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value3 = useValue ? initializers[i].call(thisArg, value3) : initializers[i].call(thisArg);
  }
  return useValue ? value3 : void 0;
};
var __esDecorate2 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor3 = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done13 = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context10 = {};
    for (var p in contextIn) context10[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context10.access[p] = contextIn.access[p];
    context10.addInitializer = function(f) {
      if (done13) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor3.get, set: descriptor3.set } : descriptor3[key], context10);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor3.get = _;
      if (_ = accept(result.set)) descriptor3.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor3[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor3);
  done13 = true;
};
var __addDisposableResource5 = function(env2, value3, async4) {
  if (value3 !== null && value3 !== void 0) {
    if (typeof value3 !== "object" && typeof value3 !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async4) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value3[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value3[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env2.stack.push({ value: value3, dispose, async: async4 });
  } else if (async4) {
    env2.stack.push({ async: true });
  }
  return value3;
};
var __disposeResources5 = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail19(e) {
      env2.error = env2.hasError ? new SuppressedError2(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    __name(fail19, "fail");
    function next4() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async) return Promise.resolve(result).then(next4, function(e) {
            fail19(e);
            return next4();
          });
        } catch (e) {
          fail19(e);
        }
      }
      if (env2.hasError) throw env2.error;
    }
    __name(next4, "next");
    return next4();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error50, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error50, e.suppressed = suppressed, e;
});
var JSHandle = (() => {
  let _classDecorators = [moveable];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _instanceExtraInitializers = [];
  let _getProperty_decorators;
  let _getProperties_decorators;
  var JSHandle2 = class {
    static {
      __name(this, "JSHandle");
    }
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      __esDecorate2(this, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "getProperty" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.getProperty, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate2(this, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "getProperties" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.getProperties, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate2(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
      JSHandle2 = _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      __runInitializers2(_classThis, _classExtraInitializers);
    }
    /**
     * @internal
     */
    constructor() {
      __runInitializers2(this, _instanceExtraInitializers);
    }
    /**
     * Evaluates the given function with the current handle as its first argument.
     */
    async evaluate(pageFunction, ...args2) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      return await this.realm.evaluate(pageFunction, this, ...args2);
    }
    /**
     * Evaluates the given function with the current handle as its first argument.
     *
     */
    async evaluateHandle(pageFunction, ...args2) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      return await this.realm.evaluateHandle(pageFunction, this, ...args2);
    }
    /**
     * @internal
     */
    async getProperty(propertyName) {
      return await this.evaluateHandle((object4, propertyName2) => {
        return object4[propertyName2];
      }, propertyName);
    }
    /**
     * Gets a map of handles representing the properties of the current handle.
     *
     * @example
     *
     * ```ts
     * const listHandle = await page.evaluateHandle(() => document.body.children);
     * const properties = await listHandle.getProperties();
     * const children = [];
     * for (const property of properties.values()) {
     *   const element = property.asElement();
     *   if (element) {
     *     children.push(element);
     *   }
     * }
     * children; // holds elementHandles to all children of document.body
     * ```
     */
    async getProperties() {
      const propertyNames = await this.evaluate((object4) => {
        const enumerableProperties = [];
        const descriptors = Object.getOwnPropertyDescriptors(object4);
        for (const propertyName in descriptors) {
          if (descriptors[propertyName]?.enumerable) {
            enumerableProperties.push(propertyName);
          }
        }
        return enumerableProperties;
      });
      const map31 = /* @__PURE__ */ new Map();
      const results = await Promise.all(propertyNames.map((key) => {
        return this.getProperty(key);
      }));
      for (const [key, value3] of Object.entries(propertyNames)) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource5(env_1, results[key], false);
          if (handle) {
            map31.set(value3, handle.move());
          }
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources5(env_1);
        }
      }
      return map31;
    }
    /** @internal */
    [(_getProperty_decorators = [throwIfDisposed()], _getProperties_decorators = [throwIfDisposed()], disposeSymbol)]() {
      return void this.dispose().catch(debugError);
    }
    /** @internal */
    [asyncDisposeSymbol]() {
      return this.dispose();
    }
  };
  return JSHandle2 = _classThis;
})();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Binding.js
var __addDisposableResource6 = function(env2, value3, async4) {
  if (value3 !== null && value3 !== void 0) {
    if (typeof value3 !== "object" && typeof value3 !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async4) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value3[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value3[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env2.stack.push({ value: value3, dispose, async: async4 });
  } else if (async4) {
    env2.stack.push({ async: true });
  }
  return value3;
};
var __disposeResources6 = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail19(e) {
      env2.error = env2.hasError ? new SuppressedError2(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    __name(fail19, "fail");
    function next4() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async) return Promise.resolve(result).then(next4, function(e) {
            fail19(e);
            return next4();
          });
        } catch (e) {
          fail19(e);
        }
      }
      if (env2.hasError) throw env2.error;
    }
    __name(next4, "next");
    return next4();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error50, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error50, e.suppressed = suppressed, e;
});
var Binding = class {
  static {
    __name(this, "Binding");
  }
  #name;
  #fn;
  #initSource;
  constructor(name, fn2, initSource) {
    this.#name = name;
    this.#fn = fn2;
    this.#initSource = initSource;
  }
  get name() {
    return this.#name;
  }
  get initSource() {
    return this.#initSource;
  }
  /**
   * @param context - Context to run the binding in; the context should have
   * the binding added to it beforehand.
   * @param id - ID of the call. This should come from the CDP
   * `onBindingCalled` response.
   * @param args - Plain arguments from CDP.
   */
  async run(context10, id2, args2, isTrivial) {
    const stack = new DisposableStack();
    try {
      if (!isTrivial) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const handles = __addDisposableResource6(env_1, await context10.evaluateHandle((name, seq2) => {
            return globalThis[name].args.get(seq2);
          }, this.#name, id2), false);
          const properties = await handles.getProperties();
          for (const [index2, handle] of properties) {
            if (index2 in args2) {
              switch (handle.remoteObject().subtype) {
                case "node":
                  args2[+index2] = handle;
                  break;
                default:
                  stack.use(handle);
              }
            } else {
              stack.use(handle);
            }
          }
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          __disposeResources6(env_1);
        }
      }
      await context10.evaluate((name, seq2, result) => {
        const callbacks = globalThis[name].callbacks;
        callbacks.get(seq2).resolve(result);
        callbacks.delete(seq2);
      }, this.#name, id2, await this.#fn(...args2));
      for (const arg of args2) {
        if (arg instanceof JSHandle) {
          stack.use(arg);
        }
      }
    } catch (error50) {
      if (isErrorLike(error50)) {
        await context10.evaluate((name, seq2, message, stack2) => {
          const error51 = new Error(message);
          error51.stack = stack2;
          const callbacks = globalThis[name].callbacks;
          callbacks.get(seq2).reject(error51);
          callbacks.delete(seq2);
        }, this.#name, id2, error50.message, error50.stack).catch(debugError);
      } else {
        await context10.evaluate((name, seq2, error51) => {
          const callbacks = globalThis[name].callbacks;
          callbacks.get(seq2).reject(error51);
          callbacks.delete(seq2);
        }, this.#name, id2, error50).catch(debugError);
      }
    }
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Connection.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var debugProtocolSend = debug3("puppeteer:protocol:SEND \u25BA");
var debugProtocolReceive = debug3("puppeteer:protocol:RECV \u25C0");
var Connection = class extends EventEmitter2 {
  static {
    __name(this, "Connection");
  }
  #url;
  #transport;
  #delay;
  #timeout;
  #sessions = /* @__PURE__ */ new Map();
  #closed = false;
  #manuallyAttached = /* @__PURE__ */ new Set();
  #callbacks = new CallbackRegistry();
  constructor(url3, transport, delay3 = 0, timeout6) {
    super();
    this.#url = url3;
    this.#delay = delay3;
    this.#timeout = timeout6 ?? 18e4;
    this.#transport = transport;
    this.#transport.onmessage = this.onMessage.bind(this);
    this.#transport.onclose = this.#onClose.bind(this);
  }
  static fromSession(session) {
    return session.connection();
  }
  /**
   * @internal
   */
  get delay() {
    return this.#delay;
  }
  get timeout() {
    return this.#timeout;
  }
  /**
   * @internal
   */
  get _closed() {
    return this.#closed;
  }
  /**
   * @internal
   */
  get _sessions() {
    return this.#sessions;
  }
  /**
   * @param sessionId - The session id
   * @returns The current CDP session if it exists
   */
  session(sessionId) {
    return this.#sessions.get(sessionId) || null;
  }
  url() {
    return this.#url;
  }
  send(method, params, options) {
    return this._rawSend(this.#callbacks, method, params, void 0, options);
  }
  /**
   * @internal
   */
  _rawSend(callbacks, method, params, sessionId, options) {
    if (this.#closed) {
      return Promise.reject(new Error("Protocol error: Connection closed."));
    }
    return callbacks.create(method, options?.timeout ?? this.#timeout, (id2) => {
      const stringifiedMessage = JSON.stringify({
        method,
        params,
        id: id2,
        sessionId
      });
      debugProtocolSend(stringifiedMessage);
      this.#transport.send(stringifiedMessage);
    });
  }
  /**
   * @internal
   */
  async closeBrowser() {
    await this.send("Browser.close");
  }
  /**
   * @internal
   */
  async onMessage(message) {
    if (this.#delay) {
      await new Promise((r) => {
        return setTimeout(r, this.#delay);
      });
    }
    debugProtocolReceive(message);
    const object4 = JSON.parse(message);
    if (object4.method === "Target.attachedToTarget") {
      const sessionId = object4.params.sessionId;
      const session = new CdpCDPSession(this, object4.params.targetInfo.type, sessionId, object4.sessionId);
      this.#sessions.set(sessionId, session);
      this.emit(CDPSessionEvent.SessionAttached, session);
      const parentSession = this.#sessions.get(object4.sessionId);
      if (parentSession) {
        parentSession.emit(CDPSessionEvent.SessionAttached, session);
      }
    } else if (object4.method === "Target.detachedFromTarget") {
      const session = this.#sessions.get(object4.params.sessionId);
      if (session) {
        session._onClosed();
        this.#sessions.delete(object4.params.sessionId);
        this.emit(CDPSessionEvent.SessionDetached, session);
        const parentSession = this.#sessions.get(object4.sessionId);
        if (parentSession) {
          parentSession.emit(CDPSessionEvent.SessionDetached, session);
        }
      }
    }
    if (object4.sessionId) {
      const session = this.#sessions.get(object4.sessionId);
      if (session) {
        session._onMessage(object4);
      }
    } else if (object4.id) {
      if (object4.error) {
        this.#callbacks.reject(object4.id, createProtocolErrorMessage(object4), object4.error.message);
      } else {
        this.#callbacks.resolve(object4.id, object4.result);
      }
    } else {
      this.emit(object4.method, object4.params);
    }
  }
  #onClose() {
    if (this.#closed) {
      return;
    }
    this.#closed = true;
    this.#transport.onmessage = void 0;
    this.#transport.onclose = void 0;
    this.#callbacks.clear();
    for (const session of this.#sessions.values()) {
      session._onClosed();
    }
    this.#sessions.clear();
    this.emit(CDPSessionEvent.Disconnected, void 0);
  }
  dispose() {
    this.#onClose();
    this.#transport.close();
  }
  /**
   * @internal
   */
  isAutoAttached(targetId) {
    return !this.#manuallyAttached.has(targetId);
  }
  /**
   * @internal
   */
  async _createSession(targetInfo, isAutoAttachEmulated = true) {
    if (!isAutoAttachEmulated) {
      this.#manuallyAttached.add(targetInfo.targetId);
    }
    const { sessionId } = await this.send("Target.attachToTarget", {
      targetId: targetInfo.targetId,
      flatten: true
    });
    this.#manuallyAttached.delete(targetInfo.targetId);
    const session = this.#sessions.get(sessionId);
    if (!session) {
      throw new Error("CDPSession creation failed.");
    }
    return session;
  }
  /**
   * @param targetInfo - The target info
   * @returns The CDP session that is created
   */
  async createSession(targetInfo) {
    return await this._createSession(targetInfo, false);
  }
  /**
   * @internal
   */
  getPendingProtocolErrors() {
    const result = [];
    result.push(...this.#callbacks.getPendingProtocolErrors());
    for (const session of this.#sessions.values()) {
      result.push(...session.getPendingProtocolErrors());
    }
    return result;
  }
};
function isTargetClosedError(error50) {
  return error50 instanceof TargetCloseError;
}
__name(isTargetClosedError, "isTargetClosedError");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Coverage.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Coverage = class {
  static {
    __name(this, "Coverage");
  }
  #jsCoverage;
  #cssCoverage;
  /**
   * @internal
   */
  constructor(client) {
    this.#jsCoverage = new JSCoverage(client);
    this.#cssCoverage = new CSSCoverage(client);
  }
  /**
   * @internal
   */
  updateClient(client) {
    this.#jsCoverage.updateClient(client);
    this.#cssCoverage.updateClient(client);
  }
  /**
   * @param options - Set of configurable options for coverage defaults to
   * `resetOnNavigation : true, reportAnonymousScripts : false,`
   * `includeRawScriptCoverage : false, useBlockCoverage : true`
   * @returns Promise that resolves when coverage is started.
   *
   * @remarks
   * Anonymous scripts are ones that don't have an associated url. These are
   * scripts that are dynamically created on the page using `eval` or
   * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous
   * scripts URL will start with `debugger://VM` (unless a magic //# sourceURL
   * comment is present, in which case that will the be URL).
   */
  async startJSCoverage(options = {}) {
    return await this.#jsCoverage.start(options);
  }
  /**
   * Promise that resolves to the array of coverage reports for
   * all scripts.
   *
   * @remarks
   * JavaScript Coverage doesn't include anonymous scripts by default.
   * However, scripts with sourceURLs are reported.
   */
  async stopJSCoverage() {
    return await this.#jsCoverage.stop();
  }
  /**
   * @param options - Set of configurable options for coverage, defaults to
   * `resetOnNavigation : true`
   * @returns Promise that resolves when coverage is started.
   */
  async startCSSCoverage(options = {}) {
    return await this.#cssCoverage.start(options);
  }
  /**
   * Promise that resolves to the array of coverage reports
   * for all stylesheets.
   *
   * @remarks
   * CSS Coverage doesn't include dynamically injected style tags
   * without sourceURLs.
   */
  async stopCSSCoverage() {
    return await this.#cssCoverage.stop();
  }
};
var JSCoverage = class {
  static {
    __name(this, "JSCoverage");
  }
  #client;
  #enabled = false;
  #scriptURLs = /* @__PURE__ */ new Map();
  #scriptSources = /* @__PURE__ */ new Map();
  #subscriptions;
  #resetOnNavigation = false;
  #reportAnonymousScripts = false;
  #includeRawScriptCoverage = false;
  /**
   * @internal
   */
  constructor(client) {
    this.#client = client;
  }
  /**
   * @internal
   */
  updateClient(client) {
    this.#client = client;
  }
  async start(options = {}) {
    assert5(!this.#enabled, "JSCoverage is already enabled");
    const { resetOnNavigation = true, reportAnonymousScripts = false, includeRawScriptCoverage = false, useBlockCoverage = true } = options;
    this.#resetOnNavigation = resetOnNavigation;
    this.#reportAnonymousScripts = reportAnonymousScripts;
    this.#includeRawScriptCoverage = includeRawScriptCoverage;
    this.#enabled = true;
    this.#scriptURLs.clear();
    this.#scriptSources.clear();
    this.#subscriptions = new DisposableStack();
    const clientEmitter = this.#subscriptions.use(new EventEmitter2(this.#client));
    clientEmitter.on("Debugger.scriptParsed", this.#onScriptParsed.bind(this));
    clientEmitter.on("Runtime.executionContextsCleared", this.#onExecutionContextsCleared.bind(this));
    await Promise.all([
      this.#client.send("Profiler.enable"),
      this.#client.send("Profiler.startPreciseCoverage", {
        callCount: this.#includeRawScriptCoverage,
        detailed: useBlockCoverage
      }),
      this.#client.send("Debugger.enable"),
      this.#client.send("Debugger.setSkipAllPauses", { skip: true })
    ]);
  }
  #onExecutionContextsCleared() {
    if (!this.#resetOnNavigation) {
      return;
    }
    this.#scriptURLs.clear();
    this.#scriptSources.clear();
  }
  async #onScriptParsed(event) {
    if (PuppeteerURL.isPuppeteerURL(event.url)) {
      return;
    }
    if (!event.url && !this.#reportAnonymousScripts) {
      return;
    }
    try {
      const response = await this.#client.send("Debugger.getScriptSource", {
        scriptId: event.scriptId
      });
      this.#scriptURLs.set(event.scriptId, event.url);
      this.#scriptSources.set(event.scriptId, response.scriptSource);
    } catch (error50) {
      debugError(error50);
    }
  }
  async stop() {
    assert5(this.#enabled, "JSCoverage is not enabled");
    this.#enabled = false;
    const result = await Promise.all([
      this.#client.send("Profiler.takePreciseCoverage"),
      this.#client.send("Profiler.stopPreciseCoverage"),
      this.#client.send("Profiler.disable"),
      this.#client.send("Debugger.disable")
    ]);
    this.#subscriptions?.dispose();
    const coverage = [];
    const profileResponse = result[0];
    for (const entry of profileResponse.result) {
      let url3 = this.#scriptURLs.get(entry.scriptId);
      if (!url3 && this.#reportAnonymousScripts) {
        url3 = "debugger://VM" + entry.scriptId;
      }
      const text2 = this.#scriptSources.get(entry.scriptId);
      if (text2 === void 0 || url3 === void 0) {
        continue;
      }
      const flattenRanges = [];
      for (const func2 of entry.functions) {
        flattenRanges.push(...func2.ranges);
      }
      const ranges = convertToDisjointRanges(flattenRanges);
      if (!this.#includeRawScriptCoverage) {
        coverage.push({ url: url3, ranges, text: text2 });
      } else {
        coverage.push({ url: url3, ranges, text: text2, rawScriptCoverage: entry });
      }
    }
    return coverage;
  }
};
var CSSCoverage = class {
  static {
    __name(this, "CSSCoverage");
  }
  #client;
  #enabled = false;
  #stylesheetURLs = /* @__PURE__ */ new Map();
  #stylesheetSources = /* @__PURE__ */ new Map();
  #eventListeners;
  #resetOnNavigation = false;
  constructor(client) {
    this.#client = client;
  }
  /**
   * @internal
   */
  updateClient(client) {
    this.#client = client;
  }
  async start(options = {}) {
    assert5(!this.#enabled, "CSSCoverage is already enabled");
    const { resetOnNavigation = true } = options;
    this.#resetOnNavigation = resetOnNavigation;
    this.#enabled = true;
    this.#stylesheetURLs.clear();
    this.#stylesheetSources.clear();
    this.#eventListeners = new DisposableStack();
    const clientEmitter = this.#eventListeners.use(new EventEmitter2(this.#client));
    clientEmitter.on("CSS.styleSheetAdded", this.#onStyleSheet.bind(this));
    clientEmitter.on("Runtime.executionContextsCleared", this.#onExecutionContextsCleared.bind(this));
    await Promise.all([
      this.#client.send("DOM.enable"),
      this.#client.send("CSS.enable"),
      this.#client.send("CSS.startRuleUsageTracking")
    ]);
  }
  #onExecutionContextsCleared() {
    if (!this.#resetOnNavigation) {
      return;
    }
    this.#stylesheetURLs.clear();
    this.#stylesheetSources.clear();
  }
  async #onStyleSheet(event) {
    const header = event.header;
    if (!header.sourceURL) {
      return;
    }
    try {
      const response = await this.#client.send("CSS.getStyleSheetText", {
        styleSheetId: header.styleSheetId
      });
      this.#stylesheetURLs.set(header.styleSheetId, header.sourceURL);
      this.#stylesheetSources.set(header.styleSheetId, response.text);
    } catch (error50) {
      debugError(error50);
    }
  }
  async stop() {
    assert5(this.#enabled, "CSSCoverage is not enabled");
    this.#enabled = false;
    const ruleTrackingResponse = await this.#client.send("CSS.stopRuleUsageTracking");
    await Promise.all([
      this.#client.send("CSS.disable"),
      this.#client.send("DOM.disable")
    ]);
    this.#eventListeners?.dispose();
    const styleSheetIdToCoverage = /* @__PURE__ */ new Map();
    for (const entry of ruleTrackingResponse.ruleUsage) {
      let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
      if (!ranges) {
        ranges = [];
        styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
      }
      ranges.push({
        startOffset: entry.startOffset,
        endOffset: entry.endOffset,
        count: entry.used ? 1 : 0
      });
    }
    const coverage = [];
    for (const styleSheetId of this.#stylesheetURLs.keys()) {
      const url3 = this.#stylesheetURLs.get(styleSheetId);
      assert5(typeof url3 !== "undefined", `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);
      const text2 = this.#stylesheetSources.get(styleSheetId);
      assert5(typeof text2 !== "undefined", `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);
      const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
      coverage.push({ url: url3, ranges, text: text2 });
    }
    return coverage;
  }
};
function convertToDisjointRanges(nestedRanges) {
  const points = [];
  for (const range4 of nestedRanges) {
    points.push({ offset: range4.startOffset, type: 0, range: range4 });
    points.push({ offset: range4.endOffset, type: 1, range: range4 });
  }
  points.sort((a, b) => {
    if (a.offset !== b.offset) {
      return a.offset - b.offset;
    }
    if (a.type !== b.type) {
      return b.type - a.type;
    }
    const aLength = a.range.endOffset - a.range.startOffset;
    const bLength = b.range.endOffset - b.range.startOffset;
    if (a.type === 0) {
      return bLength - aLength;
    }
    return aLength - bLength;
  });
  const hitCountStack = [];
  const results = [];
  let lastOffset = 0;
  for (const point of points) {
    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
      const lastResult = results[results.length - 1];
      if (lastResult && lastResult.end === lastOffset) {
        lastResult.end = point.offset;
      } else {
        results.push({ start: lastOffset, end: point.offset });
      }
    }
    lastOffset = point.offset;
    if (point.type === 0) {
      hitCountStack.push(point.range.count);
    } else {
      hitCountStack.pop();
    }
  }
  return results.filter((range4) => {
    return range4.end - range4.start > 0;
  });
}
__name(convertToDisjointRanges, "convertToDisjointRanges");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Dialog.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/Dialog.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Dialog = class {
  static {
    __name(this, "Dialog");
  }
  #type;
  #message;
  #defaultValue;
  /**
   * @internal
   */
  handled = false;
  /**
   * @internal
   */
  constructor(type, message, defaultValue = "") {
    this.#type = type;
    this.#message = message;
    this.#defaultValue = defaultValue;
  }
  /**
   * The type of the dialog.
   */
  type() {
    return this.#type;
  }
  /**
   * The message displayed in the dialog.
   */
  message() {
    return this.#message;
  }
  /**
   * The default value of the prompt, or an empty string if the dialog
   * is not a `prompt`.
   */
  defaultValue() {
    return this.#defaultValue;
  }
  /**
   * A promise that resolves when the dialog has been accepted.
   *
   * @param promptText - optional text that will be entered in the dialog
   * prompt. Has no effect if the dialog's type is not `prompt`.
   *
   */
  async accept(promptText) {
    assert5(!this.handled, "Cannot accept dialog which is already handled!");
    this.handled = true;
    await this.handle({
      accept: true,
      text: promptText
    });
  }
  /**
   * A promise which will resolve once the dialog has been dismissed
   */
  async dismiss() {
    assert5(!this.handled, "Cannot dismiss dialog which is already handled!");
    this.handled = true;
    await this.handle({
      accept: false
    });
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Dialog.js
var CdpDialog = class extends Dialog {
  static {
    __name(this, "CdpDialog");
  }
  #client;
  constructor(client, type, message, defaultValue = "") {
    super(type, message, defaultValue);
    this.#client = client;
  }
  async handle(options) {
    await this.#client.send("Page.handleJavaScriptDialog", {
      accept: options.accept,
      promptText: options.text
    });
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/EmulationManager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __runInitializers3 = function(thisArg, initializers, value3) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value3 = useValue ? initializers[i].call(thisArg, value3) : initializers[i].call(thisArg);
  }
  return useValue ? value3 : void 0;
};
var __esDecorate3 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor3 = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done13 = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context10 = {};
    for (var p in contextIn) context10[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context10.access[p] = contextIn.access[p];
    context10.addInitializer = function(f) {
      if (done13) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor3.get, set: descriptor3.set } : descriptor3[key], context10);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor3.get = _;
      if (_ = accept(result.set)) descriptor3.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor3[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor3);
  done13 = true;
};
var __setFunctionName = function(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
var EmulatedState = class {
  static {
    __name(this, "EmulatedState");
  }
  #state;
  #clientProvider;
  #updater;
  constructor(initialState, clientProvider, updater) {
    this.#state = initialState;
    this.#clientProvider = clientProvider;
    this.#updater = updater;
    this.#clientProvider.registerState(this);
  }
  async setState(state) {
    this.#state = state;
    await this.sync();
  }
  get state() {
    return this.#state;
  }
  async sync() {
    await Promise.all(this.#clientProvider.clients().map((client) => {
      return this.#updater(client, this.#state);
    }));
  }
};
var EmulationManager = (() => {
  let _instanceExtraInitializers = [];
  let _private_applyViewport_decorators;
  let _private_applyViewport_descriptor;
  let _private_emulateIdleState_decorators;
  let _private_emulateIdleState_descriptor;
  let _private_emulateTimezone_decorators;
  let _private_emulateTimezone_descriptor;
  let _private_emulateVisionDeficiency_decorators;
  let _private_emulateVisionDeficiency_descriptor;
  let _private_emulateCpuThrottling_decorators;
  let _private_emulateCpuThrottling_descriptor;
  let _private_emulateMediaFeatures_decorators;
  let _private_emulateMediaFeatures_descriptor;
  let _private_emulateMediaType_decorators;
  let _private_emulateMediaType_descriptor;
  let _private_setGeolocation_decorators;
  let _private_setGeolocation_descriptor;
  let _private_setDefaultBackgroundColor_decorators;
  let _private_setDefaultBackgroundColor_descriptor;
  let _private_setJavaScriptEnabled_decorators;
  let _private_setJavaScriptEnabled_descriptor;
  return class EmulationManager {
    static {
      __name(this, "EmulationManager");
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _private_applyViewport_decorators = [invokeAtMostOnceForArguments];
      _private_emulateIdleState_decorators = [invokeAtMostOnceForArguments];
      _private_emulateTimezone_decorators = [invokeAtMostOnceForArguments];
      _private_emulateVisionDeficiency_decorators = [invokeAtMostOnceForArguments];
      _private_emulateCpuThrottling_decorators = [invokeAtMostOnceForArguments];
      _private_emulateMediaFeatures_decorators = [invokeAtMostOnceForArguments];
      _private_emulateMediaType_decorators = [invokeAtMostOnceForArguments];
      _private_setGeolocation_decorators = [invokeAtMostOnceForArguments];
      _private_setDefaultBackgroundColor_decorators = [invokeAtMostOnceForArguments];
      _private_setJavaScriptEnabled_decorators = [invokeAtMostOnceForArguments];
      __esDecorate3(this, _private_applyViewport_descriptor = { value: __setFunctionName(async function(client, viewportState) {
        if (!viewportState.viewport) {
          await Promise.all([
            client.send("Emulation.clearDeviceMetricsOverride"),
            client.send("Emulation.setTouchEmulationEnabled", {
              enabled: false
            })
          ]).catch(debugError);
          return;
        }
        const { viewport } = viewportState;
        const mobile = viewport.isMobile || false;
        const width = viewport.width;
        const height = viewport.height;
        const deviceScaleFactor = viewport.deviceScaleFactor ?? 1;
        const screenOrientation = viewport.isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
        const hasTouch = viewport.hasTouch || false;
        await Promise.all([
          client.send("Emulation.setDeviceMetricsOverride", {
            mobile,
            width,
            height,
            deviceScaleFactor,
            screenOrientation
          }).catch((err) => {
            if (err.message.includes("Target does not support metrics override")) {
              debugError(err);
              return;
            }
            throw err;
          }),
          client.send("Emulation.setTouchEmulationEnabled", {
            enabled: hasTouch
          })
        ]);
      }, "#applyViewport") }, _private_applyViewport_decorators, { kind: "method", name: "#applyViewport", static: false, private: true, access: { has: /* @__PURE__ */ __name((obj) => #applyViewport in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.#applyViewport, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate3(this, _private_emulateIdleState_descriptor = { value: __setFunctionName(async function(client, idleStateState) {
        if (!idleStateState.active) {
          return;
        }
        if (idleStateState.overrides) {
          await client.send("Emulation.setIdleOverride", {
            isUserActive: idleStateState.overrides.isUserActive,
            isScreenUnlocked: idleStateState.overrides.isScreenUnlocked
          });
        } else {
          await client.send("Emulation.clearIdleOverride");
        }
      }, "#emulateIdleState") }, _private_emulateIdleState_decorators, { kind: "method", name: "#emulateIdleState", static: false, private: true, access: { has: /* @__PURE__ */ __name((obj) => #emulateIdleState in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.#emulateIdleState, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate3(this, _private_emulateTimezone_descriptor = { value: __setFunctionName(async function(client, timezoneState) {
        if (!timezoneState.active) {
          return;
        }
        try {
          await client.send("Emulation.setTimezoneOverride", {
            timezoneId: timezoneState.timezoneId || ""
          });
        } catch (error50) {
          if (isErrorLike(error50) && error50.message.includes("Invalid timezone")) {
            throw new Error(`Invalid timezone ID: ${timezoneState.timezoneId}`);
          }
          throw error50;
        }
      }, "#emulateTimezone") }, _private_emulateTimezone_decorators, { kind: "method", name: "#emulateTimezone", static: false, private: true, access: { has: /* @__PURE__ */ __name((obj) => #emulateTimezone in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.#emulateTimezone, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate3(this, _private_emulateVisionDeficiency_descriptor = { value: __setFunctionName(async function(client, visionDeficiency) {
        if (!visionDeficiency.active) {
          return;
        }
        await client.send("Emulation.setEmulatedVisionDeficiency", {
          type: visionDeficiency.visionDeficiency || "none"
        });
      }, "#emulateVisionDeficiency") }, _private_emulateVisionDeficiency_decorators, { kind: "method", name: "#emulateVisionDeficiency", static: false, private: true, access: { has: /* @__PURE__ */ __name((obj) => #emulateVisionDeficiency in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.#emulateVisionDeficiency, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate3(this, _private_emulateCpuThrottling_descriptor = { value: __setFunctionName(async function(client, state) {
        if (!state.active) {
          return;
        }
        await client.send("Emulation.setCPUThrottlingRate", {
          rate: state.factor ?? 1
        });
      }, "#emulateCpuThrottling") }, _private_emulateCpuThrottling_decorators, { kind: "method", name: "#emulateCpuThrottling", static: false, private: true, access: { has: /* @__PURE__ */ __name((obj) => #emulateCpuThrottling in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.#emulateCpuThrottling, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate3(this, _private_emulateMediaFeatures_descriptor = { value: __setFunctionName(async function(client, state) {
        if (!state.active) {
          return;
        }
        await client.send("Emulation.setEmulatedMedia", {
          features: state.mediaFeatures
        });
      }, "#emulateMediaFeatures") }, _private_emulateMediaFeatures_decorators, { kind: "method", name: "#emulateMediaFeatures", static: false, private: true, access: { has: /* @__PURE__ */ __name((obj) => #emulateMediaFeatures in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.#emulateMediaFeatures, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate3(this, _private_emulateMediaType_descriptor = { value: __setFunctionName(async function(client, state) {
        if (!state.active) {
          return;
        }
        await client.send("Emulation.setEmulatedMedia", {
          media: state.type || ""
        });
      }, "#emulateMediaType") }, _private_emulateMediaType_decorators, { kind: "method", name: "#emulateMediaType", static: false, private: true, access: { has: /* @__PURE__ */ __name((obj) => #emulateMediaType in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.#emulateMediaType, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate3(this, _private_setGeolocation_descriptor = { value: __setFunctionName(async function(client, state) {
        if (!state.active) {
          return;
        }
        await client.send("Emulation.setGeolocationOverride", state.geoLocation ? {
          longitude: state.geoLocation.longitude,
          latitude: state.geoLocation.latitude,
          accuracy: state.geoLocation.accuracy
        } : void 0);
      }, "#setGeolocation") }, _private_setGeolocation_decorators, { kind: "method", name: "#setGeolocation", static: false, private: true, access: { has: /* @__PURE__ */ __name((obj) => #setGeolocation in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.#setGeolocation, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate3(this, _private_setDefaultBackgroundColor_descriptor = { value: __setFunctionName(async function(client, state) {
        if (!state.active) {
          return;
        }
        await client.send("Emulation.setDefaultBackgroundColorOverride", {
          color: state.color
        });
      }, "#setDefaultBackgroundColor") }, _private_setDefaultBackgroundColor_decorators, { kind: "method", name: "#setDefaultBackgroundColor", static: false, private: true, access: { has: /* @__PURE__ */ __name((obj) => #setDefaultBackgroundColor in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.#setDefaultBackgroundColor, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate3(this, _private_setJavaScriptEnabled_descriptor = { value: __setFunctionName(async function(client, state) {
        if (!state.active) {
          return;
        }
        await client.send("Emulation.setScriptExecutionDisabled", {
          value: !state.javaScriptEnabled
        });
      }, "#setJavaScriptEnabled") }, _private_setJavaScriptEnabled_decorators, { kind: "method", name: "#setJavaScriptEnabled", static: false, private: true, access: { has: /* @__PURE__ */ __name((obj) => #setJavaScriptEnabled in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.#setJavaScriptEnabled, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    }
    #client = __runInitializers3(this, _instanceExtraInitializers);
    #emulatingMobile = false;
    #hasTouch = false;
    #states = [];
    #viewportState = new EmulatedState({
      active: false
    }, this, this.#applyViewport);
    #idleOverridesState = new EmulatedState({
      active: false
    }, this, this.#emulateIdleState);
    #timezoneState = new EmulatedState({
      active: false
    }, this, this.#emulateTimezone);
    #visionDeficiencyState = new EmulatedState({
      active: false
    }, this, this.#emulateVisionDeficiency);
    #cpuThrottlingState = new EmulatedState({
      active: false
    }, this, this.#emulateCpuThrottling);
    #mediaFeaturesState = new EmulatedState({
      active: false
    }, this, this.#emulateMediaFeatures);
    #mediaTypeState = new EmulatedState({
      active: false
    }, this, this.#emulateMediaType);
    #geoLocationState = new EmulatedState({
      active: false
    }, this, this.#setGeolocation);
    #defaultBackgroundColorState = new EmulatedState({
      active: false
    }, this, this.#setDefaultBackgroundColor);
    #javascriptEnabledState = new EmulatedState({
      javaScriptEnabled: true,
      active: false
    }, this, this.#setJavaScriptEnabled);
    #secondaryClients = /* @__PURE__ */ new Set();
    constructor(client) {
      this.#client = client;
    }
    updateClient(client) {
      this.#client = client;
      this.#secondaryClients.delete(client);
    }
    registerState(state) {
      this.#states.push(state);
    }
    clients() {
      return [this.#client, ...Array.from(this.#secondaryClients)];
    }
    async registerSpeculativeSession(client) {
      this.#secondaryClients.add(client);
      client.once(CDPSessionEvent.Disconnected, () => {
        this.#secondaryClients.delete(client);
      });
      void Promise.all(this.#states.map((s) => {
        return s.sync().catch(debugError);
      }));
    }
    get javascriptEnabled() {
      return this.#javascriptEnabledState.state.javaScriptEnabled;
    }
    async emulateViewport(viewport) {
      const currentState = this.#viewportState.state;
      if (!viewport && !currentState.active) {
        return false;
      }
      await this.#viewportState.setState(viewport ? {
        viewport,
        active: true
      } : {
        active: false
      });
      const mobile = viewport?.isMobile || false;
      const hasTouch = viewport?.hasTouch || false;
      const reloadNeeded = this.#emulatingMobile !== mobile || this.#hasTouch !== hasTouch;
      this.#emulatingMobile = mobile;
      this.#hasTouch = hasTouch;
      return reloadNeeded;
    }
    get #applyViewport() {
      return _private_applyViewport_descriptor.value;
    }
    async emulateIdleState(overrides) {
      await this.#idleOverridesState.setState({
        active: true,
        overrides
      });
    }
    get #emulateIdleState() {
      return _private_emulateIdleState_descriptor.value;
    }
    get #emulateTimezone() {
      return _private_emulateTimezone_descriptor.value;
    }
    async emulateTimezone(timezoneId) {
      await this.#timezoneState.setState({
        timezoneId,
        active: true
      });
    }
    get #emulateVisionDeficiency() {
      return _private_emulateVisionDeficiency_descriptor.value;
    }
    async emulateVisionDeficiency(type) {
      const visionDeficiencies = /* @__PURE__ */ new Set([
        "none",
        "achromatopsia",
        "blurredVision",
        "deuteranopia",
        "protanopia",
        "tritanopia"
      ]);
      assert5(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);
      await this.#visionDeficiencyState.setState({
        active: true,
        visionDeficiency: type
      });
    }
    get #emulateCpuThrottling() {
      return _private_emulateCpuThrottling_descriptor.value;
    }
    async emulateCPUThrottling(factor) {
      assert5(factor === null || factor >= 1, "Throttling rate should be greater or equal to 1");
      await this.#cpuThrottlingState.setState({
        active: true,
        factor: factor ?? void 0
      });
    }
    get #emulateMediaFeatures() {
      return _private_emulateMediaFeatures_descriptor.value;
    }
    async emulateMediaFeatures(features2) {
      if (Array.isArray(features2)) {
        for (const mediaFeature of features2) {
          const name = mediaFeature.name;
          assert5(/^(?:prefers-(?:color-scheme|reduced-motion)|color-gamut)$/.test(name), "Unsupported media feature: " + name);
        }
      }
      await this.#mediaFeaturesState.setState({
        active: true,
        mediaFeatures: features2
      });
    }
    get #emulateMediaType() {
      return _private_emulateMediaType_descriptor.value;
    }
    async emulateMediaType(type) {
      assert5(type === "screen" || type === "print" || (type ?? void 0) === void 0, "Unsupported media type: " + type);
      await this.#mediaTypeState.setState({
        type,
        active: true
      });
    }
    get #setGeolocation() {
      return _private_setGeolocation_descriptor.value;
    }
    async setGeolocation(options) {
      const { longitude, latitude, accuracy = 0 } = options;
      if (longitude < -180 || longitude > 180) {
        throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
      }
      if (latitude < -90 || latitude > 90) {
        throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
      }
      if (accuracy < 0) {
        throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
      }
      await this.#geoLocationState.setState({
        active: true,
        geoLocation: {
          longitude,
          latitude,
          accuracy
        }
      });
    }
    get #setDefaultBackgroundColor() {
      return _private_setDefaultBackgroundColor_descriptor.value;
    }
    /**
     * Resets default white background
     */
    async resetDefaultBackgroundColor() {
      await this.#defaultBackgroundColorState.setState({
        active: true,
        color: void 0
      });
    }
    /**
     * Hides default white background
     */
    async setTransparentBackgroundColor() {
      await this.#defaultBackgroundColorState.setState({
        active: true,
        color: { r: 0, g: 0, b: 0, a: 0 }
      });
    }
    get #setJavaScriptEnabled() {
      return _private_setJavaScriptEnabled_descriptor.value;
    }
    async setJavaScriptEnabled(enabled2) {
      await this.#javascriptEnabledState.setState({
        active: true,
        javaScriptEnabled: enabled2
      });
    }
  };
})();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/FirefoxTargetManager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FirefoxTargetManager = class extends EventEmitter2 {
  static {
    __name(this, "FirefoxTargetManager");
  }
  #connection;
  /**
   * Keeps track of the following events: 'Target.targetCreated',
   * 'Target.targetDestroyed'.
   *
   * A target becomes discovered when 'Target.targetCreated' is received.
   * A target is removed from this map once 'Target.targetDestroyed' is
   * received.
   *
   * `targetFilterCallback` has no effect on this map.
   */
  #discoveredTargetsByTargetId = /* @__PURE__ */ new Map();
  /**
   * Keeps track of targets that were created via 'Target.targetCreated'
   * and which one are not filtered out by `targetFilterCallback`.
   *
   * The target is removed from here once it's been destroyed.
   */
  #availableTargetsByTargetId = /* @__PURE__ */ new Map();
  /**
   * Tracks which sessions attach to which target.
   */
  #availableTargetsBySessionId = /* @__PURE__ */ new Map();
  #targetFilterCallback;
  #targetFactory;
  #attachedToTargetListenersBySession = /* @__PURE__ */ new WeakMap();
  #initializeDeferred = Deferred.create();
  #targetsIdsForInit = /* @__PURE__ */ new Set();
  constructor(connection, targetFactory, targetFilterCallback) {
    super();
    this.#connection = connection;
    this.#targetFilterCallback = targetFilterCallback;
    this.#targetFactory = targetFactory;
    this.#connection.on("Target.targetCreated", this.#onTargetCreated);
    this.#connection.on("Target.targetDestroyed", this.#onTargetDestroyed);
    this.#connection.on(CDPSessionEvent.SessionDetached, this.#onSessionDetached);
    this.setupAttachmentListeners(this.#connection);
  }
  setupAttachmentListeners(session) {
    const listener = /* @__PURE__ */ __name((event) => {
      return this.#onAttachedToTarget(session, event);
    }, "listener");
    assert5(!this.#attachedToTargetListenersBySession.has(session));
    this.#attachedToTargetListenersBySession.set(session, listener);
    session.on("Target.attachedToTarget", listener);
  }
  #onSessionDetached = /* @__PURE__ */ __name((session) => {
    this.removeSessionListeners(session);
    this.#availableTargetsBySessionId.delete(session.id());
  }, "#onSessionDetached");
  removeSessionListeners(session) {
    if (this.#attachedToTargetListenersBySession.has(session)) {
      session.off("Target.attachedToTarget", this.#attachedToTargetListenersBySession.get(session));
      this.#attachedToTargetListenersBySession.delete(session);
    }
  }
  getAvailableTargets() {
    return this.#availableTargetsByTargetId;
  }
  getChildTargets(_target) {
    return /* @__PURE__ */ new Set();
  }
  dispose() {
    this.#connection.off("Target.targetCreated", this.#onTargetCreated);
    this.#connection.off("Target.targetDestroyed", this.#onTargetDestroyed);
  }
  async initialize() {
    await this.#connection.send("Target.setDiscoverTargets", {
      discover: true,
      filter: [{}]
    });
    this.#targetsIdsForInit = new Set(this.#discoveredTargetsByTargetId.keys());
    await this.#initializeDeferred.valueOrThrow();
  }
  #onTargetCreated = /* @__PURE__ */ __name(async (event) => {
    if (this.#discoveredTargetsByTargetId.has(event.targetInfo.targetId)) {
      return;
    }
    this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
    if (event.targetInfo.type === "browser" && event.targetInfo.attached) {
      const target2 = this.#targetFactory(event.targetInfo, void 0);
      target2._initialize();
      this.#availableTargetsByTargetId.set(event.targetInfo.targetId, target2);
      this.#finishInitializationIfReady(target2._targetId);
      return;
    }
    const target = this.#targetFactory(event.targetInfo, void 0);
    if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {
      this.#finishInitializationIfReady(event.targetInfo.targetId);
      return;
    }
    target._initialize();
    this.#availableTargetsByTargetId.set(event.targetInfo.targetId, target);
    this.emit("targetAvailable", target);
    this.#finishInitializationIfReady(target._targetId);
  }, "#onTargetCreated");
  #onTargetDestroyed = /* @__PURE__ */ __name((event) => {
    this.#discoveredTargetsByTargetId.delete(event.targetId);
    this.#finishInitializationIfReady(event.targetId);
    const target = this.#availableTargetsByTargetId.get(event.targetId);
    if (target) {
      this.emit("targetGone", target);
      this.#availableTargetsByTargetId.delete(event.targetId);
    }
  }, "#onTargetDestroyed");
  #onAttachedToTarget = /* @__PURE__ */ __name(async (parentSession, event) => {
    const targetInfo = event.targetInfo;
    const session = this.#connection.session(event.sessionId);
    if (!session) {
      throw new Error(`Session ${event.sessionId} was not created.`);
    }
    const target = this.#availableTargetsByTargetId.get(targetInfo.targetId);
    assert5(target, `Target ${targetInfo.targetId} is missing`);
    session._setTarget(target);
    this.setupAttachmentListeners(session);
    this.#availableTargetsBySessionId.set(session.id(), this.#availableTargetsByTargetId.get(targetInfo.targetId));
    parentSession.emit(CDPSessionEvent.Ready, session);
  }, "#onAttachedToTarget");
  #finishInitializationIfReady(targetId) {
    this.#targetsIdsForInit.delete(targetId);
    if (this.#targetsIdsForInit.size === 0) {
      this.#initializeDeferred.resolve();
    }
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/FrameManager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/Frame.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/GetQueryHandler.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/AriaQueryHandler.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/QueryHandler.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/ElementHandleSymbol.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var _isElementHandle = Symbol("_isElementHandle");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/util/Function.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var createdFunctions = /* @__PURE__ */ new Map();
var createFunction = /* @__PURE__ */ __name((functionValue) => {
  let fn2 = createdFunctions.get(functionValue);
  if (fn2) {
    return fn2;
  }
  fn2 = new Function(`return ${functionValue}`)();
  createdFunctions.set(functionValue, fn2);
  return fn2;
}, "createFunction");
function stringifyFunction(fn2) {
  let value3;
  if (typeof fn2 === "function" && globalThis.navigator?.userAgent === "Cloudflare-Workers") {
    value3 = `((__name => (${fn2}))(t => t))`;
  } else {
    value3 = fn2.toString();
  }
  return value3;
}
__name(stringifyFunction, "stringifyFunction");
var interpolateFunction = /* @__PURE__ */ __name((fn2, replacements) => {
  let value3 = stringifyFunction(fn2);
  for (const [name, jsValue] of Object.entries(replacements)) {
    value3 = value3.replace(
      new RegExp(`PLACEHOLDER\\(\\s*(?:'${name}'|"${name}")\\s*\\)`, "g"),
      // Wrapping this ensures tersers that accidentally inline PLACEHOLDER calls
      // are still valid. Without, we may get calls like ()=>{...}() which is
      // not valid.
      `(${jsValue})`
    );
  }
  return createFunction(value3);
}, "interpolateFunction");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/HandleIterator.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __addDisposableResource7 = function(env2, value3, async4) {
  if (value3 !== null && value3 !== void 0) {
    if (typeof value3 !== "object" && typeof value3 !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async4) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value3[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value3[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env2.stack.push({ value: value3, dispose, async: async4 });
  } else if (async4) {
    env2.stack.push({ async: true });
  }
  return value3;
};
var __disposeResources7 = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail19(e) {
      env2.error = env2.hasError ? new SuppressedError2(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    __name(fail19, "fail");
    function next4() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async) return Promise.resolve(result).then(next4, function(e) {
            fail19(e);
            return next4();
          });
        } catch (e) {
          fail19(e);
        }
      }
      if (env2.hasError) throw env2.error;
    }
    __name(next4, "next");
    return next4();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error50, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error50, e.suppressed = suppressed, e;
});
var DEFAULT_BATCH_SIZE = 20;
async function* fastTransposeIteratorHandle(iterator2, size15) {
  const env_1 = { stack: [], error: void 0, hasError: false };
  try {
    const array7 = __addDisposableResource7(env_1, await iterator2.evaluateHandle(async (iterator3, size16) => {
      const results = [];
      while (results.length < size16) {
        const result = await iterator3.next();
        if (result.done) {
          break;
        }
        results.push(result.value);
      }
      return results;
    }, size15), false);
    const properties = await array7.getProperties();
    const handles = properties.values();
    const stack = __addDisposableResource7(env_1, new DisposableStack(), false);
    stack.defer(() => {
      for (const handle_1 of handles) {
        const env_2 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource7(env_2, handle_1, false);
          handle[disposeSymbol]();
        } catch (e_2) {
          env_2.error = e_2;
          env_2.hasError = true;
        } finally {
          __disposeResources7(env_2);
        }
      }
    });
    yield* handles;
    return properties.size === 0;
  } catch (e_1) {
    env_1.error = e_1;
    env_1.hasError = true;
  } finally {
    __disposeResources7(env_1);
  }
}
__name(fastTransposeIteratorHandle, "fastTransposeIteratorHandle");
async function* transposeIteratorHandle(iterator2) {
  let size15 = DEFAULT_BATCH_SIZE;
  while (!(yield* fastTransposeIteratorHandle(iterator2, size15))) {
    size15 <<= 1;
  }
}
__name(transposeIteratorHandle, "transposeIteratorHandle");
async function* transposeIterableHandle(handle) {
  const env_3 = { stack: [], error: void 0, hasError: false };
  try {
    const generatorHandle = __addDisposableResource7(env_3, await handle.evaluateHandle((iterable) => {
      return (async function* () {
        yield* iterable;
      })();
    }), false);
    yield* transposeIteratorHandle(generatorHandle);
  } catch (e_3) {
    env_3.error = e_3;
    env_3.hasError = true;
  } finally {
    __disposeResources7(env_3);
  }
}
__name(transposeIterableHandle, "transposeIterableHandle");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/LazyArg.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var LazyArg = class _LazyArg {
  static {
    __name(this, "LazyArg");
  }
  static create = /* @__PURE__ */ __name((get18) => {
    return new _LazyArg(get18);
  }, "create");
  #get;
  constructor(get18) {
    this.#get = get18;
  }
  async get(context10) {
    return await this.#get(context10);
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/QueryHandler.js
var __addDisposableResource8 = function(env2, value3, async4) {
  if (value3 !== null && value3 !== void 0) {
    if (typeof value3 !== "object" && typeof value3 !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async4) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value3[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value3[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env2.stack.push({ value: value3, dispose, async: async4 });
  } else if (async4) {
    env2.stack.push({ async: true });
  }
  return value3;
};
var __disposeResources8 = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail19(e) {
      env2.error = env2.hasError ? new SuppressedError2(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    __name(fail19, "fail");
    function next4() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async) return Promise.resolve(result).then(next4, function(e) {
            fail19(e);
            return next4();
          });
        } catch (e) {
          fail19(e);
        }
      }
      if (env2.hasError) throw env2.error;
    }
    __name(next4, "next");
    return next4();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error50, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error50, e.suppressed = suppressed, e;
});
var QueryHandler = class {
  static {
    __name(this, "QueryHandler");
  }
  // Either one of these may be implemented, but at least one must be.
  static querySelectorAll;
  static querySelector;
  static get _querySelector() {
    if (this.querySelector) {
      return this.querySelector;
    }
    if (!this.querySelectorAll) {
      throw new Error("Cannot create default `querySelector`.");
    }
    return this.querySelector = interpolateFunction(async (node, selector, PuppeteerUtil) => {
      const querySelectorAll = PLACEHOLDER("querySelectorAll");
      const results = querySelectorAll(node, selector, PuppeteerUtil);
      for await (const result of results) {
        return result;
      }
      return null;
    }, {
      querySelectorAll: stringifyFunction(this.querySelectorAll)
    });
  }
  static get _querySelectorAll() {
    if (this.querySelectorAll) {
      return this.querySelectorAll;
    }
    if (!this.querySelector) {
      throw new Error("Cannot create default `querySelectorAll`.");
    }
    return this.querySelectorAll = interpolateFunction(async function* (node, selector, PuppeteerUtil) {
      const querySelector = PLACEHOLDER("querySelector");
      const result = await querySelector(node, selector, PuppeteerUtil);
      if (result) {
        yield result;
      }
    }, {
      querySelector: stringifyFunction(this.querySelector)
    });
  }
  /**
   * Queries for multiple nodes given a selector and {@link ElementHandle}.
   *
   * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll | Document.querySelectorAll()}.
   */
  static async *queryAll(element2, selector) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const handle = __addDisposableResource8(env_1, await element2.evaluateHandle(this._querySelectorAll, selector, LazyArg.create((context10) => {
        return context10.puppeteerUtil;
      })), false);
      yield* transposeIterableHandle(handle);
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources8(env_1);
    }
  }
  /**
   * Queries for a single node given a selector and {@link ElementHandle}.
   *
   * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector}.
   */
  static async queryOne(element2, selector) {
    const env_2 = { stack: [], error: void 0, hasError: false };
    try {
      const result = __addDisposableResource8(env_2, await element2.evaluateHandle(this._querySelector, selector, LazyArg.create((context10) => {
        return context10.puppeteerUtil;
      })), false);
      if (!(_isElementHandle in result)) {
        return null;
      }
      return result.move();
    } catch (e_2) {
      env_2.error = e_2;
      env_2.hasError = true;
    } finally {
      __disposeResources8(env_2);
    }
  }
  /**
   * Waits until a single node appears for a given selector and
   * {@link ElementHandle}.
   *
   * This will always query the handle in the Puppeteer world and migrate the
   * result to the main world.
   */
  static async waitFor(elementOrFrame, selector, options) {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
      let frame;
      const element2 = __addDisposableResource8(env_3, await (async () => {
        if (!(_isElementHandle in elementOrFrame)) {
          frame = elementOrFrame;
          return;
        }
        frame = elementOrFrame.frame;
        return await frame.isolatedRealm().adoptHandle(elementOrFrame);
      })(), false);
      const { visible = false, hidden = false, timeout: timeout6, signal } = options;
      const polling = options.polling ?? (visible || hidden ? "raf" : "mutation");
      try {
        const env_4 = { stack: [], error: void 0, hasError: false };
        try {
          signal?.throwIfAborted();
          const handle = __addDisposableResource8(env_4, await frame.isolatedRealm().waitForFunction(async (PuppeteerUtil, query, selector2, root, visible2) => {
            const querySelector = PuppeteerUtil.createFunction(query);
            const node = await querySelector(root ?? document, selector2, PuppeteerUtil);
            return PuppeteerUtil.checkVisibility(node, visible2);
          }, {
            polling,
            root: element2,
            timeout: timeout6,
            signal
          }, LazyArg.create((context10) => {
            return context10.puppeteerUtil;
          }), stringifyFunction(this._querySelector), selector, element2, visible ? true : hidden ? false : void 0), false);
          if (signal?.aborted) {
            throw signal.reason;
          }
          if (!(_isElementHandle in handle)) {
            return null;
          }
          return await frame.mainRealm().transferHandle(handle);
        } catch (e_3) {
          env_4.error = e_3;
          env_4.hasError = true;
        } finally {
          __disposeResources8(env_4);
        }
      } catch (error50) {
        if (!isErrorLike(error50)) {
          throw error50;
        }
        if (error50.name === "AbortError") {
          throw error50;
        }
        error50.message = `Waiting for selector \`${selector}\` failed: ${error50.message}`;
        throw error50;
      }
    } catch (e_4) {
      env_3.error = e_4;
      env_3.hasError = true;
    } finally {
      __disposeResources8(env_3);
    }
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/util/AsyncIterableUtil.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var AsyncIterableUtil = class {
  static {
    __name(this, "AsyncIterableUtil");
  }
  static async *map(iterable, map31) {
    for await (const value3 of iterable) {
      yield await map31(value3);
    }
  }
  static async *flatMap(iterable, map31) {
    for await (const value3 of iterable) {
      yield* map31(value3);
    }
  }
  static async collect(iterable) {
    const result = [];
    for await (const value3 of iterable) {
      result.push(value3);
    }
    return result;
  }
  static async first(iterable) {
    for await (const value3 of iterable) {
      return value3;
    }
    return;
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/AriaQueryHandler.js
var isKnownAttribute = /* @__PURE__ */ __name((attribute) => {
  return ["name", "role"].includes(attribute);
}, "isKnownAttribute");
var normalizeValue = /* @__PURE__ */ __name((value3) => {
  return value3.replace(/ +/g, " ").trim();
}, "normalizeValue");
var ATTRIBUTE_REGEXP = /\[\s*(?<attribute>\w+)\s*=\s*(?<quote>"|')(?<value>\\.|.*?(?=\k<quote>))\k<quote>\s*\]/g;
var parseARIASelector = /* @__PURE__ */ __name((selector) => {
  const queryOptions = {};
  const defaultName = selector.replace(ATTRIBUTE_REGEXP, (_, attribute, __, value3) => {
    attribute = attribute.trim();
    assert5(isKnownAttribute(attribute), `Unknown aria attribute "${attribute}" in selector`);
    queryOptions[attribute] = normalizeValue(value3);
    return "";
  });
  if (defaultName && !queryOptions.name) {
    queryOptions.name = normalizeValue(defaultName);
  }
  return queryOptions;
}, "parseARIASelector");
var ARIAQueryHandler = class extends QueryHandler {
  static {
    __name(this, "ARIAQueryHandler");
  }
  static querySelector = /* @__PURE__ */ __name(async (node, selector, { ariaQuerySelector }) => {
    return await ariaQuerySelector(node, selector);
  }, "querySelector");
  static async *queryAll(element2, selector) {
    const { name, role } = parseARIASelector(selector);
    yield* element2.queryAXTree(name, role);
  }
  static queryOne = /* @__PURE__ */ __name(async (element2, selector) => {
    return await AsyncIterableUtil.first(this.queryAll(element2, selector)) ?? null;
  }, "queryOne");
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/CSSQueryHandler.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CSSQueryHandler = class extends QueryHandler {
  static {
    __name(this, "CSSQueryHandler");
  }
  static querySelector = /* @__PURE__ */ __name((element2, selector, { cssQuerySelector }) => {
    return cssQuerySelector(element2, selector);
  }, "querySelector");
  static querySelectorAll = /* @__PURE__ */ __name((element2, selector, { cssQuerySelectorAll }) => {
    return cssQuerySelectorAll(element2, selector);
  }, "querySelectorAll");
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/CustomQueryHandler.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/ScriptInjector.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/generated/injected.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var source = '"use strict";var g=Object.defineProperty;var X=Object.getOwnPropertyDescriptor;var B=Object.getOwnPropertyNames;var Y=Object.prototype.hasOwnProperty;var l=(t,e)=>{for(var r in e)g(t,r,{get:e[r],enumerable:!0})},G=(t,e,r,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of B(e))!Y.call(t,n)&&n!==r&&g(t,n,{get:()=>e[n],enumerable:!(o=X(e,n))||o.enumerable});return t};var J=t=>G(g({},"__esModule",{value:!0}),t);var pe={};l(pe,{default:()=>he});module.exports=J(pe);var N=class extends Error{constructor(e,r){super(e,r),this.name=this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}},p=class extends N{};var c=class t{static create(e){return new t(e)}static async race(e){let r=new Set;try{let o=e.map(n=>n instanceof t?(n.#n&&r.add(n),n.valueOrThrow()):n);return await Promise.race(o)}finally{for(let o of r)o.reject(new Error("Timeout cleared"))}}#e=!1;#r=!1;#o;#t;#a=new Promise(e=>{this.#t=e});#n;#i;constructor(e){e&&e.timeout>0&&(this.#i=new p(e.message),this.#n=setTimeout(()=>{this.reject(this.#i)},e.timeout))}#l(e){clearTimeout(this.#n),this.#o=e,this.#t()}resolve(e){this.#r||this.#e||(this.#e=!0,this.#l(e))}reject(e){this.#r||this.#e||(this.#r=!0,this.#l(e))}resolved(){return this.#e}finished(){return this.#e||this.#r}value(){return this.#o}#s;valueOrThrow(){return this.#s||(this.#s=(async()=>{if(await this.#a,this.#r)throw this.#o;return this.#o})()),this.#s}};var L=new Map,F=t=>{let e=L.get(t);return e||(e=new Function(`return ${t}`)(),L.set(t,e),e)};var x={};l(x,{ariaQuerySelector:()=>z,ariaQuerySelectorAll:()=>b});var z=(t,e)=>globalThis.__ariaQuerySelector(t,e),b=async function*(t,e){yield*await globalThis.__ariaQuerySelectorAll(t,e)};var E={};l(E,{cssQuerySelector:()=>K,cssQuerySelectorAll:()=>Z});var K=(t,e)=>t.querySelector(e),Z=function(t,e){return t.querySelectorAll(e)};var A={};l(A,{customQuerySelectors:()=>P});var v=class{#e=new Map;register(e,r){if(!r.queryOne&&r.queryAll){let o=r.queryAll;r.queryOne=(n,i)=>{for(let s of o(n,i))return s;return null}}else if(r.queryOne&&!r.queryAll){let o=r.queryOne;r.queryAll=(n,i)=>{let s=o(n,i);return s?[s]:[]}}else if(!r.queryOne||!r.queryAll)throw new Error("At least one query method must be defined.");this.#e.set(e,{querySelector:r.queryOne,querySelectorAll:r.queryAll})}unregister(e){this.#e.delete(e)}get(e){return this.#e.get(e)}clear(){this.#e.clear()}},P=new v;var R={};l(R,{pierceQuerySelector:()=>ee,pierceQuerySelectorAll:()=>te});var ee=(t,e)=>{let r=null,o=n=>{let i=document.createTreeWalker(n,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&o(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==n&&!r&&s.matches(e)&&(r=s)}while(!r&&i.nextNode())};return t instanceof Document&&(t=t.documentElement),o(t),r},te=(t,e)=>{let r=[],o=n=>{let i=document.createTreeWalker(n,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&o(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==n&&s.matches(e)&&r.push(s)}while(i.nextNode())};return t instanceof Document&&(t=t.documentElement),o(t),r};var u=(t,e)=>{if(!t)throw new Error(e)};var y=class{#e;#r;#o;#t;constructor(e,r){this.#e=e,this.#r=r}async start(){let e=this.#t=c.create(),r=await this.#e();if(r){e.resolve(r);return}this.#o=new MutationObserver(async()=>{let o=await this.#e();o&&(e.resolve(o),await this.stop())}),this.#o.observe(this.#r,{childList:!0,subtree:!0,attributes:!0})}async stop(){u(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#o&&(this.#o.disconnect(),this.#o=void 0)}result(){return u(this.#t,"Polling never started."),this.#t.valueOrThrow()}},w=class{#e;#r;constructor(e){this.#e=e}async start(){let e=this.#r=c.create(),r=await this.#e();if(r){e.resolve(r);return}let o=async()=>{if(e.finished())return;let n=await this.#e();if(!n){window.requestAnimationFrame(o);return}e.resolve(n),await this.stop()};window.requestAnimationFrame(o)}async stop(){u(this.#r,"Polling never started."),this.#r.finished()||this.#r.reject(new Error("Polling stopped"))}result(){return u(this.#r,"Polling never started."),this.#r.valueOrThrow()}},T=class{#e;#r;#o;#t;constructor(e,r){this.#e=e,this.#r=r}async start(){let e=this.#t=c.create(),r=await this.#e();if(r){e.resolve(r);return}this.#o=setInterval(async()=>{let o=await this.#e();o&&(e.resolve(o),await this.stop())},this.#r)}async stop(){u(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped")),this.#o&&(clearInterval(this.#o),this.#o=void 0)}result(){return u(this.#t,"Polling never started."),this.#t.valueOrThrow()}};var _={};l(_,{PCombinator:()=>H,pQuerySelector:()=>fe,pQuerySelectorAll:()=>$});var a=class{static async*map(e,r){for await(let o of e)yield await r(o)}static async*flatMap(e,r){for await(let o of e)yield*r(o)}static async collect(e){let r=[];for await(let o of e)r.push(o);return r}static async first(e){for await(let r of e)return r}};var C={};l(C,{textQuerySelectorAll:()=>m});var re=new Set(["checkbox","image","radio"]),oe=t=>t instanceof HTMLSelectElement||t instanceof HTMLTextAreaElement||t instanceof HTMLInputElement&&!re.has(t.type),ne=new Set(["SCRIPT","STYLE"]),f=t=>!ne.has(t.nodeName)&&!document.head?.contains(t),I=new WeakMap,j=t=>{for(;t;)I.delete(t),t instanceof ShadowRoot?t=t.host:t=t.parentNode},W=new WeakSet,se=new MutationObserver(t=>{for(let e of t)j(e.target)}),d=t=>{let e=I.get(t);if(e||(e={full:"",immediate:[]},!f(t)))return e;let r="";if(oe(t))e.full=t.value,e.immediate.push(t.value),t.addEventListener("input",o=>{j(o.target)},{once:!0,capture:!0});else{for(let o=t.firstChild;o;o=o.nextSibling){if(o.nodeType===Node.TEXT_NODE){e.full+=o.nodeValue??"",r+=o.nodeValue??"";continue}r&&e.immediate.push(r),r="",o.nodeType===Node.ELEMENT_NODE&&(e.full+=d(o).full)}r&&e.immediate.push(r),t instanceof Element&&t.shadowRoot&&(e.full+=d(t.shadowRoot).full),W.has(t)||(se.observe(t,{childList:!0,characterData:!0,subtree:!0}),W.add(t))}return I.set(t,e),e};var m=function*(t,e){let r=!1;for(let o of t.childNodes)if(o instanceof Element&&f(o)){let n;o.shadowRoot?n=m(o.shadowRoot,e):n=m(o,e);for(let i of n)yield i,r=!0}r||t instanceof Element&&f(t)&&d(t).full.includes(e)&&(yield t)};var O={};l(O,{checkVisibility:()=>le,pierce:()=>S,pierceAll:()=>k});var ie=["hidden","collapse"],le=(t,e)=>{if(!t)return e===!1;if(e===void 0)return t;let r=t.nodeType===Node.TEXT_NODE?t.parentElement:t,o=window.getComputedStyle(r),n=o&&!ie.includes(o.visibility)&&!ae(r);return e===n?t:!1};function ae(t){let e=t.getBoundingClientRect();return e.width===0||e.height===0}var ce=t=>"shadowRoot"in t&&t.shadowRoot instanceof ShadowRoot;function*S(t){ce(t)?yield t.shadowRoot:yield t}function*k(t){t=S(t).next().value,yield t;let e=[document.createTreeWalker(t,NodeFilter.SHOW_ELEMENT)];for(let r of e){let o;for(;o=r.nextNode();)o.shadowRoot&&(yield o.shadowRoot,e.push(document.createTreeWalker(o.shadowRoot,NodeFilter.SHOW_ELEMENT)))}}var Q={};l(Q,{xpathQuerySelectorAll:()=>q});var q=function*(t,e,r=-1){let n=(t.ownerDocument||document).evaluate(e,t,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE),i=[],s;for(;(s=n.iterateNext())&&(i.push(s),!(r&&i.length===r)););for(let h=0;h<i.length;h++)s=i[h],yield s,delete i[h]};var ue=/[-\\w\\P{ASCII}*]/,H=(r=>(r.Descendent=">>>",r.Child=">>>>",r))(H||{}),V=t=>"querySelectorAll"in t,M=class{#e;#r=[];#o=void 0;elements;constructor(e,r){this.elements=[e],this.#e=r,this.#t()}async run(){if(typeof this.#o=="string")switch(this.#o.trimStart()){case":scope":this.#t();break}for(;this.#o!==void 0;this.#t()){let e=this.#o;typeof e=="string"?e[0]&&ue.test(e[0])?this.elements=a.flatMap(this.elements,async function*(r){V(r)&&(yield*r.querySelectorAll(e))}):this.elements=a.flatMap(this.elements,async function*(r){if(!r.parentElement){if(!V(r))return;yield*r.querySelectorAll(e);return}let o=0;for(let n of r.parentElement.children)if(++o,n===r)break;yield*r.parentElement.querySelectorAll(`:scope>:nth-child(${o})${e}`)}):this.elements=a.flatMap(this.elements,async function*(r){switch(e.name){case"text":yield*m(r,e.value);break;case"xpath":yield*q(r,e.value);break;case"aria":yield*b(r,e.value);break;default:let o=P.get(e.name);if(!o)throw new Error(`Unknown selector type: ${e.name}`);yield*o.querySelectorAll(r,e.value)}})}}#t(){if(this.#r.length!==0){this.#o=this.#r.shift();return}if(this.#e.length===0){this.#o=void 0;return}let e=this.#e.shift();switch(e){case">>>>":{this.elements=a.flatMap(this.elements,S),this.#t();break}case">>>":{this.elements=a.flatMap(this.elements,k),this.#t();break}default:this.#r=e,this.#t();break}}},D=class{#e=new WeakMap;calculate(e,r=[]){if(e===null)return r;e instanceof ShadowRoot&&(e=e.host);let o=this.#e.get(e);if(o)return[...o,...r];let n=0;for(let s=e.previousSibling;s;s=s.previousSibling)++n;let i=this.calculate(e.parentNode,[n]);return this.#e.set(e,i),[...i,...r]}},U=(t,e)=>{if(t.length+e.length===0)return 0;let[r=-1,...o]=t,[n=-1,...i]=e;return r===n?U(o,i):r<n?-1:1},de=async function*(t){let e=new Set;for await(let o of t)e.add(o);let r=new D;yield*[...e.values()].map(o=>[o,r.calculate(o)]).sort(([,o],[,n])=>U(o,n)).map(([o])=>o)},$=function(t,e){let r=JSON.parse(e);if(r.some(o=>{let n=0;return o.some(i=>(typeof i=="string"?++n:n=0,n>1))}))throw new Error("Multiple deep combinators found in sequence.");return de(a.flatMap(r,o=>{let n=new M(t,o);return n.run(),n.elements}))},fe=async function(t,e){for await(let r of $(t,e))return r;return null};var me=Object.freeze({...x,...A,...R,..._,...C,...O,...Q,...E,Deferred:c,createFunction:F,createTextContent:d,IntervalPoller:T,isSuitableNodeForTextMatching:f,MutationPoller:y,RAFPoller:w}),he=me;\n';

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/ScriptInjector.js
var ScriptInjector = class {
  static {
    __name(this, "ScriptInjector");
  }
  #updated = false;
  #amendments = /* @__PURE__ */ new Set();
  // Appends a statement of the form `(PuppeteerUtil) => {...}`.
  append(statement) {
    this.#update(() => {
      this.#amendments.add(statement);
    });
  }
  pop(statement) {
    this.#update(() => {
      this.#amendments.delete(statement);
    });
  }
  inject(inject, force = false) {
    if (this.#updated || force) {
      inject(this.#get());
    }
    this.#updated = false;
  }
  #update(callback) {
    callback();
    this.#updated = true;
  }
  #get() {
    return `(() => {
      const module = {};
      ${source}
      ${[...this.#amendments].map((statement) => {
      return `(${statement})(module.exports.default);`;
    }).join("")}
      return module.exports.default;
    })()`;
  }
};
var scriptInjector = new ScriptInjector();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/CustomQueryHandler.js
var CustomQueryHandlerRegistry = class {
  static {
    __name(this, "CustomQueryHandlerRegistry");
  }
  #handlers = /* @__PURE__ */ new Map();
  get(name) {
    const handler = this.#handlers.get(name);
    return handler ? handler[1] : void 0;
  }
  /**
   * Registers a {@link CustomQueryHandler | custom query handler}.
   *
   * @remarks
   * After registration, the handler can be used everywhere where a selector is
   * expected by prepending the selection string with `<name>/`. The name is
   * only allowed to consist of lower- and upper case latin letters.
   *
   * @example
   *
   * ```ts
   * Puppeteer.customQueryHandlers.register('lit', {  });
   * const aHandle = await page.$('lit/');
   * ```
   *
   * @param name - Name to register under.
   * @param queryHandler - {@link CustomQueryHandler | Custom query handler} to
   * register.
   */
  register(name, handler) {
    assert5(!this.#handlers.has(name), `Cannot register over existing handler: ${name}`);
    assert5(/^[a-zA-Z]+$/.test(name), `Custom query handler names may only contain [a-zA-Z]`);
    assert5(handler.queryAll || handler.queryOne, `At least one query method must be implemented.`);
    const Handler = class extends QueryHandler {
      static {
        __name(this, "Handler");
      }
      static querySelectorAll = interpolateFunction((node, selector, PuppeteerUtil) => {
        return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelectorAll(node, selector);
      }, { name: JSON.stringify(name) });
      static querySelector = interpolateFunction((node, selector, PuppeteerUtil) => {
        return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelector(node, selector);
      }, { name: JSON.stringify(name) });
    };
    const registerScript = interpolateFunction((PuppeteerUtil) => {
      PuppeteerUtil.customQuerySelectors.register(PLACEHOLDER("name"), {
        queryAll: PLACEHOLDER("queryAll"),
        queryOne: PLACEHOLDER("queryOne")
      });
    }, {
      name: JSON.stringify(name),
      queryAll: handler.queryAll ? stringifyFunction(handler.queryAll) : String(void 0),
      queryOne: handler.queryOne ? stringifyFunction(handler.queryOne) : String(void 0)
    }).toString();
    this.#handlers.set(name, [registerScript, Handler]);
    scriptInjector.append(registerScript);
  }
  /**
   * Unregisters the {@link CustomQueryHandler | custom query handler} for the
   * given name.
   *
   * @throws `Error` if there is no handler under the given name.
   */
  unregister(name) {
    const handler = this.#handlers.get(name);
    if (!handler) {
      throw new Error(`Cannot unregister unknown handler: ${name}`);
    }
    scriptInjector.pop(handler[0]);
    this.#handlers.delete(name);
  }
  /**
   * Gets the names of all {@link CustomQueryHandler | custom query handlers}.
   */
  names() {
    return [...this.#handlers.keys()];
  }
  /**
   * Unregisters all custom query handlers.
   */
  clear() {
    for (const [registerScript] of this.#handlers) {
      scriptInjector.pop(registerScript);
    }
    this.#handlers.clear();
  }
};
var customQueryHandlers = new CustomQueryHandlerRegistry();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/PierceQueryHandler.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var PierceQueryHandler = class extends QueryHandler {
  static {
    __name(this, "PierceQueryHandler");
  }
  static querySelector = /* @__PURE__ */ __name((element2, selector, { pierceQuerySelector }) => {
    return pierceQuerySelector(element2, selector);
  }, "querySelector");
  static querySelectorAll = /* @__PURE__ */ __name((element2, selector, { pierceQuerySelectorAll }) => {
    return pierceQuerySelectorAll(element2, selector);
  }, "querySelectorAll");
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/PQueryHandler.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var PQueryHandler = class extends QueryHandler {
  static {
    __name(this, "PQueryHandler");
  }
  static querySelectorAll = /* @__PURE__ */ __name((element2, selector, { pQuerySelectorAll }) => {
    return pQuerySelectorAll(element2, selector);
  }, "querySelectorAll");
  static querySelector = /* @__PURE__ */ __name((element2, selector, { pQuerySelector }) => {
    return pQuerySelector(element2, selector);
  }, "querySelector");
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/PSelectorParser.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/third_party/parsel-js/parsel-js.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TOKENS = {
  attribute: /\[\s*(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(\s(?<caseSensitive>[iIsS]))?\s*)?\]/gu,
  id: /#(?<name>[-\w\P{ASCII}]+)/gu,
  class: /\.(?<name>[-\w\P{ASCII}]+)/gu,
  comma: /\s*,\s*/g,
  combinator: /\s*[\s>+~]\s*/g,
  "pseudo-element": /::(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>*)\))?/gu,
  "pseudo-class": /:(?<name>[-\w\P{ASCII}]+)(?:\((?<argument>*)\))?/gu,
  universal: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?\*/gu,
  type: /(?:(?<namespace>\*|[-\w\P{ASCII}]*)\|)?(?<name>[-\w\P{ASCII}]+)/gu
  // this must be last
};
var TRIM_TOKENS = /* @__PURE__ */ new Set(["combinator", "comma"]);
var getArgumentPatternByType = /* @__PURE__ */ __name((type) => {
  switch (type) {
    case "pseudo-element":
    case "pseudo-class":
      return new RegExp(TOKENS[type].source.replace("(?<argument>\xB6*)", "(?<argument>.*)"), "gu");
    default:
      return TOKENS[type];
  }
}, "getArgumentPatternByType");
function gobbleParens(text2, offset) {
  let nesting = 0;
  let result = "";
  for (; offset < text2.length; offset++) {
    const char2 = text2[offset];
    switch (char2) {
      case "(":
        ++nesting;
        break;
      case ")":
        --nesting;
        break;
    }
    result += char2;
    if (nesting === 0) {
      return result;
    }
  }
  return result;
}
__name(gobbleParens, "gobbleParens");
function tokenizeBy(text2, grammar = TOKENS) {
  if (!text2) {
    return [];
  }
  const tokens = [text2];
  for (const [type, pattern2] of Object.entries(grammar)) {
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (typeof token !== "string") {
        continue;
      }
      pattern2.lastIndex = 0;
      const match20 = pattern2.exec(token);
      if (!match20) {
        continue;
      }
      const from2 = match20.index - 1;
      const args2 = [];
      const content = match20[0];
      const before2 = token.slice(0, from2 + 1);
      if (before2) {
        args2.push(before2);
      }
      args2.push({
        ...match20.groups,
        type,
        content
      });
      const after3 = token.slice(from2 + content.length + 1);
      if (after3) {
        args2.push(after3);
      }
      tokens.splice(i, 1, ...args2);
    }
  }
  let offset = 0;
  for (const token of tokens) {
    switch (typeof token) {
      case "string":
        throw new Error(`Unexpected sequence ${token} found at index ${offset}`);
      case "object":
        offset += token.content.length;
        token.pos = [offset - token.content.length, offset];
        if (TRIM_TOKENS.has(token.type)) {
          token.content = token.content.trim() || " ";
        }
        break;
    }
  }
  return tokens;
}
__name(tokenizeBy, "tokenizeBy");
var STRING_PATTERN = /(['"])([^\\\n]+?)\1/g;
var ESCAPE_PATTERN = /\\./g;
function tokenize(selector, grammar = TOKENS) {
  selector = selector.trim();
  if (selector === "") {
    return [];
  }
  const replacements = [];
  selector = selector.replace(ESCAPE_PATTERN, (value3, offset) => {
    replacements.push({ value: value3, offset });
    return "\uE000".repeat(value3.length);
  });
  selector = selector.replace(STRING_PATTERN, (value3, quote, content, offset) => {
    replacements.push({ value: value3, offset });
    return `${quote}${"\uE001".repeat(content.length)}${quote}`;
  });
  {
    let pos = 0;
    let offset;
    while ((offset = selector.indexOf("(", pos)) > -1) {
      const value3 = gobbleParens(selector, offset);
      replacements.push({ value: value3, offset });
      selector = `${selector.substring(0, offset)}(${"\xB6".repeat(value3.length - 2)})${selector.substring(offset + value3.length)}`;
      pos = offset + value3.length;
    }
  }
  const tokens = tokenizeBy(selector, grammar);
  const changedTokens = /* @__PURE__ */ new Set();
  for (const replacement of replacements.reverse()) {
    for (const token of tokens) {
      const { offset, value: value3 } = replacement;
      if (!(token.pos[0] <= offset && offset + value3.length <= token.pos[1])) {
        continue;
      }
      const { content } = token;
      const tokenOffset = offset - token.pos[0];
      token.content = content.slice(0, tokenOffset) + value3 + content.slice(tokenOffset + value3.length);
      if (token.content !== content) {
        changedTokens.add(token);
      }
    }
  }
  for (const token of changedTokens) {
    const pattern2 = getArgumentPatternByType(token.type);
    if (!pattern2) {
      throw new Error(`Unknown token type: ${token.type}`);
    }
    pattern2.lastIndex = 0;
    const match20 = pattern2.exec(token.content);
    if (!match20) {
      throw new Error(`Unable to parse content for ${token.type}: ${token.content}`);
    }
    Object.assign(token, match20.groups);
  }
  return tokens;
}
__name(tokenize, "tokenize");
function* flatten16(node, parent) {
  switch (node.type) {
    case "list":
      for (let child of node.list) {
        yield* flatten16(child, node);
      }
      break;
    case "complex":
      yield* flatten16(node.left, node);
      yield* flatten16(node.right, node);
      break;
    case "compound":
      yield* node.list.map((token) => [token, node]);
      break;
    default:
      yield [node, parent];
  }
}
__name(flatten16, "flatten");
function stringify2(listOrNode) {
  let tokens;
  if (Array.isArray(listOrNode)) {
    tokens = listOrNode;
  } else {
    tokens = [...flatten16(listOrNode)].map(([token]) => token);
  }
  return tokens.map((token) => token.content).join("");
}
__name(stringify2, "stringify");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/PSelectorParser.js
TOKENS["nesting"] = /&/g;
TOKENS["combinator"] = /\s*(>>>>?|[\s>+~])\s*/g;
var ESCAPE_REGEXP = /\\[\s\S]/g;
var unquote = /* @__PURE__ */ __name((text2) => {
  if (text2.length <= 1) {
    return text2;
  }
  if ((text2[0] === '"' || text2[0] === "'") && text2.endsWith(text2[0])) {
    text2 = text2.slice(1, -1);
  }
  return text2.replace(ESCAPE_REGEXP, (match20) => {
    return match20[1];
  });
}, "unquote");
function parsePSelectors(selector) {
  let isPureCSS = true;
  let hasAria = false;
  let hasPseudoClasses = false;
  const tokens = tokenize(selector);
  if (tokens.length === 0) {
    return [[], isPureCSS, hasPseudoClasses, false];
  }
  let compoundSelector = [];
  let complexSelector = [compoundSelector];
  const selectors = [complexSelector];
  const storage = [];
  for (const token of tokens) {
    switch (token.type) {
      case "combinator":
        switch (token.content) {
          case ">>>":
            isPureCSS = false;
            if (storage.length) {
              compoundSelector.push(stringify2(storage));
              storage.splice(0);
            }
            compoundSelector = [];
            complexSelector.push(
              ">>>"
              /* PCombinator.Descendent */
            );
            complexSelector.push(compoundSelector);
            continue;
          case ">>>>":
            isPureCSS = false;
            if (storage.length) {
              compoundSelector.push(stringify2(storage));
              storage.splice(0);
            }
            compoundSelector = [];
            complexSelector.push(
              ">>>>"
              /* PCombinator.Child */
            );
            complexSelector.push(compoundSelector);
            continue;
        }
        break;
      case "pseudo-element":
        if (!token.name.startsWith("-p-")) {
          break;
        }
        isPureCSS = false;
        if (storage.length) {
          compoundSelector.push(stringify2(storage));
          storage.splice(0);
        }
        const name = token.name.slice(3);
        if (name === "aria") {
          hasAria = true;
        }
        compoundSelector.push({
          name,
          value: unquote(token.argument ?? "")
        });
        continue;
      case "pseudo-class":
        hasPseudoClasses = true;
        break;
      case "comma":
        if (storage.length) {
          compoundSelector.push(stringify2(storage));
          storage.splice(0);
        }
        compoundSelector = [];
        complexSelector = [compoundSelector];
        selectors.push(complexSelector);
        continue;
    }
    storage.push(token);
  }
  if (storage.length) {
    compoundSelector.push(stringify2(storage));
  }
  return [selectors, isPureCSS, hasPseudoClasses, hasAria];
}
__name(parsePSelectors, "parsePSelectors");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/TextQueryHandler.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TextQueryHandler = class extends QueryHandler {
  static {
    __name(this, "TextQueryHandler");
  }
  static querySelectorAll = /* @__PURE__ */ __name((element2, selector, { textQuerySelectorAll }) => {
    return textQuerySelectorAll(element2, selector);
  }, "querySelectorAll");
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/XPathQueryHandler.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var XPathQueryHandler = class extends QueryHandler {
  static {
    __name(this, "XPathQueryHandler");
  }
  static querySelectorAll = /* @__PURE__ */ __name((element2, selector, { xpathQuerySelectorAll }) => {
    return xpathQuerySelectorAll(element2, selector);
  }, "querySelectorAll");
  static querySelector = /* @__PURE__ */ __name((element2, selector, { xpathQuerySelectorAll }) => {
    for (const result of xpathQuerySelectorAll(element2, selector, 1)) {
      return result;
    }
    return null;
  }, "querySelector");
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/GetQueryHandler.js
var BUILTIN_QUERY_HANDLERS = {
  aria: ARIAQueryHandler,
  pierce: PierceQueryHandler,
  xpath: XPathQueryHandler,
  text: TextQueryHandler
};
var QUERY_SEPARATORS = ["=", "/"];
function getQueryHandlerAndSelector(selector) {
  for (const handlerMap of [
    customQueryHandlers.names().map((name) => {
      return [name, customQueryHandlers.get(name)];
    }),
    Object.entries(BUILTIN_QUERY_HANDLERS)
  ]) {
    for (const [name, QueryHandler2] of handlerMap) {
      for (const separator of QUERY_SEPARATORS) {
        const prefix = `${name}${separator}`;
        if (selector.startsWith(prefix)) {
          selector = selector.slice(prefix.length);
          return {
            updatedSelector: selector,
            polling: name === "aria" ? "raf" : "mutation",
            QueryHandler: QueryHandler2
          };
        }
      }
    }
  }
  try {
    const [pSelector, isPureCSS, hasPseudoClasses, hasAria] = parsePSelectors(selector);
    if (isPureCSS) {
      return {
        updatedSelector: selector,
        polling: hasPseudoClasses ? "raf" : "mutation",
        QueryHandler: CSSQueryHandler
      };
    }
    return {
      updatedSelector: JSON.stringify(pSelector),
      polling: hasAria ? "raf" : "mutation",
      QueryHandler: PQueryHandler
    };
  } catch {
    return {
      updatedSelector: selector,
      polling: "mutation",
      QueryHandler: CSSQueryHandler
    };
  }
}
__name(getQueryHandlerAndSelector, "getQueryHandlerAndSelector");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/Frame.js
var __runInitializers4 = function(thisArg, initializers, value3) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value3 = useValue ? initializers[i].call(thisArg, value3) : initializers[i].call(thisArg);
  }
  return useValue ? value3 : void 0;
};
var __esDecorate4 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor3 = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done13 = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context10 = {};
    for (var p in contextIn) context10[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context10.access[p] = contextIn.access[p];
    context10.addInitializer = function(f) {
      if (done13) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor3.get, set: descriptor3.set } : descriptor3[key], context10);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor3.get = _;
      if (_ = accept(result.set)) descriptor3.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor3[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor3);
  done13 = true;
};
var __addDisposableResource9 = function(env2, value3, async4) {
  if (value3 !== null && value3 !== void 0) {
    if (typeof value3 !== "object" && typeof value3 !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async4) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value3[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value3[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env2.stack.push({ value: value3, dispose, async: async4 });
  } else if (async4) {
    env2.stack.push({ async: true });
  }
  return value3;
};
var __disposeResources9 = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail19(e) {
      env2.error = env2.hasError ? new SuppressedError2(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    __name(fail19, "fail");
    function next4() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async) return Promise.resolve(result).then(next4, function(e) {
            fail19(e);
            return next4();
          });
        } catch (e) {
          fail19(e);
        }
      }
      if (env2.hasError) throw env2.error;
    }
    __name(next4, "next");
    return next4();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error50, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error50, e.suppressed = suppressed, e;
});
var FrameEvent;
(function(FrameEvent2) {
  FrameEvent2.FrameNavigated = Symbol("Frame.FrameNavigated");
  FrameEvent2.FrameSwapped = Symbol("Frame.FrameSwapped");
  FrameEvent2.LifecycleEvent = Symbol("Frame.LifecycleEvent");
  FrameEvent2.FrameNavigatedWithinDocument = Symbol("Frame.FrameNavigatedWithinDocument");
  FrameEvent2.FrameDetached = Symbol("Frame.FrameDetached");
  FrameEvent2.FrameSwappedByActivation = Symbol("Frame.FrameSwappedByActivation");
})(FrameEvent || (FrameEvent = {}));
var throwIfDetached = throwIfDisposed((frame) => {
  return `Attempted to use detached Frame '${frame._id}'.`;
});
var Frame = (() => {
  let _classSuper = EventEmitter2;
  let _instanceExtraInitializers = [];
  let _frameElement_decorators;
  let _evaluateHandle_decorators;
  let _evaluate_decorators;
  let _locator_decorators;
  let _$_decorators;
  let _$$_decorators;
  let _$eval_decorators;
  let _$$eval_decorators;
  let _waitForSelector_decorators;
  let _waitForFunction_decorators;
  let _content_decorators;
  let _addScriptTag_decorators;
  let _addStyleTag_decorators;
  let _click_decorators;
  let _focus_decorators;
  let _hover_decorators;
  let _select_decorators;
  let _tap_decorators;
  let _type_decorators;
  let _title_decorators;
  return class Frame extends _classSuper {
    static {
      __name(this, "Frame");
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _frameElement_decorators = [throwIfDetached];
      _evaluateHandle_decorators = [throwIfDetached];
      _evaluate_decorators = [throwIfDetached];
      _locator_decorators = [throwIfDetached];
      _$_decorators = [throwIfDetached];
      _$$_decorators = [throwIfDetached];
      _$eval_decorators = [throwIfDetached];
      _$$eval_decorators = [throwIfDetached];
      _waitForSelector_decorators = [throwIfDetached];
      _waitForFunction_decorators = [throwIfDetached];
      _content_decorators = [throwIfDetached];
      _addScriptTag_decorators = [throwIfDetached];
      _addStyleTag_decorators = [throwIfDetached];
      _click_decorators = [throwIfDetached];
      _focus_decorators = [throwIfDetached];
      _hover_decorators = [throwIfDetached];
      _select_decorators = [throwIfDetached];
      _tap_decorators = [throwIfDetached];
      _type_decorators = [throwIfDetached];
      _title_decorators = [throwIfDetached];
      __esDecorate4(this, null, _frameElement_decorators, { kind: "method", name: "frameElement", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "frameElement" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.frameElement, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _evaluateHandle_decorators, { kind: "method", name: "evaluateHandle", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "evaluateHandle" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.evaluateHandle, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _evaluate_decorators, { kind: "method", name: "evaluate", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "evaluate" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.evaluate, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _locator_decorators, { kind: "method", name: "locator", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "locator" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.locator, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "$" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.$, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "$$" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.$$, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _$eval_decorators, { kind: "method", name: "$eval", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "$eval" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.$eval, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _$$eval_decorators, { kind: "method", name: "$$eval", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "$$eval" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.$$eval, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "waitForSelector" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.waitForSelector, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _waitForFunction_decorators, { kind: "method", name: "waitForFunction", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "waitForFunction" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.waitForFunction, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _content_decorators, { kind: "method", name: "content", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "content" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.content, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _addScriptTag_decorators, { kind: "method", name: "addScriptTag", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "addScriptTag" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.addScriptTag, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _addStyleTag_decorators, { kind: "method", name: "addStyleTag", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "addStyleTag" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.addStyleTag, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "click" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.click, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "focus" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.focus, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "hover" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.hover, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "select" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.select, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "tap" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.tap, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "type" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.type, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate4(this, null, _title_decorators, { kind: "method", name: "title", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "title" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.title, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    }
    /**
     * @internal
     */
    _id = __runInitializers4(this, _instanceExtraInitializers);
    /**
     * @internal
     */
    _parentId;
    /**
     * @internal
     */
    _name;
    /**
     * @internal
     */
    _hasStartedLoading = false;
    /**
     * @internal
     */
    constructor() {
      super();
    }
    #_document;
    /**
     * @internal
     */
    #document() {
      if (!this.#_document) {
        this.#_document = this.mainRealm().evaluateHandle(() => {
          return document;
        });
      }
      return this.#_document;
    }
    /**
     * Used to clear the document handle that has been destroyed.
     *
     * @internal
     */
    clearDocumentHandle() {
      this.#_document = void 0;
    }
    /**
     * @returns The frame element associated with this frame (if any).
     */
    async frameElement() {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        const parentFrame = this.parentFrame();
        if (!parentFrame) {
          return null;
        }
        const list = __addDisposableResource9(env_1, await parentFrame.isolatedRealm().evaluateHandle(() => {
          return document.querySelectorAll("iframe,frame");
        }), false);
        for await (const iframe_1 of transposeIterableHandle(list)) {
          const env_2 = { stack: [], error: void 0, hasError: false };
          try {
            const iframe = __addDisposableResource9(env_2, iframe_1, false);
            const frame = await iframe.contentFrame();
            if (frame?._id === this._id) {
              return iframe.move();
            }
          } catch (e_1) {
            env_2.error = e_1;
            env_2.hasError = true;
          } finally {
            __disposeResources9(env_2);
          }
        }
        return null;
      } catch (e_2) {
        env_1.error = e_2;
        env_1.hasError = true;
      } finally {
        __disposeResources9(env_1);
      }
    }
    /**
     * Behaves identically to {@link Page.evaluateHandle} except it's run within
     * the context of this frame.
     *
     * See {@link Page.evaluateHandle} for details.
     */
    async evaluateHandle(pageFunction, ...args2) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      return await this.mainRealm().evaluateHandle(pageFunction, ...args2);
    }
    /**
     * Behaves identically to {@link Page.evaluate} except it's run within
     * the context of this frame.
     *
     * See {@link Page.evaluate} for details.
     */
    async evaluate(pageFunction, ...args2) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      return await this.mainRealm().evaluate(pageFunction, ...args2);
    }
    /**
     * @internal
     */
    locator(selectorOrFunc) {
      if (typeof selectorOrFunc === "string") {
        return NodeLocator.create(this, selectorOrFunc);
      } else {
        return FunctionLocator.create(this, selectorOrFunc);
      }
    }
    /**
     * Queries the frame for an element matching the given selector.
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows quering by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     *
     * @returns A {@link ElementHandle | element handle} to the first element
     * matching the given selector. Otherwise, `null`.
     */
    async $(selector) {
      const document2 = await this.#document();
      return await document2.$(selector);
    }
    /**
     * Queries the frame for all elements matching the given selector.
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows quering by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     *
     * @returns An array of {@link ElementHandle | element handles} that point to
     * elements matching the given selector.
     */
    async $$(selector, options) {
      const document2 = await this.#document();
      return await document2.$$(selector, options);
    }
    /**
     * Runs the given function on the first element matching the given selector in
     * the frame.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     *
     * ```ts
     * const searchValue = await frame.$eval('#search', el => el.value);
     * ```
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows quering by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @param pageFunction - The function to be evaluated in the frame's context.
     * The first element matching the selector will be passed to the function as
     * its first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $eval(selector, pageFunction, ...args2) {
      pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
      const document2 = await this.#document();
      return await document2.$eval(selector, pageFunction, ...args2);
    }
    /**
     * Runs the given function on an array of elements matching the given selector
     * in the frame.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     *
     * ```ts
     * const divsCounts = await frame.$$eval('div', divs => divs.length);
     * ```
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows quering by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @param pageFunction - The function to be evaluated in the frame's context.
     * An array of elements matching the given selector will be passed to the
     * function as its first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $$eval(selector, pageFunction, ...args2) {
      pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
      const document2 = await this.#document();
      return await document2.$$eval(selector, pageFunction, ...args2);
    }
    /**
     * Waits for an element matching the given selector to appear in the frame.
     *
     * This method works across navigations.
     *
     * @example
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   let currentURL;
     *   page
     *     .mainFrame()
     *     .waitForSelector('img')
     *     .then(() => console.log('First URL with image: ' + currentURL));
     *
     *   for (currentURL of [
     *     'https://example.com',
     *     'https://google.com',
     *     'https://bbc.com',
     *   ]) {
     *     await page.goto(currentURL);
     *   }
     *   await browser.close();
     * })();
     * ```
     *
     * @param selector - The selector to query and wait for.
     * @param options - Options for customizing waiting behavior.
     * @returns An element matching the given selector.
     * @throws Throws if an element matching the given selector doesn't appear.
     */
    async waitForSelector(selector, options = {}) {
      const { updatedSelector, QueryHandler: QueryHandler2, polling } = getQueryHandlerAndSelector(selector);
      return await QueryHandler2.waitFor(this, updatedSelector, {
        polling,
        ...options
      });
    }
    /**
     * @example
     * The `waitForFunction` can be used to observe viewport size change:
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     *
     * (async () => {
     * .  const browser = await puppeteer.launch();
     * .  const page = await browser.newPage();
     * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');
     * .  page.setViewport({width: 50, height: 50});
     * .  await watchDog;
     * .  await browser.close();
     * })();
     * ```
     *
     * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:
     *
     * ```ts
     * const selector = '.foo';
     * await frame.waitForFunction(
     *   selector => !!document.querySelector(selector),
     *   {}, // empty options object
     *   selector
     * );
     * ```
     *
     * @param pageFunction - the function to evaluate in the frame context.
     * @param options - options to configure the polling method and timeout.
     * @param args - arguments to pass to the `pageFunction`.
     * @returns the promise which resolve when the `pageFunction` returns a truthy value.
     */
    async waitForFunction(pageFunction, options = {}, ...args2) {
      return await this.mainRealm().waitForFunction(pageFunction, options, ...args2);
    }
    /**
     * The full HTML contents of the frame, including the DOCTYPE.
     */
    async content() {
      return await this.evaluate(() => {
        let content = "";
        for (const node of document.childNodes) {
          switch (node) {
            case document.documentElement:
              content += document.documentElement.outerHTML;
              break;
            default:
              content += new XMLSerializer().serializeToString(node);
              break;
          }
        }
        return content;
      });
    }
    /**
     * @internal
     */
    async setFrameContent(content) {
      return await this.evaluate((html) => {
        document.open();
        document.write(html);
        document.close();
      }, content);
    }
    /**
     * The frame's `name` attribute as specified in the tag.
     *
     * @remarks
     * If the name is empty, it returns the `id` attribute instead.
     *
     * @remarks
     * This value is calculated once when the frame is created, and will not
     * update if the attribute is changed later.
     *
     * @deprecated Use
     *
     * ```ts
     * const element = await frame.frameElement();
     * const nameOrId = await element.evaluate(frame => frame.name ?? frame.id);
     * ```
     */
    name() {
      return this._name || "";
    }
    /**
     * Is`true` if the frame has been detached. Otherwise, `false`.
     *
     * @deprecated Use the `detached` getter.
     */
    isDetached() {
      return this.detached;
    }
    /**
     * @internal
     */
    get disposed() {
      return this.detached;
    }
    /**
     * Adds a `<script>` tag into the page with the desired url or content.
     *
     * @param options - Options for the script.
     * @returns An {@link ElementHandle | element handle} to the injected
     * `<script>` element.
     */
    async addScriptTag(options) {
      let { content = "", type } = options;
      const { path } = options;
      if (+!!options.url + +!!path + +!!content !== 1) {
        throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
      }
      if (path) {
        const fs2 = await importFSPromises();
        content = await fs2.readFile(path, "utf8");
        content += `//# sourceURL=${path.replace(/\n/g, "")}`;
      }
      type = type ?? "text/javascript";
      return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url: url3, id: id2, type: type2, content: content2 }) => {
        return await new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.type = type2;
          script.text = content2;
          script.addEventListener("error", (event) => {
            reject(new Error(event.message ?? "Could not load script"));
          }, { once: true });
          if (id2) {
            script.id = id2;
          }
          if (url3) {
            script.src = url3;
            script.addEventListener("load", () => {
              resolve(script);
            }, { once: true });
            document.head.appendChild(script);
          } else {
            document.head.appendChild(script);
            resolve(script);
          }
        });
      }, { ...options, type, content }));
    }
    /**
     * @internal
     */
    async addStyleTag(options) {
      let { content = "" } = options;
      const { path } = options;
      if (+!!options.url + +!!path + +!!content !== 1) {
        throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
      }
      if (path) {
        const fs2 = await importFSPromises();
        content = await fs2.readFile(path, "utf8");
        content += "/*# sourceURL=" + path.replace(/\n/g, "") + "*/";
        options.content = content;
      }
      return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ url: url3, content: content2 }) => {
        return await new Promise((resolve, reject) => {
          let element2;
          if (!url3) {
            element2 = document.createElement("style");
            element2.appendChild(document.createTextNode(content2));
          } else {
            const link = document.createElement("link");
            link.rel = "stylesheet";
            link.href = url3;
            element2 = link;
          }
          element2.addEventListener("load", () => {
            resolve(element2);
          }, { once: true });
          element2.addEventListener("error", (event) => {
            reject(new Error(event.message ?? "Could not load style"));
          }, { once: true });
          document.head.appendChild(element2);
          return element2;
        });
      }, options));
    }
    /**
     * Clicks the first element found that matches `selector`.
     *
     * @remarks
     * If `click()` triggers a navigation event and there's a separate
     * `page.waitForNavigation()` promise to be resolved, you may end up with a
     * race condition that yields unexpected results. The correct pattern for
     * click and wait for navigation is the following:
     *
     * ```ts
     * const [response] = await Promise.all([
     *   page.waitForNavigation(waitOptions),
     *   frame.click(selector, clickOptions),
     * ]);
     * ```
     *
     * @param selector - The selector to query for.
     */
    async click(selector, options = {}) {
      const env_3 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource9(env_3, await this.$(selector), false);
        assert5(handle, `No element found for selector: ${selector}`);
        await handle.click(options);
        await handle.dispose();
      } catch (e_3) {
        env_3.error = e_3;
        env_3.hasError = true;
      } finally {
        __disposeResources9(env_3);
      }
    }
    /**
     * Focuses the first element that matches the `selector`.
     *
     * @param selector - The selector to query for.
     * @throws Throws if there's no element matching `selector`.
     */
    async focus(selector) {
      const env_4 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource9(env_4, await this.$(selector), false);
        assert5(handle, `No element found for selector: ${selector}`);
        await handle.focus();
      } catch (e_4) {
        env_4.error = e_4;
        env_4.hasError = true;
      } finally {
        __disposeResources9(env_4);
      }
    }
    /**
     * Hovers the pointer over the center of the first element that matches the
     * `selector`.
     *
     * @param selector - The selector to query for.
     * @throws Throws if there's no element matching `selector`.
     */
    async hover(selector) {
      const env_5 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource9(env_5, await this.$(selector), false);
        assert5(handle, `No element found for selector: ${selector}`);
        await handle.hover();
      } catch (e_5) {
        env_5.error = e_5;
        env_5.hasError = true;
      } finally {
        __disposeResources9(env_5);
      }
    }
    /**
     * Selects a set of value on the first `<select>` element that matches the
     * `selector`.
     *
     * @example
     *
     * ```ts
     * frame.select('select#colors', 'blue'); // single selection
     * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections
     * ```
     *
     * @param selector - The selector to query for.
     * @param values - The array of values to select. If the `<select>` has the
     * `multiple` attribute, all values are considered, otherwise only the first
     * one is taken into account.
     * @returns the list of values that were successfully selected.
     * @throws Throws if there's no `<select>` matching `selector`.
     */
    async select(selector, ...values4) {
      const env_6 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource9(env_6, await this.$(selector), false);
        assert5(handle, `No element found for selector: ${selector}`);
        return await handle.select(...values4);
      } catch (e_6) {
        env_6.error = e_6;
        env_6.hasError = true;
      } finally {
        __disposeResources9(env_6);
      }
    }
    /**
     * Taps the first element that matches the `selector`.
     *
     * @param selector - The selector to query for.
     * @throws Throws if there's no element matching `selector`.
     */
    async tap(selector) {
      const env_7 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource9(env_7, await this.$(selector), false);
        assert5(handle, `No element found for selector: ${selector}`);
        await handle.tap();
      } catch (e_7) {
        env_7.error = e_7;
        env_7.hasError = true;
      } finally {
        __disposeResources9(env_7);
      }
    }
    /**
     * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character
     * in the text.
     *
     * @remarks
     * To press a special key, like `Control` or `ArrowDown`, use
     * {@link Keyboard.press}.
     *
     * @example
     *
     * ```ts
     * await frame.type('#mytextarea', 'Hello'); // Types instantly
     * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
     * ```
     *
     * @param selector - the selector for the element to type into. If there are
     * multiple the first will be used.
     * @param text - text to type into the element
     * @param options - takes one option, `delay`, which sets the time to wait
     * between key presses in milliseconds. Defaults to `0`.
     */
    async type(selector, text2, options) {
      const env_8 = { stack: [], error: void 0, hasError: false };
      try {
        const handle = __addDisposableResource9(env_8, await this.$(selector), false);
        assert5(handle, `No element found for selector: ${selector}`);
        await handle.type(text2, options);
      } catch (e_8) {
        env_8.error = e_8;
        env_8.hasError = true;
      } finally {
        __disposeResources9(env_8);
      }
    }
    /**
     * The frame's title.
     */
    async title() {
      return await this.isolatedRealm().evaluate(() => {
        return document.title;
      });
    }
  };
})();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/CdpPreloadScript.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CdpPreloadScript = class {
  static {
    __name(this, "CdpPreloadScript");
  }
  /**
   * This is the ID of the preload script returned by
   * Page.addScriptToEvaluateOnNewDocument in the main frame.
   *
   * Sub-frames would get a different CDP ID because
   * addScriptToEvaluateOnNewDocument is called for each subframe. But
   * users only see this ID and subframe IDs are internal to Puppeteer.
   */
  #id;
  #source;
  #frameToId = /* @__PURE__ */ new WeakMap();
  constructor(mainFrame, id2, source2) {
    this.#id = id2;
    this.#source = source2;
    this.#frameToId.set(mainFrame, id2);
  }
  get id() {
    return this.#id;
  }
  get source() {
    return this.#source;
  }
  getIdForFrame(frame) {
    return this.#frameToId.get(frame);
  }
  setIdForFrame(frame, identifier2) {
    this.#frameToId.set(frame, identifier2);
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/DeviceRequestPrompt.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DeviceRequestPromptDevice = class {
  static {
    __name(this, "DeviceRequestPromptDevice");
  }
  /**
   * Device id during a prompt.
   */
  id;
  /**
   * Device name as it appears in a prompt.
   */
  name;
  /**
   * @internal
   */
  constructor(id2, name) {
    this.id = id2;
    this.name = name;
  }
};
var DeviceRequestPrompt = class {
  static {
    __name(this, "DeviceRequestPrompt");
  }
  #client;
  #timeoutSettings;
  #id;
  #handled = false;
  #updateDevicesHandle = this.#updateDevices.bind(this);
  #waitForDevicePromises = /* @__PURE__ */ new Set();
  /**
   * Current list of selectable devices.
   */
  devices = [];
  /**
   * @internal
   */
  constructor(client, timeoutSettings, firstEvent) {
    this.#client = client;
    this.#timeoutSettings = timeoutSettings;
    this.#id = firstEvent.id;
    this.#client.on("DeviceAccess.deviceRequestPrompted", this.#updateDevicesHandle);
    this.#client.on("Target.detachedFromTarget", () => {
      this.#client = null;
    });
    this.#updateDevices(firstEvent);
  }
  #updateDevices(event) {
    if (event.id !== this.#id) {
      return;
    }
    for (const rawDevice of event.devices) {
      if (this.devices.some((device) => {
        return device.id === rawDevice.id;
      })) {
        continue;
      }
      const newDevice = new DeviceRequestPromptDevice(rawDevice.id, rawDevice.name);
      this.devices.push(newDevice);
      for (const waitForDevicePromise of this.#waitForDevicePromises) {
        if (waitForDevicePromise.filter(newDevice)) {
          waitForDevicePromise.promise.resolve(newDevice);
        }
      }
    }
  }
  /**
   * Resolve to the first device in the prompt matching a filter.
   */
  async waitForDevice(filter14, options = {}) {
    for (const device of this.devices) {
      if (filter14(device)) {
        return device;
      }
    }
    const { timeout: timeout6 = this.#timeoutSettings.timeout() } = options;
    const deferred = Deferred.create({
      message: `Waiting for \`DeviceRequestPromptDevice\` failed: ${timeout6}ms exceeded`,
      timeout: timeout6
    });
    const handle = { filter: filter14, promise: deferred };
    this.#waitForDevicePromises.add(handle);
    try {
      return await deferred.valueOrThrow();
    } finally {
      this.#waitForDevicePromises.delete(handle);
    }
  }
  /**
   * Select a device in the prompt's list.
   */
  async select(device) {
    assert5(this.#client !== null, "Cannot select device through detached session!");
    assert5(this.devices.includes(device), "Cannot select unknown device!");
    assert5(!this.#handled, "Cannot select DeviceRequestPrompt which is already handled!");
    this.#client.off("DeviceAccess.deviceRequestPrompted", this.#updateDevicesHandle);
    this.#handled = true;
    return await this.#client.send("DeviceAccess.selectPrompt", {
      id: this.#id,
      deviceId: device.id
    });
  }
  /**
   * Cancel the prompt.
   */
  async cancel() {
    assert5(this.#client !== null, "Cannot cancel prompt through detached session!");
    assert5(!this.#handled, "Cannot cancel DeviceRequestPrompt which is already handled!");
    this.#client.off("DeviceAccess.deviceRequestPrompted", this.#updateDevicesHandle);
    this.#handled = true;
    return await this.#client.send("DeviceAccess.cancelPrompt", { id: this.#id });
  }
};
var DeviceRequestPromptManager = class {
  static {
    __name(this, "DeviceRequestPromptManager");
  }
  #client;
  #timeoutSettings;
  #deviceRequestPrompDeferreds = /* @__PURE__ */ new Set();
  /**
   * @internal
   */
  constructor(client, timeoutSettings) {
    this.#client = client;
    this.#timeoutSettings = timeoutSettings;
    this.#client.on("DeviceAccess.deviceRequestPrompted", (event) => {
      this.#onDeviceRequestPrompted(event);
    });
    this.#client.on("Target.detachedFromTarget", () => {
      this.#client = null;
    });
  }
  /**
   * Wait for device prompt created by an action like calling WebBluetooth's
   * requestDevice.
   */
  async waitForDevicePrompt(options = {}) {
    assert5(this.#client !== null, "Cannot wait for device prompt through detached session!");
    const needsEnable = this.#deviceRequestPrompDeferreds.size === 0;
    let enablePromise;
    if (needsEnable) {
      enablePromise = this.#client.send("DeviceAccess.enable");
    }
    const { timeout: timeout6 = this.#timeoutSettings.timeout() } = options;
    const deferred = Deferred.create({
      message: `Waiting for \`DeviceRequestPrompt\` failed: ${timeout6}ms exceeded`,
      timeout: timeout6
    });
    this.#deviceRequestPrompDeferreds.add(deferred);
    try {
      const [result] = await Promise.all([
        deferred.valueOrThrow(),
        enablePromise
      ]);
      return result;
    } finally {
      this.#deviceRequestPrompDeferreds.delete(deferred);
    }
  }
  /**
   * @internal
   */
  #onDeviceRequestPrompted(event) {
    if (!this.#deviceRequestPrompDeferreds.size) {
      return;
    }
    assert5(this.#client !== null);
    const devicePrompt = new DeviceRequestPrompt(this.#client, this.#timeoutSettings, event);
    for (const promise4 of this.#deviceRequestPrompDeferreds) {
      promise4.resolve(devicePrompt);
    }
    this.#deviceRequestPrompDeferreds.clear();
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/ExecutionContext.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/ElementHandle.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/ElementHandle.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __runInitializers5 = function(thisArg, initializers, value3) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value3 = useValue ? initializers[i].call(thisArg, value3) : initializers[i].call(thisArg);
  }
  return useValue ? value3 : void 0;
};
var __esDecorate5 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor3 = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done13 = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context10 = {};
    for (var p in contextIn) context10[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context10.access[p] = contextIn.access[p];
    context10.addInitializer = function(f) {
      if (done13) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor3.get, set: descriptor3.set } : descriptor3[key], context10);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor3.get = _;
      if (_ = accept(result.set)) descriptor3.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor3[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor3);
  done13 = true;
};
var __addDisposableResource10 = function(env2, value3, async4) {
  if (value3 !== null && value3 !== void 0) {
    if (typeof value3 !== "object" && typeof value3 !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async4) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value3[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value3[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env2.stack.push({ value: value3, dispose, async: async4 });
  } else if (async4) {
    env2.stack.push({ async: true });
  }
  return value3;
};
var __disposeResources10 = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail19(e) {
      env2.error = env2.hasError ? new SuppressedError2(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    __name(fail19, "fail");
    function next4() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async) return Promise.resolve(result).then(next4, function(e) {
            fail19(e);
            return next4();
          });
        } catch (e) {
          fail19(e);
        }
      }
      if (env2.hasError) throw env2.error;
    }
    __name(next4, "next");
    return next4();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error50, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error50, e.suppressed = suppressed, e;
});
var __setFunctionName2 = function(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
var ElementHandle = (() => {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
  let _classSuper = JSHandle;
  let _instanceExtraInitializers = [];
  let _getProperty_decorators;
  let _getProperties_decorators;
  let _jsonValue_decorators;
  let _$_decorators;
  let _$$_decorators;
  let _private_$$_decorators;
  let _private_$$_descriptor;
  let _waitForSelector_decorators;
  let _isVisible_decorators;
  let _isHidden_decorators;
  let _toElement_decorators;
  let _clickablePoint_decorators;
  let _hover_decorators;
  let _click_decorators;
  let _drag_decorators;
  let _dragEnter_decorators;
  let _dragOver_decorators;
  let _drop_decorators;
  let _dragAndDrop_decorators;
  let _select_decorators;
  let _tap_decorators;
  let _touchStart_decorators;
  let _touchMove_decorators;
  let _touchEnd_decorators;
  let _focus_decorators;
  let _type_decorators;
  let _press_decorators;
  let _boundingBox_decorators;
  let _boxModel_decorators;
  let _screenshot_decorators;
  let _isIntersectingViewport_decorators;
  let _scrollIntoView_decorators;
  return class ElementHandle2 extends _classSuper {
    static {
      __name(this, "ElementHandle");
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _getProperty_decorators = [throwIfDisposed(), (_a2 = ElementHandle2).bindIsolatedHandle.bind(_a2)];
      _getProperties_decorators = [throwIfDisposed(), (_b = ElementHandle2).bindIsolatedHandle.bind(_b)];
      _jsonValue_decorators = [throwIfDisposed(), (_c = ElementHandle2).bindIsolatedHandle.bind(_c)];
      _$_decorators = [throwIfDisposed(), (_d = ElementHandle2).bindIsolatedHandle.bind(_d)];
      _$$_decorators = [throwIfDisposed()];
      _private_$$_decorators = [(_e = ElementHandle2).bindIsolatedHandle.bind(_e)];
      _waitForSelector_decorators = [throwIfDisposed(), (_f = ElementHandle2).bindIsolatedHandle.bind(_f)];
      _isVisible_decorators = [throwIfDisposed(), (_g = ElementHandle2).bindIsolatedHandle.bind(_g)];
      _isHidden_decorators = [throwIfDisposed(), (_h = ElementHandle2).bindIsolatedHandle.bind(_h)];
      _toElement_decorators = [throwIfDisposed(), (_j = ElementHandle2).bindIsolatedHandle.bind(_j)];
      _clickablePoint_decorators = [throwIfDisposed(), (_k = ElementHandle2).bindIsolatedHandle.bind(_k)];
      _hover_decorators = [throwIfDisposed(), (_l = ElementHandle2).bindIsolatedHandle.bind(_l)];
      _click_decorators = [throwIfDisposed(), (_m = ElementHandle2).bindIsolatedHandle.bind(_m)];
      _drag_decorators = [throwIfDisposed(), (_o = ElementHandle2).bindIsolatedHandle.bind(_o)];
      _dragEnter_decorators = [throwIfDisposed(), (_p = ElementHandle2).bindIsolatedHandle.bind(_p)];
      _dragOver_decorators = [throwIfDisposed(), (_q = ElementHandle2).bindIsolatedHandle.bind(_q)];
      _drop_decorators = [throwIfDisposed(), (_r = ElementHandle2).bindIsolatedHandle.bind(_r)];
      _dragAndDrop_decorators = [throwIfDisposed(), (_s = ElementHandle2).bindIsolatedHandle.bind(_s)];
      _select_decorators = [throwIfDisposed(), (_t = ElementHandle2).bindIsolatedHandle.bind(_t)];
      _tap_decorators = [throwIfDisposed(), (_u = ElementHandle2).bindIsolatedHandle.bind(_u)];
      _touchStart_decorators = [throwIfDisposed(), (_v = ElementHandle2).bindIsolatedHandle.bind(_v)];
      _touchMove_decorators = [throwIfDisposed(), (_w = ElementHandle2).bindIsolatedHandle.bind(_w)];
      _touchEnd_decorators = [throwIfDisposed(), (_x = ElementHandle2).bindIsolatedHandle.bind(_x)];
      _focus_decorators = [throwIfDisposed(), (_y = ElementHandle2).bindIsolatedHandle.bind(_y)];
      _type_decorators = [throwIfDisposed(), (_z = ElementHandle2).bindIsolatedHandle.bind(_z)];
      _press_decorators = [throwIfDisposed(), (_0 = ElementHandle2).bindIsolatedHandle.bind(_0)];
      _boundingBox_decorators = [throwIfDisposed(), (_1 = ElementHandle2).bindIsolatedHandle.bind(_1)];
      _boxModel_decorators = [throwIfDisposed(), (_2 = ElementHandle2).bindIsolatedHandle.bind(_2)];
      _screenshot_decorators = [throwIfDisposed(), (_3 = ElementHandle2).bindIsolatedHandle.bind(_3)];
      _isIntersectingViewport_decorators = [throwIfDisposed(), (_4 = ElementHandle2).bindIsolatedHandle.bind(_4)];
      _scrollIntoView_decorators = [throwIfDisposed(), (_5 = ElementHandle2).bindIsolatedHandle.bind(_5)];
      __esDecorate5(this, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "getProperty" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.getProperty, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "getProperties" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.getProperties, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _jsonValue_decorators, { kind: "method", name: "jsonValue", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "jsonValue" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.jsonValue, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "$" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.$, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "$$" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.$$, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, _private_$$_descriptor = { value: __setFunctionName2(async function(selector) {
        return await this.#$$impl(selector);
      }, "#$$") }, _private_$$_decorators, { kind: "method", name: "#$$", static: false, private: true, access: { has: /* @__PURE__ */ __name((obj) => #$$ in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.#$$, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "waitForSelector" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.waitForSelector, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _isVisible_decorators, { kind: "method", name: "isVisible", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "isVisible" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.isVisible, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _isHidden_decorators, { kind: "method", name: "isHidden", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "isHidden" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.isHidden, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _toElement_decorators, { kind: "method", name: "toElement", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "toElement" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.toElement, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _clickablePoint_decorators, { kind: "method", name: "clickablePoint", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "clickablePoint" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.clickablePoint, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "hover" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.hover, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "click" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.click, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _drag_decorators, { kind: "method", name: "drag", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "drag" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.drag, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _dragEnter_decorators, { kind: "method", name: "dragEnter", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "dragEnter" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.dragEnter, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _dragOver_decorators, { kind: "method", name: "dragOver", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "dragOver" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.dragOver, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _drop_decorators, { kind: "method", name: "drop", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "drop" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.drop, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _dragAndDrop_decorators, { kind: "method", name: "dragAndDrop", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "dragAndDrop" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.dragAndDrop, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "select" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.select, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "tap" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.tap, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _touchStart_decorators, { kind: "method", name: "touchStart", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "touchStart" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.touchStart, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _touchMove_decorators, { kind: "method", name: "touchMove", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "touchMove" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.touchMove, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _touchEnd_decorators, { kind: "method", name: "touchEnd", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "touchEnd" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.touchEnd, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "focus" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.focus, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "type" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.type, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _press_decorators, { kind: "method", name: "press", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "press" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.press, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _boundingBox_decorators, { kind: "method", name: "boundingBox", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "boundingBox" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.boundingBox, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _boxModel_decorators, { kind: "method", name: "boxModel", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "boxModel" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.boxModel, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "screenshot" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.screenshot, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _isIntersectingViewport_decorators, { kind: "method", name: "isIntersectingViewport", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "isIntersectingViewport" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.isIntersectingViewport, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate5(this, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "scrollIntoView" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.scrollIntoView, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    }
    /**
     * @internal
     * Cached isolatedHandle to prevent
     * trying to adopt it multiple times
     */
    isolatedHandle = __runInitializers5(this, _instanceExtraInitializers);
    /**
     * A given method will have it's `this` replaced with an isolated version of
     * `this` when decorated with this decorator.
     *
     * All changes of isolated `this` are reflected on the actual `this`.
     *
     * @internal
     */
    static bindIsolatedHandle(target, _) {
      return async function(...args2) {
        if (this.realm === this.frame.isolatedRealm()) {
          return await target.call(this, ...args2);
        }
        let adoptedThis;
        if (this["isolatedHandle"]) {
          adoptedThis = this["isolatedHandle"];
        } else {
          this["isolatedHandle"] = adoptedThis = await this.frame.isolatedRealm().adoptHandle(this);
        }
        const result = await target.call(adoptedThis, ...args2);
        if (result === adoptedThis) {
          return this;
        }
        if (result instanceof JSHandle) {
          return await this.realm.transferHandle(result);
        }
        if (Array.isArray(result)) {
          await Promise.all(result.map(async (item, index2, result2) => {
            if (item instanceof JSHandle) {
              result2[index2] = await this.realm.transferHandle(item);
            }
          }));
        }
        if (result instanceof Map) {
          await Promise.all([...result.entries()].map(async ([key, value3]) => {
            if (value3 instanceof JSHandle) {
              result.set(key, await this.realm.transferHandle(value3));
            }
          }));
        }
        return result;
      };
    }
    /**
     * @internal
     */
    handle;
    /**
     * @internal
     */
    constructor(handle) {
      super();
      this.handle = handle;
      this[_isElementHandle] = true;
    }
    /**
     * @internal
     */
    get id() {
      return this.handle.id;
    }
    /**
     * @internal
     */
    get disposed() {
      return this.handle.disposed;
    }
    /**
     * @internal
     */
    async getProperty(propertyName) {
      return await this.handle.getProperty(propertyName);
    }
    /**
     * @internal
     */
    async getProperties() {
      return await this.handle.getProperties();
    }
    /**
     * @internal
     */
    async evaluate(pageFunction, ...args2) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      return await this.handle.evaluate(pageFunction, ...args2);
    }
    /**
     * @internal
     */
    async evaluateHandle(pageFunction, ...args2) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      return await this.handle.evaluateHandle(pageFunction, ...args2);
    }
    /**
     * @internal
     */
    async jsonValue() {
      return await this.handle.jsonValue();
    }
    /**
     * @internal
     */
    toString() {
      return this.handle.toString();
    }
    /**
     * @internal
     */
    remoteObject() {
      return this.handle.remoteObject();
    }
    /**
     * @internal
     */
    dispose() {
      return this.handle.dispose();
    }
    /**
     * @internal
     */
    asElement() {
      return this;
    }
    /**
     * Queries the current element for an element matching the given selector.
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows quering by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @returns A {@link ElementHandle | element handle} to the first element
     * matching the given selector. Otherwise, `null`.
     */
    async $(selector) {
      const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
      return await QueryHandler2.queryOne(this, updatedSelector);
    }
    /**
     * Queries the current element for all elements matching the given selector.
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows quering by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @returns An array of {@link ElementHandle | element handles} that point to
     * elements matching the given selector.
     */
    async $$(selector, options) {
      if (options?.isolate === false) {
        return await this.#$$impl(selector);
      }
      return await this.#$$(selector);
    }
    /**
     * Isolates {@link ElementHandle.$$} if needed.
     *
     * @internal
     */
    get #$$() {
      return _private_$$_descriptor.value;
    }
    /**
     * Implementation for {@link ElementHandle.$$}.
     *
     * @internal
     */
    async #$$impl(selector) {
      const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
      return await AsyncIterableUtil.collect(QueryHandler2.queryAll(this, updatedSelector));
    }
    /**
     * Runs the given function on the first element matching the given selector in
     * the current element.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     *
     * ```ts
     * const tweetHandle = await page.$('.tweet');
     * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(
     *   '100'
     * );
     * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(
     *   '10'
     * );
     * ```
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows quering by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @param pageFunction - The function to be evaluated in this element's page's
     * context. The first element matching the selector will be passed in as the
     * first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $eval(selector, pageFunction, ...args2) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
        const elementHandle = __addDisposableResource10(env_1, await this.$(selector), false);
        if (!elementHandle) {
          throw new Error(`Error: failed to find element matching selector "${selector}"`);
        }
        return await elementHandle.evaluate(pageFunction, ...args2);
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources10(env_1);
      }
    }
    /**
     * Runs the given function on an array of elements matching the given selector
     * in the current element.
     *
     * If the given function returns a promise, then this method will wait till
     * the promise resolves.
     *
     * @example
     * HTML:
     *
     * ```html
     * <div class="feed">
     *   <div class="tweet">Hello!</div>
     *   <div class="tweet">Hi!</div>
     * </div>
     * ```
     *
     * JavaScript:
     *
     * ```ts
     * const feedHandle = await page.$('.feed');
     * expect(
     *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))
     * ).toEqual(['Hello!', 'Hi!']);
     * ```
     *
     * @param selector -
     * {@link https://pptr.dev/guides/page-interactions#selectors | selector}
     * to query page for.
     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | CSS selectors}
     * can be passed as-is and a
     * {@link https://pptr.dev/guides/page-interactions#non-css-selectors | Puppeteer-specific selector syntax}
     * allows quering by
     * {@link https://pptr.dev/guides/page-interactions#text-selectors--p-text | text},
     * {@link https://pptr.dev/guides/page-interactions#aria-selectors--p-aria | a11y role and name},
     * and
     * {@link https://pptr.dev/guides/page-interactions#xpath-selectors--p-xpath | xpath}
     * and
     * {@link https://pptr.dev/guides/page-interactions#querying-elements-in-shadow-dom | combining these queries across shadow roots}.
     * Alternatively, you can specify the selector type using a
     * {@link https://pptr.dev/guides/page-interactions#prefixed-selector-syntax | prefix}.
     * @param pageFunction - The function to be evaluated in the element's page's
     * context. An array of elements matching the given selector will be passed to
     * the function as its first argument.
     * @param args - Additional arguments to pass to `pageFunction`.
     * @returns A promise to the result of the function.
     */
    async $$eval(selector, pageFunction, ...args2) {
      const env_2 = { stack: [], error: void 0, hasError: false };
      try {
        pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
        const results = await this.$$(selector);
        const elements = __addDisposableResource10(env_2, await this.evaluateHandle((_, ...elements2) => {
          return elements2;
        }, ...results), false);
        const [result] = await Promise.all([
          elements.evaluate(pageFunction, ...args2),
          ...results.map((results2) => {
            return results2.dispose();
          })
        ]);
        return result;
      } catch (e_2) {
        env_2.error = e_2;
        env_2.hasError = true;
      } finally {
        __disposeResources10(env_2);
      }
    }
    /**
     * Wait for an element matching the given selector to appear in the current
     * element.
     *
     * Unlike {@link Frame.waitForSelector}, this method does not work across
     * navigations or if the element is detached from DOM.
     *
     * @example
     *
     * ```ts
     * import puppeteer from 'puppeteer';
     *
     * (async () => {
     *   const browser = await puppeteer.launch();
     *   const page = await browser.newPage();
     *   let currentURL;
     *   page
     *     .mainFrame()
     *     .waitForSelector('img')
     *     .then(() => console.log('First URL with image: ' + currentURL));
     *
     *   for (currentURL of [
     *     'https://example.com',
     *     'https://google.com',
     *     'https://bbc.com',
     *   ]) {
     *     await page.goto(currentURL);
     *   }
     *   await browser.close();
     * })();
     * ```
     *
     * @param selector - The selector to query and wait for.
     * @param options - Options for customizing waiting behavior.
     * @returns An element matching the given selector.
     * @throws Throws if an element matching the given selector doesn't appear.
     */
    async waitForSelector(selector, options = {}) {
      const { updatedSelector, QueryHandler: QueryHandler2, polling } = getQueryHandlerAndSelector(selector);
      return await QueryHandler2.waitFor(this, updatedSelector, {
        polling,
        ...options
      });
    }
    async #checkVisibility(visibility) {
      return await this.evaluate(async (element2, PuppeteerUtil, visibility2) => {
        return Boolean(PuppeteerUtil.checkVisibility(element2, visibility2));
      }, LazyArg.create((context10) => {
        return context10.puppeteerUtil;
      }), visibility);
    }
    /**
     * An element is considered to be visible if all of the following is
     * true:
     *
     * - the element has
     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.
     *
     * - the element has a non-empty
     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.
     *
     * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}
     *   is not `hidden` or `collapse`.
     */
    async isVisible() {
      return await this.#checkVisibility(true);
    }
    /**
     * An element is considered to be hidden if at least one of the following is true:
     *
     * - the element has no
     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle | computed styles}.
     *
     * - the element has an empty
     *   {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect | bounding client rect}.
     *
     * - the element's {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | visibility}
     *   is `hidden` or `collapse`.
     */
    async isHidden() {
      return await this.#checkVisibility(false);
    }
    /**
     * Converts the current handle to the given element type.
     *
     * @example
     *
     * ```ts
     * const element: ElementHandle<Element> = await page.$(
     *   '.class-name-of-anchor'
     * );
     * // DO NOT DISPOSE `element`, this will be always be the same handle.
     * const anchor: ElementHandle<HTMLAnchorElement> =
     *   await element.toElement('a');
     * ```
     *
     * @param tagName - The tag name of the desired element type.
     * @throws An error if the handle does not match. **The handle will not be
     * automatically disposed.**
     */
    async toElement(tagName) {
      const isMatchingTagName = await this.evaluate((node, tagName2) => {
        return node.nodeName === tagName2.toUpperCase();
      }, tagName);
      if (!isMatchingTagName) {
        throw new Error(`Element is not a(n) \`${tagName}\` element`);
      }
      return this;
    }
    /**
     * Returns the middle point within an element unless a specific offset is provided.
     */
    async clickablePoint(offset) {
      const box = await this.#clickableBox();
      if (!box) {
        throw new Error("Node is either not clickable or not an Element");
      }
      if (offset !== void 0) {
        return {
          x: box.x + offset.x,
          y: box.y + offset.y
        };
      }
      return {
        x: box.x + box.width / 2,
        y: box.y + box.height / 2
      };
    }
    /**
     * This method scrolls element into view if needed, and then
     * uses {@link Page.mouse} to hover over the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async hover() {
      await this.scrollIntoViewIfNeeded();
      const { x, y } = await this.clickablePoint();
      await this.frame.page().mouse.move(x, y);
    }
    /**
     * This method scrolls element into view if needed, and then
     * uses {@link Page.mouse} to click in the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async click(options = {}) {
      await this.scrollIntoViewIfNeeded();
      const { x, y } = await this.clickablePoint(options.offset);
      await this.frame.page().mouse.click(x, y, options);
    }
    /**
     * Drags an element over the given element or point.
     *
     * @returns DEPRECATED. When drag interception is enabled, the drag payload is
     * returned.
     */
    async drag(target) {
      await this.scrollIntoViewIfNeeded();
      const page = this.frame.page();
      if (page.isDragInterceptionEnabled()) {
        const source2 = await this.clickablePoint();
        if (target instanceof ElementHandle2) {
          target = await target.clickablePoint();
        }
        return await page.mouse.drag(source2, target);
      }
      try {
        if (!page._isDragging) {
          page._isDragging = true;
          await this.hover();
          await page.mouse.down();
        }
        if (target instanceof ElementHandle2) {
          await target.hover();
        } else {
          await page.mouse.move(target.x, target.y);
        }
      } catch (error50) {
        page._isDragging = false;
        throw error50;
      }
    }
    /**
     * @deprecated Do not use. `dragenter` will automatically be performed during dragging.
     */
    async dragEnter(data = { items: [], dragOperationsMask: 1 }) {
      const page = this.frame.page();
      await this.scrollIntoViewIfNeeded();
      const target = await this.clickablePoint();
      await page.mouse.dragEnter(target, data);
    }
    /**
     * @deprecated Do not use. `dragover` will automatically be performed during dragging.
     */
    async dragOver(data = { items: [], dragOperationsMask: 1 }) {
      const page = this.frame.page();
      await this.scrollIntoViewIfNeeded();
      const target = await this.clickablePoint();
      await page.mouse.dragOver(target, data);
    }
    /**
     * @internal
     */
    async drop(dataOrElement = {
      items: [],
      dragOperationsMask: 1
    }) {
      const page = this.frame.page();
      if ("items" in dataOrElement) {
        await this.scrollIntoViewIfNeeded();
        const destination = await this.clickablePoint();
        await page.mouse.drop(destination, dataOrElement);
      } else {
        await dataOrElement.drag(this);
        page._isDragging = false;
        await page.mouse.up();
      }
    }
    /**
     * @deprecated Use `ElementHandle.drop` instead.
     */
    async dragAndDrop(target, options) {
      const page = this.frame.page();
      assert5(page.isDragInterceptionEnabled(), "Drag Interception is not enabled!");
      await this.scrollIntoViewIfNeeded();
      const startPoint = await this.clickablePoint();
      const targetPoint = await target.clickablePoint();
      await page.mouse.dragAndDrop(startPoint, targetPoint, options);
    }
    /**
     * Triggers a `change` and `input` event once all the provided options have been
     * selected. If there's no `<select>` element matching `selector`, the method
     * throws an error.
     *
     * @example
     *
     * ```ts
     * handle.select('blue'); // single selection
     * handle.select('red', 'green', 'blue'); // multiple selections
     * ```
     *
     * @param values - Values of options to select. If the `<select>` has the
     * `multiple` attribute, all values are considered, otherwise only the first
     * one is taken into account.
     */
    async select(...values4) {
      for (const value3 of values4) {
        assert5(isString2(value3), 'Values must be strings. Found value "' + value3 + '" of type "' + typeof value3 + '"');
      }
      return await this.evaluate((element2, vals) => {
        const values5 = new Set(vals);
        if (!(element2 instanceof HTMLSelectElement)) {
          throw new Error("Element is not a <select> element.");
        }
        const selectedValues = /* @__PURE__ */ new Set();
        if (!element2.multiple) {
          for (const option5 of element2.options) {
            option5.selected = false;
          }
          for (const option5 of element2.options) {
            if (values5.has(option5.value)) {
              option5.selected = true;
              selectedValues.add(option5.value);
              break;
            }
          }
        } else {
          for (const option5 of element2.options) {
            option5.selected = values5.has(option5.value);
            if (option5.selected) {
              selectedValues.add(option5.value);
            }
          }
        }
        element2.dispatchEvent(new Event("input", { bubbles: true }));
        element2.dispatchEvent(new Event("change", { bubbles: true }));
        return [...selectedValues.values()];
      }, values4);
    }
    /**
     * This method scrolls element into view if needed, and then uses
     * {@link Touchscreen.tap} to tap in the center of the element.
     * If the element is detached from DOM, the method throws an error.
     */
    async tap() {
      await this.scrollIntoViewIfNeeded();
      const { x, y } = await this.clickablePoint();
      await this.frame.page().touchscreen.tap(x, y);
    }
    async touchStart() {
      await this.scrollIntoViewIfNeeded();
      const { x, y } = await this.clickablePoint();
      await this.frame.page().touchscreen.touchStart(x, y);
    }
    async touchMove() {
      await this.scrollIntoViewIfNeeded();
      const { x, y } = await this.clickablePoint();
      await this.frame.page().touchscreen.touchMove(x, y);
    }
    async touchEnd() {
      await this.scrollIntoViewIfNeeded();
      await this.frame.page().touchscreen.touchEnd();
    }
    /**
     * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.
     */
    async focus() {
      await this.evaluate((element2) => {
        if (!(element2 instanceof HTMLElement)) {
          throw new Error("Cannot focus non-HTMLElement");
        }
        return element2.focus();
      });
    }
    /**
     * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and
     * `keyup` event for each character in the text.
     *
     * To press a special key, like `Control` or `ArrowDown`,
     * use {@link ElementHandle.press}.
     *
     * @example
     *
     * ```ts
     * await elementHandle.type('Hello'); // Types instantly
     * await elementHandle.type('World', {delay: 100}); // Types slower, like a user
     * ```
     *
     * @example
     * An example of typing into a text field and then submitting the form:
     *
     * ```ts
     * const elementHandle = await page.$('input');
     * await elementHandle.type('some text');
     * await elementHandle.press('Enter');
     * ```
     *
     * @param options - Delay in milliseconds. Defaults to 0.
     */
    async type(text2, options) {
      await this.focus();
      await this.frame.page().keyboard.type(text2, options);
    }
    /**
     * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.
     *
     * @remarks
     * If `key` is a single character and no modifier keys besides `Shift`
     * are being held down, a `keypress`/`input` event will also be generated.
     * The `text` option can be specified to force an input event to be generated.
     *
     * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`
     * will type the text in upper case.
     *
     * @param key - Name of key to press, such as `ArrowLeft`.
     * See {@link KeyInput} for a list of all key names.
     */
    async press(key, options) {
      await this.focus();
      await this.frame.page().keyboard.press(key, options);
    }
    async #clickableBox() {
      const boxes = await this.evaluate((element2) => {
        if (!(element2 instanceof Element)) {
          return null;
        }
        return [...element2.getClientRects()].map((rect) => {
          return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        });
      });
      if (!boxes?.length) {
        return null;
      }
      await this.#intersectBoundingBoxesWithFrame(boxes);
      let frame = this.frame;
      let parentFrame;
      while (parentFrame = frame?.parentFrame()) {
        const env_3 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource10(env_3, await frame.frameElement(), false);
          if (!handle) {
            throw new Error("Unsupported frame type");
          }
          const parentBox = await handle.evaluate((element2) => {
            if (element2.getClientRects().length === 0) {
              return null;
            }
            const rect = element2.getBoundingClientRect();
            const style = window.getComputedStyle(element2);
            return {
              left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
              top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
            };
          });
          if (!parentBox) {
            return null;
          }
          for (const box2 of boxes) {
            box2.x += parentBox.left;
            box2.y += parentBox.top;
          }
          await handle.#intersectBoundingBoxesWithFrame(boxes);
          frame = parentFrame;
        } catch (e_3) {
          env_3.error = e_3;
          env_3.hasError = true;
        } finally {
          __disposeResources10(env_3);
        }
      }
      const box = boxes.find((box2) => {
        return box2.width >= 1 && box2.height >= 1;
      });
      if (!box) {
        return null;
      }
      return {
        x: box.x,
        y: box.y,
        height: box.height,
        width: box.width
      };
    }
    async #intersectBoundingBoxesWithFrame(boxes) {
      const { documentWidth, documentHeight } = await this.frame.isolatedRealm().evaluate(() => {
        return {
          documentWidth: document.documentElement.clientWidth,
          documentHeight: document.documentElement.clientHeight
        };
      });
      for (const box of boxes) {
        intersectBoundingBox(box, documentWidth, documentHeight);
      }
    }
    /**
     * This method returns the bounding box of the element (relative to the main frame),
     * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
     * (example: `display: none`).
     */
    async boundingBox() {
      const box = await this.evaluate((element2) => {
        if (!(element2 instanceof Element)) {
          return null;
        }
        if (element2.getClientRects().length === 0) {
          return null;
        }
        const rect = element2.getBoundingClientRect();
        return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
      });
      if (!box) {
        return null;
      }
      const offset = await this.#getTopLeftCornerOfFrame();
      if (!offset) {
        return null;
      }
      return {
        x: box.x + offset.x,
        y: box.y + offset.y,
        height: box.height,
        width: box.width
      };
    }
    /**
     * This method returns boxes of the element,
     * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
     * (example: `display: none`).
     *
     * @remarks
     *
     * Boxes are represented as an array of points;
     * Each Point is an object `{x, y}`. Box points are sorted clock-wise.
     */
    async boxModel() {
      const model = await this.evaluate((element2) => {
        if (!(element2 instanceof Element)) {
          return null;
        }
        if (element2.getClientRects().length === 0) {
          return null;
        }
        const rect = element2.getBoundingClientRect();
        const style = window.getComputedStyle(element2);
        const offsets = {
          padding: {
            left: parseInt(style.paddingLeft, 10),
            top: parseInt(style.paddingTop, 10),
            right: parseInt(style.paddingRight, 10),
            bottom: parseInt(style.paddingBottom, 10)
          },
          margin: {
            left: -parseInt(style.marginLeft, 10),
            top: -parseInt(style.marginTop, 10),
            right: -parseInt(style.marginRight, 10),
            bottom: -parseInt(style.marginBottom, 10)
          },
          border: {
            left: parseInt(style.borderLeft, 10),
            top: parseInt(style.borderTop, 10),
            right: parseInt(style.borderRight, 10),
            bottom: parseInt(style.borderBottom, 10)
          }
        };
        const border = [
          { x: rect.left, y: rect.top },
          { x: rect.left + rect.width, y: rect.top },
          { x: rect.left + rect.width, y: rect.top + rect.bottom },
          { x: rect.left, y: rect.top + rect.bottom }
        ];
        const padding = transformQuadWithOffsets(border, offsets.border);
        const content = transformQuadWithOffsets(padding, offsets.padding);
        const margin = transformQuadWithOffsets(border, offsets.margin);
        return {
          content,
          padding,
          border,
          margin,
          width: rect.width,
          height: rect.height
        };
        function transformQuadWithOffsets(quad, offsets2) {
          return [
            {
              x: quad[0].x + offsets2.left,
              y: quad[0].y + offsets2.top
            },
            {
              x: quad[1].x - offsets2.right,
              y: quad[1].y + offsets2.top
            },
            {
              x: quad[2].x - offsets2.right,
              y: quad[2].y - offsets2.bottom
            },
            {
              x: quad[3].x + offsets2.left,
              y: quad[3].y - offsets2.bottom
            }
          ];
        }
        __name(transformQuadWithOffsets, "transformQuadWithOffsets");
      });
      if (!model) {
        return null;
      }
      const offset = await this.#getTopLeftCornerOfFrame();
      if (!offset) {
        return null;
      }
      for (const attribute of [
        "content",
        "padding",
        "border",
        "margin"
      ]) {
        for (const point of model[attribute]) {
          point.x += offset.x;
          point.y += offset.y;
        }
      }
      return model;
    }
    async #getTopLeftCornerOfFrame() {
      const point = { x: 0, y: 0 };
      let frame = this.frame;
      let parentFrame;
      while (parentFrame = frame?.parentFrame()) {
        const env_4 = { stack: [], error: void 0, hasError: false };
        try {
          const handle = __addDisposableResource10(env_4, await frame.frameElement(), false);
          if (!handle) {
            throw new Error("Unsupported frame type");
          }
          const parentBox = await handle.evaluate((element2) => {
            if (element2.getClientRects().length === 0) {
              return null;
            }
            const rect = element2.getBoundingClientRect();
            const style = window.getComputedStyle(element2);
            return {
              left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
              top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
            };
          });
          if (!parentBox) {
            return null;
          }
          point.x += parentBox.left;
          point.y += parentBox.top;
          frame = parentFrame;
        } catch (e_4) {
          env_4.error = e_4;
          env_4.hasError = true;
        } finally {
          __disposeResources10(env_4);
        }
      }
      return point;
    }
    async screenshot(options = {}) {
      const { scrollIntoView = true, clip } = options;
      const page = this.frame.page();
      if (scrollIntoView) {
        await this.scrollIntoViewIfNeeded();
      }
      const elementClip = await this.#nonEmptyVisibleBoundingBox();
      const [pageLeft, pageTop] = await this.evaluate(() => {
        if (!window.visualViewport) {
          throw new Error("window.visualViewport is not supported.");
        }
        return [
          window.visualViewport.pageLeft,
          window.visualViewport.pageTop
        ];
      });
      elementClip.x += pageLeft;
      elementClip.y += pageTop;
      if (clip) {
        elementClip.x += clip.x;
        elementClip.y += clip.y;
        elementClip.height = clip.height;
        elementClip.width = clip.width;
      }
      return await page.screenshot({ ...options, clip: elementClip });
    }
    async #nonEmptyVisibleBoundingBox() {
      const box = await this.boundingBox();
      assert5(box, "Node is either not visible or not an HTMLElement");
      assert5(box.width !== 0, "Node has 0 width.");
      assert5(box.height !== 0, "Node has 0 height.");
      return box;
    }
    /**
     * @internal
     */
    async assertConnectedElement() {
      const error50 = await this.evaluate(async (element2) => {
        if (!element2.isConnected) {
          return "Node is detached from document";
        }
        if (element2.nodeType !== Node.ELEMENT_NODE) {
          return "Node is not of type HTMLElement";
        }
        return;
      });
      if (error50) {
        throw new Error(error50);
      }
    }
    /**
     * @internal
     */
    async scrollIntoViewIfNeeded() {
      if (await this.isIntersectingViewport({
        threshold: 1
      })) {
        return;
      }
      await this.scrollIntoView();
    }
    /**
     * Resolves to true if the element is visible in the current viewport. If an
     * element is an SVG, we check if the svg owner element is in the viewport
     * instead. See https://crbug.com/963246.
     *
     * @param options - Threshold for the intersection between 0 (no intersection) and 1
     * (full intersection). Defaults to 1.
     */
    async isIntersectingViewport(options = {}) {
      const env_5 = { stack: [], error: void 0, hasError: false };
      try {
        await this.assertConnectedElement();
        const handle = await this.#asSVGElementHandle();
        const target = __addDisposableResource10(env_5, handle && await handle.#getOwnerSVGElement(), false);
        return await (target ?? this).evaluate(async (element2, threshold) => {
          const visibleRatio = await new Promise((resolve) => {
            const observer = new IntersectionObserver((entries2) => {
              resolve(entries2[0].intersectionRatio);
              observer.disconnect();
            });
            observer.observe(element2);
          });
          return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;
        }, options.threshold ?? 0);
      } catch (e_5) {
        env_5.error = e_5;
        env_5.hasError = true;
      } finally {
        __disposeResources10(env_5);
      }
    }
    /**
     * Scrolls the element into view using either the automation protocol client
     * or by calling element.scrollIntoView.
     */
    async scrollIntoView() {
      await this.assertConnectedElement();
      await this.evaluate(async (element2) => {
        element2.scrollIntoView({
          block: "center",
          inline: "center",
          behavior: "instant"
        });
      });
    }
    /**
     * Returns true if an element is an SVGElement (included svg, path, rect
     * etc.).
     */
    async #asSVGElementHandle() {
      if (await this.evaluate((element2) => {
        return element2 instanceof SVGElement;
      })) {
        return this;
      } else {
        return null;
      }
    }
    async #getOwnerSVGElement() {
      return await this.evaluateHandle((element2) => {
        if (element2 instanceof SVGSVGElement) {
          return element2;
        }
        return element2.ownerSVGElement;
      });
    }
  };
})();
function intersectBoundingBox(box, width, height) {
  box.width = Math.max(box.x >= 0 ? Math.min(width - box.x, box.width) : Math.min(width, box.width + box.x), 0);
  box.height = Math.max(box.y >= 0 ? Math.min(height - box.y, box.height) : Math.min(height, box.height + box.y), 0);
}
__name(intersectBoundingBox, "intersectBoundingBox");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/JSHandle.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/utils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function createEvaluationError(details) {
  let name;
  let message;
  if (!details.exception) {
    name = "Error";
    message = details.text;
  } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
    return valueFromRemoteObject(details.exception);
  } else {
    const detail = getErrorDetails(details);
    name = detail.name;
    message = detail.message;
  }
  const messageHeight = message.split("\n").length;
  const error50 = new Error(message);
  error50.name = name;
  const stackLines = error50.stack.split("\n");
  const messageLines = stackLines.splice(0, messageHeight);
  stackLines.shift();
  if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
    for (const frame of details.stackTrace.callFrames.reverse()) {
      if (PuppeteerURL.isPuppeteerURL(frame.url) && frame.url !== PuppeteerURL.INTERNAL_URL) {
        const url3 = PuppeteerURL.parse(frame.url);
        stackLines.unshift(`    at ${frame.functionName || url3.functionName} (${url3.functionName} at ${url3.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
      } else {
        stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
      }
      if (stackLines.length >= Error.stackTraceLimit) {
        break;
      }
    }
  }
  error50.stack = [...messageLines, ...stackLines].join("\n");
  return error50;
}
__name(createEvaluationError, "createEvaluationError");
var getErrorDetails = /* @__PURE__ */ __name((details) => {
  let name = "";
  let message;
  const lines = details.exception?.description?.split("\n    at ") ?? [];
  const size15 = Math.min(details.stackTrace?.callFrames.length ?? 0, lines.length - 1);
  lines.splice(-size15, size15);
  if (details.exception?.className) {
    name = details.exception.className;
  }
  message = lines.join("\n");
  if (name && message.startsWith(`${name}: `)) {
    message = message.slice(name.length + 2);
  }
  return { message, name };
}, "getErrorDetails");
function createClientError(details) {
  let name;
  let message;
  if (!details.exception) {
    name = "Error";
    message = details.text;
  } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
    return valueFromRemoteObject(details.exception);
  } else {
    const detail = getErrorDetails(details);
    name = detail.name;
    message = detail.message;
  }
  const error50 = new Error(message);
  error50.name = name;
  const messageHeight = error50.message.split("\n").length;
  const messageLines = error50.stack.split("\n").splice(0, messageHeight);
  const stackLines = [];
  if (details.stackTrace) {
    for (const frame of details.stackTrace.callFrames) {
      stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber + 1}:${frame.columnNumber + 1})`);
      if (stackLines.length >= Error.stackTraceLimit) {
        break;
      }
    }
  }
  error50.stack = [...messageLines, ...stackLines].join("\n");
  return error50;
}
__name(createClientError, "createClientError");
function valueFromRemoteObject(remoteObject) {
  assert5(!remoteObject.objectId, "Cannot extract value when objectId is given");
  if (remoteObject.unserializableValue) {
    if (remoteObject.type === "bigint") {
      return BigInt(remoteObject.unserializableValue.replace("n", ""));
    }
    switch (remoteObject.unserializableValue) {
      case "-0":
        return -0;
      case "NaN":
        return NaN;
      case "Infinity":
        return Infinity;
      case "-Infinity":
        return -Infinity;
      default:
        throw new Error("Unsupported unserializable value: " + remoteObject.unserializableValue);
    }
  }
  return remoteObject.value;
}
__name(valueFromRemoteObject, "valueFromRemoteObject");
function addPageBinding(type, name, prefix) {
  if (globalThis[name]) {
    return;
  }
  Object.assign(globalThis, {
    [name](...args2) {
      const callPuppeteer = globalThis[name];
      callPuppeteer.args ??= /* @__PURE__ */ new Map();
      callPuppeteer.callbacks ??= /* @__PURE__ */ new Map();
      const seq2 = (callPuppeteer.lastSeq ?? 0) + 1;
      callPuppeteer.lastSeq = seq2;
      callPuppeteer.args.set(seq2, args2);
      globalThis[prefix + name](JSON.stringify({
        type,
        name,
        seq: seq2,
        args: args2,
        isTrivial: !args2.some((value3) => {
          return value3 instanceof Node;
        })
      }));
      return new Promise((resolve, reject) => {
        callPuppeteer.callbacks.set(seq2, {
          resolve(value3) {
            callPuppeteer.args.delete(seq2);
            resolve(value3);
          },
          reject(value3) {
            callPuppeteer.args.delete(seq2);
            reject(value3);
          }
        });
      });
    }
  });
}
__name(addPageBinding, "addPageBinding");
var CDP_BINDING_PREFIX = "puppeteer_";
function pageBindingInitString(type, name) {
  return evaluationString(addPageBinding, type, name, CDP_BINDING_PREFIX);
}
__name(pageBindingInitString, "pageBindingInitString");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/JSHandle.js
var CdpJSHandle = class extends JSHandle {
  static {
    __name(this, "CdpJSHandle");
  }
  #disposed = false;
  #remoteObject;
  #world;
  constructor(world, remoteObject) {
    super();
    this.#world = world;
    this.#remoteObject = remoteObject;
  }
  get disposed() {
    return this.#disposed;
  }
  get realm() {
    return this.#world;
  }
  get client() {
    return this.realm.environment.client;
  }
  async jsonValue() {
    if (!this.#remoteObject.objectId) {
      return valueFromRemoteObject(this.#remoteObject);
    }
    const value3 = await this.evaluate((object4) => {
      return object4;
    });
    if (value3 === void 0) {
      throw new Error("Could not serialize referenced object");
    }
    return value3;
  }
  /**
   * Either `null` or the handle itself if the handle is an
   * instance of {@link ElementHandle}.
   */
  asElement() {
    return null;
  }
  async dispose() {
    if (this.#disposed) {
      return;
    }
    this.#disposed = true;
    await releaseObject(this.client, this.#remoteObject);
  }
  toString() {
    if (!this.#remoteObject.objectId) {
      return "JSHandle:" + valueFromRemoteObject(this.#remoteObject);
    }
    const type = this.#remoteObject.subtype || this.#remoteObject.type;
    return "JSHandle@" + type;
  }
  get id() {
    return this.#remoteObject.objectId;
  }
  remoteObject() {
    return this.#remoteObject;
  }
  async getProperties() {
    const response = await this.client.send("Runtime.getProperties", {
      objectId: this.#remoteObject.objectId,
      ownProperties: true
    });
    const result = /* @__PURE__ */ new Map();
    for (const property2 of response.result) {
      if (!property2.enumerable || !property2.value) {
        continue;
      }
      result.set(property2.name, this.#world.createCdpHandle(property2.value));
    }
    return result;
  }
};
async function releaseObject(client, remoteObject) {
  if (!remoteObject.objectId) {
    return;
  }
  await client.send("Runtime.releaseObject", { objectId: remoteObject.objectId }).catch((error50) => {
    debugError(error50);
  });
}
__name(releaseObject, "releaseObject");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/ElementHandle.js
var __runInitializers6 = function(thisArg, initializers, value3) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value3 = useValue ? initializers[i].call(thisArg, value3) : initializers[i].call(thisArg);
  }
  return useValue ? value3 : void 0;
};
var __esDecorate6 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor3 = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done13 = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context10 = {};
    for (var p in contextIn) context10[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context10.access[p] = contextIn.access[p];
    context10.addInitializer = function(f) {
      if (done13) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor3.get, set: descriptor3.set } : descriptor3[key], context10);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor3.get = _;
      if (_ = accept(result.set)) descriptor3.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor3[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor3);
  done13 = true;
};
var NON_ELEMENT_NODE_ROLES = /* @__PURE__ */ new Set(["StaticText", "InlineTextBox"]);
var CdpElementHandle = (() => {
  var _a2, _b;
  let _classSuper = ElementHandle;
  let _instanceExtraInitializers = [];
  let _contentFrame_decorators;
  let _scrollIntoView_decorators;
  let _uploadFile_decorators;
  let _autofill_decorators;
  return class CdpElementHandle extends _classSuper {
    static {
      __name(this, "CdpElementHandle");
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      _contentFrame_decorators = [throwIfDisposed()];
      _scrollIntoView_decorators = [throwIfDisposed(), (_a2 = ElementHandle).bindIsolatedHandle.bind(_a2)];
      _uploadFile_decorators = [throwIfDisposed(), (_b = ElementHandle).bindIsolatedHandle.bind(_b)];
      _autofill_decorators = [throwIfDisposed()];
      __esDecorate6(this, null, _contentFrame_decorators, { kind: "method", name: "contentFrame", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "contentFrame" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.contentFrame, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate6(this, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "scrollIntoView" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.scrollIntoView, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate6(this, null, _uploadFile_decorators, { kind: "method", name: "uploadFile", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "uploadFile" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.uploadFile, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate6(this, null, _autofill_decorators, { kind: "method", name: "autofill", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "autofill" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.autofill, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    }
    constructor(world, remoteObject) {
      super(new CdpJSHandle(world, remoteObject));
      __runInitializers6(this, _instanceExtraInitializers);
    }
    get realm() {
      return this.handle.realm;
    }
    get client() {
      return this.handle.client;
    }
    remoteObject() {
      return this.handle.remoteObject();
    }
    get #frameManager() {
      return this.frame._frameManager;
    }
    get frame() {
      return this.realm.environment;
    }
    async contentFrame() {
      const nodeInfo = await this.client.send("DOM.describeNode", {
        objectId: this.id
      });
      if (typeof nodeInfo.node.frameId !== "string") {
        return null;
      }
      return this.#frameManager.frame(nodeInfo.node.frameId);
    }
    async scrollIntoView() {
      await this.assertConnectedElement();
      try {
        await this.client.send("DOM.scrollIntoViewIfNeeded", {
          objectId: this.id
        });
      } catch (error50) {
        debugError(error50);
        await super.scrollIntoView();
      }
    }
    async uploadFile(...filePaths) {
      const isMultiple = await this.evaluate((element2) => {
        return element2.multiple;
      });
      assert5(filePaths.length <= 1 || isMultiple, "Multiple file uploads only work with <input type=file multiple>");
      let path;
      try {
        path = await import("path");
      } catch (error50) {
        if (error50 instanceof TypeError) {
          throw new Error(`JSHandle#uploadFile can only be used in Node-like environments.`);
        }
        throw error50;
      }
      const files = filePaths.map((filePath) => {
        if (path.win32.isAbsolute(filePath) || path.posix.isAbsolute(filePath)) {
          return filePath;
        } else {
          return path.resolve(filePath);
        }
      });
      if (files.length === 0) {
        await this.evaluate((element2) => {
          element2.files = new DataTransfer().files;
          element2.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
          element2.dispatchEvent(new Event("change", { bubbles: true }));
        });
        return;
      }
      const { node: { backendNodeId } } = await this.client.send("DOM.describeNode", {
        objectId: this.id
      });
      await this.client.send("DOM.setFileInputFiles", {
        objectId: this.id,
        files,
        backendNodeId
      });
    }
    async autofill(data) {
      const nodeInfo = await this.client.send("DOM.describeNode", {
        objectId: this.handle.id
      });
      const fieldId = nodeInfo.node.backendNodeId;
      const frameId = this.frame._id;
      await this.client.send("Autofill.trigger", {
        fieldId,
        frameId,
        card: data.creditCard
      });
    }
    async *queryAXTree(name, role) {
      const { nodes } = await this.client.send("Accessibility.queryAXTree", {
        objectId: this.id,
        accessibleName: name,
        role
      });
      const results = nodes.filter((node) => {
        if (node.ignored) {
          return false;
        }
        if (!node.role) {
          return false;
        }
        if (NON_ELEMENT_NODE_ROLES.has(node.role.value)) {
          return false;
        }
        return true;
      });
      return yield* AsyncIterableUtil.map(results, (node) => {
        return this.realm.adoptBackendNode(node.backendDOMNodeId);
      });
    }
  };
})();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/ExecutionContext.js
var __addDisposableResource11 = function(env2, value3, async4) {
  if (value3 !== null && value3 !== void 0) {
    if (typeof value3 !== "object" && typeof value3 !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async4) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value3[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value3[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env2.stack.push({ value: value3, dispose, async: async4 });
  } else if (async4) {
    env2.stack.push({ async: true });
  }
  return value3;
};
var __disposeResources11 = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail19(e) {
      env2.error = env2.hasError ? new SuppressedError2(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    __name(fail19, "fail");
    function next4() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async) return Promise.resolve(result).then(next4, function(e) {
            fail19(e);
            return next4();
          });
        } catch (e) {
          fail19(e);
        }
      }
      if (env2.hasError) throw env2.error;
    }
    __name(next4, "next");
    return next4();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error50, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error50, e.suppressed = suppressed, e;
});
var ariaQuerySelectorBinding = new Binding(
  "__ariaQuerySelector",
  ARIAQueryHandler.queryOne,
  ""
  // custom init
);
var ariaQuerySelectorAllBinding = new Binding(
  "__ariaQuerySelectorAll",
  (async (element2, selector) => {
    const results = ARIAQueryHandler.queryAll(element2, selector);
    return await element2.realm.evaluateHandle((...elements) => {
      return elements;
    }, ...await AsyncIterableUtil.collect(results));
  }),
  ""
  // custom init
);
var ExecutionContext = class extends EventEmitter2 {
  static {
    __name(this, "ExecutionContext");
  }
  #client;
  #world;
  #id;
  #name;
  #disposables = new DisposableStack();
  constructor(client, contextPayload, world) {
    super();
    this.#client = client;
    this.#world = world;
    this.#id = contextPayload.id;
    if (contextPayload.name) {
      this.#name = contextPayload.name;
    }
    const clientEmitter = this.#disposables.use(new EventEmitter2(this.#client));
    clientEmitter.on("Runtime.bindingCalled", this.#onBindingCalled.bind(this));
    clientEmitter.on("Runtime.executionContextDestroyed", async (event) => {
      if (event.executionContextId === this.#id) {
        this[disposeSymbol]();
      }
    });
    clientEmitter.on("Runtime.executionContextsCleared", async () => {
      this[disposeSymbol]();
    });
    clientEmitter.on("Runtime.consoleAPICalled", this.#onConsoleAPI.bind(this));
    clientEmitter.on(CDPSessionEvent.Disconnected, () => {
      this[disposeSymbol]();
    });
  }
  // Contains mapping from functions that should be bound to Puppeteer functions.
  #bindings = /* @__PURE__ */ new Map();
  // If multiple waitFor are set up asynchronously, we need to wait for the
  // first one to set up the binding in the page before running the others.
  #mutex = new Mutex();
  async #addBinding(binding2) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      if (this.#bindings.has(binding2.name)) {
        return;
      }
      const _ = __addDisposableResource11(env_1, await this.#mutex.acquire(), false);
      try {
        await this.#client.send("Runtime.addBinding", this.#name ? {
          name: CDP_BINDING_PREFIX + binding2.name,
          executionContextName: this.#name
        } : {
          name: CDP_BINDING_PREFIX + binding2.name,
          executionContextId: this.#id
        });
        await this.evaluate(addPageBinding, "internal", binding2.name, CDP_BINDING_PREFIX);
        this.#bindings.set(binding2.name, binding2);
      } catch (error50) {
        if (error50 instanceof Error) {
          if (error50.message.includes("Execution context was destroyed")) {
            return;
          }
          if (error50.message.includes("Cannot find context with specified id")) {
            return;
          }
        }
        debugError(error50);
      }
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources11(env_1);
    }
  }
  async #onBindingCalled(event) {
    if (event.executionContextId !== this.#id) {
      return;
    }
    let payload;
    try {
      payload = JSON.parse(event.payload);
    } catch {
      return;
    }
    const { type, name, seq: seq2, args: args2, isTrivial } = payload;
    if (type !== "internal") {
      this.emit("bindingcalled", event);
      return;
    }
    if (!this.#bindings.has(name)) {
      this.emit("bindingcalled", event);
      return;
    }
    try {
      const binding2 = this.#bindings.get(name);
      await binding2?.run(this, seq2, args2, isTrivial);
    } catch (err) {
      debugError(err);
    }
  }
  get id() {
    return this.#id;
  }
  #onConsoleAPI(event) {
    if (event.executionContextId !== this.#id) {
      return;
    }
    this.emit("consoleapicalled", event);
  }
  #bindingsInstalled = false;
  #puppeteerUtil;
  get puppeteerUtil() {
    let promise4 = Promise.resolve();
    if (!this.#bindingsInstalled) {
      promise4 = Promise.all([
        this.#addBindingWithoutThrowing(ariaQuerySelectorBinding),
        this.#addBindingWithoutThrowing(ariaQuerySelectorAllBinding)
      ]);
      this.#bindingsInstalled = true;
    }
    scriptInjector.inject((script) => {
      if (this.#puppeteerUtil) {
        void this.#puppeteerUtil.then((handle) => {
          void handle.dispose();
        });
      }
      this.#puppeteerUtil = promise4.then(() => {
        return this.evaluateHandle(script);
      });
    }, !this.#puppeteerUtil);
    return this.#puppeteerUtil;
  }
  async #addBindingWithoutThrowing(binding2) {
    try {
      await this.#addBinding(binding2);
    } catch (err) {
      debugError(err);
    }
  }
  /**
   * Evaluates the given function.
   *
   * @example
   *
   * ```ts
   * const executionContext = await page.mainFrame().executionContext();
   * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;
   * console.log(result); // prints "56"
   * ```
   *
   * @example
   * A string can also be passed in instead of a function:
   *
   * ```ts
   * console.log(await executionContext.evaluate('1 + 2')); // prints "3"
   * ```
   *
   * @example
   * Handles can also be passed as `args`. They resolve to their referenced object:
   *
   * ```ts
   * const oneHandle = await executionContext.evaluateHandle(() => 1);
   * const twoHandle = await executionContext.evaluateHandle(() => 2);
   * const result = await executionContext.evaluate(
   *   (a, b) => a + b,
   *   oneHandle,
   *   twoHandle
   * );
   * await oneHandle.dispose();
   * await twoHandle.dispose();
   * console.log(result); // prints '3'.
   * ```
   *
   * @param pageFunction - The function to evaluate.
   * @param args - Additional arguments to pass into the function.
   * @returns The result of evaluating the function. If the result is an object,
   * a vanilla object containing the serializable properties of the result is
   * returned.
   */
  async evaluate(pageFunction, ...args2) {
    return await this.#evaluate(true, pageFunction, ...args2);
  }
  /**
   * Evaluates the given function.
   *
   * Unlike {@link ExecutionContext.evaluate | evaluate}, this method returns a
   * handle to the result of the function.
   *
   * This method may be better suited if the object cannot be serialized (e.g.
   * `Map`) and requires further manipulation.
   *
   * @example
   *
   * ```ts
   * const context = await page.mainFrame().executionContext();
   * const handle: JSHandle<typeof globalThis> = await context.evaluateHandle(
   *   () => Promise.resolve(self)
   * );
   * ```
   *
   * @example
   * A string can also be passed in instead of a function.
   *
   * ```ts
   * const handle: JSHandle<number> = await context.evaluateHandle('1 + 2');
   * ```
   *
   * @example
   * Handles can also be passed as `args`. They resolve to their referenced object:
   *
   * ```ts
   * const bodyHandle: ElementHandle<HTMLBodyElement> =
   *   await context.evaluateHandle(() => {
   *     return document.body;
   *   });
   * const stringHandle: JSHandle<string> = await context.evaluateHandle(
   *   body => body.innerHTML,
   *   body
   * );
   * console.log(await stringHandle.jsonValue()); // prints body's innerHTML
   * // Always dispose your garbage! :)
   * await bodyHandle.dispose();
   * await stringHandle.dispose();
   * ```
   *
   * @param pageFunction - The function to evaluate.
   * @param args - Additional arguments to pass into the function.
   * @returns A {@link JSHandle | handle} to the result of evaluating the
   * function. If the result is a `Node`, then this will return an
   * {@link ElementHandle | element handle}.
   */
  async evaluateHandle(pageFunction, ...args2) {
    return await this.#evaluate(false, pageFunction, ...args2);
  }
  async #evaluate(returnByValue, pageFunction, ...args2) {
    const sourceUrlComment = getSourceUrlComment(getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ?? PuppeteerURL.INTERNAL_URL);
    if (isString2(pageFunction)) {
      const contextId = this.#id;
      const expression = pageFunction;
      const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : `${expression}
${sourceUrlComment}
`;
      const { exceptionDetails: exceptionDetails2, result: remoteObject2 } = await this.#client.send("Runtime.evaluate", {
        expression: expressionWithSourceUrl,
        contextId,
        returnByValue,
        awaitPromise: true,
        userGesture: true
      }).catch(rewriteError2);
      if (exceptionDetails2) {
        throw createEvaluationError(exceptionDetails2);
      }
      return returnByValue ? valueFromRemoteObject(remoteObject2) : this.#world.createCdpHandle(remoteObject2);
    }
    const functionDeclaration = stringifyFunction(pageFunction);
    const functionDeclarationWithSourceUrl = SOURCE_URL_REGEX.test(functionDeclaration) ? functionDeclaration : `${functionDeclaration}
${sourceUrlComment}
`;
    let callFunctionOnPromise;
    try {
      callFunctionOnPromise = this.#client.send("Runtime.callFunctionOn", {
        functionDeclaration: functionDeclarationWithSourceUrl,
        executionContextId: this.#id,
        arguments: args2.length ? await Promise.all(args2.map(convertArgument.bind(this))) : [],
        returnByValue,
        awaitPromise: true,
        userGesture: true
      });
    } catch (error50) {
      if (error50 instanceof TypeError && error50.message.startsWith("Converting circular structure to JSON")) {
        error50.message += " Recursive objects are not allowed.";
      }
      throw error50;
    }
    const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError2);
    if (exceptionDetails) {
      throw createEvaluationError(exceptionDetails);
    }
    return returnByValue ? valueFromRemoteObject(remoteObject) : this.#world.createCdpHandle(remoteObject);
    async function convertArgument(arg) {
      if (arg instanceof LazyArg) {
        arg = await arg.get(this);
      }
      if (typeof arg === "bigint") {
        return { unserializableValue: `${arg.toString()}n` };
      }
      if (Object.is(arg, -0)) {
        return { unserializableValue: "-0" };
      }
      if (Object.is(arg, Infinity)) {
        return { unserializableValue: "Infinity" };
      }
      if (Object.is(arg, -Infinity)) {
        return { unserializableValue: "-Infinity" };
      }
      if (Object.is(arg, NaN)) {
        return { unserializableValue: "NaN" };
      }
      const objectHandle = arg && (arg instanceof CdpJSHandle || arg instanceof CdpElementHandle) ? arg : null;
      if (objectHandle) {
        if (objectHandle.realm !== this.#world) {
          throw new Error("JSHandles can be evaluated only in the context they were created!");
        }
        if (objectHandle.disposed) {
          throw new Error("JSHandle is disposed!");
        }
        if (objectHandle.remoteObject().unserializableValue) {
          return {
            unserializableValue: objectHandle.remoteObject().unserializableValue
          };
        }
        if (!objectHandle.remoteObject().objectId) {
          return { value: objectHandle.remoteObject().value };
        }
        return { objectId: objectHandle.remoteObject().objectId };
      }
      return { value: arg };
    }
    __name(convertArgument, "convertArgument");
  }
  [disposeSymbol]() {
    this.#disposables.dispose();
    this.emit("disposed", void 0);
  }
};
var rewriteError2 = /* @__PURE__ */ __name((error50) => {
  if (error50.message.includes("Object reference chain is too long")) {
    return { result: { type: "undefined" } };
  }
  if (error50.message.includes("Object couldn't be returned by value")) {
    return { result: { type: "undefined" } };
  }
  if (error50.message.endsWith("Cannot find context with specified id") || error50.message.endsWith("Inspected target navigated or closed")) {
    throw new Error("Execution context was destroyed, most likely because of a navigation.");
  }
  throw error50;
}, "rewriteError");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Frame.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Accessibility.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Accessibility = class {
  static {
    __name(this, "Accessibility");
  }
  #realm;
  /**
   * @internal
   */
  constructor(realm) {
    this.#realm = realm;
  }
  /**
   * Captures the current state of the accessibility tree.
   * The returned object represents the root accessible node of the page.
   *
   * @remarks
   *
   * **NOTE** The Chrome accessibility tree contains nodes that go unused on
   * most platforms and by most screen readers. Puppeteer will discard them as
   * well for an easier to process tree, unless `interestingOnly` is set to
   * `false`.
   *
   * @example
   * An example of dumping the entire accessibility tree:
   *
   * ```ts
   * const snapshot = await page.accessibility.snapshot();
   * console.log(snapshot);
   * ```
   *
   * @example
   * An example of logging the focused node's name:
   *
   * ```ts
   * const snapshot = await page.accessibility.snapshot();
   * const node = findFocusedNode(snapshot);
   * console.log(node && node.name);
   *
   * function findFocusedNode(node) {
   *   if (node.focused) return node;
   *   for (const child of node.children || []) {
   *     const foundNode = findFocusedNode(child);
   *     return foundNode;
   *   }
   *   return null;
   * }
   * ```
   *
   * @returns An AXNode object representing the snapshot.
   */
  async snapshot(options = {}) {
    const { interestingOnly = true, root = null } = options;
    const { nodes } = await this.#realm.environment.client.send("Accessibility.getFullAXTree");
    let backendNodeId;
    if (root) {
      const { node } = await this.#realm.environment.client.send("DOM.describeNode", {
        objectId: root.id
      });
      backendNodeId = node.backendNodeId;
    }
    const defaultRoot = AXNode.createTree(this.#realm, nodes);
    let needle = defaultRoot;
    if (backendNodeId) {
      needle = defaultRoot.find((node) => {
        return node.payload.backendDOMNodeId === backendNodeId;
      });
      if (!needle) {
        return null;
      }
    }
    if (!interestingOnly) {
      return this.serializeTree(needle)[0] ?? null;
    }
    const interestingNodes = /* @__PURE__ */ new Set();
    this.collectInterestingNodes(interestingNodes, defaultRoot, false);
    if (!interestingNodes.has(needle)) {
      return null;
    }
    return this.serializeTree(needle, interestingNodes)[0] ?? null;
  }
  serializeTree(node, interestingNodes) {
    const children2 = [];
    for (const child of node.children) {
      children2.push(...this.serializeTree(child, interestingNodes));
    }
    if (interestingNodes && !interestingNodes.has(node)) {
      return children2;
    }
    const serializedNode = node.serialize();
    if (children2.length) {
      serializedNode.children = children2;
    }
    return [serializedNode];
  }
  collectInterestingNodes(collection, node, insideControl) {
    if (node.isInteresting(insideControl)) {
      collection.add(node);
    }
    if (node.isLeafNode()) {
      return;
    }
    insideControl = insideControl || node.isControl();
    for (const child of node.children) {
      this.collectInterestingNodes(collection, child, insideControl);
    }
  }
};
var AXNode = class _AXNode {
  static {
    __name(this, "AXNode");
  }
  payload;
  children = [];
  #richlyEditable = false;
  #editable = false;
  #focusable = false;
  #hidden = false;
  #name;
  #role;
  #ignored;
  #cachedHasFocusableChild;
  #realm;
  constructor(realm, payload) {
    this.payload = payload;
    this.#name = this.payload.name ? this.payload.name.value : "";
    this.#role = this.payload.role ? this.payload.role.value : "Unknown";
    this.#ignored = this.payload.ignored;
    this.#realm = realm;
    for (const property2 of this.payload.properties || []) {
      if (property2.name === "editable") {
        this.#richlyEditable = property2.value.value === "richtext";
        this.#editable = true;
      }
      if (property2.name === "focusable") {
        this.#focusable = property2.value.value;
      }
      if (property2.name === "hidden") {
        this.#hidden = property2.value.value;
      }
    }
  }
  #isPlainTextField() {
    if (this.#richlyEditable) {
      return false;
    }
    if (this.#editable) {
      return true;
    }
    return this.#role === "textbox" || this.#role === "searchbox";
  }
  #isTextOnlyObject() {
    const role = this.#role;
    return role === "LineBreak" || role === "text" || role === "InlineTextBox" || role === "StaticText";
  }
  #hasFocusableChild() {
    if (this.#cachedHasFocusableChild === void 0) {
      this.#cachedHasFocusableChild = false;
      for (const child of this.children) {
        if (child.#focusable || child.#hasFocusableChild()) {
          this.#cachedHasFocusableChild = true;
          break;
        }
      }
    }
    return this.#cachedHasFocusableChild;
  }
  find(predicate) {
    if (predicate(this)) {
      return this;
    }
    for (const child of this.children) {
      const result = child.find(predicate);
      if (result) {
        return result;
      }
    }
    return null;
  }
  isLeafNode() {
    if (!this.children.length) {
      return true;
    }
    if (this.#isPlainTextField() || this.#isTextOnlyObject()) {
      return true;
    }
    switch (this.#role) {
      case "doc-cover":
      case "graphics-symbol":
      case "img":
      case "image":
      case "Meter":
      case "scrollbar":
      case "slider":
      case "separator":
      case "progressbar":
        return true;
      default:
        break;
    }
    if (this.#hasFocusableChild()) {
      return false;
    }
    if (this.#focusable && this.#name) {
      return true;
    }
    if (this.#role === "heading" && this.#name) {
      return true;
    }
    return false;
  }
  isControl() {
    switch (this.#role) {
      case "button":
      case "checkbox":
      case "ColorWell":
      case "combobox":
      case "DisclosureTriangle":
      case "listbox":
      case "menu":
      case "menubar":
      case "menuitem":
      case "menuitemcheckbox":
      case "menuitemradio":
      case "radio":
      case "scrollbar":
      case "searchbox":
      case "slider":
      case "spinbutton":
      case "switch":
      case "tab":
      case "textbox":
      case "tree":
      case "treeitem":
        return true;
      default:
        return false;
    }
  }
  isInteresting(insideControl) {
    const role = this.#role;
    if (role === "Ignored" || this.#hidden || this.#ignored) {
      return false;
    }
    if (this.#focusable || this.#richlyEditable) {
      return true;
    }
    if (this.isControl()) {
      return true;
    }
    if (insideControl) {
      return false;
    }
    return this.isLeafNode() && !!this.#name;
  }
  serialize() {
    const properties = /* @__PURE__ */ new Map();
    for (const property2 of this.payload.properties || []) {
      properties.set(property2.name.toLowerCase(), property2.value.value);
    }
    if (this.payload.name) {
      properties.set("name", this.payload.name.value);
    }
    if (this.payload.value) {
      properties.set("value", this.payload.value.value);
    }
    if (this.payload.description) {
      properties.set("description", this.payload.description.value);
    }
    const node = {
      role: this.#role,
      elementHandle: /* @__PURE__ */ __name(async () => {
        if (!this.payload.backendDOMNodeId) {
          return null;
        }
        return await this.#realm.adoptBackendNode(this.payload.backendDOMNodeId);
      }, "elementHandle")
    };
    const userStringProperties = [
      "name",
      "value",
      "description",
      "keyshortcuts",
      "roledescription",
      "valuetext"
    ];
    const getUserStringPropertyValue = /* @__PURE__ */ __name((key) => {
      return properties.get(key);
    }, "getUserStringPropertyValue");
    for (const userStringProperty of userStringProperties) {
      if (!properties.has(userStringProperty)) {
        continue;
      }
      node[userStringProperty] = getUserStringPropertyValue(userStringProperty);
    }
    const booleanProperties = [
      "disabled",
      "expanded",
      "focused",
      "modal",
      "multiline",
      "multiselectable",
      "readonly",
      "required",
      "selected"
    ];
    const getBooleanPropertyValue = /* @__PURE__ */ __name((key) => {
      return properties.get(key);
    }, "getBooleanPropertyValue");
    for (const booleanProperty of booleanProperties) {
      if (booleanProperty === "focused" && this.#role === "RootWebArea") {
        continue;
      }
      const value3 = getBooleanPropertyValue(booleanProperty);
      if (!value3) {
        continue;
      }
      node[booleanProperty] = getBooleanPropertyValue(booleanProperty);
    }
    const tristateProperties = ["checked", "pressed"];
    for (const tristateProperty of tristateProperties) {
      if (!properties.has(tristateProperty)) {
        continue;
      }
      const value3 = properties.get(tristateProperty);
      node[tristateProperty] = value3 === "mixed" ? "mixed" : value3 === "true" ? true : false;
    }
    const numericalProperties = [
      "level",
      "valuemax",
      "valuemin"
    ];
    const getNumericalPropertyValue = /* @__PURE__ */ __name((key) => {
      return properties.get(key);
    }, "getNumericalPropertyValue");
    for (const numericalProperty of numericalProperties) {
      if (!properties.has(numericalProperty)) {
        continue;
      }
      node[numericalProperty] = getNumericalPropertyValue(numericalProperty);
    }
    const tokenProperties = [
      "autocomplete",
      "haspopup",
      "invalid",
      "orientation"
    ];
    const getTokenPropertyValue = /* @__PURE__ */ __name((key) => {
      return properties.get(key);
    }, "getTokenPropertyValue");
    for (const tokenProperty of tokenProperties) {
      const value3 = getTokenPropertyValue(tokenProperty);
      if (!value3 || value3 === "false") {
        continue;
      }
      node[tokenProperty] = getTokenPropertyValue(tokenProperty);
    }
    return node;
  }
  static createTree(realm, payloads) {
    const nodeById = /* @__PURE__ */ new Map();
    for (const payload of payloads) {
      nodeById.set(payload.nodeId, new _AXNode(realm, payload));
    }
    for (const node of nodeById.values()) {
      for (const childId of node.payload.childIds || []) {
        const child = nodeById.get(childId);
        if (child) {
          node.children.push(child);
        }
      }
    }
    return nodeById.values().next().value;
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/FrameManagerEvents.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FrameManagerEvent;
(function(FrameManagerEvent2) {
  FrameManagerEvent2.FrameAttached = Symbol("FrameManager.FrameAttached");
  FrameManagerEvent2.FrameNavigated = Symbol("FrameManager.FrameNavigated");
  FrameManagerEvent2.FrameDetached = Symbol("FrameManager.FrameDetached");
  FrameManagerEvent2.FrameSwapped = Symbol("FrameManager.FrameSwapped");
  FrameManagerEvent2.LifecycleEvent = Symbol("FrameManager.LifecycleEvent");
  FrameManagerEvent2.FrameNavigatedWithinDocument = Symbol("FrameManager.FrameNavigatedWithinDocument");
  FrameManagerEvent2.ConsoleApiCalled = Symbol("FrameManager.ConsoleApiCalled");
  FrameManagerEvent2.BindingCalled = Symbol("FrameManager.BindingCalled");
})(FrameManagerEvent || (FrameManagerEvent = {}));

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/IsolatedWorld.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/Realm.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/WaitTask.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var WaitTask = class {
  static {
    __name(this, "WaitTask");
  }
  #world;
  #polling;
  #root;
  #fn;
  #args;
  #timeout;
  #timeoutError;
  #result = Deferred.create();
  #poller;
  #signal;
  #reruns = [];
  constructor(world, options, fn2, ...args2) {
    this.#world = world;
    this.#polling = options.polling;
    this.#root = options.root;
    this.#signal = options.signal;
    this.#signal?.addEventListener("abort", () => {
      void this.terminate(this.#signal?.reason);
    }, {
      once: true
    });
    switch (typeof fn2) {
      case "string":
        this.#fn = `() => {return (${fn2});}`;
        break;
      default:
        this.#fn = stringifyFunction(fn2);
        break;
    }
    this.#args = args2;
    this.#world.taskManager.add(this);
    if (options.timeout) {
      this.#timeoutError = new TimeoutError(`Waiting failed: ${options.timeout}ms exceeded`);
      this.#timeout = setTimeout(() => {
        void this.terminate(this.#timeoutError);
      }, options.timeout);
    }
    void this.rerun();
  }
  get result() {
    return this.#result.valueOrThrow();
  }
  async rerun() {
    for (const prev of this.#reruns) {
      prev.abort();
    }
    this.#reruns.length = 0;
    const controller = new AbortController();
    this.#reruns.push(controller);
    try {
      switch (this.#polling) {
        case "raf":
          this.#poller = await this.#world.evaluateHandle(({ RAFPoller, createFunction: createFunction2 }, fn2, ...args2) => {
            const fun = createFunction2(fn2);
            return new RAFPoller(() => {
              return fun(...args2);
            });
          }, LazyArg.create((context10) => {
            return context10.puppeteerUtil;
          }), this.#fn, ...this.#args);
          break;
        case "mutation":
          this.#poller = await this.#world.evaluateHandle(({ MutationPoller, createFunction: createFunction2 }, root, fn2, ...args2) => {
            const fun = createFunction2(fn2);
            return new MutationPoller(() => {
              return fun(...args2);
            }, root || document);
          }, LazyArg.create((context10) => {
            return context10.puppeteerUtil;
          }), this.#root, this.#fn, ...this.#args);
          break;
        default:
          this.#poller = await this.#world.evaluateHandle(({ IntervalPoller, createFunction: createFunction2 }, ms, fn2, ...args2) => {
            const fun = createFunction2(fn2);
            return new IntervalPoller(() => {
              return fun(...args2);
            }, ms);
          }, LazyArg.create((context10) => {
            return context10.puppeteerUtil;
          }), this.#polling, this.#fn, ...this.#args);
          break;
      }
      await this.#poller.evaluate((poller) => {
        void poller.start();
      });
      const result = await this.#poller.evaluateHandle((poller) => {
        return poller.result();
      });
      this.#result.resolve(result);
      await this.terminate();
    } catch (error50) {
      if (controller.signal.aborted) {
        return;
      }
      const badError = this.getBadError(error50);
      if (badError) {
        await this.terminate(badError);
      }
    }
  }
  async terminate(error50) {
    this.#world.taskManager.delete(this);
    clearTimeout(this.#timeout);
    if (error50 && !this.#result.finished()) {
      this.#result.reject(error50);
    }
    if (this.#poller) {
      try {
        await this.#poller.evaluateHandle(async (poller) => {
          await poller.stop();
        });
        if (this.#poller) {
          await this.#poller.dispose();
          this.#poller = void 0;
        }
      } catch {
      }
    }
  }
  /**
   * Not all errors lead to termination. They usually imply we need to rerun the task.
   */
  getBadError(error50) {
    if (isErrorLike(error50)) {
      if (error50.message.includes("Execution context is not available in detached frame")) {
        return new Error("Waiting failed: Frame detached");
      }
      if (error50.message.includes("Execution context was destroyed")) {
        return;
      }
      if (error50.message.includes("Cannot find context with specified id")) {
        return;
      }
      if (error50.message.includes("AbortError: Actor 'MessageHandlerFrame' destroyed")) {
        return;
      }
      return error50;
    }
    return new Error("WaitTask failed with an error", {
      cause: error50
    });
  }
};
var TaskManager = class {
  static {
    __name(this, "TaskManager");
  }
  #tasks = /* @__PURE__ */ new Set();
  add(task) {
    this.#tasks.add(task);
  }
  delete(task) {
    this.#tasks.delete(task);
  }
  terminateAll(error50) {
    for (const task of this.#tasks) {
      void task.terminate(error50);
    }
    this.#tasks.clear();
  }
  async rerunAll() {
    await Promise.all([...this.#tasks].map((task) => {
      return task.rerun();
    }));
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/Realm.js
var Realm = class {
  static {
    __name(this, "Realm");
  }
  timeoutSettings;
  taskManager = new TaskManager();
  constructor(timeoutSettings) {
    this.timeoutSettings = timeoutSettings;
  }
  async waitForFunction(pageFunction, options = {}, ...args2) {
    const { polling = "raf", timeout: timeout6 = this.timeoutSettings.timeout(), root, signal } = options;
    if (typeof polling === "number" && polling < 0) {
      throw new Error("Cannot poll with non-positive interval");
    }
    const waitTask = new WaitTask(this, {
      polling,
      root,
      timeout: timeout6,
      signal
    }, pageFunction, ...args2);
    return await waitTask.result;
  }
  get disposed() {
    return this.#disposed;
  }
  #disposed = false;
  /** @internal */
  dispose() {
    this.#disposed = true;
    this.taskManager.terminateAll(new Error("waitForFunction failed: frame got detached."));
  }
  /** @internal */
  [disposeSymbol]() {
    this.dispose();
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/IsolatedWorld.js
var IsolatedWorld = class extends Realm {
  static {
    __name(this, "IsolatedWorld");
  }
  #context;
  #emitter = new EventEmitter2();
  #frameOrWorker;
  constructor(frameOrWorker, timeoutSettings) {
    super(timeoutSettings);
    this.#frameOrWorker = frameOrWorker;
  }
  get environment() {
    return this.#frameOrWorker;
  }
  get client() {
    return this.#frameOrWorker.client;
  }
  get emitter() {
    return this.#emitter;
  }
  setContext(context10) {
    this.#context?.[disposeSymbol]();
    context10.once("disposed", this.#onContextDisposed.bind(this));
    context10.on("consoleapicalled", this.#onContextConsoleApiCalled.bind(this));
    context10.on("bindingcalled", this.#onContextBindingCalled.bind(this));
    this.#context = context10;
    this.#emitter.emit("context", context10);
    void this.taskManager.rerunAll();
  }
  #onContextDisposed() {
    this.#context = void 0;
    if ("clearDocumentHandle" in this.#frameOrWorker) {
      this.#frameOrWorker.clearDocumentHandle();
    }
  }
  #onContextConsoleApiCalled(event) {
    this.#emitter.emit("consoleapicalled", event);
  }
  #onContextBindingCalled(event) {
    this.#emitter.emit("bindingcalled", event);
  }
  hasContext() {
    return !!this.#context;
  }
  get context() {
    return this.#context;
  }
  #executionContext() {
    if (this.disposed) {
      throw new Error(`Execution context is not available in detached frame or worker "${this.environment.url()}" (are you trying to evaluate?)`);
    }
    return this.#context;
  }
  /**
   * Waits for the next context to be set on the isolated world.
   */
  async #waitForExecutionContext() {
    const result = await firstValueFrom(fromEmitterEvent(this.#emitter, "context").pipe(raceWith4(fromEmitterEvent(this.#emitter, "disposed").pipe(map30(() => {
      throw new Error("Execution context was destroyed");
    })), timeout5(this.timeoutSettings.timeout()))));
    return result;
  }
  async evaluateHandle(pageFunction, ...args2) {
    pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
    let context10 = this.#executionContext();
    if (!context10) {
      context10 = await this.#waitForExecutionContext();
    }
    return await context10.evaluateHandle(pageFunction, ...args2);
  }
  async evaluate(pageFunction, ...args2) {
    pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
    let context10 = this.#executionContext();
    if (!context10) {
      context10 = await this.#waitForExecutionContext();
    }
    return await context10.evaluate(pageFunction, ...args2);
  }
  async adoptBackendNode(backendNodeId) {
    let context10 = this.#executionContext();
    if (!context10) {
      context10 = await this.#waitForExecutionContext();
    }
    const { object: object4 } = await this.client.send("DOM.resolveNode", {
      backendNodeId,
      executionContextId: context10.id
    });
    return this.createCdpHandle(object4);
  }
  async adoptHandle(handle) {
    if (handle.realm === this) {
      return await handle.evaluateHandle((value3) => {
        return value3;
      });
    }
    const nodeInfo = await this.client.send("DOM.describeNode", {
      objectId: handle.id
    });
    return await this.adoptBackendNode(nodeInfo.node.backendNodeId);
  }
  async transferHandle(handle) {
    if (handle.realm === this) {
      return handle;
    }
    if (handle.remoteObject().objectId === void 0) {
      return handle;
    }
    const info3 = await this.client.send("DOM.describeNode", {
      objectId: handle.remoteObject().objectId
    });
    const newHandle = await this.adoptBackendNode(info3.node.backendNodeId);
    await handle.dispose();
    return newHandle;
  }
  /**
   * @internal
   */
  createCdpHandle(remoteObject) {
    if (remoteObject.subtype === "node") {
      return new CdpElementHandle(this, remoteObject);
    }
    return new CdpJSHandle(this, remoteObject);
  }
  [disposeSymbol]() {
    this.#context?.[disposeSymbol]();
    this.#emitter.emit("disposed", void 0);
    super[disposeSymbol]();
    this.#emitter.removeAllListeners();
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/IsolatedWorlds.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MAIN_WORLD = Symbol("mainWorld");
var PUPPETEER_WORLD = Symbol("puppeteerWorld");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/LifecycleWatcher.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var puppeteerToProtocolLifecycle = /* @__PURE__ */ new Map([
  ["load", "load"],
  ["domcontentloaded", "DOMContentLoaded"],
  ["networkidle0", "networkIdle"],
  ["networkidle2", "networkAlmostIdle"]
]);
var LifecycleWatcher = class {
  static {
    __name(this, "LifecycleWatcher");
  }
  #expectedLifecycle;
  #frame;
  #timeout;
  #navigationRequest = null;
  #subscriptions = new DisposableStack();
  #initialLoaderId;
  #terminationDeferred;
  #sameDocumentNavigationDeferred = Deferred.create();
  #lifecycleDeferred = Deferred.create();
  #newDocumentNavigationDeferred = Deferred.create();
  #hasSameDocumentNavigation;
  #swapped;
  #navigationResponseReceived;
  constructor(networkManager, frame, waitUntil, timeout6) {
    if (Array.isArray(waitUntil)) {
      waitUntil = waitUntil.slice();
    } else if (typeof waitUntil === "string") {
      waitUntil = [waitUntil];
    }
    this.#initialLoaderId = frame._loaderId;
    this.#expectedLifecycle = waitUntil.map((value3) => {
      const protocolEvent = puppeteerToProtocolLifecycle.get(value3);
      assert5(protocolEvent, "Unknown value for options.waitUntil: " + value3);
      return protocolEvent;
    });
    this.#frame = frame;
    this.#timeout = timeout6;
    const frameManagerEmitter = this.#subscriptions.use(new EventEmitter2(frame._frameManager));
    frameManagerEmitter.on(FrameManagerEvent.LifecycleEvent, this.#checkLifecycleComplete.bind(this));
    const frameEmitter = this.#subscriptions.use(new EventEmitter2(frame));
    frameEmitter.on(FrameEvent.FrameNavigatedWithinDocument, this.#navigatedWithinDocument.bind(this));
    frameEmitter.on(FrameEvent.FrameNavigated, this.#navigated.bind(this));
    frameEmitter.on(FrameEvent.FrameSwapped, this.#frameSwapped.bind(this));
    frameEmitter.on(FrameEvent.FrameSwappedByActivation, this.#frameSwapped.bind(this));
    frameEmitter.on(FrameEvent.FrameDetached, this.#onFrameDetached.bind(this));
    const networkManagerEmitter = this.#subscriptions.use(new EventEmitter2(networkManager));
    networkManagerEmitter.on(NetworkManagerEvent.Request, this.#onRequest.bind(this));
    networkManagerEmitter.on(NetworkManagerEvent.Response, this.#onResponse.bind(this));
    networkManagerEmitter.on(NetworkManagerEvent.RequestFailed, this.#onRequestFailed.bind(this));
    this.#terminationDeferred = Deferred.create({
      timeout: this.#timeout,
      message: `Navigation timeout of ${this.#timeout} ms exceeded`
    });
    this.#checkLifecycleComplete();
  }
  #onRequest(request2) {
    if (request2.frame() !== this.#frame || !request2.isNavigationRequest()) {
      return;
    }
    this.#navigationRequest = request2;
    this.#navigationResponseReceived?.resolve();
    this.#navigationResponseReceived = Deferred.create();
    if (request2.response() !== null) {
      this.#navigationResponseReceived?.resolve();
    }
  }
  #onRequestFailed(request2) {
    if (this.#navigationRequest?.id !== request2.id) {
      return;
    }
    this.#navigationResponseReceived?.resolve();
  }
  #onResponse(response) {
    if (this.#navigationRequest?.id !== response.request().id) {
      return;
    }
    this.#navigationResponseReceived?.resolve();
  }
  #onFrameDetached(frame) {
    if (this.#frame === frame) {
      this.#terminationDeferred.resolve(new Error("Navigating frame was detached"));
      return;
    }
    this.#checkLifecycleComplete();
  }
  async navigationResponse() {
    await this.#navigationResponseReceived?.valueOrThrow();
    return this.#navigationRequest ? this.#navigationRequest.response() : null;
  }
  sameDocumentNavigationPromise() {
    return this.#sameDocumentNavigationDeferred.valueOrThrow();
  }
  newDocumentNavigationPromise() {
    return this.#newDocumentNavigationDeferred.valueOrThrow();
  }
  lifecyclePromise() {
    return this.#lifecycleDeferred.valueOrThrow();
  }
  terminationPromise() {
    return this.#terminationDeferred.valueOrThrow();
  }
  #navigatedWithinDocument() {
    this.#hasSameDocumentNavigation = true;
    this.#checkLifecycleComplete();
  }
  #navigated(navigationType) {
    if (navigationType === "BackForwardCacheRestore") {
      return this.#frameSwapped();
    }
    this.#checkLifecycleComplete();
  }
  #frameSwapped() {
    this.#swapped = true;
    this.#checkLifecycleComplete();
  }
  #checkLifecycleComplete() {
    if (!checkLifecycle(this.#frame, this.#expectedLifecycle)) {
      return;
    }
    this.#lifecycleDeferred.resolve();
    if (this.#hasSameDocumentNavigation) {
      this.#sameDocumentNavigationDeferred.resolve(void 0);
    }
    if (this.#swapped || this.#frame._loaderId !== this.#initialLoaderId) {
      this.#newDocumentNavigationDeferred.resolve(void 0);
    }
    function checkLifecycle(frame, expectedLifecycle) {
      for (const event of expectedLifecycle) {
        if (!frame._lifecycleEvents.has(event)) {
          return false;
        }
      }
      for (const child of frame.childFrames()) {
        if (child._hasStartedLoading && !checkLifecycle(child, expectedLifecycle)) {
          return false;
        }
      }
      return true;
    }
    __name(checkLifecycle, "checkLifecycle");
  }
  dispose() {
    this.#subscriptions.dispose();
    this.#terminationDeferred.resolve(new Error("LifecycleWatcher disposed"));
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Frame.js
var __runInitializers7 = function(thisArg, initializers, value3) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value3 = useValue ? initializers[i].call(thisArg, value3) : initializers[i].call(thisArg);
  }
  return useValue ? value3 : void 0;
};
var __esDecorate7 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor3 = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done13 = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context10 = {};
    for (var p in contextIn) context10[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context10.access[p] = contextIn.access[p];
    context10.addInitializer = function(f) {
      if (done13) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor3.get, set: descriptor3.set } : descriptor3[key], context10);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor3.get = _;
      if (_ = accept(result.set)) descriptor3.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor3[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor3);
  done13 = true;
};
var CdpFrame = (() => {
  let _classSuper = Frame;
  let _instanceExtraInitializers = [];
  let _goto_decorators;
  let _waitForNavigation_decorators;
  let _setContent_decorators;
  let _addPreloadScript_decorators;
  let _addExposedFunctionBinding_decorators;
  let _removeExposedFunctionBinding_decorators;
  let _waitForDevicePrompt_decorators;
  return class CdpFrame extends _classSuper {
    static {
      __name(this, "CdpFrame");
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
      __esDecorate7(this, null, _goto_decorators, { kind: "method", name: "goto", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "goto" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.goto, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate7(this, null, _waitForNavigation_decorators, { kind: "method", name: "waitForNavigation", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "waitForNavigation" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.waitForNavigation, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate7(this, null, _setContent_decorators, { kind: "method", name: "setContent", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "setContent" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.setContent, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate7(this, null, _addPreloadScript_decorators, { kind: "method", name: "addPreloadScript", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "addPreloadScript" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.addPreloadScript, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate7(this, null, _addExposedFunctionBinding_decorators, { kind: "method", name: "addExposedFunctionBinding", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "addExposedFunctionBinding" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.addExposedFunctionBinding, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate7(this, null, _removeExposedFunctionBinding_decorators, { kind: "method", name: "removeExposedFunctionBinding", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "removeExposedFunctionBinding" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.removeExposedFunctionBinding, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      __esDecorate7(this, null, _waitForDevicePrompt_decorators, { kind: "method", name: "waitForDevicePrompt", static: false, private: false, access: { has: /* @__PURE__ */ __name((obj) => "waitForDevicePrompt" in obj, "has"), get: /* @__PURE__ */ __name((obj) => obj.waitForDevicePrompt, "get") }, metadata: _metadata }, null, _instanceExtraInitializers);
      if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    }
    #url = (__runInitializers7(this, _instanceExtraInitializers), "");
    #detached = false;
    #client;
    _frameManager;
    _loaderId = "";
    _lifecycleEvents = /* @__PURE__ */ new Set();
    _id;
    _parentId;
    accessibility;
    worlds;
    constructor(frameManager, frameId, parentFrameId, client) {
      super();
      this._frameManager = frameManager;
      this.#url = "";
      this._id = frameId;
      this._parentId = parentFrameId;
      this.#detached = false;
      this.#client = client;
      this._loaderId = "";
      this.worlds = {
        [MAIN_WORLD]: new IsolatedWorld(this, this._frameManager.timeoutSettings),
        [PUPPETEER_WORLD]: new IsolatedWorld(this, this._frameManager.timeoutSettings)
      };
      this.accessibility = new Accessibility(this.worlds[MAIN_WORLD]);
      this.on(FrameEvent.FrameSwappedByActivation, () => {
        this._onLoadingStarted();
        this._onLoadingStopped();
      });
      this.worlds[MAIN_WORLD].emitter.on("consoleapicalled", this.#onMainWorldConsoleApiCalled.bind(this));
      this.worlds[MAIN_WORLD].emitter.on("bindingcalled", this.#onMainWorldBindingCalled.bind(this));
    }
    #onMainWorldConsoleApiCalled(event) {
      this._frameManager.emit(FrameManagerEvent.ConsoleApiCalled, [
        this.worlds[MAIN_WORLD],
        event
      ]);
    }
    #onMainWorldBindingCalled(event) {
      this._frameManager.emit(FrameManagerEvent.BindingCalled, [
        this.worlds[MAIN_WORLD],
        event
      ]);
    }
    /**
     * This is used internally in DevTools.
     *
     * @internal
     */
    _client() {
      return this.#client;
    }
    /**
     * Updates the frame ID with the new ID. This happens when the main frame is
     * replaced by a different frame.
     */
    updateId(id2) {
      this._id = id2;
    }
    updateClient(client) {
      this.#client = client;
    }
    page() {
      return this._frameManager.page();
    }
    isOOPFrame() {
      return this.#client !== this._frameManager.client;
    }
    async goto(url3, options = {}) {
      const { referer = this._frameManager.networkManager.extraHTTPHeaders()["referer"], referrerPolicy = this._frameManager.networkManager.extraHTTPHeaders()["referer-policy"], waitUntil = ["load"], timeout: timeout6 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
      let ensureNewDocumentNavigation = false;
      const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout6);
      let error50 = await Deferred.race([
        navigate(this.#client, url3, referer, referrerPolicy, this._id),
        watcher.terminationPromise()
      ]);
      if (!error50) {
        error50 = await Deferred.race([
          watcher.terminationPromise(),
          ensureNewDocumentNavigation ? watcher.newDocumentNavigationPromise() : watcher.sameDocumentNavigationPromise()
        ]);
      }
      try {
        if (error50) {
          throw error50;
        }
        return await watcher.navigationResponse();
      } finally {
        watcher.dispose();
      }
      async function navigate(client, url4, referrer, referrerPolicy2, frameId) {
        try {
          const response = await client.send("Page.navigate", {
            url: url4,
            referrer,
            frameId,
            referrerPolicy: referrerPolicy2
          });
          ensureNewDocumentNavigation = !!response.loaderId;
          if (response.errorText === "net::ERR_HTTP_RESPONSE_CODE_FAILURE") {
            return null;
          }
          return response.errorText ? new Error(`${response.errorText} at ${url4}`) : null;
        } catch (error51) {
          if (isErrorLike(error51)) {
            return error51;
          }
          throw error51;
        }
      }
      __name(navigate, "navigate");
    }
    async waitForNavigation(options = {}) {
      const { waitUntil = ["load"], timeout: timeout6 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
      const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout6);
      const error50 = await Deferred.race([
        watcher.terminationPromise(),
        ...options.ignoreSameDocumentNavigation ? [] : [watcher.sameDocumentNavigationPromise()],
        watcher.newDocumentNavigationPromise()
      ]);
      try {
        if (error50) {
          throw error50;
        }
        const result = await Deferred.race([watcher.terminationPromise(), watcher.navigationResponse()]);
        if (result instanceof Error) {
          throw error50;
        }
        return result || null;
      } finally {
        watcher.dispose();
      }
    }
    get client() {
      return this.#client;
    }
    mainRealm() {
      return this.worlds[MAIN_WORLD];
    }
    isolatedRealm() {
      return this.worlds[PUPPETEER_WORLD];
    }
    async setContent(html, options = {}) {
      const { waitUntil = ["load"], timeout: timeout6 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
      await this.setFrameContent(html);
      const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout6);
      const error50 = await Deferred.race([
        watcher.terminationPromise(),
        watcher.lifecyclePromise()
      ]);
      watcher.dispose();
      if (error50) {
        throw error50;
      }
    }
    url() {
      return this.#url;
    }
    parentFrame() {
      return this._frameManager._frameTree.parentFrame(this._id) || null;
    }
    childFrames() {
      return this._frameManager._frameTree.childFrames(this._id);
    }
    #deviceRequestPromptManager() {
      const rootFrame = this.page().mainFrame();
      if (this.isOOPFrame() || rootFrame === null) {
        return this._frameManager._deviceRequestPromptManager(this.#client);
      } else {
        return rootFrame._frameManager._deviceRequestPromptManager(this.#client);
      }
    }
    async addPreloadScript(preloadScript) {
      if (!this.isOOPFrame() && this !== this._frameManager.mainFrame()) {
        return;
      }
      if (preloadScript.getIdForFrame(this)) {
        return;
      }
      const { identifier: identifier2 } = await this.#client.send("Page.addScriptToEvaluateOnNewDocument", {
        source: preloadScript.source
      });
      preloadScript.setIdForFrame(this, identifier2);
    }
    async addExposedFunctionBinding(binding2) {
      if (this !== this._frameManager.mainFrame() && !this._hasStartedLoading) {
        return;
      }
      await Promise.all([
        this.#client.send("Runtime.addBinding", {
          name: CDP_BINDING_PREFIX + binding2.name
        }),
        this.evaluate(binding2.initSource).catch(debugError)
      ]);
    }
    async removeExposedFunctionBinding(binding2) {
      if (this !== this._frameManager.mainFrame() && !this._hasStartedLoading) {
        return;
      }
      await Promise.all([
        this.#client.send("Runtime.removeBinding", {
          name: CDP_BINDING_PREFIX + binding2.name
        }),
        this.evaluate((name) => {
          globalThis[name] = void 0;
        }, binding2.name).catch(debugError)
      ]);
    }
    async waitForDevicePrompt(options = {}) {
      return await this.#deviceRequestPromptManager().waitForDevicePrompt(options);
    }
    _navigated(framePayload) {
      this._name = framePayload.name;
      this.#url = `${framePayload.url}${framePayload.urlFragment || ""}`;
    }
    _navigatedWithinDocument(url3) {
      this.#url = url3;
    }
    _onLifecycleEvent(loaderId, name) {
      if (name === "init") {
        this._loaderId = loaderId;
        this._lifecycleEvents.clear();
      }
      this._lifecycleEvents.add(name);
    }
    _onLoadingStopped() {
      this._lifecycleEvents.add("DOMContentLoaded");
      this._lifecycleEvents.add("load");
    }
    _onLoadingStarted() {
      this._hasStartedLoading = true;
    }
    get detached() {
      return this.#detached;
    }
    [(_goto_decorators = [throwIfDetached], _waitForNavigation_decorators = [throwIfDetached], _setContent_decorators = [throwIfDetached], _addPreloadScript_decorators = [throwIfDetached], _addExposedFunctionBinding_decorators = [throwIfDetached], _removeExposedFunctionBinding_decorators = [throwIfDetached], _waitForDevicePrompt_decorators = [throwIfDetached], disposeSymbol)]() {
      if (this.#detached) {
        return;
      }
      this.#detached = true;
      this.worlds[MAIN_WORLD][disposeSymbol]();
      this.worlds[PUPPETEER_WORLD][disposeSymbol]();
    }
    exposeFunction() {
      throw new UnsupportedOperation();
    }
  };
})();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/FrameTree.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FrameTree = class {
  static {
    __name(this, "FrameTree");
  }
  #frames = /* @__PURE__ */ new Map();
  // frameID -> parentFrameID
  #parentIds = /* @__PURE__ */ new Map();
  // frameID -> childFrameIDs
  #childIds = /* @__PURE__ */ new Map();
  #mainFrame;
  #isMainFrameStale = false;
  #waitRequests = /* @__PURE__ */ new Map();
  getMainFrame() {
    return this.#mainFrame;
  }
  getById(frameId) {
    return this.#frames.get(frameId);
  }
  /**
   * Returns a promise that is resolved once the frame with
   * the given ID is added to the tree.
   */
  waitForFrame(frameId) {
    const frame = this.getById(frameId);
    if (frame) {
      return Promise.resolve(frame);
    }
    const deferred = Deferred.create();
    const callbacks = this.#waitRequests.get(frameId) || /* @__PURE__ */ new Set();
    callbacks.add(deferred);
    return deferred.valueOrThrow();
  }
  frames() {
    return Array.from(this.#frames.values());
  }
  addFrame(frame) {
    this.#frames.set(frame._id, frame);
    if (frame._parentId) {
      this.#parentIds.set(frame._id, frame._parentId);
      if (!this.#childIds.has(frame._parentId)) {
        this.#childIds.set(frame._parentId, /* @__PURE__ */ new Set());
      }
      this.#childIds.get(frame._parentId).add(frame._id);
    } else if (!this.#mainFrame || this.#isMainFrameStale) {
      this.#mainFrame = frame;
      this.#isMainFrameStale = false;
    }
    this.#waitRequests.get(frame._id)?.forEach((request2) => {
      return request2.resolve(frame);
    });
  }
  removeFrame(frame) {
    this.#frames.delete(frame._id);
    this.#parentIds.delete(frame._id);
    if (frame._parentId) {
      this.#childIds.get(frame._parentId)?.delete(frame._id);
    } else {
      this.#isMainFrameStale = true;
    }
  }
  childFrames(frameId) {
    const childIds = this.#childIds.get(frameId);
    if (!childIds) {
      return [];
    }
    return Array.from(childIds).map((id2) => {
      return this.getById(id2);
    }).filter((frame) => {
      return frame !== void 0;
    });
  }
  parentFrame(frameId) {
    const parentId = this.#parentIds.get(frameId);
    return parentId ? this.getById(parentId) : void 0;
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/NetworkManager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/HTTPRequest.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/HTTPRequest.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var HTTPRequest = class {
  static {
    __name(this, "HTTPRequest");
  }
  /**
   * @internal
   */
  _interceptionId;
  /**
   * @internal
   */
  _failureText = null;
  /**
   * @internal
   */
  _response = null;
  /**
   * @internal
   */
  _fromMemoryCache = false;
  /**
   * @internal
   */
  _redirectChain = [];
  /**
   * @internal
   */
  interception = {
    enabled: false,
    handled: false,
    handlers: [],
    resolutionState: {
      action: InterceptResolutionAction.None
    },
    requestOverrides: {},
    response: null,
    abortReason: null
  };
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * The `ContinueRequestOverrides` that will be used
   * if the interception is allowed to continue (ie, `abort()` and
   * `respond()` aren't called).
   */
  continueRequestOverrides() {
    assert5(this.interception.enabled, "Request Interception is not enabled!");
    return this.interception.requestOverrides;
  }
  /**
   * The `ResponseForRequest` that gets used if the
   * interception is allowed to respond (ie, `abort()` is not called).
   */
  responseForRequest() {
    assert5(this.interception.enabled, "Request Interception is not enabled!");
    return this.interception.response;
  }
  /**
   * The most recent reason for aborting the request
   */
  abortErrorReason() {
    assert5(this.interception.enabled, "Request Interception is not enabled!");
    return this.interception.abortReason;
  }
  /**
   * An InterceptResolutionState object describing the current resolution
   * action and priority.
   *
   * InterceptResolutionState contains:
   * action: InterceptResolutionAction
   * priority?: number
   *
   * InterceptResolutionAction is one of: `abort`, `respond`, `continue`,
   * `disabled`, `none`, or `already-handled`.
   */
  interceptResolutionState() {
    if (!this.interception.enabled) {
      return { action: InterceptResolutionAction.Disabled };
    }
    if (this.interception.handled) {
      return { action: InterceptResolutionAction.AlreadyHandled };
    }
    return { ...this.interception.resolutionState };
  }
  /**
   * Is `true` if the intercept resolution has already been handled,
   * `false` otherwise.
   */
  isInterceptResolutionHandled() {
    return this.interception.handled;
  }
  /**
   * Adds an async request handler to the processing queue.
   * Deferred handlers are not guaranteed to execute in any particular order,
   * but they are guaranteed to resolve before the request interception
   * is finalized.
   */
  enqueueInterceptAction(pendingHandler) {
    this.interception.handlers.push(pendingHandler);
  }
  /**
   * Awaits pending interception handlers and then decides how to fulfill
   * the request interception.
   */
  async finalizeInterceptions() {
    await this.interception.handlers.reduce((promiseChain, interceptAction) => {
      return promiseChain.then(interceptAction);
    }, Promise.resolve());
    this.interception.handlers = [];
    const { action } = this.interceptResolutionState();
    switch (action) {
      case "abort":
        return await this._abort(this.interception.abortReason);
      case "respond":
        if (this.interception.response === null) {
          throw new Error("Response is missing for the interception");
        }
        return await this._respond(this.interception.response);
      case "continue":
        return await this._continue(this.interception.requestOverrides);
    }
  }
  /**
   * Continues request with optional request overrides.
   *
   * @example
   *
   * ```ts
   * await page.setRequestInterception(true);
   * page.on('request', request => {
   *   // Override headers
   *   const headers = Object.assign({}, request.headers(), {
   *     foo: 'bar', // set "foo" header
   *     origin: undefined, // remove "origin" header
   *   });
   *   request.continue({headers});
   * });
   * ```
   *
   * @param overrides - optional overrides to apply to the request.
   * @param priority - If provided, intercept is resolved using cooperative
   * handling rules. Otherwise, intercept is resolved immediately.
   *
   * @remarks
   *
   * To use this, request interception should be enabled with
   * {@link Page.setRequestInterception}.
   *
   * Exception is immediately thrown if the request interception is not enabled.
   */
  async continue(overrides = {}, priority) {
    if (this.url().startsWith("data:")) {
      return;
    }
    assert5(this.interception.enabled, "Request Interception is not enabled!");
    assert5(!this.interception.handled, "Request is already handled!");
    if (priority === void 0) {
      return await this._continue(overrides);
    }
    this.interception.requestOverrides = overrides;
    if (this.interception.resolutionState.priority === void 0 || priority > this.interception.resolutionState.priority) {
      this.interception.resolutionState = {
        action: InterceptResolutionAction.Continue,
        priority
      };
      return;
    }
    if (priority === this.interception.resolutionState.priority) {
      if (this.interception.resolutionState.action === "abort" || this.interception.resolutionState.action === "respond") {
        return;
      }
      this.interception.resolutionState.action = InterceptResolutionAction.Continue;
    }
    return;
  }
  /**
   * Fulfills a request with the given response.
   *
   * @example
   * An example of fulfilling all requests with 404 responses:
   *
   * ```ts
   * await page.setRequestInterception(true);
   * page.on('request', request => {
   *   request.respond({
   *     status: 404,
   *     contentType: 'text/plain',
   *     body: 'Not Found!',
   *   });
   * });
   * ```
   *
   * NOTE: Mocking responses for dataURL requests is not supported.
   * Calling `request.respond` for a dataURL request is a noop.
   *
   * @param response - the response to fulfill the request with.
   * @param priority - If provided, intercept is resolved using
   * cooperative handling rules. Otherwise, intercept is resolved
   * immediately.
   *
   * @remarks
   *
   * To use this, request
   * interception should be enabled with {@link Page.setRequestInterception}.
   *
   * Exception is immediately thrown if the request interception is not enabled.
   */
  async respond(response, priority) {
    if (this.url().startsWith("data:")) {
      return;
    }
    assert5(this.interception.enabled, "Request Interception is not enabled!");
    assert5(!this.interception.handled, "Request is already handled!");
    if (priority === void 0) {
      return await this._respond(response);
    }
    this.interception.response = response;
    if (this.interception.resolutionState.priority === void 0 || priority > this.interception.resolutionState.priority) {
      this.interception.resolutionState = {
        action: InterceptResolutionAction.Respond,
        priority
      };
      return;
    }
    if (priority === this.interception.resolutionState.priority) {
      if (this.interception.resolutionState.action === "abort") {
        return;
      }
      this.interception.resolutionState.action = InterceptResolutionAction.Respond;
    }
  }
  /**
   * Aborts a request.
   *
   * @param errorCode - optional error code to provide.
   * @param priority - If provided, intercept is resolved using
   * cooperative handling rules. Otherwise, intercept is resolved
   * immediately.
   *
   * @remarks
   *
   * To use this, request interception should be enabled with
   * {@link Page.setRequestInterception}. If it is not enabled, this method will
   * throw an exception immediately.
   */
  async abort(errorCode = "failed", priority) {
    if (this.url().startsWith("data:")) {
      return;
    }
    const errorReason = errorReasons[errorCode];
    assert5(errorReason, "Unknown error code: " + errorCode);
    assert5(this.interception.enabled, "Request Interception is not enabled!");
    assert5(!this.interception.handled, "Request is already handled!");
    if (priority === void 0) {
      return await this._abort(errorReason);
    }
    this.interception.abortReason = errorReason;
    if (this.interception.resolutionState.priority === void 0 || priority >= this.interception.resolutionState.priority) {
      this.interception.resolutionState = {
        action: InterceptResolutionAction.Abort,
        priority
      };
      return;
    }
  }
  /**
   * @internal
   */
  static getResponse(body) {
    const byteBody = isString2(body) ? new TextEncoder().encode(body) : body;
    const bytes = [];
    for (const byte of byteBody) {
      bytes.push(String.fromCharCode(byte));
    }
    return {
      contentLength: byteBody.byteLength,
      base64: btoa(bytes.join(""))
    };
  }
};
var InterceptResolutionAction;
(function(InterceptResolutionAction2) {
  InterceptResolutionAction2["Abort"] = "abort";
  InterceptResolutionAction2["Respond"] = "respond";
  InterceptResolutionAction2["Continue"] = "continue";
  InterceptResolutionAction2["Disabled"] = "disabled";
  InterceptResolutionAction2["None"] = "none";
  InterceptResolutionAction2["AlreadyHandled"] = "already-handled";
})(InterceptResolutionAction || (InterceptResolutionAction = {}));
function headersArray(headers) {
  const result = [];
  for (const name in headers) {
    const value3 = headers[name];
    if (!Object.is(value3, void 0)) {
      const values4 = Array.isArray(value3) ? value3 : [value3];
      result.push(...values4.map((value4) => {
        return { name, value: value4 + "" };
      }));
    }
  }
  return result;
}
__name(headersArray, "headersArray");
var STATUS_TEXTS = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "306": "Switch Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
var errorReasons = {
  aborted: "Aborted",
  accessdenied: "AccessDenied",
  addressunreachable: "AddressUnreachable",
  blockedbyclient: "BlockedByClient",
  blockedbyresponse: "BlockedByResponse",
  connectionaborted: "ConnectionAborted",
  connectionclosed: "ConnectionClosed",
  connectionfailed: "ConnectionFailed",
  connectionrefused: "ConnectionRefused",
  connectionreset: "ConnectionReset",
  internetdisconnected: "InternetDisconnected",
  namenotresolved: "NameNotResolved",
  timedout: "TimedOut",
  failed: "Failed"
};
function handleError(error50) {
  if (error50.originalMessage.includes("Invalid header") || error50.originalMessage.includes('Expected "header"') || // WebDriver BiDi error for invalid values, for example, headers.
  error50.originalMessage.includes("invalid argument")) {
    throw error50;
  }
  debugError(error50);
}
__name(handleError, "handleError");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/HTTPRequest.js
var CdpHTTPRequest = class extends HTTPRequest {
  static {
    __name(this, "CdpHTTPRequest");
  }
  id;
  #client;
  #isNavigationRequest;
  #url;
  #resourceType;
  #method;
  #hasPostData = false;
  #postData;
  #headers = {};
  #frame;
  #initiator;
  get client() {
    return this.#client;
  }
  constructor(client, frame, interceptionId, allowInterception, data, redirectChain) {
    super();
    this.#client = client;
    this.id = data.requestId;
    this.#isNavigationRequest = data.requestId === data.loaderId && data.type === "Document";
    this._interceptionId = interceptionId;
    this.#url = data.request.url;
    this.#resourceType = (data.type || "other").toLowerCase();
    this.#method = data.request.method;
    this.#postData = data.request.postData;
    this.#hasPostData = data.request.hasPostData ?? false;
    this.#frame = frame;
    this._redirectChain = redirectChain;
    this.#initiator = data.initiator;
    this.interception.enabled = allowInterception;
    for (const [key, value3] of Object.entries(data.request.headers)) {
      this.#headers[key.toLowerCase()] = value3;
    }
  }
  url() {
    return this.#url;
  }
  resourceType() {
    return this.#resourceType;
  }
  method() {
    return this.#method;
  }
  postData() {
    return this.#postData;
  }
  hasPostData() {
    return this.#hasPostData;
  }
  async fetchPostData() {
    try {
      const result = await this.#client.send("Network.getRequestPostData", {
        requestId: this.id
      });
      return result.postData;
    } catch (err) {
      debugError(err);
      return;
    }
  }
  headers() {
    return this.#headers;
  }
  response() {
    return this._response;
  }
  frame() {
    return this.#frame;
  }
  isNavigationRequest() {
    return this.#isNavigationRequest;
  }
  initiator() {
    return this.#initiator;
  }
  redirectChain() {
    return this._redirectChain.slice();
  }
  failure() {
    if (!this._failureText) {
      return null;
    }
    return {
      errorText: this._failureText
    };
  }
  /**
   * @internal
   */
  async _continue(overrides = {}) {
    const { url: url3, method, postData, headers } = overrides;
    this.interception.handled = true;
    const postDataBinaryBase64 = postData ? btoa(postData) : void 0;
    if (this._interceptionId === void 0) {
      throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.continueRequest");
    }
    await this.#client.send("Fetch.continueRequest", {
      requestId: this._interceptionId,
      url: url3,
      method,
      postData: postDataBinaryBase64,
      headers: headers ? headersArray(headers) : void 0
    }).catch((error50) => {
      this.interception.handled = false;
      return handleError(error50);
    });
  }
  async _respond(response) {
    this.interception.handled = true;
    let parsedBody;
    if (response.body) {
      parsedBody = HTTPRequest.getResponse(response.body);
    }
    const responseHeaders = {};
    if (response.headers) {
      for (const header of Object.keys(response.headers)) {
        const value3 = response.headers[header];
        responseHeaders[header.toLowerCase()] = Array.isArray(value3) ? value3.map((item) => {
          return String(item);
        }) : String(value3);
      }
    }
    if (response.contentType) {
      responseHeaders["content-type"] = response.contentType;
    }
    if (parsedBody?.contentLength && !("content-length" in responseHeaders)) {
      responseHeaders["content-length"] = String(parsedBody.contentLength);
    }
    const status2 = response.status || 200;
    if (this._interceptionId === void 0) {
      throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest");
    }
    await this.#client.send("Fetch.fulfillRequest", {
      requestId: this._interceptionId,
      responseCode: status2,
      responsePhrase: STATUS_TEXTS[status2],
      responseHeaders: headersArray(responseHeaders),
      body: parsedBody?.base64
    }).catch((error50) => {
      this.interception.handled = false;
      return handleError(error50);
    });
  }
  async _abort(errorReason) {
    this.interception.handled = true;
    if (this._interceptionId === void 0) {
      throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.failRequest");
    }
    await this.#client.send("Fetch.failRequest", {
      requestId: this._interceptionId,
      errorReason: errorReason || "Failed"
    }).catch(handleError);
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/HTTPResponse.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/HTTPResponse.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var HTTPResponse = class {
  static {
    __name(this, "HTTPResponse");
  }
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * True if the response was successful (status in the range 200-299).
   */
  ok() {
    const status2 = this.status();
    return status2 === 0 || status2 >= 200 && status2 <= 299;
  }
  /**
   * Promise which resolves to a text (utf8) representation of response body.
   */
  async text() {
    const content = await this.buffer();
    return content.toString("utf8");
  }
  /**
   * Promise which resolves to a JSON representation of response body.
   *
   * @remarks
   *
   * This method will throw if the response body is not parsable via
   * `JSON.parse`.
   */
  async json() {
    const content = await this.text();
    return JSON.parse(content);
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/SecurityDetails.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SecurityDetails = class {
  static {
    __name(this, "SecurityDetails");
  }
  #subjectName;
  #issuer;
  #validFrom;
  #validTo;
  #protocol;
  #sanList;
  /**
   * @internal
   */
  constructor(securityPayload) {
    this.#subjectName = securityPayload.subjectName;
    this.#issuer = securityPayload.issuer;
    this.#validFrom = securityPayload.validFrom;
    this.#validTo = securityPayload.validTo;
    this.#protocol = securityPayload.protocol;
    this.#sanList = securityPayload.sanList;
  }
  /**
   * The name of the issuer of the certificate.
   */
  issuer() {
    return this.#issuer;
  }
  /**
   * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
   * marking the start of the certificate's validity.
   */
  validFrom() {
    return this.#validFrom;
  }
  /**
   * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
   * marking the end of the certificate's validity.
   */
  validTo() {
    return this.#validTo;
  }
  /**
   * The security protocol being used, e.g. "TLS 1.2".
   */
  protocol() {
    return this.#protocol;
  }
  /**
   * The name of the subject to which the certificate was issued.
   */
  subjectName() {
    return this.#subjectName;
  }
  /**
   * The list of {@link https://en.wikipedia.org/wiki/Subject_Alternative_Name | subject alternative names (SANs)} of the certificate.
   */
  subjectAlternativeNames() {
    return this.#sanList;
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/HTTPResponse.js
var CdpHTTPResponse = class extends HTTPResponse {
  static {
    __name(this, "CdpHTTPResponse");
  }
  #client;
  #request;
  #contentPromise = null;
  #bodyLoadedDeferred = Deferred.create();
  #remoteAddress;
  #status;
  #statusText;
  #url;
  #fromDiskCache;
  #fromServiceWorker;
  #headers = {};
  #securityDetails;
  #timing;
  constructor(client, request2, responsePayload, extraInfo) {
    super();
    this.#client = client;
    this.#request = request2;
    this.#remoteAddress = {
      ip: responsePayload.remoteIPAddress,
      port: responsePayload.remotePort
    };
    this.#statusText = this.#parseStatusTextFromExtraInfo(extraInfo) || responsePayload.statusText;
    this.#url = request2.url();
    this.#fromDiskCache = !!responsePayload.fromDiskCache;
    this.#fromServiceWorker = !!responsePayload.fromServiceWorker;
    this.#status = extraInfo ? extraInfo.statusCode : responsePayload.status;
    const headers = extraInfo ? extraInfo.headers : responsePayload.headers;
    for (const [key, value3] of Object.entries(headers)) {
      this.#headers[key.toLowerCase()] = value3;
    }
    this.#securityDetails = responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null;
    this.#timing = responsePayload.timing || null;
  }
  #parseStatusTextFromExtraInfo(extraInfo) {
    if (!extraInfo || !extraInfo.headersText) {
      return;
    }
    const firstLine = extraInfo.headersText.split("\r", 1)[0];
    if (!firstLine) {
      return;
    }
    const match20 = firstLine.match(/[^ ]* [^ ]* (.*)/);
    if (!match20) {
      return;
    }
    const statusText = match20[1];
    if (!statusText) {
      return;
    }
    return statusText;
  }
  _resolveBody(err) {
    if (err) {
      return this.#bodyLoadedDeferred.reject(err);
    }
    return this.#bodyLoadedDeferred.resolve();
  }
  remoteAddress() {
    return this.#remoteAddress;
  }
  url() {
    return this.#url;
  }
  status() {
    return this.#status;
  }
  statusText() {
    return this.#statusText;
  }
  headers() {
    return this.#headers;
  }
  securityDetails() {
    return this.#securityDetails;
  }
  timing() {
    return this.#timing;
  }
  buffer() {
    if (!this.#contentPromise) {
      this.#contentPromise = this.#bodyLoadedDeferred.valueOrThrow().then(async () => {
        try {
          const response = await this.#client.send("Network.getResponseBody", {
            requestId: this.#request.id
          });
          return Buffer.from(response.body, response.base64Encoded ? "base64" : "utf8");
        } catch (error50) {
          if (error50 instanceof ProtocolError && error50.originalMessage === "No resource with given identifier found") {
            throw new ProtocolError("Could not load body for this request. This might happen if the request is a preflight request.");
          }
          throw error50;
        }
      });
    }
    return this.#contentPromise;
  }
  request() {
    return this.#request;
  }
  fromCache() {
    return this.#fromDiskCache || this.#request._fromMemoryCache;
  }
  fromServiceWorker() {
    return this.#fromServiceWorker;
  }
  frame() {
    return this.#request.frame();
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/NetworkEventManager.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var NetworkEventManager = class {
  static {
    __name(this, "NetworkEventManager");
  }
  /**
   * There are four possible orders of events:
   * A. `_onRequestWillBeSent`
   * B. `_onRequestWillBeSent`, `_onRequestPaused`
   * C. `_onRequestPaused`, `_onRequestWillBeSent`
   * D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
   * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`
   * (see crbug.com/1196004)
   *
   * For `_onRequest` we need the event from `_onRequestWillBeSent` and
   * optionally the `interceptionId` from `_onRequestPaused`.
   *
   * If request interception is disabled, call `_onRequest` once per call to
   * `_onRequestWillBeSent`.
   * If request interception is enabled, call `_onRequest` once per call to
   * `_onRequestPaused` (once per `interceptionId`).
   *
   * Events are stored to allow for subsequent events to call `_onRequest`.
   *
   * Note that (chains of) redirect requests have the same `requestId` (!) as
   * the original request. We have to anticipate series of events like these:
   * A. `_onRequestWillBeSent`,
   * `_onRequestWillBeSent`, ...
   * B. `_onRequestWillBeSent`, `_onRequestPaused`,
   * `_onRequestWillBeSent`, `_onRequestPaused`, ...
   * C. `_onRequestWillBeSent`, `_onRequestPaused`,
   * `_onRequestPaused`, `_onRequestWillBeSent`, ...
   * D. `_onRequestPaused`, `_onRequestWillBeSent`,
   * `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
   * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`, ...
   * (see crbug.com/1196004)
   */
  #requestWillBeSentMap = /* @__PURE__ */ new Map();
  #requestPausedMap = /* @__PURE__ */ new Map();
  #httpRequestsMap = /* @__PURE__ */ new Map();
  /*
   * The below maps are used to reconcile Network.responseReceivedExtraInfo
   * events with their corresponding request. Each response and redirect
   * response gets an ExtraInfo event, and we don't know which will come first.
   * This means that we have to store a Response or an ExtraInfo for each
   * response, and emit the event when we get both of them. In addition, to
   * handle redirects, we have to make them Arrays to represent the chain of
   * events.
   */
  #responseReceivedExtraInfoMap = /* @__PURE__ */ new Map();
  #queuedRedirectInfoMap = /* @__PURE__ */ new Map();
  #queuedEventGroupMap = /* @__PURE__ */ new Map();
  forget(networkRequestId) {
    this.#requestWillBeSentMap.delete(networkRequestId);
    this.#requestPausedMap.delete(networkRequestId);
    this.#queuedEventGroupMap.delete(networkRequestId);
    this.#queuedRedirectInfoMap.delete(networkRequestId);
    this.#responseReceivedExtraInfoMap.delete(networkRequestId);
  }
  responseExtraInfo(networkRequestId) {
    if (!this.#responseReceivedExtraInfoMap.has(networkRequestId)) {
      this.#responseReceivedExtraInfoMap.set(networkRequestId, []);
    }
    return this.#responseReceivedExtraInfoMap.get(networkRequestId);
  }
  queuedRedirectInfo(fetchRequestId) {
    if (!this.#queuedRedirectInfoMap.has(fetchRequestId)) {
      this.#queuedRedirectInfoMap.set(fetchRequestId, []);
    }
    return this.#queuedRedirectInfoMap.get(fetchRequestId);
  }
  queueRedirectInfo(fetchRequestId, redirectInfo) {
    this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);
  }
  takeQueuedRedirectInfo(fetchRequestId) {
    return this.queuedRedirectInfo(fetchRequestId).shift();
  }
  inFlightRequestsCount() {
    let inFlightRequestCounter = 0;
    for (const request2 of this.#httpRequestsMap.values()) {
      if (!request2.response()) {
        inFlightRequestCounter++;
      }
    }
    return inFlightRequestCounter;
  }
  storeRequestWillBeSent(networkRequestId, event) {
    this.#requestWillBeSentMap.set(networkRequestId, event);
  }
  getRequestWillBeSent(networkRequestId) {
    return this.#requestWillBeSentMap.get(networkRequestId);
  }
  forgetRequestWillBeSent(networkRequestId) {
    this.#requestWillBeSentMap.delete(networkRequestId);
  }
  getRequestPaused(networkRequestId) {
    return this.#requestPausedMap.get(networkRequestId);
  }
  forgetRequestPaused(networkRequestId) {
    this.#requestPausedMap.delete(networkRequestId);
  }
  storeRequestPaused(networkRequestId, event) {
    this.#requestPausedMap.set(networkRequestId, event);
  }
  getRequest(networkRequestId) {
    return this.#httpRequestsMap.get(networkRequestId);
  }
  storeRequest(networkRequestId, request2) {
    this.#httpRequestsMap.set(networkRequestId, request2);
  }
  forgetRequest(networkRequestId) {
    this.#httpRequestsMap.delete(networkRequestId);
  }
  getQueuedEventGroup(networkRequestId) {
    return this.#queuedEventGroupMap.get(networkRequestId);
  }
  queueEventGroup(networkRequestId, event) {
    this.#queuedEventGroupMap.set(networkRequestId, event);
  }
  forgetQueuedEventGroup(networkRequestId) {
    this.#queuedEventGroupMap.delete(networkRequestId);
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/NetworkManager.js
var NetworkManager = class extends EventEmitter2 {
  static {
    __name(this, "NetworkManager");
  }
  #frameManager;
  #networkEventManager = new NetworkEventManager();
  #extraHTTPHeaders;
  #credentials = null;
  #attemptedAuthentications = /* @__PURE__ */ new Set();
  #userRequestInterceptionEnabled = false;
  #protocolRequestInterceptionEnabled = false;
  #userCacheDisabled;
  #emulatedNetworkConditions;
  #userAgent;
  #userAgentMetadata;
  #handlers = [
    ["Fetch.requestPaused", this.#onRequestPaused],
    ["Fetch.authRequired", this.#onAuthRequired],
    ["Network.requestWillBeSent", this.#onRequestWillBeSent],
    ["Network.requestServedFromCache", this.#onRequestServedFromCache],
    ["Network.responseReceived", this.#onResponseReceived],
    ["Network.loadingFinished", this.#onLoadingFinished],
    ["Network.loadingFailed", this.#onLoadingFailed],
    ["Network.responseReceivedExtraInfo", this.#onResponseReceivedExtraInfo],
    [CDPSessionEvent.Disconnected, this.#removeClient]
  ];
  #clients = /* @__PURE__ */ new Map();
  constructor(frameManager) {
    super();
    this.#frameManager = frameManager;
  }
  async addClient(client) {
    if (this.#clients.has(client)) {
      return;
    }
    const subscriptions = new DisposableStack();
    this.#clients.set(client, subscriptions);
    const clientEmitter = subscriptions.use(new EventEmitter2(client));
    for (const [event, handler] of this.#handlers) {
      clientEmitter.on(event, (arg) => {
        return handler.bind(this)(client, arg);
      });
    }
    await Promise.all([
      client.send("Network.enable"),
      this.#applyExtraHTTPHeaders(client),
      this.#applyNetworkConditions(client),
      this.#applyProtocolCacheDisabled(client),
      this.#applyProtocolRequestInterception(client),
      this.#applyUserAgent(client)
    ]);
  }
  async #removeClient(client) {
    this.#clients.get(client)?.dispose();
    this.#clients.delete(client);
  }
  async authenticate(credentials) {
    this.#credentials = credentials;
    const enabled2 = this.#userRequestInterceptionEnabled || !!this.#credentials;
    if (enabled2 === this.#protocolRequestInterceptionEnabled) {
      return;
    }
    this.#protocolRequestInterceptionEnabled = enabled2;
    await this.#applyToAllClients(this.#applyProtocolRequestInterception.bind(this));
  }
  async setExtraHTTPHeaders(headers) {
    const extraHTTPHeaders = {};
    for (const [key, value3] of Object.entries(headers)) {
      assert5(isString2(value3), `Expected value of header "${key}" to be String, but "${typeof value3}" is found.`);
      extraHTTPHeaders[key.toLowerCase()] = value3;
    }
    this.#extraHTTPHeaders = extraHTTPHeaders;
    await this.#applyToAllClients(this.#applyExtraHTTPHeaders.bind(this));
  }
  async #applyExtraHTTPHeaders(client) {
    if (this.#extraHTTPHeaders === void 0) {
      return;
    }
    await client.send("Network.setExtraHTTPHeaders", {
      headers: this.#extraHTTPHeaders
    });
  }
  extraHTTPHeaders() {
    return Object.assign({}, this.#extraHTTPHeaders);
  }
  inFlightRequestsCount() {
    return this.#networkEventManager.inFlightRequestsCount();
  }
  async setOfflineMode(value3) {
    if (!this.#emulatedNetworkConditions) {
      this.#emulatedNetworkConditions = {
        offline: false,
        upload: -1,
        download: -1,
        latency: 0
      };
    }
    this.#emulatedNetworkConditions.offline = value3;
    await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));
  }
  async emulateNetworkConditions(networkConditions) {
    if (!this.#emulatedNetworkConditions) {
      this.#emulatedNetworkConditions = {
        offline: false,
        upload: -1,
        download: -1,
        latency: 0
      };
    }
    this.#emulatedNetworkConditions.upload = networkConditions ? networkConditions.upload : -1;
    this.#emulatedNetworkConditions.download = networkConditions ? networkConditions.download : -1;
    this.#emulatedNetworkConditions.latency = networkConditions ? networkConditions.latency : 0;
    await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));
  }
  async #applyToAllClients(fn2) {
    await Promise.all(Array.from(this.#clients.keys()).map((client) => {
      return fn2(client);
    }));
  }
  async #applyNetworkConditions(client) {
    if (this.#emulatedNetworkConditions === void 0) {
      return;
    }
    await client.send("Network.emulateNetworkConditions", {
      offline: this.#emulatedNetworkConditions.offline,
      latency: this.#emulatedNetworkConditions.latency,
      uploadThroughput: this.#emulatedNetworkConditions.upload,
      downloadThroughput: this.#emulatedNetworkConditions.download
    });
  }
  async setUserAgent(userAgent, userAgentMetadata) {
    this.#userAgent = userAgent;
    this.#userAgentMetadata = userAgentMetadata;
    await this.#applyToAllClients(this.#applyUserAgent.bind(this));
  }
  async #applyUserAgent(client) {
    if (this.#userAgent === void 0) {
      return;
    }
    await client.send("Network.setUserAgentOverride", {
      userAgent: this.#userAgent,
      userAgentMetadata: this.#userAgentMetadata
    });
  }
  async setCacheEnabled(enabled2) {
    this.#userCacheDisabled = !enabled2;
    await this.#applyToAllClients(this.#applyProtocolCacheDisabled.bind(this));
  }
  async setRequestInterception(value3) {
    this.#userRequestInterceptionEnabled = value3;
    const enabled2 = this.#userRequestInterceptionEnabled || !!this.#credentials;
    if (enabled2 === this.#protocolRequestInterceptionEnabled) {
      return;
    }
    this.#protocolRequestInterceptionEnabled = enabled2;
    await this.#applyToAllClients(this.#applyProtocolRequestInterception.bind(this));
  }
  async #applyProtocolRequestInterception(client) {
    if (this.#userCacheDisabled === void 0) {
      this.#userCacheDisabled = false;
    }
    if (this.#protocolRequestInterceptionEnabled) {
      await Promise.all([
        this.#applyProtocolCacheDisabled(client),
        client.send("Fetch.enable", {
          handleAuthRequests: true,
          patterns: [{ urlPattern: "*" }]
        })
      ]);
    } else {
      await Promise.all([
        this.#applyProtocolCacheDisabled(client),
        client.send("Fetch.disable")
      ]);
    }
  }
  async #applyProtocolCacheDisabled(client) {
    if (this.#userCacheDisabled === void 0) {
      return;
    }
    await client.send("Network.setCacheDisabled", {
      cacheDisabled: this.#userCacheDisabled
    });
  }
  #onRequestWillBeSent(client, event) {
    if (this.#userRequestInterceptionEnabled && !event.request.url.startsWith("data:")) {
      const { requestId: networkRequestId } = event;
      this.#networkEventManager.storeRequestWillBeSent(networkRequestId, event);
      const requestPausedEvent = this.#networkEventManager.getRequestPaused(networkRequestId);
      if (requestPausedEvent) {
        const { requestId: fetchRequestId } = requestPausedEvent;
        this.#patchRequestEventHeaders(event, requestPausedEvent);
        this.#onRequest(client, event, fetchRequestId);
        this.#networkEventManager.forgetRequestPaused(networkRequestId);
      }
      return;
    }
    this.#onRequest(client, event, void 0);
  }
  #onAuthRequired(client, event) {
    let response = "Default";
    if (this.#attemptedAuthentications.has(event.requestId)) {
      response = "CancelAuth";
    } else if (this.#credentials) {
      response = "ProvideCredentials";
      this.#attemptedAuthentications.add(event.requestId);
    }
    const { username, password } = this.#credentials || {
      username: void 0,
      password: void 0
    };
    client.send("Fetch.continueWithAuth", {
      requestId: event.requestId,
      authChallengeResponse: { response, username, password }
    }).catch(debugError);
  }
  /**
   * CDP may send a Fetch.requestPaused without or before a
   * Network.requestWillBeSent
   *
   * CDP may send multiple Fetch.requestPaused
   * for the same Network.requestWillBeSent.
   */
  #onRequestPaused(client, event) {
    if (!this.#userRequestInterceptionEnabled && this.#protocolRequestInterceptionEnabled) {
      client.send("Fetch.continueRequest", {
        requestId: event.requestId
      }).catch(debugError);
    }
    const { networkId: networkRequestId, requestId: fetchRequestId } = event;
    if (!networkRequestId) {
      this.#onRequestWithoutNetworkInstrumentation(client, event);
      return;
    }
    const requestWillBeSentEvent = (() => {
      const requestWillBeSentEvent2 = this.#networkEventManager.getRequestWillBeSent(networkRequestId);
      if (requestWillBeSentEvent2 && (requestWillBeSentEvent2.request.url !== event.request.url || requestWillBeSentEvent2.request.method !== event.request.method)) {
        this.#networkEventManager.forgetRequestWillBeSent(networkRequestId);
        return;
      }
      return requestWillBeSentEvent2;
    })();
    if (requestWillBeSentEvent) {
      this.#patchRequestEventHeaders(requestWillBeSentEvent, event);
      this.#onRequest(client, requestWillBeSentEvent, fetchRequestId);
    } else {
      this.#networkEventManager.storeRequestPaused(networkRequestId, event);
    }
  }
  #patchRequestEventHeaders(requestWillBeSentEvent, requestPausedEvent) {
    requestWillBeSentEvent.request.headers = {
      ...requestWillBeSentEvent.request.headers,
      // includes extra headers, like: Accept, Origin
      ...requestPausedEvent.request.headers
    };
  }
  #onRequestWithoutNetworkInstrumentation(client, event) {
    const frame = event.frameId ? this.#frameManager.frame(event.frameId) : null;
    const request2 = new CdpHTTPRequest(client, frame, event.requestId, this.#userRequestInterceptionEnabled, event, []);
    this.emit(NetworkManagerEvent.Request, request2);
    void request2.finalizeInterceptions();
  }
  #onRequest(client, event, fetchRequestId) {
    let redirectChain = [];
    if (event.redirectResponse) {
      let redirectResponseExtraInfo = null;
      if (event.redirectHasExtraInfo) {
        redirectResponseExtraInfo = this.#networkEventManager.responseExtraInfo(event.requestId).shift();
        if (!redirectResponseExtraInfo) {
          this.#networkEventManager.queueRedirectInfo(event.requestId, {
            event,
            fetchRequestId
          });
          return;
        }
      }
      const request3 = this.#networkEventManager.getRequest(event.requestId);
      if (request3) {
        this.#handleRequestRedirect(client, request3, event.redirectResponse, redirectResponseExtraInfo);
        redirectChain = request3._redirectChain;
      }
    }
    const frame = event.frameId ? this.#frameManager.frame(event.frameId) : null;
    const request2 = new CdpHTTPRequest(client, frame, fetchRequestId, this.#userRequestInterceptionEnabled, event, redirectChain);
    this.#networkEventManager.storeRequest(event.requestId, request2);
    this.emit(NetworkManagerEvent.Request, request2);
    void request2.finalizeInterceptions();
  }
  #onRequestServedFromCache(_client, event) {
    const request2 = this.#networkEventManager.getRequest(event.requestId);
    if (request2) {
      request2._fromMemoryCache = true;
    }
    this.emit(NetworkManagerEvent.RequestServedFromCache, request2);
  }
  #handleRequestRedirect(client, request2, responsePayload, extraInfo) {
    const response = new CdpHTTPResponse(client, request2, responsePayload, extraInfo);
    request2._response = response;
    request2._redirectChain.push(request2);
    response._resolveBody(new Error("Response body is unavailable for redirect responses"));
    this.#forgetRequest(request2, false);
    this.emit(NetworkManagerEvent.Response, response);
    this.emit(NetworkManagerEvent.RequestFinished, request2);
  }
  #emitResponseEvent(client, responseReceived, extraInfo) {
    const request2 = this.#networkEventManager.getRequest(responseReceived.requestId);
    if (!request2) {
      return;
    }
    const extraInfos = this.#networkEventManager.responseExtraInfo(responseReceived.requestId);
    if (extraInfos.length) {
      debugError(new Error("Unexpected extraInfo events for request " + responseReceived.requestId));
    }
    if (responseReceived.response.fromDiskCache) {
      extraInfo = null;
    }
    const response = new CdpHTTPResponse(client, request2, responseReceived.response, extraInfo);
    request2._response = response;
    this.emit(NetworkManagerEvent.Response, response);
  }
  #onResponseReceived(client, event) {
    const request2 = this.#networkEventManager.getRequest(event.requestId);
    let extraInfo = null;
    if (request2 && !request2._fromMemoryCache && event.hasExtraInfo) {
      extraInfo = this.#networkEventManager.responseExtraInfo(event.requestId).shift();
      if (!extraInfo) {
        this.#networkEventManager.queueEventGroup(event.requestId, {
          responseReceivedEvent: event
        });
        return;
      }
    }
    this.#emitResponseEvent(client, event, extraInfo);
  }
  #onResponseReceivedExtraInfo(client, event) {
    const redirectInfo = this.#networkEventManager.takeQueuedRedirectInfo(event.requestId);
    if (redirectInfo) {
      this.#networkEventManager.responseExtraInfo(event.requestId).push(event);
      this.#onRequest(client, redirectInfo.event, redirectInfo.fetchRequestId);
      return;
    }
    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
    if (queuedEvents) {
      this.#networkEventManager.forgetQueuedEventGroup(event.requestId);
      this.#emitResponseEvent(client, queuedEvents.responseReceivedEvent, event);
      if (queuedEvents.loadingFinishedEvent) {
        this.#emitLoadingFinished(queuedEvents.loadingFinishedEvent);
      }
      if (queuedEvents.loadingFailedEvent) {
        this.#emitLoadingFailed(queuedEvents.loadingFailedEvent);
      }
      return;
    }
    this.#networkEventManager.responseExtraInfo(event.requestId).push(event);
  }
  #forgetRequest(request2, events) {
    const requestId = request2.id;
    const interceptionId = request2._interceptionId;
    this.#networkEventManager.forgetRequest(requestId);
    interceptionId !== void 0 && this.#attemptedAuthentications.delete(interceptionId);
    if (events) {
      this.#networkEventManager.forget(requestId);
    }
  }
  #onLoadingFinished(_client, event) {
    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
    if (queuedEvents) {
      queuedEvents.loadingFinishedEvent = event;
    } else {
      this.#emitLoadingFinished(event);
    }
  }
  #emitLoadingFinished(event) {
    const request2 = this.#networkEventManager.getRequest(event.requestId);
    if (!request2) {
      return;
    }
    if (request2.response()) {
      request2.response()?._resolveBody();
    }
    this.#forgetRequest(request2, true);
    this.emit(NetworkManagerEvent.RequestFinished, request2);
  }
  #onLoadingFailed(_client, event) {
    const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
    if (queuedEvents) {
      queuedEvents.loadingFailedEvent = event;
    } else {
      this.#emitLoadingFailed(event);
    }
  }
  #emitLoadingFailed(event) {
    const request2 = this.#networkEventManager.getRequest(event.requestId);
    if (!request2) {
      return;
    }
    request2._failureText = event.errorText;
    const response = request2.response();
    if (response) {
      response._resolveBody();
    }
    this.#forgetRequest(request2, true);
    this.emit(NetworkManagerEvent.RequestFailed, request2);
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/FrameManager.js
var TIME_FOR_WAITING_FOR_SWAP = 100;
var FrameManager = class extends EventEmitter2 {
  static {
    __name(this, "FrameManager");
  }
  #page;
  #networkManager;
  #timeoutSettings;
  #isolatedWorlds = /* @__PURE__ */ new Set();
  #client;
  #scriptsToEvaluateOnNewDocument = /* @__PURE__ */ new Map();
  #bindings = /* @__PURE__ */ new Set();
  _frameTree = new FrameTree();
  /**
   * Set of frame IDs stored to indicate if a frame has received a
   * frameNavigated event so that frame tree responses could be ignored as the
   * frameNavigated event usually contains the latest information.
   */
  #frameNavigatedReceived = /* @__PURE__ */ new Set();
  #deviceRequestPromptManagerMap = /* @__PURE__ */ new WeakMap();
  #frameTreeHandled;
  get timeoutSettings() {
    return this.#timeoutSettings;
  }
  get networkManager() {
    return this.#networkManager;
  }
  get client() {
    return this.#client;
  }
  constructor(client, page, timeoutSettings) {
    super();
    this.#client = client;
    this.#page = page;
    this.#networkManager = new NetworkManager(this);
    this.#timeoutSettings = timeoutSettings;
    this.setupEventListeners(this.#client);
    client.once(CDPSessionEvent.Disconnected, () => {
      this.#onClientDisconnect().catch(debugError);
    });
  }
  /**
   * Called when the frame's client is disconnected. We don't know if the
   * disconnect means that the frame is removed or if it will be replaced by a
   * new frame. Therefore, we wait for a swap event.
   */
  async #onClientDisconnect() {
    const mainFrame = this._frameTree.getMainFrame();
    if (!mainFrame) {
      return;
    }
    for (const child of mainFrame.childFrames()) {
      this.#removeFramesRecursively(child);
    }
    const swapped = Deferred.create({
      timeout: TIME_FOR_WAITING_FOR_SWAP,
      message: "Frame was not swapped"
    });
    mainFrame.once(FrameEvent.FrameSwappedByActivation, () => {
      swapped.resolve();
    });
    try {
      await swapped.valueOrThrow();
    } catch (err) {
      this.#removeFramesRecursively(mainFrame);
    }
  }
  /**
   * When the main frame is replaced by another main frame,
   * we maintain the main frame object identity while updating
   * its frame tree and ID.
   */
  async swapFrameTree(client) {
    this.#client = client;
    assert5(this.#client instanceof CdpCDPSession, "CDPSession is not an instance of CDPSessionImpl.");
    const frame = this._frameTree.getMainFrame();
    if (frame) {
      this.#frameNavigatedReceived.add(this.#client._target()._targetId);
      this._frameTree.removeFrame(frame);
      frame.updateId(this.#client._target()._targetId);
      this._frameTree.addFrame(frame);
      frame.updateClient(client);
    }
    this.setupEventListeners(client);
    client.once(CDPSessionEvent.Disconnected, () => {
      this.#onClientDisconnect().catch(debugError);
    });
    await this.initialize(client, frame);
    await this.#networkManager.addClient(client);
    if (frame) {
      frame.emit(FrameEvent.FrameSwappedByActivation, void 0);
    }
  }
  async registerSpeculativeSession(client) {
    await this.#networkManager.addClient(client);
  }
  setupEventListeners(session) {
    session.on("Page.frameAttached", async (event) => {
      await this.#frameTreeHandled?.valueOrThrow();
      this.#onFrameAttached(session, event.frameId, event.parentFrameId);
    });
    session.on("Page.frameNavigated", async (event) => {
      this.#frameNavigatedReceived.add(event.frame.id);
      await this.#frameTreeHandled?.valueOrThrow();
      void this.#onFrameNavigated(event.frame, event.type);
    });
    session.on("Page.navigatedWithinDocument", async (event) => {
      await this.#frameTreeHandled?.valueOrThrow();
      this.#onFrameNavigatedWithinDocument(event.frameId, event.url);
    });
    session.on("Page.frameDetached", async (event) => {
      await this.#frameTreeHandled?.valueOrThrow();
      this.#onFrameDetached(event.frameId, event.reason);
    });
    session.on("Page.frameStartedLoading", async (event) => {
      await this.#frameTreeHandled?.valueOrThrow();
      this.#onFrameStartedLoading(event.frameId);
    });
    session.on("Page.frameStoppedLoading", async (event) => {
      await this.#frameTreeHandled?.valueOrThrow();
      this.#onFrameStoppedLoading(event.frameId);
    });
    session.on("Runtime.executionContextCreated", async (event) => {
      await this.#frameTreeHandled?.valueOrThrow();
      this.#onExecutionContextCreated(event.context, session);
    });
    session.on("Page.lifecycleEvent", async (event) => {
      await this.#frameTreeHandled?.valueOrThrow();
      this.#onLifecycleEvent(event);
    });
  }
  async initialize(client, frame) {
    try {
      this.#frameTreeHandled?.resolve();
      this.#frameTreeHandled = Deferred.create();
      await Promise.all([
        this.#networkManager.addClient(client),
        client.send("Page.enable"),
        client.send("Page.getFrameTree").then(({ frameTree }) => {
          this.#handleFrameTree(client, frameTree);
          this.#frameTreeHandled?.resolve();
        }),
        client.send("Page.setLifecycleEventsEnabled", { enabled: true }),
        client.send("Runtime.enable").then(() => {
          return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
        }),
        ...(frame ? Array.from(this.#scriptsToEvaluateOnNewDocument.values()) : []).map((script) => {
          return frame?.addPreloadScript(script);
        }),
        ...(frame ? Array.from(this.#bindings.values()) : []).map((binding2) => {
          return frame?.addExposedFunctionBinding(binding2);
        })
      ]);
    } catch (error50) {
      this.#frameTreeHandled?.resolve();
      if (isErrorLike(error50) && isTargetClosedError(error50)) {
        return;
      }
      throw error50;
    }
  }
  page() {
    return this.#page;
  }
  mainFrame() {
    const mainFrame = this._frameTree.getMainFrame();
    assert5(mainFrame, "Requesting main frame too early!");
    return mainFrame;
  }
  frames() {
    return Array.from(this._frameTree.frames());
  }
  frame(frameId) {
    return this._frameTree.getById(frameId) || null;
  }
  async addExposedFunctionBinding(binding2) {
    this.#bindings.add(binding2);
    await Promise.all(this.frames().map(async (frame) => {
      return await frame.addExposedFunctionBinding(binding2);
    }));
  }
  async removeExposedFunctionBinding(binding2) {
    this.#bindings.delete(binding2);
    await Promise.all(this.frames().map(async (frame) => {
      return await frame.removeExposedFunctionBinding(binding2);
    }));
  }
  async evaluateOnNewDocument(source2) {
    const { identifier: identifier2 } = await this.mainFrame()._client().send("Page.addScriptToEvaluateOnNewDocument", {
      source: source2
    });
    const preloadScript = new CdpPreloadScript(this.mainFrame(), identifier2, source2);
    this.#scriptsToEvaluateOnNewDocument.set(identifier2, preloadScript);
    await Promise.all(this.frames().map(async (frame) => {
      return await frame.addPreloadScript(preloadScript);
    }));
    return { identifier: identifier2 };
  }
  async removeScriptToEvaluateOnNewDocument(identifier2) {
    const preloadScript = this.#scriptsToEvaluateOnNewDocument.get(identifier2);
    if (!preloadScript) {
      throw new Error(`Script to evaluate on new document with id ${identifier2} not found`);
    }
    this.#scriptsToEvaluateOnNewDocument.delete(identifier2);
    await Promise.all(this.frames().map((frame) => {
      const identifier3 = preloadScript.getIdForFrame(frame);
      if (!identifier3) {
        return;
      }
      return frame._client().send("Page.removeScriptToEvaluateOnNewDocument", {
        identifier: identifier3
      }).catch(debugError);
    }));
  }
  onAttachedToTarget(target) {
    if (target._getTargetInfo().type !== "iframe") {
      return;
    }
    const frame = this.frame(target._getTargetInfo().targetId);
    if (frame) {
      frame.updateClient(target._session());
    }
    this.setupEventListeners(target._session());
    void this.initialize(target._session(), frame);
  }
  _deviceRequestPromptManager(client) {
    let manager = this.#deviceRequestPromptManagerMap.get(client);
    if (manager === void 0) {
      manager = new DeviceRequestPromptManager(client, this.#timeoutSettings);
      this.#deviceRequestPromptManagerMap.set(client, manager);
    }
    return manager;
  }
  #onLifecycleEvent(event) {
    const frame = this.frame(event.frameId);
    if (!frame) {
      return;
    }
    frame._onLifecycleEvent(event.loaderId, event.name);
    this.emit(FrameManagerEvent.LifecycleEvent, frame);
    frame.emit(FrameEvent.LifecycleEvent, void 0);
  }
  #onFrameStartedLoading(frameId) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    frame._onLoadingStarted();
  }
  #onFrameStoppedLoading(frameId) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    frame._onLoadingStopped();
    this.emit(FrameManagerEvent.LifecycleEvent, frame);
    frame.emit(FrameEvent.LifecycleEvent, void 0);
  }
  #handleFrameTree(session, frameTree) {
    if (frameTree.frame.parentId) {
      this.#onFrameAttached(session, frameTree.frame.id, frameTree.frame.parentId);
    }
    if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {
      void this.#onFrameNavigated(frameTree.frame, "Navigation");
    } else {
      this.#frameNavigatedReceived.delete(frameTree.frame.id);
    }
    if (!frameTree.childFrames) {
      return;
    }
    for (const child of frameTree.childFrames) {
      this.#handleFrameTree(session, child);
    }
  }
  #onFrameAttached(session, frameId, parentFrameId) {
    let frame = this.frame(frameId);
    if (frame) {
      if (session && frame.isOOPFrame()) {
        frame.updateClient(session);
      }
      return;
    }
    frame = new CdpFrame(this, frameId, parentFrameId, session);
    this._frameTree.addFrame(frame);
    this.emit(FrameManagerEvent.FrameAttached, frame);
  }
  async #onFrameNavigated(framePayload, navigationType) {
    const frameId = framePayload.id;
    const isMainFrame = !framePayload.parentId;
    let frame = this._frameTree.getById(frameId);
    if (frame) {
      for (const child of frame.childFrames()) {
        this.#removeFramesRecursively(child);
      }
    }
    if (isMainFrame) {
      if (frame) {
        this._frameTree.removeFrame(frame);
        frame._id = frameId;
      } else {
        frame = new CdpFrame(this, frameId, void 0, this.#client);
      }
      this._frameTree.addFrame(frame);
    }
    frame = await this._frameTree.waitForFrame(frameId);
    frame._navigated(framePayload);
    this.emit(FrameManagerEvent.FrameNavigated, frame);
    frame.emit(FrameEvent.FrameNavigated, navigationType);
  }
  async #createIsolatedWorld(session, name) {
    const key = `${session.id()}:${name}`;
    if (this.#isolatedWorlds.has(key)) {
      return;
    }
    await session.send("Page.addScriptToEvaluateOnNewDocument", {
      source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,
      worldName: name
    });
    await Promise.all(this.frames().filter((frame) => {
      return frame.client === session;
    }).map((frame) => {
      return session.send("Page.createIsolatedWorld", {
        frameId: frame._id,
        worldName: name,
        grantUniveralAccess: true
      }).catch(debugError);
    }));
    this.#isolatedWorlds.add(key);
  }
  #onFrameNavigatedWithinDocument(frameId, url3) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    frame._navigatedWithinDocument(url3);
    this.emit(FrameManagerEvent.FrameNavigatedWithinDocument, frame);
    frame.emit(FrameEvent.FrameNavigatedWithinDocument, void 0);
    this.emit(FrameManagerEvent.FrameNavigated, frame);
    frame.emit(FrameEvent.FrameNavigated, "Navigation");
  }
  #onFrameDetached(frameId, reason) {
    const frame = this.frame(frameId);
    if (!frame) {
      return;
    }
    switch (reason) {
      case "remove":
        this.#removeFramesRecursively(frame);
        break;
      case "swap":
        this.emit(FrameManagerEvent.FrameSwapped, frame);
        frame.emit(FrameEvent.FrameSwapped, void 0);
        break;
    }
  }
  #onExecutionContextCreated(contextPayload, session) {
    const auxData = contextPayload.auxData;
    const frameId = auxData && auxData.frameId;
    const frame = typeof frameId === "string" ? this.frame(frameId) : void 0;
    let world;
    if (frame) {
      if (frame.client !== session) {
        return;
      }
      if (contextPayload.auxData && contextPayload.auxData["isDefault"]) {
        world = frame.worlds[MAIN_WORLD];
      } else if (contextPayload.name === UTILITY_WORLD_NAME) {
        world = frame.worlds[PUPPETEER_WORLD];
      }
    }
    if (!world) {
      return;
    }
    const context10 = new ExecutionContext(frame?.client || this.#client, contextPayload, world);
    world.setContext(context10);
  }
  #removeFramesRecursively(frame) {
    for (const child of frame.childFrames()) {
      this.#removeFramesRecursively(child);
    }
    frame[disposeSymbol]();
    this._frameTree.removeFrame(frame);
    this.emit(FrameManagerEvent.FrameDetached, frame);
    frame.emit(FrameEvent.FrameDetached, frame);
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Input.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/Input.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Keyboard = class {
  static {
    __name(this, "Keyboard");
  }
  /**
   * @internal
   */
  constructor() {
  }
};
var MouseButton = Object.freeze({
  Left: "left",
  Right: "right",
  Middle: "middle",
  Back: "back",
  Forward: "forward"
});
var Mouse = class {
  static {
    __name(this, "Mouse");
  }
  /**
   * @internal
   */
  constructor() {
  }
};
var Touchscreen = class {
  static {
    __name(this, "Touchscreen");
  }
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Dispatches a `touchstart` and `touchend` event.
   * @param x - Horizontal position of the tap.
   * @param y - Vertical position of the tap.
   */
  async tap(x, y) {
    await this.touchStart(x, y);
    await this.touchEnd();
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/USKeyboardLayout.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var _keyDefinitions = {
  "0": { keyCode: 48, key: "0", code: "Digit0" },
  "1": { keyCode: 49, key: "1", code: "Digit1" },
  "2": { keyCode: 50, key: "2", code: "Digit2" },
  "3": { keyCode: 51, key: "3", code: "Digit3" },
  "4": { keyCode: 52, key: "4", code: "Digit4" },
  "5": { keyCode: 53, key: "5", code: "Digit5" },
  "6": { keyCode: 54, key: "6", code: "Digit6" },
  "7": { keyCode: 55, key: "7", code: "Digit7" },
  "8": { keyCode: 56, key: "8", code: "Digit8" },
  "9": { keyCode: 57, key: "9", code: "Digit9" },
  Power: { key: "Power", code: "Power" },
  Eject: { key: "Eject", code: "Eject" },
  Abort: { keyCode: 3, code: "Abort", key: "Cancel" },
  Help: { keyCode: 6, code: "Help", key: "Help" },
  Backspace: { keyCode: 8, code: "Backspace", key: "Backspace" },
  Tab: { keyCode: 9, code: "Tab", key: "Tab" },
  Numpad5: {
    keyCode: 12,
    shiftKeyCode: 101,
    key: "Clear",
    code: "Numpad5",
    shiftKey: "5",
    location: 3
  },
  NumpadEnter: {
    keyCode: 13,
    code: "NumpadEnter",
    key: "Enter",
    text: "\r",
    location: 3
  },
  Enter: { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
  "\r": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
  "\n": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
  ShiftLeft: { keyCode: 16, code: "ShiftLeft", key: "Shift", location: 1 },
  ShiftRight: { keyCode: 16, code: "ShiftRight", key: "Shift", location: 2 },
  ControlLeft: {
    keyCode: 17,
    code: "ControlLeft",
    key: "Control",
    location: 1
  },
  ControlRight: {
    keyCode: 17,
    code: "ControlRight",
    key: "Control",
    location: 2
  },
  AltLeft: { keyCode: 18, code: "AltLeft", key: "Alt", location: 1 },
  AltRight: { keyCode: 18, code: "AltRight", key: "Alt", location: 2 },
  Pause: { keyCode: 19, code: "Pause", key: "Pause" },
  CapsLock: { keyCode: 20, code: "CapsLock", key: "CapsLock" },
  Escape: { keyCode: 27, code: "Escape", key: "Escape" },
  Convert: { keyCode: 28, code: "Convert", key: "Convert" },
  NonConvert: { keyCode: 29, code: "NonConvert", key: "NonConvert" },
  Space: { keyCode: 32, code: "Space", key: " " },
  Numpad9: {
    keyCode: 33,
    shiftKeyCode: 105,
    key: "PageUp",
    code: "Numpad9",
    shiftKey: "9",
    location: 3
  },
  PageUp: { keyCode: 33, code: "PageUp", key: "PageUp" },
  Numpad3: {
    keyCode: 34,
    shiftKeyCode: 99,
    key: "PageDown",
    code: "Numpad3",
    shiftKey: "3",
    location: 3
  },
  PageDown: { keyCode: 34, code: "PageDown", key: "PageDown" },
  End: { keyCode: 35, code: "End", key: "End" },
  Numpad1: {
    keyCode: 35,
    shiftKeyCode: 97,
    key: "End",
    code: "Numpad1",
    shiftKey: "1",
    location: 3
  },
  Home: { keyCode: 36, code: "Home", key: "Home" },
  Numpad7: {
    keyCode: 36,
    shiftKeyCode: 103,
    key: "Home",
    code: "Numpad7",
    shiftKey: "7",
    location: 3
  },
  ArrowLeft: { keyCode: 37, code: "ArrowLeft", key: "ArrowLeft" },
  Numpad4: {
    keyCode: 37,
    shiftKeyCode: 100,
    key: "ArrowLeft",
    code: "Numpad4",
    shiftKey: "4",
    location: 3
  },
  Numpad8: {
    keyCode: 38,
    shiftKeyCode: 104,
    key: "ArrowUp",
    code: "Numpad8",
    shiftKey: "8",
    location: 3
  },
  ArrowUp: { keyCode: 38, code: "ArrowUp", key: "ArrowUp" },
  ArrowRight: { keyCode: 39, code: "ArrowRight", key: "ArrowRight" },
  Numpad6: {
    keyCode: 39,
    shiftKeyCode: 102,
    key: "ArrowRight",
    code: "Numpad6",
    shiftKey: "6",
    location: 3
  },
  Numpad2: {
    keyCode: 40,
    shiftKeyCode: 98,
    key: "ArrowDown",
    code: "Numpad2",
    shiftKey: "2",
    location: 3
  },
  ArrowDown: { keyCode: 40, code: "ArrowDown", key: "ArrowDown" },
  Select: { keyCode: 41, code: "Select", key: "Select" },
  Open: { keyCode: 43, code: "Open", key: "Execute" },
  PrintScreen: { keyCode: 44, code: "PrintScreen", key: "PrintScreen" },
  Insert: { keyCode: 45, code: "Insert", key: "Insert" },
  Numpad0: {
    keyCode: 45,
    shiftKeyCode: 96,
    key: "Insert",
    code: "Numpad0",
    shiftKey: "0",
    location: 3
  },
  Delete: { keyCode: 46, code: "Delete", key: "Delete" },
  NumpadDecimal: {
    keyCode: 46,
    shiftKeyCode: 110,
    code: "NumpadDecimal",
    key: "\0",
    shiftKey: ".",
    location: 3
  },
  Digit0: { keyCode: 48, code: "Digit0", shiftKey: ")", key: "0" },
  Digit1: { keyCode: 49, code: "Digit1", shiftKey: "!", key: "1" },
  Digit2: { keyCode: 50, code: "Digit2", shiftKey: "@", key: "2" },
  Digit3: { keyCode: 51, code: "Digit3", shiftKey: "#", key: "3" },
  Digit4: { keyCode: 52, code: "Digit4", shiftKey: "$", key: "4" },
  Digit5: { keyCode: 53, code: "Digit5", shiftKey: "%", key: "5" },
  Digit6: { keyCode: 54, code: "Digit6", shiftKey: "^", key: "6" },
  Digit7: { keyCode: 55, code: "Digit7", shiftKey: "&", key: "7" },
  Digit8: { keyCode: 56, code: "Digit8", shiftKey: "*", key: "8" },
  Digit9: { keyCode: 57, code: "Digit9", shiftKey: "(", key: "9" },
  KeyA: { keyCode: 65, code: "KeyA", shiftKey: "A", key: "a" },
  KeyB: { keyCode: 66, code: "KeyB", shiftKey: "B", key: "b" },
  KeyC: { keyCode: 67, code: "KeyC", shiftKey: "C", key: "c" },
  KeyD: { keyCode: 68, code: "KeyD", shiftKey: "D", key: "d" },
  KeyE: { keyCode: 69, code: "KeyE", shiftKey: "E", key: "e" },
  KeyF: { keyCode: 70, code: "KeyF", shiftKey: "F", key: "f" },
  KeyG: { keyCode: 71, code: "KeyG", shiftKey: "G", key: "g" },
  KeyH: { keyCode: 72, code: "KeyH", shiftKey: "H", key: "h" },
  KeyI: { keyCode: 73, code: "KeyI", shiftKey: "I", key: "i" },
  KeyJ: { keyCode: 74, code: "KeyJ", shiftKey: "J", key: "j" },
  KeyK: { keyCode: 75, code: "KeyK", shiftKey: "K", key: "k" },
  KeyL: { keyCode: 76, code: "KeyL", shiftKey: "L", key: "l" },
  KeyM: { keyCode: 77, code: "KeyM", shiftKey: "M", key: "m" },
  KeyN: { keyCode: 78, code: "KeyN", shiftKey: "N", key: "n" },
  KeyO: { keyCode: 79, code: "KeyO", shiftKey: "O", key: "o" },
  KeyP: { keyCode: 80, code: "KeyP", shiftKey: "P", key: "p" },
  KeyQ: { keyCode: 81, code: "KeyQ", shiftKey: "Q", key: "q" },
  KeyR: { keyCode: 82, code: "KeyR", shiftKey: "R", key: "r" },
  KeyS: { keyCode: 83, code: "KeyS", shiftKey: "S", key: "s" },
  KeyT: { keyCode: 84, code: "KeyT", shiftKey: "T", key: "t" },
  KeyU: { keyCode: 85, code: "KeyU", shiftKey: "U", key: "u" },
  KeyV: { keyCode: 86, code: "KeyV", shiftKey: "V", key: "v" },
  KeyW: { keyCode: 87, code: "KeyW", shiftKey: "W", key: "w" },
  KeyX: { keyCode: 88, code: "KeyX", shiftKey: "X", key: "x" },
  KeyY: { keyCode: 89, code: "KeyY", shiftKey: "Y", key: "y" },
  KeyZ: { keyCode: 90, code: "KeyZ", shiftKey: "Z", key: "z" },
  MetaLeft: { keyCode: 91, code: "MetaLeft", key: "Meta", location: 1 },
  MetaRight: { keyCode: 92, code: "MetaRight", key: "Meta", location: 2 },
  ContextMenu: { keyCode: 93, code: "ContextMenu", key: "ContextMenu" },
  NumpadMultiply: {
    keyCode: 106,
    code: "NumpadMultiply",
    key: "*",
    location: 3
  },
  NumpadAdd: { keyCode: 107, code: "NumpadAdd", key: "+", location: 3 },
  NumpadSubtract: {
    keyCode: 109,
    code: "NumpadSubtract",
    key: "-",
    location: 3
  },
  NumpadDivide: { keyCode: 111, code: "NumpadDivide", key: "/", location: 3 },
  F1: { keyCode: 112, code: "F1", key: "F1" },
  F2: { keyCode: 113, code: "F2", key: "F2" },
  F3: { keyCode: 114, code: "F3", key: "F3" },
  F4: { keyCode: 115, code: "F4", key: "F4" },
  F5: { keyCode: 116, code: "F5", key: "F5" },
  F6: { keyCode: 117, code: "F6", key: "F6" },
  F7: { keyCode: 118, code: "F7", key: "F7" },
  F8: { keyCode: 119, code: "F8", key: "F8" },
  F9: { keyCode: 120, code: "F9", key: "F9" },
  F10: { keyCode: 121, code: "F10", key: "F10" },
  F11: { keyCode: 122, code: "F11", key: "F11" },
  F12: { keyCode: 123, code: "F12", key: "F12" },
  F13: { keyCode: 124, code: "F13", key: "F13" },
  F14: { keyCode: 125, code: "F14", key: "F14" },
  F15: { keyCode: 126, code: "F15", key: "F15" },
  F16: { keyCode: 127, code: "F16", key: "F16" },
  F17: { keyCode: 128, code: "F17", key: "F17" },
  F18: { keyCode: 129, code: "F18", key: "F18" },
  F19: { keyCode: 130, code: "F19", key: "F19" },
  F20: { keyCode: 131, code: "F20", key: "F20" },
  F21: { keyCode: 132, code: "F21", key: "F21" },
  F22: { keyCode: 133, code: "F22", key: "F22" },
  F23: { keyCode: 134, code: "F23", key: "F23" },
  F24: { keyCode: 135, code: "F24", key: "F24" },
  NumLock: { keyCode: 144, code: "NumLock", key: "NumLock" },
  ScrollLock: { keyCode: 145, code: "ScrollLock", key: "ScrollLock" },
  AudioVolumeMute: {
    keyCode: 173,
    code: "AudioVolumeMute",
    key: "AudioVolumeMute"
  },
  AudioVolumeDown: {
    keyCode: 174,
    code: "AudioVolumeDown",
    key: "AudioVolumeDown"
  },
  AudioVolumeUp: { keyCode: 175, code: "AudioVolumeUp", key: "AudioVolumeUp" },
  MediaTrackNext: {
    keyCode: 176,
    code: "MediaTrackNext",
    key: "MediaTrackNext"
  },
  MediaTrackPrevious: {
    keyCode: 177,
    code: "MediaTrackPrevious",
    key: "MediaTrackPrevious"
  },
  MediaStop: { keyCode: 178, code: "MediaStop", key: "MediaStop" },
  MediaPlayPause: {
    keyCode: 179,
    code: "MediaPlayPause",
    key: "MediaPlayPause"
  },
  Semicolon: { keyCode: 186, code: "Semicolon", shiftKey: ":", key: ";" },
  Equal: { keyCode: 187, code: "Equal", shiftKey: "+", key: "=" },
  NumpadEqual: { keyCode: 187, code: "NumpadEqual", key: "=", location: 3 },
  Comma: { keyCode: 188, code: "Comma", shiftKey: "<", key: "," },
  Minus: { keyCode: 189, code: "Minus", shiftKey: "_", key: "-" },
  Period: { keyCode: 190, code: "Period", shiftKey: ">", key: "." },
  Slash: { keyCode: 191, code: "Slash", shiftKey: "?", key: "/" },
  Backquote: { keyCode: 192, code: "Backquote", shiftKey: "~", key: "`" },
  BracketLeft: { keyCode: 219, code: "BracketLeft", shiftKey: "{", key: "[" },
  Backslash: { keyCode: 220, code: "Backslash", shiftKey: "|", key: "\\" },
  BracketRight: { keyCode: 221, code: "BracketRight", shiftKey: "}", key: "]" },
  Quote: { keyCode: 222, code: "Quote", shiftKey: '"', key: "'" },
  AltGraph: { keyCode: 225, code: "AltGraph", key: "AltGraph" },
  Props: { keyCode: 247, code: "Props", key: "CrSel" },
  Cancel: { keyCode: 3, key: "Cancel", code: "Abort" },
  Clear: { keyCode: 12, key: "Clear", code: "Numpad5", location: 3 },
  Shift: { keyCode: 16, key: "Shift", code: "ShiftLeft", location: 1 },
  Control: { keyCode: 17, key: "Control", code: "ControlLeft", location: 1 },
  Alt: { keyCode: 18, key: "Alt", code: "AltLeft", location: 1 },
  Accept: { keyCode: 30, key: "Accept" },
  ModeChange: { keyCode: 31, key: "ModeChange" },
  " ": { keyCode: 32, key: " ", code: "Space" },
  Print: { keyCode: 42, key: "Print" },
  Execute: { keyCode: 43, key: "Execute", code: "Open" },
  "\0": { keyCode: 46, key: "\0", code: "NumpadDecimal", location: 3 },
  a: { keyCode: 65, key: "a", code: "KeyA" },
  b: { keyCode: 66, key: "b", code: "KeyB" },
  c: { keyCode: 67, key: "c", code: "KeyC" },
  d: { keyCode: 68, key: "d", code: "KeyD" },
  e: { keyCode: 69, key: "e", code: "KeyE" },
  f: { keyCode: 70, key: "f", code: "KeyF" },
  g: { keyCode: 71, key: "g", code: "KeyG" },
  h: { keyCode: 72, key: "h", code: "KeyH" },
  i: { keyCode: 73, key: "i", code: "KeyI" },
  j: { keyCode: 74, key: "j", code: "KeyJ" },
  k: { keyCode: 75, key: "k", code: "KeyK" },
  l: { keyCode: 76, key: "l", code: "KeyL" },
  m: { keyCode: 77, key: "m", code: "KeyM" },
  n: { keyCode: 78, key: "n", code: "KeyN" },
  o: { keyCode: 79, key: "o", code: "KeyO" },
  p: { keyCode: 80, key: "p", code: "KeyP" },
  q: { keyCode: 81, key: "q", code: "KeyQ" },
  r: { keyCode: 82, key: "r", code: "KeyR" },
  s: { keyCode: 83, key: "s", code: "KeyS" },
  t: { keyCode: 84, key: "t", code: "KeyT" },
  u: { keyCode: 85, key: "u", code: "KeyU" },
  v: { keyCode: 86, key: "v", code: "KeyV" },
  w: { keyCode: 87, key: "w", code: "KeyW" },
  x: { keyCode: 88, key: "x", code: "KeyX" },
  y: { keyCode: 89, key: "y", code: "KeyY" },
  z: { keyCode: 90, key: "z", code: "KeyZ" },
  Meta: { keyCode: 91, key: "Meta", code: "MetaLeft", location: 1 },
  "*": { keyCode: 106, key: "*", code: "NumpadMultiply", location: 3 },
  "+": { keyCode: 107, key: "+", code: "NumpadAdd", location: 3 },
  "-": { keyCode: 109, key: "-", code: "NumpadSubtract", location: 3 },
  "/": { keyCode: 111, key: "/", code: "NumpadDivide", location: 3 },
  ";": { keyCode: 186, key: ";", code: "Semicolon" },
  "=": { keyCode: 187, key: "=", code: "Equal" },
  ",": { keyCode: 188, key: ",", code: "Comma" },
  ".": { keyCode: 190, key: ".", code: "Period" },
  "`": { keyCode: 192, key: "`", code: "Backquote" },
  "[": { keyCode: 219, key: "[", code: "BracketLeft" },
  "\\": { keyCode: 220, key: "\\", code: "Backslash" },
  "]": { keyCode: 221, key: "]", code: "BracketRight" },
  "'": { keyCode: 222, key: "'", code: "Quote" },
  Attn: { keyCode: 246, key: "Attn" },
  CrSel: { keyCode: 247, key: "CrSel", code: "Props" },
  ExSel: { keyCode: 248, key: "ExSel" },
  EraseEof: { keyCode: 249, key: "EraseEof" },
  Play: { keyCode: 250, key: "Play" },
  ZoomOut: { keyCode: 251, key: "ZoomOut" },
  ")": { keyCode: 48, key: ")", code: "Digit0" },
  "!": { keyCode: 49, key: "!", code: "Digit1" },
  "@": { keyCode: 50, key: "@", code: "Digit2" },
  "#": { keyCode: 51, key: "#", code: "Digit3" },
  $: { keyCode: 52, key: "$", code: "Digit4" },
  "%": { keyCode: 53, key: "%", code: "Digit5" },
  "^": { keyCode: 54, key: "^", code: "Digit6" },
  "&": { keyCode: 55, key: "&", code: "Digit7" },
  "(": { keyCode: 57, key: "(", code: "Digit9" },
  A: { keyCode: 65, key: "A", code: "KeyA" },
  B: { keyCode: 66, key: "B", code: "KeyB" },
  C: { keyCode: 67, key: "C", code: "KeyC" },
  D: { keyCode: 68, key: "D", code: "KeyD" },
  E: { keyCode: 69, key: "E", code: "KeyE" },
  F: { keyCode: 70, key: "F", code: "KeyF" },
  G: { keyCode: 71, key: "G", code: "KeyG" },
  H: { keyCode: 72, key: "H", code: "KeyH" },
  I: { keyCode: 73, key: "I", code: "KeyI" },
  J: { keyCode: 74, key: "J", code: "KeyJ" },
  K: { keyCode: 75, key: "K", code: "KeyK" },
  L: { keyCode: 76, key: "L", code: "KeyL" },
  M: { keyCode: 77, key: "M", code: "KeyM" },
  N: { keyCode: 78, key: "N", code: "KeyN" },
  O: { keyCode: 79, key: "O", code: "KeyO" },
  P: { keyCode: 80, key: "P", code: "KeyP" },
  Q: { keyCode: 81, key: "Q", code: "KeyQ" },
  R: { keyCode: 82, key: "R", code: "KeyR" },
  S: { keyCode: 83, key: "S", code: "KeyS" },
  T: { keyCode: 84, key: "T", code: "KeyT" },
  U: { keyCode: 85, key: "U", code: "KeyU" },
  V: { keyCode: 86, key: "V", code: "KeyV" },
  W: { keyCode: 87, key: "W", code: "KeyW" },
  X: { keyCode: 88, key: "X", code: "KeyX" },
  Y: { keyCode: 89, key: "Y", code: "KeyY" },
  Z: { keyCode: 90, key: "Z", code: "KeyZ" },
  ":": { keyCode: 186, key: ":", code: "Semicolon" },
  "<": { keyCode: 188, key: "<", code: "Comma" },
  _: { keyCode: 189, key: "_", code: "Minus" },
  ">": { keyCode: 190, key: ">", code: "Period" },
  "?": { keyCode: 191, key: "?", code: "Slash" },
  "~": { keyCode: 192, key: "~", code: "Backquote" },
  "{": { keyCode: 219, key: "{", code: "BracketLeft" },
  "|": { keyCode: 220, key: "|", code: "Backslash" },
  "}": { keyCode: 221, key: "}", code: "BracketRight" },
  '"': { keyCode: 222, key: '"', code: "Quote" },
  SoftLeft: { key: "SoftLeft", code: "SoftLeft", location: 4 },
  SoftRight: { key: "SoftRight", code: "SoftRight", location: 4 },
  Camera: { keyCode: 44, key: "Camera", code: "Camera", location: 4 },
  Call: { key: "Call", code: "Call", location: 4 },
  EndCall: { keyCode: 95, key: "EndCall", code: "EndCall", location: 4 },
  VolumeDown: {
    keyCode: 182,
    key: "VolumeDown",
    code: "VolumeDown",
    location: 4
  },
  VolumeUp: { keyCode: 183, key: "VolumeUp", code: "VolumeUp", location: 4 }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Input.js
var CdpKeyboard = class extends Keyboard {
  static {
    __name(this, "CdpKeyboard");
  }
  #client;
  #pressedKeys = /* @__PURE__ */ new Set();
  _modifiers = 0;
  constructor(client) {
    super();
    this.#client = client;
  }
  updateClient(client) {
    this.#client = client;
  }
  async down(key, options = {
    text: void 0,
    commands: []
  }) {
    const description = this.#keyDescriptionForString(key);
    const autoRepeat = this.#pressedKeys.has(description.code);
    this.#pressedKeys.add(description.code);
    this._modifiers |= this.#modifierBit(description.key);
    const text2 = options.text === void 0 ? description.text : options.text;
    await this.#client.send("Input.dispatchKeyEvent", {
      type: text2 ? "keyDown" : "rawKeyDown",
      modifiers: this._modifiers,
      windowsVirtualKeyCode: description.keyCode,
      code: description.code,
      key: description.key,
      text: text2,
      unmodifiedText: text2,
      autoRepeat,
      location: description.location,
      isKeypad: description.location === 3,
      commands: options.commands
    });
  }
  #modifierBit(key) {
    if (key === "Alt") {
      return 1;
    }
    if (key === "Control") {
      return 2;
    }
    if (key === "Meta") {
      return 4;
    }
    if (key === "Shift") {
      return 8;
    }
    return 0;
  }
  #keyDescriptionForString(keyString) {
    const shift2 = this._modifiers & 8;
    const description = {
      key: "",
      keyCode: 0,
      code: "",
      text: "",
      location: 0
    };
    const definition = _keyDefinitions[keyString];
    assert5(definition, `Unknown key: "${keyString}"`);
    if (definition.key) {
      description.key = definition.key;
    }
    if (shift2 && definition.shiftKey) {
      description.key = definition.shiftKey;
    }
    if (definition.keyCode) {
      description.keyCode = definition.keyCode;
    }
    if (shift2 && definition.shiftKeyCode) {
      description.keyCode = definition.shiftKeyCode;
    }
    if (definition.code) {
      description.code = definition.code;
    }
    if (definition.location) {
      description.location = definition.location;
    }
    if (description.key.length === 1) {
      description.text = description.key;
    }
    if (definition.text) {
      description.text = definition.text;
    }
    if (shift2 && definition.shiftText) {
      description.text = definition.shiftText;
    }
    if (this._modifiers & ~8) {
      description.text = "";
    }
    return description;
  }
  async up(key) {
    const description = this.#keyDescriptionForString(key);
    this._modifiers &= ~this.#modifierBit(description.key);
    this.#pressedKeys.delete(description.code);
    await this.#client.send("Input.dispatchKeyEvent", {
      type: "keyUp",
      modifiers: this._modifiers,
      key: description.key,
      windowsVirtualKeyCode: description.keyCode,
      code: description.code,
      location: description.location
    });
  }
  async sendCharacter(char2) {
    await this.#client.send("Input.insertText", { text: char2 });
  }
  charIsKey(char2) {
    return !!_keyDefinitions[char2];
  }
  async type(text2, options = {}) {
    const delay3 = options.delay || void 0;
    for (const char2 of text2) {
      if (this.charIsKey(char2)) {
        await this.press(char2, { delay: delay3 });
      } else {
        if (delay3) {
          await new Promise((f) => {
            return setTimeout(f, delay3);
          });
        }
        await this.sendCharacter(char2);
      }
    }
  }
  async press(key, options = {}) {
    const { delay: delay3 = null } = options;
    await this.down(key, options);
    if (delay3) {
      await new Promise((f) => {
        return setTimeout(f, options.delay);
      });
    }
    await this.up(key);
  }
};
var getFlag = /* @__PURE__ */ __name((button) => {
  switch (button) {
    case MouseButton.Left:
      return 1;
    case MouseButton.Right:
      return 2;
    case MouseButton.Middle:
      return 4;
    case MouseButton.Back:
      return 8;
    case MouseButton.Forward:
      return 16;
  }
}, "getFlag");
var getButtonFromPressedButtons = /* @__PURE__ */ __name((buttons) => {
  if (buttons & 1) {
    return MouseButton.Left;
  } else if (buttons & 2) {
    return MouseButton.Right;
  } else if (buttons & 4) {
    return MouseButton.Middle;
  } else if (buttons & 8) {
    return MouseButton.Back;
  } else if (buttons & 16) {
    return MouseButton.Forward;
  }
  return "none";
}, "getButtonFromPressedButtons");
var CdpMouse = class extends Mouse {
  static {
    __name(this, "CdpMouse");
  }
  #client;
  #keyboard;
  constructor(client, keyboard) {
    super();
    this.#client = client;
    this.#keyboard = keyboard;
  }
  updateClient(client) {
    this.#client = client;
  }
  #_state = {
    position: { x: 0, y: 0 },
    buttons: 0
  };
  get #state() {
    return Object.assign({ ...this.#_state }, ...this.#transactions);
  }
  // Transactions can run in parallel, so we store each of thme in this array.
  #transactions = [];
  #createTransaction() {
    const transaction = {};
    this.#transactions.push(transaction);
    const popTransaction = /* @__PURE__ */ __name(() => {
      this.#transactions.splice(this.#transactions.indexOf(transaction), 1);
    }, "popTransaction");
    return {
      update: /* @__PURE__ */ __name((updates) => {
        Object.assign(transaction, updates);
      }, "update"),
      commit: /* @__PURE__ */ __name(() => {
        this.#_state = { ...this.#_state, ...transaction };
        popTransaction();
      }, "commit"),
      rollback: popTransaction
    };
  }
  /**
   * This is a shortcut for a typical update, commit/rollback lifecycle based on
   * the error of the action.
   */
  async #withTransaction(action) {
    const { update: update6, commit: commit3, rollback } = this.#createTransaction();
    try {
      await action(update6);
      commit3();
    } catch (error50) {
      rollback();
      throw error50;
    }
  }
  async reset() {
    const actions = [];
    for (const [flag, button] of [
      [1, MouseButton.Left],
      [4, MouseButton.Middle],
      [2, MouseButton.Right],
      [16, MouseButton.Forward],
      [8, MouseButton.Back]
    ]) {
      if (this.#state.buttons & flag) {
        actions.push(this.up({ button }));
      }
    }
    if (this.#state.position.x !== 0 || this.#state.position.y !== 0) {
      actions.push(this.move(0, 0));
    }
    await Promise.all(actions);
  }
  async move(x, y, options = {}) {
    const { steps = 1 } = options;
    const from2 = this.#state.position;
    const to = { x, y };
    for (let i = 1; i <= steps; i++) {
      await this.#withTransaction((updateState) => {
        updateState({
          position: {
            x: from2.x + (to.x - from2.x) * (i / steps),
            y: from2.y + (to.y - from2.y) * (i / steps)
          }
        });
        const { buttons, position } = this.#state;
        return this.#client.send("Input.dispatchMouseEvent", {
          type: "mouseMoved",
          modifiers: this.#keyboard._modifiers,
          buttons,
          button: getButtonFromPressedButtons(buttons),
          ...position
        });
      });
    }
  }
  async down(options = {}) {
    const { button = MouseButton.Left, clickCount = 1 } = options;
    const flag = getFlag(button);
    if (!flag) {
      throw new Error(`Unsupported mouse button: ${button}`);
    }
    if (this.#state.buttons & flag) {
      throw new Error(`'${button}' is already pressed.`);
    }
    await this.#withTransaction((updateState) => {
      updateState({
        buttons: this.#state.buttons | flag
      });
      const { buttons, position } = this.#state;
      return this.#client.send("Input.dispatchMouseEvent", {
        type: "mousePressed",
        modifiers: this.#keyboard._modifiers,
        clickCount,
        buttons,
        button,
        ...position
      });
    });
  }
  async up(options = {}) {
    const { button = MouseButton.Left, clickCount = 1 } = options;
    const flag = getFlag(button);
    if (!flag) {
      throw new Error(`Unsupported mouse button: ${button}`);
    }
    if (!(this.#state.buttons & flag)) {
      throw new Error(`'${button}' is not pressed.`);
    }
    await this.#withTransaction((updateState) => {
      updateState({
        buttons: this.#state.buttons & ~flag
      });
      const { buttons, position } = this.#state;
      return this.#client.send("Input.dispatchMouseEvent", {
        type: "mouseReleased",
        modifiers: this.#keyboard._modifiers,
        clickCount,
        buttons,
        button,
        ...position
      });
    });
  }
  async click(x, y, options = {}) {
    const { delay: delay3, count: count6 = 1, clickCount = count6 } = options;
    if (count6 < 1) {
      throw new Error("Click must occur a positive number of times.");
    }
    const actions = [this.move(x, y)];
    if (clickCount === count6) {
      for (let i = 1; i < count6; ++i) {
        actions.push(this.down({ ...options, clickCount: i }), this.up({ ...options, clickCount: i }));
      }
    }
    actions.push(this.down({ ...options, clickCount }));
    if (typeof delay3 === "number") {
      await Promise.all(actions);
      actions.length = 0;
      await new Promise((resolve) => {
        setTimeout(resolve, delay3);
      });
    }
    actions.push(this.up({ ...options, clickCount }));
    await Promise.all(actions);
  }
  async wheel(options = {}) {
    const { deltaX = 0, deltaY = 0 } = options;
    const { position, buttons } = this.#state;
    await this.#client.send("Input.dispatchMouseEvent", {
      type: "mouseWheel",
      pointerType: "mouse",
      modifiers: this.#keyboard._modifiers,
      deltaY,
      deltaX,
      buttons,
      ...position
    });
  }
  async drag(start5, target) {
    const promise4 = new Promise((resolve) => {
      this.#client.once("Input.dragIntercepted", (event) => {
        return resolve(event.data);
      });
    });
    await this.move(start5.x, start5.y);
    await this.down();
    await this.move(target.x, target.y);
    return await promise4;
  }
  async dragEnter(target, data) {
    await this.#client.send("Input.dispatchDragEvent", {
      type: "dragEnter",
      x: target.x,
      y: target.y,
      modifiers: this.#keyboard._modifiers,
      data
    });
  }
  async dragOver(target, data) {
    await this.#client.send("Input.dispatchDragEvent", {
      type: "dragOver",
      x: target.x,
      y: target.y,
      modifiers: this.#keyboard._modifiers,
      data
    });
  }
  async drop(target, data) {
    await this.#client.send("Input.dispatchDragEvent", {
      type: "drop",
      x: target.x,
      y: target.y,
      modifiers: this.#keyboard._modifiers,
      data
    });
  }
  async dragAndDrop(start5, target, options = {}) {
    const { delay: delay3 = null } = options;
    const data = await this.drag(start5, target);
    await this.dragEnter(target, data);
    await this.dragOver(target, data);
    if (delay3) {
      await new Promise((resolve) => {
        return setTimeout(resolve, delay3);
      });
    }
    await this.drop(target, data);
    await this.up();
  }
};
var CdpTouchscreen = class extends Touchscreen {
  static {
    __name(this, "CdpTouchscreen");
  }
  #client;
  #keyboard;
  constructor(client, keyboard) {
    super();
    this.#client = client;
    this.#keyboard = keyboard;
  }
  updateClient(client) {
    this.#client = client;
  }
  async touchStart(x, y) {
    await this.#client.send("Input.dispatchTouchEvent", {
      type: "touchStart",
      touchPoints: [
        {
          x: Math.round(x),
          y: Math.round(y),
          radiusX: 0.5,
          radiusY: 0.5,
          force: 0.5
        }
      ],
      modifiers: this.#keyboard._modifiers
    });
  }
  async touchMove(x, y) {
    await this.#client.send("Input.dispatchTouchEvent", {
      type: "touchMove",
      touchPoints: [
        {
          x: Math.round(x),
          y: Math.round(y),
          radiusX: 0.5,
          radiusY: 0.5,
          force: 0.5
        }
      ],
      modifiers: this.#keyboard._modifiers
    });
  }
  async touchEnd() {
    await this.#client.send("Input.dispatchTouchEvent", {
      type: "touchEnd",
      touchPoints: [],
      modifiers: this.#keyboard._modifiers
    });
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Tracing.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Tracing = class {
  static {
    __name(this, "Tracing");
  }
  #client;
  #recording = false;
  #path;
  /**
   * @internal
   */
  constructor(client) {
    this.#client = client;
  }
  /**
   * @internal
   */
  updateClient(client) {
    this.#client = client;
  }
  /**
   * Starts a trace for the current page.
   * @remarks
   * Only one trace can be active at a time per browser.
   *
   * @param options - Optional `TracingOptions`.
   */
  async start(options = {}) {
    assert5(!this.#recording, "Cannot start recording trace while already recording trace.");
    const defaultCategories = [
      "-*",
      "devtools.timeline",
      "v8.execute",
      "disabled-by-default-devtools.timeline",
      "disabled-by-default-devtools.timeline.frame",
      "toplevel",
      "blink.console",
      "blink.user_timing",
      "latencyInfo",
      "disabled-by-default-devtools.timeline.stack",
      "disabled-by-default-v8.cpu_profiler"
    ];
    const { path, screenshots = false, categories = defaultCategories } = options;
    if (screenshots) {
      categories.push("disabled-by-default-devtools.screenshot");
    }
    const excludedCategories = categories.filter((cat) => {
      return cat.startsWith("-");
    }).map((cat) => {
      return cat.slice(1);
    });
    const includedCategories = categories.filter((cat) => {
      return !cat.startsWith("-");
    });
    this.#path = path;
    this.#recording = true;
    await this.#client.send("Tracing.start", {
      transferMode: "ReturnAsStream",
      traceConfig: {
        excludedCategories,
        includedCategories
      }
    });
  }
  /**
   * Stops a trace started with the `start` method.
   * @returns Promise which resolves to buffer with trace data.
   */
  async stop() {
    const contentDeferred = Deferred.create();
    this.#client.once("Tracing.tracingComplete", async (event) => {
      try {
        assert5(event.stream, 'Missing "stream"');
        const readable = await getReadableFromProtocolStream(this.#client, event.stream);
        const buffer3 = await getReadableAsBuffer(readable, this.#path);
        contentDeferred.resolve(buffer3 ?? void 0);
      } catch (error50) {
        if (isErrorLike(error50)) {
          contentDeferred.reject(error50);
        } else {
          contentDeferred.reject(new Error(`Unknown error: ${error50}`));
        }
      }
    });
    await this.#client.send("Tracing.end");
    this.#recording = false;
    return await contentDeferred.valueOrThrow();
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/WebWorker.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/WebWorker.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var WebWorker = class extends EventEmitter2 {
  static {
    __name(this, "WebWorker");
  }
  /**
   * @internal
   */
  timeoutSettings = new TimeoutSettings();
  #url;
  /**
   * @internal
   */
  constructor(url3) {
    super();
    this.#url = url3;
  }
  /**
   * The URL of this web worker.
   */
  url() {
    return this.#url;
  }
  /**
   * Evaluates a given function in the {@link WebWorker | worker}.
   *
   * @remarks If the given function returns a promise,
   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
   *
   * As a rule of thumb, if the return value of the given function is more
   * complicated than a JSON object (e.g. most classes), then
   * {@link WebWorker.evaluate | evaluate} will _likely_ return some truncated
   * value (or `{}`). This is because we are not returning the actual return
   * value, but a deserialized version as a result of transferring the return
   * value through a protocol to Puppeteer.
   *
   * In general, you should use
   * {@link WebWorker.evaluateHandle | evaluateHandle} if
   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
   * properly or you need a mutable {@link JSHandle | handle} to the return
   * object.
   *
   * @param func - Function to be evaluated.
   * @param args - Arguments to pass into `func`.
   * @returns The result of `func`.
   */
  async evaluate(func2, ...args2) {
    func2 = withSourcePuppeteerURLIfNone(this.evaluate.name, func2);
    return await this.mainRealm().evaluate(func2, ...args2);
  }
  /**
   * Evaluates a given function in the {@link WebWorker | worker}.
   *
   * @remarks If the given function returns a promise,
   * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
   *
   * In general, you should use
   * {@link WebWorker.evaluateHandle | evaluateHandle} if
   * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
   * properly or you need a mutable {@link JSHandle | handle} to the return
   * object.
   *
   * @param func - Function to be evaluated.
   * @param args - Arguments to pass into `func`.
   * @returns A {@link JSHandle | handle} to the return value of `func`.
   */
  async evaluateHandle(func2, ...args2) {
    func2 = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, func2);
    return await this.mainRealm().evaluateHandle(func2, ...args2);
  }
  async close() {
    throw new UnsupportedOperation("WebWorker.close() is not supported");
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/WebWorker.js
var CdpWebWorker = class extends WebWorker {
  static {
    __name(this, "CdpWebWorker");
  }
  #world;
  #client;
  #id;
  #targetType;
  constructor(client, url3, targetId, targetType, consoleAPICalled, exceptionThrown) {
    super(url3);
    this.#id = targetId;
    this.#client = client;
    this.#targetType = targetType;
    this.#world = new IsolatedWorld(this, new TimeoutSettings());
    this.#client.once("Runtime.executionContextCreated", async (event) => {
      this.#world.setContext(new ExecutionContext(client, event.context, this.#world));
    });
    this.#world.emitter.on("consoleapicalled", async (event) => {
      try {
        return consoleAPICalled(event.type, event.args.map((object4) => {
          return new CdpJSHandle(this.#world, object4);
        }), event.stackTrace);
      } catch (err) {
        debugError(err);
      }
    });
    this.#client.on("Runtime.exceptionThrown", exceptionThrown);
    this.#client.once(CDPSessionEvent.Disconnected, () => {
      this.#world.dispose();
    });
    this.#client.send("Runtime.enable").catch(debugError);
  }
  mainRealm() {
    return this.#world;
  }
  get client() {
    return this.#client;
  }
  async close() {
    switch (this.#targetType) {
      case TargetType.SERVICE_WORKER:
      case TargetType.SHARED_WORKER: {
        await this.client.connection()?.send("Target.closeTarget", {
          targetId: this.#id
        });
        await this.client.connection()?.send("Target.detachFromTarget", {
          sessionId: this.client.id()
        });
        break;
      }
      default:
        await this.evaluate(() => {
          self.close();
        });
    }
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Page.js
var __addDisposableResource12 = function(env2, value3, async4) {
  if (value3 !== null && value3 !== void 0) {
    if (typeof value3 !== "object" && typeof value3 !== "function") throw new TypeError("Object expected.");
    var dispose;
    if (async4) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value3[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value3[Symbol.dispose];
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    env2.stack.push({ value: value3, dispose, async: async4 });
  } else if (async4) {
    env2.stack.push({ async: true });
  }
  return value3;
};
var __disposeResources12 = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env2) {
    function fail19(e) {
      env2.error = env2.hasError ? new SuppressedError2(e, env2.error, "An error was suppressed during disposal.") : e;
      env2.hasError = true;
    }
    __name(fail19, "fail");
    function next4() {
      while (env2.stack.length) {
        var rec = env2.stack.pop();
        try {
          var result = rec.dispose && rec.dispose.call(rec.value);
          if (rec.async) return Promise.resolve(result).then(next4, function(e) {
            fail19(e);
            return next4();
          });
        } catch (e) {
          fail19(e);
        }
      }
      if (env2.hasError) throw env2.error;
    }
    __name(next4, "next");
    return next4();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error50, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error50, e.suppressed = suppressed, e;
});
function convertConsoleMessageLevel(method) {
  switch (method) {
    case "warning":
      return "warn";
    default:
      return method;
  }
}
__name(convertConsoleMessageLevel, "convertConsoleMessageLevel");
var CdpPage = class _CdpPage extends Page {
  static {
    __name(this, "CdpPage");
  }
  static async _create(client, target, defaultViewport) {
    const page = new _CdpPage(client, target);
    await page.#initialize();
    if (defaultViewport) {
      try {
        await page.setViewport(defaultViewport);
      } catch (err) {
        if (isErrorLike(err) && isTargetClosedError(err)) {
          debugError(err);
        } else {
          throw err;
        }
      }
    }
    return page;
  }
  #closed = false;
  #targetManager;
  #primaryTargetClient;
  #primaryTarget;
  #tabTargetClient;
  #tabTarget;
  #keyboard;
  #mouse;
  #touchscreen;
  #frameManager;
  #emulationManager;
  #tracing;
  #bindings = /* @__PURE__ */ new Map();
  #exposedFunctions = /* @__PURE__ */ new Map();
  #coverage;
  #viewport;
  #workers = /* @__PURE__ */ new Map();
  #fileChooserDeferreds = /* @__PURE__ */ new Set();
  #sessionCloseDeferred = Deferred.create();
  #serviceWorkerBypassed = false;
  #userDragInterceptionEnabled = false;
  #frameManagerHandlers = [
    [
      FrameManagerEvent.FrameAttached,
      (frame) => {
        this.emit("frameattached", frame);
      }
    ],
    [
      FrameManagerEvent.FrameDetached,
      (frame) => {
        this.emit("framedetached", frame);
      }
    ],
    [
      FrameManagerEvent.FrameNavigated,
      (frame) => {
        this.emit("framenavigated", frame);
      }
    ]
  ];
  #networkManagerHandlers = [
    [
      NetworkManagerEvent.Request,
      (request2) => {
        this.emit("request", request2);
      }
    ],
    [
      NetworkManagerEvent.RequestServedFromCache,
      (request2) => {
        this.emit("requestservedfromcache", request2);
      }
    ],
    [
      NetworkManagerEvent.Response,
      (response) => {
        this.emit("response", response);
      }
    ],
    [
      NetworkManagerEvent.RequestFailed,
      (request2) => {
        this.emit("requestfailed", request2);
      }
    ],
    [
      NetworkManagerEvent.RequestFinished,
      (request2) => {
        this.emit("requestfinished", request2);
      }
    ]
  ];
  #sessionHandlers = [
    [
      CDPSessionEvent.Disconnected,
      () => {
        this.#sessionCloseDeferred.reject(new TargetCloseError("Target closed"));
      }
    ],
    [
      "Page.domContentEventFired",
      () => {
        return this.emit("domcontentloaded", void 0);
      }
    ],
    [
      "Page.loadEventFired",
      () => {
        return this.emit("load", void 0);
      }
    ],
    ["Page.javascriptDialogOpening", this.#onDialog.bind(this)],
    ["Runtime.exceptionThrown", this.#handleException.bind(this)],
    ["Inspector.targetCrashed", this.#onTargetCrashed.bind(this)],
    ["Performance.metrics", this.#emitMetrics.bind(this)],
    ["Log.entryAdded", this.#onLogEntryAdded.bind(this)],
    ["Page.fileChooserOpened", this.#onFileChooser.bind(this)]
  ];
  constructor(client, target) {
    super();
    this.#primaryTargetClient = client;
    this.#tabTargetClient = client.parentSession();
    assert5(this.#tabTargetClient, "Tab target session is not defined.");
    this.#tabTarget = this.#tabTargetClient._target();
    assert5(this.#tabTarget, "Tab target is not defined.");
    this.#primaryTarget = target;
    this.#targetManager = target._targetManager();
    this.#keyboard = new CdpKeyboard(client);
    this.#mouse = new CdpMouse(client, this.#keyboard);
    this.#touchscreen = new CdpTouchscreen(client, this.#keyboard);
    this.#frameManager = new FrameManager(client, this, this._timeoutSettings);
    this.#emulationManager = new EmulationManager(client);
    this.#tracing = new Tracing(client);
    this.#coverage = new Coverage(client);
    this.#viewport = null;
    for (const [eventName, handler] of this.#frameManagerHandlers) {
      this.#frameManager.on(eventName, handler);
    }
    this.#frameManager.on(FrameManagerEvent.ConsoleApiCalled, ([world, event]) => {
      this.#onConsoleAPI(world, event);
    });
    this.#frameManager.on(FrameManagerEvent.BindingCalled, ([world, event]) => {
      void this.#onBindingCalled(world, event);
    });
    for (const [eventName, handler] of this.#networkManagerHandlers) {
      this.#frameManager.networkManager.on(eventName, handler);
    }
    this.#tabTargetClient.on(CDPSessionEvent.Swapped, this.#onActivation.bind(this));
    this.#tabTargetClient.on(CDPSessionEvent.Ready, this.#onSecondaryTarget.bind(this));
    this.#targetManager.on("targetGone", this.#onDetachedFromTarget);
    this.#tabTarget._isClosedDeferred.valueOrThrow().then(() => {
      this.#targetManager.off("targetGone", this.#onDetachedFromTarget);
      this.emit("close", void 0);
      this.#closed = true;
    }).catch(debugError);
    this.#setupPrimaryTargetListeners();
    this.#attachExistingTargets();
  }
  #attachExistingTargets() {
    const queue = [];
    for (const childTarget of this.#targetManager.getChildTargets(this.#primaryTarget)) {
      queue.push(childTarget);
    }
    let idx = 0;
    while (idx < queue.length) {
      const next4 = queue[idx];
      idx++;
      const session = next4._session();
      if (session) {
        this.#onAttachedToTarget(session);
      }
      for (const childTarget of this.#targetManager.getChildTargets(next4)) {
        queue.push(childTarget);
      }
    }
  }
  async #onActivation(newSession) {
    this.#primaryTargetClient = newSession;
    assert5(this.#primaryTargetClient instanceof CdpCDPSession, "CDPSession is not instance of CDPSessionImpl");
    this.#primaryTarget = this.#primaryTargetClient._target();
    assert5(this.#primaryTarget, "Missing target on swap");
    this.#keyboard.updateClient(newSession);
    this.#mouse.updateClient(newSession);
    this.#touchscreen.updateClient(newSession);
    this.#emulationManager.updateClient(newSession);
    this.#tracing.updateClient(newSession);
    this.#coverage.updateClient(newSession);
    await this.#frameManager.swapFrameTree(newSession);
    this.#setupPrimaryTargetListeners();
  }
  async #onSecondaryTarget(session) {
    assert5(session instanceof CdpCDPSession);
    if (session._target()._subtype() !== "prerender") {
      return;
    }
    this.#frameManager.registerSpeculativeSession(session).catch(debugError);
    this.#emulationManager.registerSpeculativeSession(session).catch(debugError);
  }
  /**
   * Sets up listeners for the primary target. The primary target can change
   * during a navigation to a prerended page.
   */
  #setupPrimaryTargetListeners() {
    this.#primaryTargetClient.on(CDPSessionEvent.Ready, this.#onAttachedToTarget);
    for (const [eventName, handler] of this.#sessionHandlers) {
      this.#primaryTargetClient.on(eventName, handler);
    }
  }
  #onDetachedFromTarget = /* @__PURE__ */ __name((target) => {
    const sessionId = target._session()?.id();
    const worker2 = this.#workers.get(sessionId);
    if (!worker2) {
      return;
    }
    this.#workers.delete(sessionId);
    this.emit("workerdestroyed", worker2);
  }, "#onDetachedFromTarget");
  #onAttachedToTarget = /* @__PURE__ */ __name((session) => {
    assert5(session instanceof CdpCDPSession);
    this.#frameManager.onAttachedToTarget(session._target());
    if (session._target()._getTargetInfo().type === "worker") {
      const worker2 = new CdpWebWorker(session, session._target().url(), session._target()._targetId, session._target().type(), this.#addConsoleMessage.bind(this), this.#handleException.bind(this));
      this.#workers.set(session.id(), worker2);
      this.emit("workercreated", worker2);
    }
    session.on(CDPSessionEvent.Ready, this.#onAttachedToTarget);
  }, "#onAttachedToTarget");
  async #initialize() {
    try {
      await Promise.all([
        this.#frameManager.initialize(this.#primaryTargetClient),
        this.#primaryTargetClient.send("Performance.enable"),
        this.#primaryTargetClient.send("Log.enable")
      ]);
    } catch (err) {
      if (isErrorLike(err) && isTargetClosedError(err)) {
        debugError(err);
      } else {
        throw err;
      }
    }
  }
  async #onFileChooser(event) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      if (!this.#fileChooserDeferreds.size) {
        return;
      }
      const frame = this.#frameManager.frame(event.frameId);
      assert5(frame, "This should never happen.");
      const handle = __addDisposableResource12(env_1, await frame.worlds[MAIN_WORLD].adoptBackendNode(event.backendNodeId), false);
      const fileChooser = new FileChooser(handle.move(), event);
      for (const promise4 of this.#fileChooserDeferreds) {
        promise4.resolve(fileChooser);
      }
      this.#fileChooserDeferreds.clear();
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources12(env_1);
    }
  }
  _client() {
    return this.#primaryTargetClient;
  }
  isServiceWorkerBypassed() {
    return this.#serviceWorkerBypassed;
  }
  isDragInterceptionEnabled() {
    return this.#userDragInterceptionEnabled;
  }
  isJavaScriptEnabled() {
    return this.#emulationManager.javascriptEnabled;
  }
  async waitForFileChooser(options = {}) {
    const needsEnable = this.#fileChooserDeferreds.size === 0;
    const { timeout: timeout6 = this._timeoutSettings.timeout() } = options;
    const deferred = Deferred.create({
      message: `Waiting for \`FileChooser\` failed: ${timeout6}ms exceeded`,
      timeout: timeout6
    });
    this.#fileChooserDeferreds.add(deferred);
    let enablePromise;
    if (needsEnable) {
      enablePromise = this.#primaryTargetClient.send("Page.setInterceptFileChooserDialog", {
        enabled: true
      });
    }
    try {
      const [result] = await Promise.all([
        deferred.valueOrThrow(),
        enablePromise
      ]);
      return result;
    } catch (error50) {
      this.#fileChooserDeferreds.delete(deferred);
      throw error50;
    }
  }
  async setGeolocation(options) {
    return await this.#emulationManager.setGeolocation(options);
  }
  target() {
    return this.#primaryTarget;
  }
  browser() {
    return this.#primaryTarget.browser();
  }
  browserContext() {
    return this.#primaryTarget.browserContext();
  }
  #onTargetCrashed() {
    this.emit("error", new Error("Page crashed!"));
  }
  #onLogEntryAdded(event) {
    const { level, text: text2, args: args2, source: source2, url: url3, lineNumber } = event.entry;
    if (args2) {
      args2.map((arg) => {
        void releaseObject(this.#primaryTargetClient, arg);
      });
    }
    if (source2 !== "worker") {
      this.emit("console", new ConsoleMessage(convertConsoleMessageLevel(level), text2, [], [{ url: url3, lineNumber }]));
    }
  }
  mainFrame() {
    return this.#frameManager.mainFrame();
  }
  get keyboard() {
    return this.#keyboard;
  }
  get touchscreen() {
    return this.#touchscreen;
  }
  get coverage() {
    return this.#coverage;
  }
  get tracing() {
    return this.#tracing;
  }
  frames() {
    return this.#frameManager.frames();
  }
  workers() {
    return Array.from(this.#workers.values());
  }
  async setRequestInterception(value3) {
    return await this.#frameManager.networkManager.setRequestInterception(value3);
  }
  async setBypassServiceWorker(bypass) {
    this.#serviceWorkerBypassed = bypass;
    return await this.#primaryTargetClient.send("Network.setBypassServiceWorker", { bypass });
  }
  async setDragInterception(enabled2) {
    this.#userDragInterceptionEnabled = enabled2;
    return await this.#primaryTargetClient.send("Input.setInterceptDrags", {
      enabled: enabled2
    });
  }
  async setOfflineMode(enabled2) {
    return await this.#frameManager.networkManager.setOfflineMode(enabled2);
  }
  async emulateNetworkConditions(networkConditions) {
    return await this.#frameManager.networkManager.emulateNetworkConditions(networkConditions);
  }
  setDefaultNavigationTimeout(timeout6) {
    this._timeoutSettings.setDefaultNavigationTimeout(timeout6);
  }
  setDefaultTimeout(timeout6) {
    this._timeoutSettings.setDefaultTimeout(timeout6);
  }
  getDefaultTimeout() {
    return this._timeoutSettings.timeout();
  }
  async queryObjects(prototypeHandle) {
    assert5(!prototypeHandle.disposed, "Prototype JSHandle is disposed!");
    assert5(prototypeHandle.id, "Prototype JSHandle must not be referencing primitive value");
    const response = await this.mainFrame().client.send("Runtime.queryObjects", {
      prototypeObjectId: prototypeHandle.id
    });
    return this.mainFrame().mainRealm().createCdpHandle(response.objects);
  }
  async cookies(...urls) {
    const originalCookies = (await this.#primaryTargetClient.send("Network.getCookies", {
      urls: urls.length ? urls : [this.url()]
    })).cookies;
    const unsupportedCookieAttributes = ["sourcePort"];
    const filterUnsupportedAttributes = /* @__PURE__ */ __name((cookie) => {
      for (const attr of unsupportedCookieAttributes) {
        delete cookie[attr];
      }
      return cookie;
    }, "filterUnsupportedAttributes");
    return originalCookies.map(filterUnsupportedAttributes);
  }
  async deleteCookie(...cookies) {
    const pageURL = this.url();
    for (const cookie of cookies) {
      const item = Object.assign({}, cookie);
      if (!cookie.url && pageURL.startsWith("http")) {
        item.url = pageURL;
      }
      await this.#primaryTargetClient.send("Network.deleteCookies", item);
    }
  }
  async setCookie(...cookies) {
    const pageURL = this.url();
    const startsWithHTTP = pageURL.startsWith("http");
    const items = cookies.map((cookie) => {
      const item = Object.assign({}, cookie);
      if (!item.url && startsWithHTTP) {
        item.url = pageURL;
      }
      assert5(item.url !== "about:blank", `Blank page can not have cookie "${item.name}"`);
      assert5(!String.prototype.startsWith.call(item.url || "", "data:"), `Data URL page can not have cookie "${item.name}"`);
      return item;
    });
    await this.deleteCookie(...items);
    if (items.length) {
      await this.#primaryTargetClient.send("Network.setCookies", {
        cookies: items
      });
    }
  }
  async exposeFunction(name, pptrFunction) {
    if (this.#bindings.has(name)) {
      throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);
    }
    const source2 = pageBindingInitString("exposedFun", name);
    let binding2;
    switch (typeof pptrFunction) {
      case "function":
        binding2 = new Binding(name, pptrFunction, source2);
        break;
      default:
        binding2 = new Binding(name, pptrFunction.default, source2);
        break;
    }
    this.#bindings.set(name, binding2);
    const [{ identifier: identifier2 }] = await Promise.all([
      this.#frameManager.evaluateOnNewDocument(source2),
      this.#frameManager.addExposedFunctionBinding(binding2)
    ]);
    this.#exposedFunctions.set(name, identifier2);
  }
  async removeExposedFunction(name) {
    const exposedFunctionId = this.#exposedFunctions.get(name);
    if (!exposedFunctionId) {
      throw new Error(`Function with name "${name}" does not exist`);
    }
    const binding2 = this.#bindings.get(name);
    this.#exposedFunctions.delete(name);
    this.#bindings.delete(name);
    await Promise.all([
      this.#frameManager.removeScriptToEvaluateOnNewDocument(exposedFunctionId),
      this.#frameManager.removeExposedFunctionBinding(binding2)
    ]);
  }
  async authenticate(credentials) {
    return await this.#frameManager.networkManager.authenticate(credentials);
  }
  async setExtraHTTPHeaders(headers) {
    return await this.#frameManager.networkManager.setExtraHTTPHeaders(headers);
  }
  async setUserAgent(userAgent, userAgentMetadata) {
    return await this.#frameManager.networkManager.setUserAgent(userAgent, userAgentMetadata);
  }
  async metrics() {
    const response = await this.#primaryTargetClient.send("Performance.getMetrics");
    return this.#buildMetricsObject(response.metrics);
  }
  #emitMetrics(event) {
    this.emit("metrics", {
      title: event.title,
      metrics: this.#buildMetricsObject(event.metrics)
    });
  }
  #buildMetricsObject(metrics) {
    const result = {};
    for (const metric of metrics || []) {
      if (supportedMetrics.has(metric.name)) {
        result[metric.name] = metric.value;
      }
    }
    return result;
  }
  #handleException(exception) {
    this.emit("pageerror", createClientError(exception.exceptionDetails));
  }
  #onConsoleAPI(world, event) {
    const values4 = event.args.map((arg) => {
      return world.createCdpHandle(arg);
    });
    this.#addConsoleMessage(convertConsoleMessageLevel(event.type), values4, event.stackTrace);
  }
  async #onBindingCalled(world, event) {
    let payload;
    try {
      payload = JSON.parse(event.payload);
    } catch {
      return;
    }
    const { type, name, seq: seq2, args: args2, isTrivial } = payload;
    if (type !== "exposedFun") {
      return;
    }
    const context10 = world.context;
    if (!context10) {
      return;
    }
    const binding2 = this.#bindings.get(name);
    await binding2?.run(context10, seq2, args2, isTrivial);
  }
  #addConsoleMessage(eventType, args2, stackTrace) {
    if (!this.listenerCount(
      "console"
      /* PageEvent.Console */
    )) {
      args2.forEach((arg) => {
        return arg.dispose();
      });
      return;
    }
    const textTokens = [];
    for (const arg of args2) {
      const remoteObject = arg.remoteObject();
      if (remoteObject.objectId) {
        textTokens.push(arg.toString());
      } else {
        textTokens.push(valueFromRemoteObject(remoteObject));
      }
    }
    const stackTraceLocations = [];
    if (stackTrace) {
      for (const callFrame of stackTrace.callFrames) {
        stackTraceLocations.push({
          url: callFrame.url,
          lineNumber: callFrame.lineNumber,
          columnNumber: callFrame.columnNumber
        });
      }
    }
    const message = new ConsoleMessage(convertConsoleMessageLevel(eventType), textTokens.join(" "), args2, stackTraceLocations);
    this.emit("console", message);
  }
  #onDialog(event) {
    const type = validateDialogType(event.type);
    const dialog = new CdpDialog(this.#primaryTargetClient, type, event.message, event.defaultPrompt);
    this.emit("dialog", dialog);
  }
  async reload(options) {
    const [result] = await Promise.all([
      this.waitForNavigation({
        ...options,
        ignoreSameDocumentNavigation: true
      }),
      this.#primaryTargetClient.send("Page.reload")
    ]);
    return result;
  }
  async createCDPSession() {
    return await this.target().createCDPSession();
  }
  async goBack(options = {}) {
    return await this.#go(-1, options);
  }
  async goForward(options = {}) {
    return await this.#go(1, options);
  }
  async #go(delta, options) {
    const history2 = await this.#primaryTargetClient.send("Page.getNavigationHistory");
    const entry = history2.entries[history2.currentIndex + delta];
    if (!entry) {
      return null;
    }
    const result = await Promise.all([
      this.waitForNavigation(options),
      this.#primaryTargetClient.send("Page.navigateToHistoryEntry", {
        entryId: entry.id
      })
    ]);
    return result[0];
  }
  async bringToFront() {
    await this.#primaryTargetClient.send("Page.bringToFront");
  }
  async setJavaScriptEnabled(enabled2) {
    return await this.#emulationManager.setJavaScriptEnabled(enabled2);
  }
  async setBypassCSP(enabled2) {
    await this.#primaryTargetClient.send("Page.setBypassCSP", { enabled: enabled2 });
  }
  async emulateMediaType(type) {
    return await this.#emulationManager.emulateMediaType(type);
  }
  async emulateCPUThrottling(factor) {
    return await this.#emulationManager.emulateCPUThrottling(factor);
  }
  async emulateMediaFeatures(features2) {
    return await this.#emulationManager.emulateMediaFeatures(features2);
  }
  async emulateTimezone(timezoneId) {
    return await this.#emulationManager.emulateTimezone(timezoneId);
  }
  async emulateIdleState(overrides) {
    return await this.#emulationManager.emulateIdleState(overrides);
  }
  async emulateVisionDeficiency(type) {
    return await this.#emulationManager.emulateVisionDeficiency(type);
  }
  async setViewport(viewport) {
    const needsReload = await this.#emulationManager.emulateViewport(viewport);
    this.#viewport = viewport;
    if (needsReload) {
      await this.reload();
    }
  }
  viewport() {
    return this.#viewport;
  }
  async evaluateOnNewDocument(pageFunction, ...args2) {
    const source2 = evaluationString(pageFunction, ...args2);
    return await this.#frameManager.evaluateOnNewDocument(source2);
  }
  async removeScriptToEvaluateOnNewDocument(identifier2) {
    return await this.#frameManager.removeScriptToEvaluateOnNewDocument(identifier2);
  }
  async setCacheEnabled(enabled2 = true) {
    await this.#frameManager.networkManager.setCacheEnabled(enabled2);
  }
  async _screenshot(options) {
    const env_2 = { stack: [], error: void 0, hasError: false };
    try {
      const { fromSurface, omitBackground, optimizeForSpeed, quality, clip: userClip, type, captureBeyondViewport } = options;
      const isFirefox = this.target()._targetManager() instanceof FirefoxTargetManager;
      const stack = __addDisposableResource12(env_2, new AsyncDisposableStack(), true);
      if (!isFirefox && omitBackground && (type === "png" || type === "webp")) {
        await this.#emulationManager.setTransparentBackgroundColor();
        stack.defer(async () => {
          await this.#emulationManager.resetDefaultBackgroundColor().catch(debugError);
        });
      }
      let clip = userClip;
      if (clip && !captureBeyondViewport) {
        const viewport = await this.mainFrame().isolatedRealm().evaluate(() => {
          const { height, pageLeft: x, pageTop: y, width } = window.visualViewport;
          return { x, y, height, width };
        });
        clip = getIntersectionRect(clip, viewport);
      }
      const { data } = await this.#primaryTargetClient.send("Page.captureScreenshot", {
        format: type,
        ...optimizeForSpeed ? { optimizeForSpeed } : {},
        ...quality !== void 0 ? { quality: Math.round(quality) } : {},
        ...clip ? { clip: { ...clip, scale: clip.scale ?? 1 } } : {},
        ...!fromSurface ? { fromSurface } : {},
        captureBeyondViewport
      });
      return data;
    } catch (e_2) {
      env_2.error = e_2;
      env_2.hasError = true;
    } finally {
      const result_1 = __disposeResources12(env_2);
      if (result_1)
        await result_1;
    }
  }
  async createPDFStream(options = {}) {
    const { timeout: ms = this._timeoutSettings.timeout() } = options;
    const { landscape, displayHeaderFooter, headerTemplate, footerTemplate, printBackground, scale: scale2, width: paperWidth, height: paperHeight, margin, pageRanges, preferCSSPageSize, omitBackground, tagged: generateTaggedPDF, outline: generateDocumentOutline, waitForFonts } = parsePDFOptions(options);
    if (omitBackground) {
      await this.#emulationManager.setTransparentBackgroundColor();
    }
    if (waitForFonts) {
      await firstValueFrom(from(this.mainFrame().isolatedRealm().evaluate(() => {
        return document.fonts.ready;
      })).pipe(raceWith4(timeout5(ms))));
    }
    const printCommandPromise = this.#primaryTargetClient.send("Page.printToPDF", {
      transferMode: "ReturnAsStream",
      landscape,
      displayHeaderFooter,
      headerTemplate,
      footerTemplate,
      printBackground,
      scale: scale2,
      paperWidth,
      paperHeight,
      marginTop: margin.top,
      marginBottom: margin.bottom,
      marginLeft: margin.left,
      marginRight: margin.right,
      pageRanges,
      preferCSSPageSize,
      generateTaggedPDF,
      generateDocumentOutline
    });
    const result = await firstValueFrom(from(printCommandPromise).pipe(raceWith4(timeout5(ms))));
    if (omitBackground) {
      await this.#emulationManager.resetDefaultBackgroundColor();
    }
    assert5(result.stream, "`stream` is missing from `Page.printToPDF");
    return await getReadableFromProtocolStream(this.#primaryTargetClient, result.stream);
  }
  async pdf(options = {}) {
    const { path = void 0 } = options;
    const readable = await this.createPDFStream(options);
    const buffer3 = await getReadableAsBuffer(readable, path);
    assert5(buffer3, "Could not create buffer");
    return buffer3;
  }
  async close(options = { runBeforeUnload: void 0 }) {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
      const _guard = __addDisposableResource12(env_3, await this.browserContext().waitForScreenshotOperations(), false);
      const connection = this.#primaryTargetClient.connection();
      assert5(connection, "Protocol error: Connection closed. Most likely the page has been closed.");
      const runBeforeUnload = !!options.runBeforeUnload;
      if (runBeforeUnload) {
        await this.#primaryTargetClient.send("Page.close");
      } else {
        await connection.send("Target.closeTarget", {
          targetId: this.#primaryTarget._targetId
        });
        await this.#tabTarget._isClosedDeferred.valueOrThrow();
      }
    } catch (e_3) {
      env_3.error = e_3;
      env_3.hasError = true;
    } finally {
      __disposeResources12(env_3);
    }
  }
  isClosed() {
    return this.#closed;
  }
  get mouse() {
    return this.#mouse;
  }
  /**
   * This method is typically coupled with an action that triggers a device
   * request from an api such as WebBluetooth.
   *
   * :::caution
   *
   * This must be called before the device request is made. It will not return a
   * currently active device prompt.
   *
   * :::
   *
   * @example
   *
   * ```ts
   * const [devicePrompt] = Promise.all([
   *   page.waitForDevicePrompt(),
   *   page.click('#connect-bluetooth'),
   * ]);
   * await devicePrompt.select(
   *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))
   * );
   * ```
   */
  async waitForDevicePrompt(options = {}) {
    return await this.mainFrame().waitForDevicePrompt(options);
  }
};
var supportedMetrics = /* @__PURE__ */ new Set([
  "Timestamp",
  "Documents",
  "Frames",
  "JSEventListeners",
  "Nodes",
  "LayoutCount",
  "RecalcStyleCount",
  "LayoutDuration",
  "RecalcStyleDuration",
  "ScriptDuration",
  "TaskDuration",
  "JSHeapUsedSize",
  "JSHeapTotalSize"
]);
function getIntersectionRect(clip, viewport) {
  const x = Math.max(clip.x, viewport.x);
  const y = Math.max(clip.y, viewport.y);
  return {
    x,
    y,
    width: Math.max(Math.min(clip.x + clip.width, viewport.x + viewport.width) - x, 0),
    height: Math.max(Math.min(clip.y + clip.height, viewport.y + viewport.height) - y, 0)
  };
}
__name(getIntersectionRect, "getIntersectionRect");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Target.js
var InitializationStatus;
(function(InitializationStatus2) {
  InitializationStatus2["SUCCESS"] = "success";
  InitializationStatus2["ABORTED"] = "aborted";
})(InitializationStatus || (InitializationStatus = {}));
var CdpTarget = class extends Target {
  static {
    __name(this, "CdpTarget");
  }
  #browserContext;
  #session;
  #targetInfo;
  #targetManager;
  #sessionFactory;
  #childTargets = /* @__PURE__ */ new Set();
  _initializedDeferred = Deferred.create();
  _isClosedDeferred = Deferred.create();
  _targetId;
  /**
   * To initialize the target for use, call initialize.
   *
   * @internal
   */
  constructor(targetInfo, session, browserContext, targetManager, sessionFactory) {
    super();
    this.#session = session;
    this.#targetManager = targetManager;
    this.#targetInfo = targetInfo;
    this.#browserContext = browserContext;
    this._targetId = targetInfo.targetId;
    this.#sessionFactory = sessionFactory;
    if (this.#session && this.#session instanceof CdpCDPSession) {
      this.#session._setTarget(this);
    }
  }
  async asPage() {
    const session = this._session();
    if (!session) {
      return await this.createCDPSession().then((client) => {
        return CdpPage._create(client, this, null);
      });
    }
    return await CdpPage._create(session, this, null);
  }
  _subtype() {
    return this.#targetInfo.subtype;
  }
  _session() {
    return this.#session;
  }
  _addChildTarget(target) {
    this.#childTargets.add(target);
  }
  _removeChildTarget(target) {
    this.#childTargets.delete(target);
  }
  _childTargets() {
    return this.#childTargets;
  }
  _sessionFactory() {
    if (!this.#sessionFactory) {
      throw new Error("sessionFactory is not initialized");
    }
    return this.#sessionFactory;
  }
  createCDPSession() {
    if (!this.#sessionFactory) {
      throw new Error("sessionFactory is not initialized");
    }
    return this.#sessionFactory(false).then((session) => {
      session._setTarget(this);
      return session;
    });
  }
  url() {
    return this.#targetInfo.url;
  }
  type() {
    const type = this.#targetInfo.type;
    switch (type) {
      case "page":
        return TargetType.PAGE;
      case "background_page":
        return TargetType.BACKGROUND_PAGE;
      case "service_worker":
        return TargetType.SERVICE_WORKER;
      case "shared_worker":
        return TargetType.SHARED_WORKER;
      case "browser":
        return TargetType.BROWSER;
      case "webview":
        return TargetType.WEBVIEW;
      case "tab":
        return TargetType.TAB;
      default:
        return TargetType.OTHER;
    }
  }
  _targetManager() {
    if (!this.#targetManager) {
      throw new Error("targetManager is not initialized");
    }
    return this.#targetManager;
  }
  _getTargetInfo() {
    return this.#targetInfo;
  }
  browser() {
    if (!this.#browserContext) {
      throw new Error("browserContext is not initialized");
    }
    return this.#browserContext.browser();
  }
  browserContext() {
    if (!this.#browserContext) {
      throw new Error("browserContext is not initialized");
    }
    return this.#browserContext;
  }
  opener() {
    const { openerId } = this.#targetInfo;
    if (!openerId) {
      return;
    }
    return this.browser().targets().find((target) => {
      return target._targetId === openerId;
    });
  }
  _targetInfoChanged(targetInfo) {
    this.#targetInfo = targetInfo;
    this._checkIfInitialized();
  }
  _initialize() {
    this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
  }
  _isTargetExposed() {
    return this.type() !== TargetType.TAB && !this._subtype();
  }
  _checkIfInitialized() {
    if (!this._initializedDeferred.resolved()) {
      this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
    }
  }
};
var PageTarget = class _PageTarget extends CdpTarget {
  static {
    __name(this, "PageTarget");
  }
  #defaultViewport;
  pagePromise;
  constructor(targetInfo, session, browserContext, targetManager, sessionFactory, defaultViewport) {
    super(targetInfo, session, browserContext, targetManager, sessionFactory);
    this.#defaultViewport = defaultViewport ?? void 0;
  }
  _initialize() {
    this._initializedDeferred.valueOrThrow().then(async (result) => {
      if (result === InitializationStatus.ABORTED) {
        return;
      }
      const opener = this.opener();
      if (!(opener instanceof _PageTarget)) {
        return;
      }
      if (!opener || !opener.pagePromise || this.type() !== "page") {
        return true;
      }
      const openerPage = await opener.pagePromise;
      if (!openerPage.listenerCount(
        "popup"
        /* PageEvent.Popup */
      )) {
        return true;
      }
      const popupPage = await this.page();
      openerPage.emit("popup", popupPage);
      return true;
    }).catch(debugError);
    this._checkIfInitialized();
  }
  async page() {
    if (!this.pagePromise) {
      const session = this._session();
      this.pagePromise = (session ? Promise.resolve(session) : this._sessionFactory()(
        /* isAutoAttachEmulated=*/
        false
      )).then((client) => {
        return CdpPage._create(client, this, this.#defaultViewport ?? null);
      });
    }
    return await this.pagePromise ?? null;
  }
  _checkIfInitialized() {
    if (this._initializedDeferred.resolved()) {
      return;
    }
    if (this._getTargetInfo().url !== "") {
      this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
    }
  }
};
var DevToolsTarget = class extends PageTarget {
  static {
    __name(this, "DevToolsTarget");
  }
};
var WorkerTarget = class extends CdpTarget {
  static {
    __name(this, "WorkerTarget");
  }
  #workerPromise;
  async worker() {
    if (!this.#workerPromise) {
      const session = this._session();
      this.#workerPromise = (session ? Promise.resolve(session) : this._sessionFactory()(
        /* isAutoAttachEmulated=*/
        false
      )).then((client) => {
        return new CdpWebWorker(
          client,
          this._getTargetInfo().url,
          this._targetId,
          this.type(),
          () => {
          },
          () => {
          }
          /* exceptionThrown */
        );
      });
    }
    return await this.#workerPromise;
  }
};
var OtherTarget = class extends CdpTarget {
  static {
    __name(this, "OtherTarget");
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/ChromeTargetManager.js
function isPageTargetBecomingPrimary(target, newTargetInfo) {
  return Boolean(target._subtype()) && !newTargetInfo.subtype;
}
__name(isPageTargetBecomingPrimary, "isPageTargetBecomingPrimary");
var ChromeTargetManager = class extends EventEmitter2 {
  static {
    __name(this, "ChromeTargetManager");
  }
  #connection;
  /**
   * Keeps track of the following events: 'Target.targetCreated',
   * 'Target.targetDestroyed', 'Target.targetInfoChanged'.
   *
   * A target becomes discovered when 'Target.targetCreated' is received.
   * A target is removed from this map once 'Target.targetDestroyed' is
   * received.
   *
   * `targetFilterCallback` has no effect on this map.
   */
  #discoveredTargetsByTargetId = /* @__PURE__ */ new Map();
  /**
   * A target is added to this map once ChromeTargetManager has created
   * a Target and attached at least once to it.
   */
  #attachedTargetsByTargetId = /* @__PURE__ */ new Map();
  /**
   * Tracks which sessions attach to which target.
   */
  #attachedTargetsBySessionId = /* @__PURE__ */ new Map();
  /**
   * If a target was filtered out by `targetFilterCallback`, we still receive
   * events about it from CDP, but we don't forward them to the rest of Puppeteer.
   */
  #ignoredTargets = /* @__PURE__ */ new Set();
  #targetFilterCallback;
  #targetFactory;
  #attachedToTargetListenersBySession = /* @__PURE__ */ new WeakMap();
  #detachedFromTargetListenersBySession = /* @__PURE__ */ new WeakMap();
  #initializeDeferred = Deferred.create();
  #targetsIdsForInit = /* @__PURE__ */ new Set();
  #waitForInitiallyDiscoveredTargets = true;
  #discoveryFilter = [{}];
  constructor(connection, targetFactory, targetFilterCallback, waitForInitiallyDiscoveredTargets = true) {
    super();
    this.#connection = connection;
    this.#targetFilterCallback = targetFilterCallback;
    this.#targetFactory = targetFactory;
    this.#waitForInitiallyDiscoveredTargets = waitForInitiallyDiscoveredTargets;
    this.#connection.on("Target.targetCreated", this.#onTargetCreated);
    this.#connection.on("Target.targetDestroyed", this.#onTargetDestroyed);
    this.#connection.on("Target.targetInfoChanged", this.#onTargetInfoChanged);
    this.#connection.on(CDPSessionEvent.SessionDetached, this.#onSessionDetached);
    this.#setupAttachmentListeners(this.#connection);
  }
  #storeExistingTargetsForInit = /* @__PURE__ */ __name(() => {
    if (!this.#waitForInitiallyDiscoveredTargets) {
      return;
    }
    for (const [targetId, targetInfo] of this.#discoveredTargetsByTargetId.entries()) {
      const targetForFilter = new CdpTarget(targetInfo, void 0, void 0, this, void 0);
      const skipTarget = targetInfo.type === "browser" || targetInfo.url.startsWith("chrome-extension://");
      if ((!this.#targetFilterCallback || this.#targetFilterCallback(targetForFilter)) && !skipTarget) {
        this.#targetsIdsForInit.add(targetId);
      }
    }
  }, "#storeExistingTargetsForInit");
  async initialize() {
    await this.#connection.send("Target.setDiscoverTargets", {
      discover: true,
      filter: this.#discoveryFilter
    });
    this.#storeExistingTargetsForInit();
    await this.#connection.send("Target.setAutoAttach", {
      waitForDebuggerOnStart: true,
      flatten: true,
      autoAttach: true,
      filter: [
        {
          type: "page",
          exclude: true
        },
        ...this.#discoveryFilter
      ]
    });
    this.#finishInitializationIfReady();
    await this.#initializeDeferred.valueOrThrow();
  }
  getChildTargets(target) {
    return target._childTargets();
  }
  dispose() {
    this.#connection.off("Target.targetCreated", this.#onTargetCreated);
    this.#connection.off("Target.targetDestroyed", this.#onTargetDestroyed);
    this.#connection.off("Target.targetInfoChanged", this.#onTargetInfoChanged);
    this.#connection.off(CDPSessionEvent.SessionDetached, this.#onSessionDetached);
    this.#removeAttachmentListeners(this.#connection);
  }
  getAvailableTargets() {
    return this.#attachedTargetsByTargetId;
  }
  #setupAttachmentListeners(session) {
    const listener = /* @__PURE__ */ __name((event) => {
      void this.#onAttachedToTarget(session, event);
    }, "listener");
    assert5(!this.#attachedToTargetListenersBySession.has(session));
    this.#attachedToTargetListenersBySession.set(session, listener);
    session.on("Target.attachedToTarget", listener);
    const detachedListener = /* @__PURE__ */ __name((event) => {
      return this.#onDetachedFromTarget(session, event);
    }, "detachedListener");
    assert5(!this.#detachedFromTargetListenersBySession.has(session));
    this.#detachedFromTargetListenersBySession.set(session, detachedListener);
    session.on("Target.detachedFromTarget", detachedListener);
  }
  #removeAttachmentListeners(session) {
    const listener = this.#attachedToTargetListenersBySession.get(session);
    if (listener) {
      session.off("Target.attachedToTarget", listener);
      this.#attachedToTargetListenersBySession.delete(session);
    }
    if (this.#detachedFromTargetListenersBySession.has(session)) {
      session.off("Target.detachedFromTarget", this.#detachedFromTargetListenersBySession.get(session));
      this.#detachedFromTargetListenersBySession.delete(session);
    }
  }
  #onSessionDetached = /* @__PURE__ */ __name((session) => {
    this.#removeAttachmentListeners(session);
  }, "#onSessionDetached");
  #onTargetCreated = /* @__PURE__ */ __name(async (event) => {
    this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
    this.emit("targetDiscovered", event.targetInfo);
    if (event.targetInfo.type === "browser" && event.targetInfo.attached) {
      if (this.#attachedTargetsByTargetId.has(event.targetInfo.targetId)) {
        return;
      }
      const target = this.#targetFactory(event.targetInfo, void 0);
      target._initialize();
      this.#attachedTargetsByTargetId.set(event.targetInfo.targetId, target);
    }
  }, "#onTargetCreated");
  #onTargetDestroyed = /* @__PURE__ */ __name((event) => {
    const targetInfo = this.#discoveredTargetsByTargetId.get(event.targetId);
    this.#discoveredTargetsByTargetId.delete(event.targetId);
    this.#finishInitializationIfReady(event.targetId);
    if (targetInfo?.type === "service_worker" && this.#attachedTargetsByTargetId.has(event.targetId)) {
      const target = this.#attachedTargetsByTargetId.get(event.targetId);
      if (target) {
        this.emit("targetGone", target);
        this.#attachedTargetsByTargetId.delete(event.targetId);
      }
    }
  }, "#onTargetDestroyed");
  #onTargetInfoChanged = /* @__PURE__ */ __name((event) => {
    this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
    if (this.#ignoredTargets.has(event.targetInfo.targetId) || !this.#attachedTargetsByTargetId.has(event.targetInfo.targetId) || !event.targetInfo.attached) {
      return;
    }
    const target = this.#attachedTargetsByTargetId.get(event.targetInfo.targetId);
    if (!target) {
      return;
    }
    const previousURL = target.url();
    const wasInitialized = target._initializedDeferred.value() === InitializationStatus.SUCCESS;
    if (isPageTargetBecomingPrimary(target, event.targetInfo)) {
      const session = target?._session();
      assert5(session, "Target that is being activated is missing a CDPSession.");
      session.parentSession()?.emit(CDPSessionEvent.Swapped, session);
    }
    target._targetInfoChanged(event.targetInfo);
    if (wasInitialized && previousURL !== target.url()) {
      this.emit("targetChanged", {
        target,
        wasInitialized,
        previousURL
      });
    }
  }, "#onTargetInfoChanged");
  #onAttachedToTarget = /* @__PURE__ */ __name(async (parentSession, event) => {
    const targetInfo = event.targetInfo;
    const session = this.#connection.session(event.sessionId);
    if (!session) {
      throw new Error(`Session ${event.sessionId} was not created.`);
    }
    const silentDetach = /* @__PURE__ */ __name(async () => {
      await session.send("Runtime.runIfWaitingForDebugger").catch(debugError);
      await parentSession.send("Target.detachFromTarget", {
        sessionId: session.id()
      }).catch(debugError);
    }, "silentDetach");
    if (!this.#connection.isAutoAttached(targetInfo.targetId)) {
      return;
    }
    if (targetInfo.type === "service_worker") {
      this.#finishInitializationIfReady(targetInfo.targetId);
      await silentDetach();
      if (this.#attachedTargetsByTargetId.has(targetInfo.targetId)) {
        return;
      }
      const target2 = this.#targetFactory(targetInfo);
      target2._initialize();
      this.#attachedTargetsByTargetId.set(targetInfo.targetId, target2);
      this.emit("targetAvailable", target2);
      return;
    }
    const isExistingTarget = this.#attachedTargetsByTargetId.has(targetInfo.targetId);
    const target = isExistingTarget ? this.#attachedTargetsByTargetId.get(targetInfo.targetId) : this.#targetFactory(targetInfo, session, parentSession instanceof CDPSession ? parentSession : void 0);
    if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {
      this.#ignoredTargets.add(targetInfo.targetId);
      this.#finishInitializationIfReady(targetInfo.targetId);
      await silentDetach();
      return;
    }
    this.#setupAttachmentListeners(session);
    if (isExistingTarget) {
      session._setTarget(target);
      this.#attachedTargetsBySessionId.set(session.id(), this.#attachedTargetsByTargetId.get(targetInfo.targetId));
    } else {
      target._initialize();
      this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);
      this.#attachedTargetsBySessionId.set(session.id(), target);
    }
    const parentTarget = parentSession instanceof CDPSession ? parentSession._target() : null;
    parentTarget?._addChildTarget(target);
    parentSession.emit(CDPSessionEvent.Ready, session);
    this.#targetsIdsForInit.delete(target._targetId);
    if (!isExistingTarget) {
      this.emit("targetAvailable", target);
    }
    this.#finishInitializationIfReady();
    await Promise.all([
      session.send("Target.setAutoAttach", {
        waitForDebuggerOnStart: true,
        flatten: true,
        autoAttach: true,
        filter: this.#discoveryFilter
      }),
      session.send("Runtime.runIfWaitingForDebugger")
    ]).catch(debugError);
  }, "#onAttachedToTarget");
  #finishInitializationIfReady(targetId) {
    targetId !== void 0 && this.#targetsIdsForInit.delete(targetId);
    if (this.#targetsIdsForInit.size === 0) {
      this.#initializeDeferred.resolve();
    }
  }
  #onDetachedFromTarget = /* @__PURE__ */ __name((parentSession, event) => {
    const target = this.#attachedTargetsBySessionId.get(event.sessionId);
    this.#attachedTargetsBySessionId.delete(event.sessionId);
    if (!target) {
      return;
    }
    if (parentSession instanceof CDPSession) {
      parentSession._target()._removeChildTarget(target);
    }
    this.#attachedTargetsByTargetId.delete(target._targetId);
    this.emit("targetGone", target);
  }, "#onDetachedFromTarget");
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Browser.js
var CdpBrowser = class _CdpBrowser extends Browser {
  static {
    __name(this, "CdpBrowser");
  }
  protocol = "cdp";
  static async _create(product2, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process4, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true, sessionId) {
    const browser = new _CdpBrowser(product2, connection, contextIds, defaultViewport, process4, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets, sessionId);
    if (ignoreHTTPSErrors) {
      await connection.send("Security.setIgnoreCertificateErrors", {
        ignore: true
      });
    }
    await browser._attach();
    return browser;
  }
  #defaultViewport;
  #process;
  #connection;
  #closeCallback;
  #targetFilterCallback;
  #isPageTargetCallback;
  #defaultContext;
  #contexts = /* @__PURE__ */ new Map();
  #targetManager;
  #sessionId;
  constructor(product2, connection, contextIds, defaultViewport, process4, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true, sessionId) {
    super();
    product2 = product2 || "chrome";
    this.#defaultViewport = defaultViewport;
    this.#process = process4;
    this.#connection = connection;
    this.#closeCallback = closeCallback || (() => {
    });
    this.#targetFilterCallback = targetFilterCallback || (() => {
      return true;
    });
    this.#setIsPageTargetCallback(isPageTargetCallback);
    if (product2 === "firefox") {
      this.#targetManager = new FirefoxTargetManager(connection, this.#createTarget, this.#targetFilterCallback);
    } else {
      this.#targetManager = new ChromeTargetManager(connection, this.#createTarget, this.#targetFilterCallback, waitForInitiallyDiscoveredTargets);
    }
    this.#defaultContext = new CdpBrowserContext(this.#connection, this);
    for (const contextId of contextIds) {
      this.#contexts.set(contextId, new CdpBrowserContext(this.#connection, this, contextId));
    }
    this.#sessionId = sessionId || "unknown";
  }
  #emitDisconnected = /* @__PURE__ */ __name(() => {
    this.emit("disconnected", void 0);
  }, "#emitDisconnected");
  async _attach() {
    this.#connection.on(CDPSessionEvent.Disconnected, this.#emitDisconnected);
    this.#targetManager.on("targetAvailable", this.#onAttachedToTarget);
    this.#targetManager.on("targetGone", this.#onDetachedFromTarget);
    this.#targetManager.on("targetChanged", this.#onTargetChanged);
    this.#targetManager.on("targetDiscovered", this.#onTargetDiscovered);
    await this.#targetManager.initialize();
  }
  _detach() {
    this.#connection.off(CDPSessionEvent.Disconnected, this.#emitDisconnected);
    this.#targetManager.off("targetAvailable", this.#onAttachedToTarget);
    this.#targetManager.off("targetGone", this.#onDetachedFromTarget);
    this.#targetManager.off("targetChanged", this.#onTargetChanged);
    this.#targetManager.off("targetDiscovered", this.#onTargetDiscovered);
  }
  process() {
    return this.#process ?? null;
  }
  _targetManager() {
    return this.#targetManager;
  }
  #setIsPageTargetCallback(isPageTargetCallback) {
    this.#isPageTargetCallback = isPageTargetCallback || ((target) => {
      return target.type() === "page" || target.type() === "background_page" || target.type() === "webview";
    });
  }
  _getIsPageTargetCallback() {
    return this.#isPageTargetCallback;
  }
  async createBrowserContext(options = {}) {
    const { proxyServer, proxyBypassList } = options;
    const { browserContextId } = await this.#connection.send("Target.createBrowserContext", {
      proxyServer,
      proxyBypassList: proxyBypassList && proxyBypassList.join(",")
    });
    const context10 = new CdpBrowserContext(this.#connection, this, browserContextId);
    this.#contexts.set(browserContextId, context10);
    return context10;
  }
  browserContexts() {
    return [this.#defaultContext, ...Array.from(this.#contexts.values())];
  }
  defaultBrowserContext() {
    return this.#defaultContext;
  }
  async _disposeContext(contextId) {
    if (!contextId) {
      return;
    }
    await this.#connection.send("Target.disposeBrowserContext", {
      browserContextId: contextId
    });
    this.#contexts.delete(contextId);
  }
  #createTarget = /* @__PURE__ */ __name((targetInfo, session) => {
    const { browserContextId } = targetInfo;
    const context10 = browserContextId && this.#contexts.has(browserContextId) ? this.#contexts.get(browserContextId) : this.#defaultContext;
    if (!context10) {
      throw new Error("Missing browser context");
    }
    const createSession = /* @__PURE__ */ __name((isAutoAttachEmulated) => {
      return this.#connection._createSession(targetInfo, isAutoAttachEmulated);
    }, "createSession");
    const otherTarget = new OtherTarget(targetInfo, session, context10, this.#targetManager, createSession);
    if (targetInfo.url?.startsWith("devtools://")) {
      return new DevToolsTarget(targetInfo, session, context10, this.#targetManager, createSession, this.#defaultViewport ?? null);
    }
    if (this.#isPageTargetCallback(otherTarget)) {
      return new PageTarget(targetInfo, session, context10, this.#targetManager, createSession, this.#defaultViewport ?? null);
    }
    if (targetInfo.type === "service_worker" || targetInfo.type === "shared_worker") {
      return new WorkerTarget(targetInfo, session, context10, this.#targetManager, createSession);
    }
    return otherTarget;
  }, "#createTarget");
  #onAttachedToTarget = /* @__PURE__ */ __name(async (target) => {
    if (target._isTargetExposed() && await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS) {
      this.emit("targetcreated", target);
      target.browserContext().emit("targetcreated", target);
    }
  }, "#onAttachedToTarget");
  #onDetachedFromTarget = /* @__PURE__ */ __name(async (target) => {
    target._initializedDeferred.resolve(InitializationStatus.ABORTED);
    target._isClosedDeferred.resolve();
    if (target._isTargetExposed() && await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS) {
      this.emit("targetdestroyed", target);
      target.browserContext().emit("targetdestroyed", target);
    }
  }, "#onDetachedFromTarget");
  #onTargetChanged = /* @__PURE__ */ __name(({ target }) => {
    this.emit("targetchanged", target);
    target.browserContext().emit("targetchanged", target);
  }, "#onTargetChanged");
  #onTargetDiscovered = /* @__PURE__ */ __name((targetInfo) => {
    this.emit("targetdiscovered", targetInfo);
  }, "#onTargetDiscovered");
  wsEndpoint() {
    return this.#connection.url();
  }
  async newPage() {
    return await this.#defaultContext.newPage();
  }
  async _createPageInContext(contextId) {
    const { targetId } = await this.#connection.send("Target.createTarget", {
      url: "about:blank",
      browserContextId: contextId || void 0
    });
    const target = await this.waitForTarget((t) => {
      return t._targetId === targetId;
    });
    if (!target) {
      throw new Error(`Missing target for page (id = ${targetId})`);
    }
    const initialized = await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS;
    if (!initialized) {
      throw new Error(`Failed to create target for page (id = ${targetId})`);
    }
    const page = await target.page();
    if (!page) {
      throw new Error(`Failed to create a page for context (id = ${contextId})`);
    }
    return page;
  }
  targets() {
    return Array.from(this.#targetManager.getAvailableTargets().values()).filter((target) => {
      return target._isTargetExposed() && target._initializedDeferred.value() === InitializationStatus.SUCCESS;
    });
  }
  target() {
    const browserTarget = this.targets().find((target) => {
      return target.type() === "browser";
    });
    if (!browserTarget) {
      throw new Error("Browser target is not found");
    }
    return browserTarget;
  }
  async version() {
    const version4 = await this.#getVersion();
    return version4.product;
  }
  async userAgent() {
    const version4 = await this.#getVersion();
    return version4.userAgent;
  }
  async close() {
    await this.#closeCallback.call(null);
    await this.disconnect();
  }
  disconnect() {
    this.#targetManager.dispose();
    this.#connection.dispose();
    this._detach();
    return Promise.resolve();
  }
  get connected() {
    return !this.#connection._closed;
  }
  #getVersion() {
    return this.#connection.send("Browser.getVersion");
  }
  get debugInfo() {
    return {
      pendingProtocolErrors: this.#connection.getPendingProtocolErrors()
    };
  }
  /**
   * Get the BISO session ID associated with this browser
   * @public
   */
  sessionId() {
    return this.#sessionId;
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cdp/BrowserConnector.js
async function _connectToCdpBrowser(connectionTransport, url3, options) {
  const { ignoreHTTPSErrors = false, defaultViewport = DEFAULT_VIEWPORT, targetFilter, _isPageTarget: isPageTarget, slowMo = 0, protocolTimeout } = options;
  const connection = new Connection(url3, connectionTransport, slowMo, protocolTimeout);
  const version4 = await connection.send("Browser.getVersion");
  const product2 = version4.product.toLowerCase().includes("firefox") ? "firefox" : "chrome";
  const { browserContextIds } = await connection.send("Target.getBrowserContexts");
  const browser = await CdpBrowser._create(product2 || "chrome", connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, void 0, () => {
    return connection.send("Browser.close").catch(debugError);
  }, targetFilter, isPageTarget);
  return browser;
}
__name(_connectToCdpBrowser, "_connectToCdpBrowser");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/BrowserConnector.js
var getWebSocketTransportClass = /* @__PURE__ */ __name(async () => {
  return isNode ? (await Promise.resolve().then(() => (init_NodeWebSocketTransport(), NodeWebSocketTransport_exports))).NodeWebSocketTransport : (await Promise.resolve().then(() => (init_BrowserWebSocketTransport(), BrowserWebSocketTransport_exports))).BrowserWebSocketTransport;
}, "getWebSocketTransportClass");
async function _connectToBrowser(options) {
  const { connectionTransport, endpointUrl } = await getConnectionTransport(options);
  const cdpBrowser = await _connectToCdpBrowser(connectionTransport, endpointUrl, options);
  return cdpBrowser;
}
__name(_connectToBrowser, "_connectToBrowser");
async function getConnectionTransport(options) {
  const { browserWSEndpoint, browserURL, transport, headers = {} } = options;
  assert5(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) === 1, "Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect");
  if (transport) {
    return { connectionTransport: transport, endpointUrl: "" };
  } else if (browserWSEndpoint) {
    const WebSocketClass = await getWebSocketTransportClass();
    const connectionTransport = await WebSocketClass.create(browserWSEndpoint, headers);
    return {
      connectionTransport,
      endpointUrl: browserWSEndpoint
    };
  } else if (browserURL) {
    const connectionURL = await getWSEndpoint(browserURL);
    const WebSocketClass = await getWebSocketTransportClass();
    const connectionTransport = await WebSocketClass.create(connectionURL);
    return {
      connectionTransport,
      endpointUrl: connectionURL
    };
  }
  throw new Error("Invalid connection options");
}
__name(getConnectionTransport, "getConnectionTransport");
async function getWSEndpoint(browserURL) {
  const endpointURL = new URL("/json/version", browserURL);
  try {
    const result = await globalThis.fetch(endpointURL.toString(), {
      method: "GET"
    });
    if (!result.ok) {
      throw new Error(`HTTP ${result.statusText}`);
    }
    const data = await result.json();
    return data.webSocketDebuggerUrl;
  } catch (error50) {
    if (isErrorLike(error50)) {
      error50.message = `Failed to fetch browser webSocket URL from ${endpointURL}: ` + error50.message;
    }
    throw error50;
  }
}
__name(getWSEndpoint, "getWSEndpoint");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/Puppeteer.js
var Puppeteer = class {
  static {
    __name(this, "Puppeteer");
  }
  /**
   * Operations for {@link CustomQueryHandler | custom query handlers}. See
   * {@link CustomQueryHandlerRegistry}.
   *
   * @internal
   */
  static customQueryHandlers = customQueryHandlers;
  /**
   * Registers a {@link CustomQueryHandler | custom query handler}.
   *
   * @remarks
   * After registration, the handler can be used everywhere where a selector is
   * expected by prepending the selection string with `<name>/`. The name is only
   * allowed to consist of lower- and upper case latin letters.
   *
   * @example
   *
   * ```
   * puppeteer.registerCustomQueryHandler('text', {  });
   * const aHandle = await page.$('text/');
   * ```
   *
   * @param name - The name that the custom query handler will be registered
   * under.
   * @param queryHandler - The {@link CustomQueryHandler | custom query handler}
   * to register.
   *
   * @public
   */
  static registerCustomQueryHandler(name, queryHandler) {
    return this.customQueryHandlers.register(name, queryHandler);
  }
  /**
   * Unregisters a custom query handler for a given name.
   */
  static unregisterCustomQueryHandler(name) {
    return this.customQueryHandlers.unregister(name);
  }
  /**
   * Gets the names of all custom query handlers.
   */
  static customQueryHandlerNames() {
    return this.customQueryHandlers.names();
  }
  /**
   * Unregisters all custom query handlers.
   */
  static clearCustomQueryHandlers() {
    return this.customQueryHandlers.clear();
  }
  /**
   * @internal
   */
  _isPuppeteerCore;
  /**
   * @internal
   */
  _changedProduct = false;
  /**
   * @internal
   */
  constructor(settings) {
    this._isPuppeteerCore = settings.isPuppeteerCore;
    this.connect = this.connect.bind(this);
  }
  /**
   * This method attaches Puppeteer to an existing browser instance.
   *
   * @remarks
   *
   * @param options - Set of configurable options to set on the browser.
   * @returns Promise which resolves to browser instance.
   */
  connect(options) {
    return _connectToBrowser(options);
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cloudflare/utils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DEFAULT_VIEWPORT2 = Object.freeze({ width: 800, height: 600 });
async function connectToCDPBrowser(connectionTransport, options) {
  const { ignoreHTTPSErrors = false, defaultViewport = DEFAULT_VIEWPORT2, targetFilter, _isPageTarget: isPageTarget, slowMo = 0, protocolTimeout, sessionId = "unknown" } = options;
  const connection = new Connection("", connectionTransport, slowMo, protocolTimeout);
  const version4 = await connection.send("Browser.getVersion");
  const product2 = version4.product.toLowerCase().includes("firefox") ? "firefox" : "chrome";
  const { browserContextIds } = await connection.send("Target.getBrowserContexts");
  const browser = await CdpBrowser._create(product2 || "chrome", connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, void 0, () => {
    return connection.send("Browser.close").catch(console.log);
  }, targetFilter, isPageTarget, true, sessionId);
  return browser;
}
__name(connectToCDPBrowser, "connectToCDPBrowser");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cloudflare/WorkersWebSocketTransport.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_version2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cloudflare/chunking.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var HEADER_SIZE = 4;
var MAX_MESSAGE_SIZE = 1048575;
var FIRST_CHUNK_DATA_SIZE = MAX_MESSAGE_SIZE - HEADER_SIZE;
var messageToChunks = /* @__PURE__ */ __name((data) => {
  const encoder2 = new TextEncoder();
  const encodedUint8Array = encoder2.encode(data);
  const firstChunk = new Uint8Array(Math.min(MAX_MESSAGE_SIZE, HEADER_SIZE + encodedUint8Array.length));
  const view = new DataView(firstChunk.buffer);
  view.setUint32(0, encodedUint8Array.length, true);
  firstChunk.set(encodedUint8Array.slice(0, FIRST_CHUNK_DATA_SIZE), HEADER_SIZE);
  const chunks3 = [firstChunk];
  for (let i = FIRST_CHUNK_DATA_SIZE; i < encodedUint8Array.length; i += MAX_MESSAGE_SIZE) {
    chunks3.push(encodedUint8Array.slice(i, i + MAX_MESSAGE_SIZE));
  }
  return chunks3;
}, "messageToChunks");
var chunksToMessage = /* @__PURE__ */ __name((chunks3, sessionid) => {
  if (chunks3.length === 0) {
    return null;
  }
  const emptyBuffer = new Uint8Array(0);
  const firstChunk = chunks3[0] || emptyBuffer;
  const view = new DataView(firstChunk.buffer);
  const expectedBytes = view.getUint32(0, true);
  let totalBytes = -HEADER_SIZE;
  for (let i = 0; i < chunks3.length; ++i) {
    const curChunk = chunks3[i] || emptyBuffer;
    totalBytes += curChunk.length;
    if (totalBytes > expectedBytes) {
      throw new Error(`Should have gotten the exact number of bytes but we got more.  SessionID: ${sessionid}`);
    }
    if (totalBytes === expectedBytes) {
      const chunksToCombine = chunks3.splice(0, i + 1);
      chunksToCombine[0] = firstChunk.subarray(HEADER_SIZE);
      const combined = new Uint8Array(expectedBytes);
      let offset = 0;
      for (let j = 0; j <= i; ++j) {
        const chunk4 = chunksToCombine[j] || emptyBuffer;
        combined.set(chunk4, offset);
        offset += chunk4.length;
      }
      const decoder2 = new TextDecoder();
      const message = decoder2.decode(combined);
      return message;
    }
  }
  return null;
}, "chunksToMessage");

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cloudflare/WorkersWebSocketTransport.js
var FAKE_HOST = "https://fake.host";
var WorkersWebSocketTransport = class _WorkersWebSocketTransport {
  static {
    __name(this, "WorkersWebSocketTransport");
  }
  ws;
  pingInterval;
  chunks = [];
  onmessage;
  onclose;
  sessionId;
  static async create(endpoint, sessionId) {
    const path = `${FAKE_HOST}/v1/connectDevtools?browser_session=${sessionId}`;
    const response = await endpoint.fetch(path, {
      headers: {
        Upgrade: "websocket",
        "cf-brapi-client": `@cloudflare/puppeteer@${packageVersion}`
      }
    });
    response.webSocket.accept();
    return new _WorkersWebSocketTransport(response.webSocket, sessionId);
  }
  constructor(ws, sessionId) {
    this.pingInterval = setInterval(() => {
      return this.ws.send("ping");
    }, 1e3);
    this.ws = ws;
    this.sessionId = sessionId;
    this.ws.addEventListener("message", (event) => {
      this.chunks.push(new Uint8Array(event.data));
      const message = chunksToMessage(this.chunks, sessionId);
      if (message && this.onmessage) {
        this.onmessage(message);
      }
    });
    this.ws.addEventListener("close", () => {
      clearInterval(this.pingInterval);
      if (this.onclose) {
        this.onclose();
      }
    });
    this.ws.addEventListener("error", (e) => {
      const message = e.message || "Unknown error";
      debugError(`WebSocket error: SessionID: ${sessionId} - ${message}`);
      clearInterval(this.pingInterval);
    });
  }
  send(message) {
    for (const chunk4 of messageToChunks(message)) {
      this.ws.send(chunk4);
    }
  }
  close() {
    clearInterval(this.pingInterval);
    this.ws.close();
  }
  toString() {
    return this.sessionId;
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cloudflare/PuppeteerWorkers.js
var FAKE_HOST2 = "https://fake.host";
var PuppeteerWorkers = class extends Puppeteer {
  static {
    __name(this, "PuppeteerWorkers");
  }
  constructor() {
    super({ isPuppeteerCore: false });
    this.acquire = this.acquire.bind(this);
    this.connect = this.connect.bind(this);
    this.launch = this.launch.bind(this);
    this.sessions = this.sessions.bind(this);
    this.history = this.history.bind(this);
    this.limits = this.limits.bind(this);
  }
  /**
   * Launch a browser session.
   *
   * @param endpoint - Cloudflare worker binding
   * @returns a browser session or throws
   */
  async launch(endpoint, options) {
    const response = await this.acquire(endpoint, options);
    return await this.connect(endpoint, response.sessionId);
  }
  /**
   * Returns active sessions
   *
   * @remarks
   * Sessions with a connnectionId already have a worker connection established
   *
   * @param endpoint - Cloudflare worker binding
   * @returns List of active sessions
   */
  async sessions(endpoint) {
    const res = await endpoint.fetch(`${FAKE_HOST2}/v1/sessions`);
    const status2 = res.status;
    const text2 = await res.text();
    if (status2 !== 200) {
      throw new Error(`Unable to fetch new sessions: code: ${status2}: message: ${text2}`);
    }
    const data = JSON.parse(text2);
    return data.sessions;
  }
  /**
   * Returns recent sessions (active and closed)
   *
   * @param endpoint - Cloudflare worker binding
   * @returns List of recent sessions (active and closed)
   */
  async history(endpoint) {
    const res = await endpoint.fetch(`${FAKE_HOST2}/v1/history`);
    const status2 = res.status;
    const text2 = await res.text();
    if (status2 !== 200) {
      throw new Error(`Unable to fetch account history: code: ${status2}: message: ${text2}`);
    }
    const data = JSON.parse(text2);
    return data.history;
  }
  /**
   * Returns current limits
   *
   * @param endpoint - Cloudflare worker binding
   * @returns current limits
   */
  async limits(endpoint) {
    const res = await endpoint.fetch(`${FAKE_HOST2}/v1/limits`);
    const status2 = res.status;
    const text2 = await res.text();
    if (status2 !== 200) {
      throw new Error(`Unable to fetch account limits: code: ${status2}: message: ${text2}`);
    }
    const data = JSON.parse(text2);
    return data;
  }
  /**
   * Establish a devtools connection to an existing session
   *
   * @param borwserWorker - BrowserWorker
   * @returns a browser instance
   */
  async connect(endpoint, sessionId) {
    try {
      if (!sessionId) {
        return await super.connect(endpoint);
      }
      const connectionTransport = await WorkersWebSocketTransport.create(endpoint, sessionId);
      return await connectToCDPBrowser(connectionTransport, { sessionId });
    } catch (e) {
      throw new Error(`Unable to connect to existing session ${sessionId} (it may still be in use or not ready yet) - retry or launch a new browser: ${e}`);
    }
  }
  /**
   * Acquire a new browser session.
   *
   * @param borwserWorker - BrowserWorker
   * @returns a new browser session
   */
  async acquire(endpoint, options) {
    const searchParams = new URLSearchParams();
    if (options?.keep_alive) {
      searchParams.set("keep_alive", `${options.keep_alive}`);
    }
    if (options?.location) {
      searchParams.set("location", options.location);
    }
    const acquireUrl = `${FAKE_HOST2}/v1/acquire?${searchParams.toString()}`;
    const res = await endpoint.fetch(acquireUrl);
    const status2 = res.status;
    const text2 = await res.text();
    if (status2 !== 200) {
      throw new Error(`Unable to create new browser: code: ${status2}: message: ${text2}`);
    }
    const response = JSON.parse(text2);
    return response;
  }
};

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/api.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/api/Environment.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/common.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_BrowserWebSocketTransport();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/Configuration.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/ConnectionTransport.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/ConnectOptions.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/Cookie.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/Device.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var knownDevices = [
  {
    name: "Blackberry PlayBook",
    userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
    viewport: {
      width: 600,
      height: 1024,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Blackberry PlayBook landscape",
    userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
    viewport: {
      width: 1024,
      height: 600,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "BlackBerry Z30",
    userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "BlackBerry Z30 landscape",
    userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy Note 3",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy Note 3 landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy Note II",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy Note II landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy S III",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy S III landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy S5",
    userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy S5 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy S8",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 740,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy S8 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36",
    viewport: {
      width: 740,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy S9+",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
    viewport: {
      width: 320,
      height: 658,
      deviceScaleFactor: 4.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy S9+ landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36",
    viewport: {
      width: 658,
      height: 320,
      deviceScaleFactor: 4.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Galaxy Tab S4",
    userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
    viewport: {
      width: 712,
      height: 1138,
      deviceScaleFactor: 2.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Galaxy Tab S4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36",
    viewport: {
      width: 1138,
      height: 712,
      deviceScaleFactor: 2.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 768,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1024,
      height: 768,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad (gen 6)",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 768,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad (gen 6) landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1024,
      height: 768,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad (gen 7)",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 810,
      height: 1080,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad (gen 7) landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1080,
      height: 810,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad Mini",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 768,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad Mini landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1024,
      height: 768,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad Pro",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1024,
      height: 1366,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad Pro landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
    viewport: {
      width: 1366,
      height: 1024,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPad Pro 11",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 834,
      height: 1194,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPad Pro 11 landscape",
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1194,
      height: 834,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 4",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
    viewport: {
      width: 320,
      height: 480,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 4 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
    viewport: {
      width: 480,
      height: 320,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 5",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 320,
      height: 568,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 5 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 568,
      height: 320,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 6",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 667,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 6 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 667,
      height: 375,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 6 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 414,
      height: 736,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 6 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 736,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 7",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 667,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 7 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 667,
      height: 375,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 7 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 414,
      height: 736,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 7 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 736,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 8",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 667,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 8 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 667,
      height: 375,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 8 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 414,
      height: 736,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 8 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 736,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone SE",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 320,
      height: 568,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone SE landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 568,
      height: 320,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone X",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone X landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone XR",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 414,
      height: 896,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone XR landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 896,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 11",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 414,
      height: 828,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 11 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 828,
      height: 414,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 11 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 11 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 11 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 414,
      height: 896,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 11 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 13_7 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 896,
      height: 414,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 12",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 12 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 12 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 12 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 12 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 428,
      height: 926,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 12 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 926,
      height: 428,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 12 Mini",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 12 Mini landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 13",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 13 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 13 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 844,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 13 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 844,
      height: 390,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 13 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 428,
      height: 926,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 13 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 926,
      height: 428,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 13 Mini",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 375,
      height: 812,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 13 Mini landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 812,
      height: 375,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 14",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 663,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 14 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 750,
      height: 340,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 14 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 428,
      height: 745,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 14 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 832,
      height: 378,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 14 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 393,
      height: 659,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 14 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 734,
      height: 343,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 14 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 430,
      height: 739,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 14 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 814,
      height: 380,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 15",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 393,
      height: 659,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 15 landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 734,
      height: 343,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 15 Plus",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 430,
      height: 739,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 15 Plus landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 814,
      height: 380,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 15 Pro",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 393,
      height: 659,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 15 Pro landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 734,
      height: 343,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "iPhone 15 Pro Max",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 430,
      height: 739,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "iPhone 15 Pro Max landscape",
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.5 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 814,
      height: 380,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "JioPhone 2",
    userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
    viewport: {
      width: 240,
      height: 320,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "JioPhone 2 landscape",
    userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
    viewport: {
      width: 320,
      height: 240,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Kindle Fire HDX",
    userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
    viewport: {
      width: 800,
      height: 1280,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Kindle Fire HDX landscape",
    userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
    viewport: {
      width: 1280,
      height: 800,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "LG Optimus L70",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 384,
      height: 640,
      deviceScaleFactor: 1.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "LG Optimus L70 landscape",
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 384,
      deviceScaleFactor: 1.25,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Microsoft Lumia 550",
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Microsoft Lumia 950",
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 4,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Microsoft Lumia 950 landscape",
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 4,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 10",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 800,
      height: 1280,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 10 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 1280,
      height: 800,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 4",
    userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 384,
      height: 640,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 384,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 5",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 5 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 5X",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 732,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 5X landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 732,
      height: 412,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 6",
    userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 732,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 6 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 732,
      height: 412,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 6P",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 732,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 6P landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 732,
      height: 412,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nexus 7",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 600,
      height: 960,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nexus 7 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
    viewport: {
      width: 960,
      height: 600,
      deviceScaleFactor: 2,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nokia Lumia 520",
    userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
    viewport: {
      width: 320,
      height: 533,
      deviceScaleFactor: 1.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nokia Lumia 520 landscape",
    userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
    viewport: {
      width: 533,
      height: 320,
      deviceScaleFactor: 1.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Nokia N9",
    userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
    viewport: {
      width: 480,
      height: 854,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Nokia N9 landscape",
    userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
    viewport: {
      width: 854,
      height: 480,
      deviceScaleFactor: 1,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 2",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 411,
      height: 731,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 2 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 731,
      height: 411,
      deviceScaleFactor: 2.625,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 2 XL",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 411,
      height: 823,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 2 XL landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
    viewport: {
      width: 823,
      height: 411,
      deviceScaleFactor: 3.5,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 3",
    userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
    viewport: {
      width: 393,
      height: 786,
      deviceScaleFactor: 2.75,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 3 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36",
    viewport: {
      width: 786,
      height: 393,
      deviceScaleFactor: 2.75,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 4",
    userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
    viewport: {
      width: 353,
      height: 745,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36",
    viewport: {
      width: 745,
      height: 353,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 4a (5G)",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 353,
      height: 745,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 4a (5G) landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 745,
      height: 353,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Pixel 5",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 393,
      height: 851,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Pixel 5 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 851,
      height: 393,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  },
  {
    name: "Moto G4",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 640,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: false
    }
  },
  {
    name: "Moto G4 landscape",
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4812.0 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 360,
      deviceScaleFactor: 3,
      isMobile: true,
      hasTouch: true,
      isLandscape: true
    }
  }
];
var knownDevicesByName = {};
for (const device of knownDevices) {
  knownDevicesByName[device.name] = device;
}
var KnownDevices = Object.freeze(knownDevicesByName);

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/Product.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/TaskQueue.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/types.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/common/Viewport.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/revisions.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var PUPPETEER_REVISIONS = Object.freeze({
  chrome: "126.0.6478.182",
  "chrome-headless-shell": "126.0.6478.182",
  firefox: "latest"
});

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/util/util.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/cloudflare/BrowserWorker.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@cloudflare/puppeteer/lib/esm/puppeteer/puppeteer-cloudflare.js
var puppeteer = new PuppeteerWorkers();
var { connect, history, launch: launch3, limits, sessions, acquire } = puppeteer;
var puppeteer_cloudflare_default = puppeteer;

// src/services/Browser.ts
var Browser2 = class extends Context_exports.Tag("Browser")() {
  static {
    __name(this, "Browser");
  }
};
var READABLE_CONTENT_TYPES = ["json", "text", "xml", "form"];
async function tryReadResponseBody(res) {
  try {
    const contentType = res.headers()["content-type"] ?? "";
    if (READABLE_CONTENT_TYPES.some((t) => contentType.includes(t))) {
      return await res.text();
    }
  } catch {
  }
  return void 0;
}
__name(tryReadResponseBody, "tryReadResponseBody");
async function resolveResponseEvent(res, requestIdMap, pendingRequests) {
  const req = res.request();
  const id2 = requestIdMap.get(req);
  if (!id2) return null;
  const pending5 = pendingRequests.get(id2);
  if (!pending5) return null;
  pendingRequests.delete(id2);
  const responseBody = await tryReadResponseBody(res);
  return new NetworkEvent({
    requestId: id2,
    url: pending5.url,
    method: pending5.method,
    resourceType: pending5.resourceType,
    requestHeaders: pending5.headers,
    requestBody: pending5.postData,
    responseStatus: res.status(),
    responseHeaders: res.headers(),
    responseBody,
    timestamp: pending5.timestamp
  });
}
__name(resolveResponseEvent, "resolveResponseEvent");
function makeCfBrowser(binding2) {
  return Effect_exports.gen(function* () {
    const { BrowserError: BrowserErr } = yield* Effect_exports.promise(() => Promise.resolve().then(() => (init_Errors(), Errors_exports)));
    const browser = yield* Effect_exports.acquireRelease(
      Effect_exports.tryPromise({
        try: /* @__PURE__ */ __name(() => puppeteer_cloudflare_default.launch(binding2), "try"),
        catch: /* @__PURE__ */ __name((e) => new BrowserErr({ message: `Launch failed: ${e}` }), "catch")
      }),
      (b) => Effect_exports.promise(() => b.close().catch(() => {
      }))
    );
    const page = yield* Effect_exports.tryPromise({
      try: /* @__PURE__ */ __name(() => browser.newPage(), "try"),
      catch: /* @__PURE__ */ __name((e) => new BrowserErr({ message: `New page failed: ${e}` }), "catch")
    });
    yield* Effect_exports.tryPromise({
      try: /* @__PURE__ */ __name(() => page.setUserAgent("unsurf/0.2.0 (API discovery tool; https://unsurf.coey.dev)"), "try"),
      catch: /* @__PURE__ */ __name((e) => new BrowserErr({ message: `Set user-agent failed: ${e}` }), "catch")
    });
    const eventsRef = yield* Ref_exports.make([]);
    const pendingRequests = /* @__PURE__ */ new Map();
    let networkStreamPush = null;
    let networkStreamEnd = null;
    const requestIdMap = /* @__PURE__ */ new WeakMap();
    yield* Effect_exports.tryPromise({
      try: /* @__PURE__ */ __name(() => page.setRequestInterception(true), "try"),
      catch: /* @__PURE__ */ __name((e) => new BrowserErr({ message: `Interception setup failed: ${e}` }), "catch")
    });
    page.on("request", (req) => {
      const id2 = `${req.method()}-${req.url()}-${Date.now()}`;
      if (isApiRequest(req.resourceType(), req.url())) {
        pendingRequests.set(id2, {
          url: req.url(),
          method: req.method(),
          resourceType: req.resourceType(),
          headers: req.headers(),
          postData: req.postData(),
          timestamp: Date.now()
        });
        requestIdMap.set(req, id2);
      }
      req.continue();
    });
    page.on("response", async (res) => {
      try {
        const event = await resolveResponseEvent(res, requestIdMap, pendingRequests);
        if (!event) return;
        Effect_exports.runSync(Ref_exports.update(eventsRef, (arr) => [...arr, event]));
        networkStreamPush?.(event);
      } catch {
      }
    });
    const service3 = {
      navigate: /* @__PURE__ */ __name((url3) => Effect_exports.tryPromise({
        try: /* @__PURE__ */ __name(() => page.goto(url3, { waitUntil: "networkidle0", timeout: 3e4 }).then(() => {
        }), "try"),
        catch: /* @__PURE__ */ __name((e) => new BrowserErr({ message: `Navigate to ${url3} failed: ${e}` }), "catch")
      }), "navigate"),
      captureNetwork: /* @__PURE__ */ __name(() => Effect_exports.succeed(
        Stream_exports.async((emit3) => {
          networkStreamPush = /* @__PURE__ */ __name((event) => emit3.single(event), "networkStreamPush");
          networkStreamEnd = /* @__PURE__ */ __name(() => emit3.end(), "networkStreamEnd");
        })
      ), "captureNetwork"),
      screenshot: /* @__PURE__ */ __name(() => Effect_exports.tryPromise({
        try: /* @__PURE__ */ __name(async () => {
          const buf = await page.screenshot({ type: "png" });
          if (buf instanceof Uint8Array) return buf;
          return new Uint8Array(buf);
        }, "try"),
        catch: /* @__PURE__ */ __name((e) => new BrowserErr({ message: `Screenshot failed: ${e}` }), "catch")
      }), "screenshot"),
      evaluate: /* @__PURE__ */ __name(((fn2) => Effect_exports.tryPromise({
        try: /* @__PURE__ */ __name(() => page.evaluate(fn2), "try"),
        catch: /* @__PURE__ */ __name((e) => new BrowserErr({ message: `Evaluate failed: ${e}` }), "catch")
      })), "evaluate"),
      click: /* @__PURE__ */ __name((selector) => Effect_exports.tryPromise({
        try: /* @__PURE__ */ __name(() => page.click(selector), "try"),
        catch: /* @__PURE__ */ __name((e) => new BrowserErr({ message: `Click ${selector} failed: ${e}` }), "catch")
      }), "click"),
      type: /* @__PURE__ */ __name((selector, text2) => Effect_exports.tryPromise({
        try: /* @__PURE__ */ __name(() => page.type(selector, text2), "try"),
        catch: /* @__PURE__ */ __name((e) => new BrowserErr({ message: `Type into ${selector} failed: ${e}` }), "catch")
      }), "type"),
      waitForSelector: /* @__PURE__ */ __name((selector) => Effect_exports.tryPromise({
        try: /* @__PURE__ */ __name(() => page.waitForSelector(selector, { timeout: 1e4 }).then(() => {
        }), "try"),
        catch: /* @__PURE__ */ __name((e) => new BrowserErr({ message: `Wait for ${selector} timed out: ${e}` }), "catch")
      }), "waitForSelector"),
      waitForNavigation: /* @__PURE__ */ __name(() => Effect_exports.tryPromise({
        try: /* @__PURE__ */ __name(() => page.waitForNavigation({ waitUntil: "networkidle0", timeout: 15e3 }).then(() => {
        }), "try"),
        catch: /* @__PURE__ */ __name((e) => new BrowserErr({ message: `Wait for navigation failed: ${e}` }), "catch")
      }), "waitForNavigation"),
      getNetworkEvents: /* @__PURE__ */ __name(() => Ref_exports.get(eventsRef), "getNetworkEvents"),
      close: /* @__PURE__ */ __name(() => Effect_exports.sync(() => {
        networkStreamEnd?.();
      }), "close")
    };
    return service3;
  });
}
__name(makeCfBrowser, "makeCfBrowser");
var BrowserCfLive = /* @__PURE__ */ __name((binding2) => Layer_exports.scoped(Browser2, makeCfBrowser(binding2)), "BrowserCfLive");
function makeTestBrowser() {
  const events = [];
  const pages = /* @__PURE__ */ new Map();
  let currentUrl = "";
  return {
    navigate: /* @__PURE__ */ __name((url3) => Effect_exports.sync(() => {
      currentUrl = url3;
      pages.set(url3, "loaded");
    }), "navigate"),
    captureNetwork: /* @__PURE__ */ __name(() => Effect_exports.succeed(Stream_exports.fromIterable(events)), "captureNetwork"),
    screenshot: /* @__PURE__ */ __name(() => Effect_exports.succeed(new Uint8Array([137, 80, 78, 71])), "screenshot"),
    // PNG magic
    evaluate: /* @__PURE__ */ __name(() => Effect_exports.succeed(void 0), "evaluate"),
    click: /* @__PURE__ */ __name((_selector) => Effect_exports.void, "click"),
    type: /* @__PURE__ */ __name((_selector, _text) => Effect_exports.void, "type"),
    waitForSelector: /* @__PURE__ */ __name((_selector) => Effect_exports.void, "waitForSelector"),
    waitForNavigation: /* @__PURE__ */ __name(() => Effect_exports.void, "waitForNavigation"),
    getNetworkEvents: /* @__PURE__ */ __name(() => Effect_exports.succeed(events), "getNetworkEvents"),
    close: /* @__PURE__ */ __name(() => Effect_exports.void, "close")
  };
}
__name(makeTestBrowser, "makeTestBrowser");
var BrowserTestLive = Layer_exports.succeed(Browser2, makeTestBrowser());

// src/services/Directory.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();
init_Errors();
var Directory = class extends Context_exports.Tag("Directory")() {
  static {
    __name(this, "Directory");
  }
};
function generateId(prefix) {
  const rand = Math.random().toString(36).slice(2, 10);
  const ts = Date.now().toString(36);
  return `${prefix}_${ts}_${rand}`;
}
__name(generateId, "generateId");
function nowISO() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
__name(nowISO, "nowISO");
var CAPABILITY_PATTERNS = {
  auth: [
    /\/auth/i,
    /\/login/i,
    /\/logout/i,
    /\/register/i,
    /\/users?\//i,
    /\/session/i,
    /\/oauth/i
  ],
  payments: [/\/pay/i, /\/charge/i, /\/invoice/i, /\/subscription/i, /\/billing/i, /\/stripe/i],
  content: [/\/posts?\//i, /\/articles?\//i, /\/comments?\//i, /\/feed/i, /\/blog/i],
  crud: [/\/api\/v?\d*\//i],
  search: [/\/search/i, /\/query/i, /\/find/i],
  messaging: [/\/messages?\//i, /\/chat/i, /\/notifications?\//i, /\/email/i],
  files: [/\/files?\//i, /\/upload/i, /\/download/i, /\/media/i, /\/images?\//i],
  analytics: [/\/analytics/i, /\/metrics/i, /\/stats/i, /\/events/i, /\/track/i],
  social: [/\/friends?\//i, /\/follow/i, /\/like/i, /\/share/i, /\/profile/i],
  ecommerce: [/\/cart/i, /\/products?\//i, /\/orders?\//i, /\/checkout/i, /\/inventory/i],
  forms: [/\/contact/i, /\/form/i, /\/submit/i, /\/inquiry/i],
  other: []
};
function classifyEndpoint(method, path) {
  for (const [cap, patterns] of Object.entries(CAPABILITY_PATTERNS)) {
    if (cap === "other") continue;
    for (const pattern2 of patterns) {
      if (pattern2.test(path)) return cap;
    }
  }
  return "other";
}
__name(classifyEndpoint, "classifyEndpoint");
function detectAuth(headers) {
  if (!headers) return "unknown";
  const authHeader = headers.authorization || headers.Authorization || "";
  if (authHeader.toLowerCase().startsWith("bearer")) return "bearer";
  if (authHeader.toLowerCase().startsWith("basic")) return "basic";
  if (headers["x-api-key"] || headers["X-Api-Key"]) return "api-key";
  if (headers.cookie || headers.Cookie) return "cookie";
  return "none";
}
__name(detectAuth, "detectAuth");
function generateSummary(method, path) {
  const parts2 = path.split("/").filter(Boolean);
  const resource = parts2.find((p) => !p.startsWith(":") && !p.match(/^[a-f0-9-]+$/i)) || "resource";
  const hasId = parts2.some((p) => p.startsWith(":") || p.match(/^[a-f0-9-]+$/i));
  switch (method.toUpperCase()) {
    case "GET":
      return hasId ? `Get ${resource} by ID` : `List ${resource}s`;
    case "POST":
      return `Create ${resource}`;
    case "PUT":
    case "PATCH":
      return `Update ${resource}`;
    case "DELETE":
      return `Delete ${resource}`;
    default:
      return `${method} ${resource}`;
  }
}
__name(generateSummary, "generateSummary");
function makeD1Directory(db, storage, vectors, ai) {
  const tryD1 = /* @__PURE__ */ __name((fn2) => Effect_exports.tryPromise({
    try: fn2,
    catch: /* @__PURE__ */ __name((e) => new StoreError({ message: String(e) }), "catch")
  }), "tryD1");
  return {
    getFingerprint: /* @__PURE__ */ __name((domain4) => tryD1(
      () => db.prepare("SELECT * FROM fingerprints WHERE domain = ?").bind(domain4).first()
    ).pipe(
      Effect_exports.flatMap(
        (row) => row ? Effect_exports.succeed(rowToFingerprint(row)) : Effect_exports.fail(new NotFoundError({ id: domain4, resource: "fingerprint" }))
      )
    ), "getFingerprint"),
    getCapabilitySlice: /* @__PURE__ */ __name((domain4, capability) => Effect_exports.gen(function* () {
      const fp = yield* tryD1(
        () => db.prepare("SELECT id FROM fingerprints WHERE domain = ?").bind(domain4).first()
      );
      if (!fp)
        return yield* Effect_exports.fail(new NotFoundError({ id: domain4, resource: "fingerprint" }));
      const rows = yield* tryD1(
        () => db.prepare(
          "SELECT * FROM directory_endpoints WHERE fingerprint_id = ? AND capability = ?"
        ).bind(fp.id, capability).all()
      );
      return {
        domain: domain4,
        capability,
        endpoints: rows.results.map(rowToEndpointSummary)
      };
    }), "getCapabilitySlice"),
    getEndpoint: /* @__PURE__ */ __name((domain4, method, path) => Effect_exports.gen(function* () {
      const fp = yield* tryD1(
        () => db.prepare("SELECT id FROM fingerprints WHERE domain = ?").bind(domain4).first()
      );
      if (!fp)
        return yield* Effect_exports.fail(new NotFoundError({ id: domain4, resource: "fingerprint" }));
      const row = yield* tryD1(
        () => db.prepare(
          "SELECT * FROM directory_endpoints WHERE fingerprint_id = ? AND method = ? AND path = ?"
        ).bind(fp.id, method.toUpperCase(), path).first()
      );
      if (!row)
        return yield* Effect_exports.fail(
          new NotFoundError({ id: `${method} ${path}`, resource: "endpoint" })
        );
      return rowToEndpointSummary(row);
    }), "getEndpoint"),
    getSpec: /* @__PURE__ */ __name((domain4) => Effect_exports.gen(function* () {
      const fp = yield* tryD1(
        () => db.prepare("SELECT spec_key FROM fingerprints WHERE domain = ?").bind(domain4).first()
      );
      if (!fp)
        return yield* Effect_exports.fail(new NotFoundError({ id: domain4, resource: "fingerprint" }));
      const obj = yield* tryD1(() => storage.get(fp.spec_key));
      if (!obj) return yield* Effect_exports.fail(new NotFoundError({ id: domain4, resource: "spec" }));
      const text2 = yield* tryD1(() => obj.text());
      return JSON.parse(text2);
    }), "getSpec"),
    search: /* @__PURE__ */ __name((query, limit = 10) => Effect_exports.gen(function* () {
      const embedding = yield* tryD1(
        () => ai.run("@cf/baai/bge-base-en-v1.5", { text: [query] })
      );
      const queryVector = embedding.data[0];
      if (!queryVector) return [];
      const results = yield* tryD1(
        () => vectors.query(queryVector, { topK: limit, returnMetadata: true })
      );
      return results.matches.map((m) => ({
        domain: m.metadata?.domain || "",
        match: m.metadata?.match || "",
        capability: m.metadata?.capability || "other",
        confidence: m.score,
        specUrl: `/d/${m.metadata?.domain}/spec`
      }));
    }), "search"),
    publish: /* @__PURE__ */ __name((siteId, contributor = "anonymous") => (
      // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: multi-step DB operation
      Effect_exports.gen(function* () {
        const site = yield* tryD1(
          () => db.prepare("SELECT * FROM sites WHERE id = ?").bind(siteId).first()
        );
        if (!site) return yield* Effect_exports.fail(new NotFoundError({ id: siteId, resource: "site" }));
        const endpointRows = yield* tryD1(
          () => db.prepare("SELECT * FROM endpoints WHERE site_id = ?").bind(siteId).all()
        );
        const endpoints2 = endpointRows.results;
        const domain4 = site.domain;
        const url3 = site.url;
        const now2 = nowISO();
        if (endpoints2.length === 0) {
          return yield* Effect_exports.fail(
            new ValidationError({
              field: "endpoints",
              message: "No endpoints captured - cannot publish empty API"
            })
          );
        }
        const scoutSpecKey = `specs/${siteId}/openapi.json`;
        const specCheck = yield* tryD1(() => storage.get(scoutSpecKey));
        if (!specCheck) {
          return yield* Effect_exports.fail(
            new ValidationError({
              field: "spec",
              message: "OpenAPI spec not found - scout may have failed"
            })
          );
        }
        const specBody = yield* tryD1(() => specCheck.arrayBuffer());
        let specJson;
        try {
          specJson = JSON.parse(new TextDecoder().decode(specBody));
        } catch {
          return yield* Effect_exports.fail(
            new ValidationError({ field: "spec", message: "OpenAPI spec is not valid JSON" })
          );
        }
        const specPaths = specJson.paths;
        if (!specPaths || Object.keys(specPaths).length === 0) {
          return yield* Effect_exports.fail(
            new ValidationError({ field: "spec", message: "OpenAPI spec has no paths defined" })
          );
        }
        const capabilitySet = /* @__PURE__ */ new Set();
        const methodCounts = {};
        let detectedAuth = "none";
        for (const ep of endpoints2) {
          const cap = classifyEndpoint(ep.method, ep.path_pattern);
          capabilitySet.add(cap);
          methodCounts[ep.method] = (methodCounts[ep.method] || 0) + 1;
          if (ep.request_headers) {
            const auth = detectAuth(JSON.parse(ep.request_headers));
            if (auth !== "none" && auth !== "unknown") detectedAuth = auth;
          }
        }
        const capabilities = [...capabilitySet];
        const specKey = `directory/${domain4}/openapi.json`;
        const existing = yield* tryD1(
          () => db.prepare("SELECT * FROM fingerprints WHERE domain = ?").bind(domain4).first()
        );
        let fingerprintId;
        let version4 = 1;
        if (existing) {
          fingerprintId = existing.id;
          version4 = (existing.version || 1) + 1;
          yield* tryD1(
            () => db.prepare(
              "UPDATE fingerprints SET url=?, endpoint_count=?, capabilities=?, methods=?, auth=?, confidence=?, updated_at=?, version=? WHERE id=?"
            ).bind(
              url3,
              endpoints2.length,
              JSON.stringify(capabilities),
              JSON.stringify(methodCounts),
              detectedAuth,
              90,
              now2,
              version4,
              fingerprintId
            ).run()
          );
          yield* tryD1(
            () => db.prepare("DELETE FROM directory_endpoints WHERE fingerprint_id = ?").bind(fingerprintId).run()
          );
        } else {
          fingerprintId = generateId("fp");
          yield* tryD1(
            () => db.prepare(
              "INSERT INTO fingerprints (id, domain, url, endpoint_count, capabilities, methods, auth, confidence, spec_key, contributor, created_at, updated_at, version) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)"
            ).bind(
              fingerprintId,
              domain4,
              url3,
              endpoints2.length,
              JSON.stringify(capabilities),
              JSON.stringify(methodCounts),
              detectedAuth,
              90,
              specKey,
              contributor,
              now2,
              now2,
              1
            ).run()
          );
        }
        const vectorsToInsert = [];
        const embeddingTexts = [];
        for (const ep of endpoints2) {
          const epId = generateId("ep");
          const cap = classifyEndpoint(ep.method, ep.path_pattern);
          const summary5 = generateSummary(ep.method, ep.path_pattern);
          const vectorId = generateId("vec");
          yield* tryD1(
            () => db.prepare(
              "INSERT INTO directory_endpoints (id, fingerprint_id, method, path, summary, capability, request_schema, response_schema, auth, vector_id) VALUES (?,?,?,?,?,?,?,?,?,?)"
            ).bind(
              epId,
              fingerprintId,
              ep.method,
              ep.path_pattern,
              summary5,
              cap,
              ep.request_schema,
              ep.response_schema,
              ep.request_headers ? 1 : 0,
              vectorId
            ).run()
          );
          const embeddingText = `${domain4} ${ep.method} ${ep.path_pattern} ${summary5} ${cap}`;
          embeddingTexts.push(embeddingText);
          vectorsToInsert.push({
            id: vectorId,
            values: [],
            // Will be filled below
            metadata: {
              domain: domain4,
              match: `${ep.method} ${ep.path_pattern}`,
              capability: cap
            }
          });
        }
        if (vectorsToInsert.length > 0) {
          const embeddings = yield* tryD1(
            () => ai.run("@cf/baai/bge-base-en-v1.5", { text: embeddingTexts })
          );
          for (let i = 0; i < vectorsToInsert.length; i++) {
            const vec = vectorsToInsert[i];
            if (vec) vec.values = embeddings.data[i] ?? [];
          }
          yield* tryD1(() => vectors.insert(vectorsToInsert));
        }
        yield* tryD1(() => storage.put(specKey, specBody));
        return {
          domain: domain4,
          url: url3,
          endpoints: endpoints2.length,
          capabilities,
          methods: methodCounts,
          auth: detectedAuth,
          confidence: 0.9,
          lastScouted: now2,
          version: version4,
          specUrl: `/d/${domain4}/spec`
        };
      })
    ), "publish"),
    list: /* @__PURE__ */ __name((offset = 0, limit = 20) => tryD1(
      () => db.prepare("SELECT * FROM fingerprints ORDER BY updated_at DESC LIMIT ? OFFSET ?").bind(limit, offset).all()
    ).pipe(
      Effect_exports.map(
        (result) => result.results.map(rowToFingerprint)
      )
    ), "list"),
    delete: /* @__PURE__ */ __name((domain4) => Effect_exports.gen(function* () {
      const fp = yield* tryD1(
        () => db.prepare("SELECT id, spec_key FROM fingerprints WHERE domain = ?").bind(domain4).first()
      );
      if (!fp)
        return yield* Effect_exports.fail(new NotFoundError({ id: domain4, resource: "fingerprint" }));
      const { id: id2, spec_key } = fp;
      yield* tryD1(
        () => db.prepare("DELETE FROM directory_endpoints WHERE fingerprint_id = ?").bind(id2).run()
      );
      yield* tryD1(() => db.prepare("DELETE FROM fingerprints WHERE id = ?").bind(id2).run());
      if (spec_key) {
        yield* tryD1(() => storage.delete(spec_key));
      }
    }), "delete")
  };
}
__name(makeD1Directory, "makeD1Directory");
function rowToFingerprint(row) {
  return {
    domain: row.domain,
    url: row.url,
    endpoints: row.endpoint_count,
    capabilities: JSON.parse(row.capabilities),
    methods: JSON.parse(row.methods),
    auth: row.auth,
    confidence: row.confidence / 100,
    lastScouted: row.updated_at,
    version: row.version,
    specUrl: `/d/${row.domain}/spec`
  };
}
__name(rowToFingerprint, "rowToFingerprint");
function rowToEndpointSummary(row) {
  return {
    method: row.method,
    path: row.path,
    summary: row.summary,
    requestSchema: row.request_schema ? Option_exports.some(JSON.parse(row.request_schema)) : Option_exports.none(),
    responseSchema: row.response_schema ? JSON.parse(row.response_schema) : {},
    auth: row.auth === 1,
    example: row.example_request || row.example_response ? Option_exports.some({
      request: row.example_request ? JSON.parse(row.example_request) : null,
      response: row.example_response ? JSON.parse(row.example_response) : null
    }) : Option_exports.none()
  };
}
__name(rowToEndpointSummary, "rowToEndpointSummary");

// src/services/Gallery.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();
init_Errors();
var Gallery = class extends Context_exports.Tag("Gallery")() {
  static {
    __name(this, "Gallery");
  }
};
var KvCache = class extends Context_exports.Tag("KvCache")() {
  static {
    __name(this, "KvCache");
  }
};
function generateId2(prefix) {
  const rand = Math.random().toString(36).slice(2, 10);
  const ts = Date.now().toString(36);
  return `${prefix}_${ts}_${rand}`;
}
__name(generateId2, "generateId");
function nowISO2() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
__name(nowISO2, "nowISO");
var CACHE_TTL = 3600;
function makeD1Gallery(db, store, kv) {
  const tryD1 = /* @__PURE__ */ __name((fn2) => Effect_exports.tryPromise({
    try: fn2,
    catch: /* @__PURE__ */ __name((e) => new StoreError({ message: String(e) }), "catch")
  }), "tryD1");
  const cacheGet = /* @__PURE__ */ __name((key) => kv ? kv.get(key) : Effect_exports.succeed(null), "cacheGet");
  const cachePut = /* @__PURE__ */ __name((key, value3) => kv ? kv.put(key, value3, CACHE_TTL) : Effect_exports.void, "cachePut");
  return {
    search: /* @__PURE__ */ __name((query, domain4, limit = 10) => {
      const effectiveLimit = Math.min(limit, 50);
      const cacheKey = `q:${query}:${domain4 ?? ""}:${effectiveLimit}`;
      return cacheGet(cacheKey).pipe(
        Effect_exports.flatMap((cached5) => {
          if (cached5) {
            return Effect_exports.succeed(JSON.parse(cached5));
          }
          let sql2;
          let params;
          if (domain4 && !query) {
            sql2 = "SELECT * FROM gallery WHERE domain = ? LIMIT ?";
            params = [domain4, effectiveLimit];
          } else if (query && !domain4) {
            sql2 = "SELECT g.* FROM gallery g JOIN gallery_fts f ON g.rowid = f.rowid WHERE gallery_fts MATCH ? LIMIT ?";
            params = [query, effectiveLimit];
          } else {
            sql2 = "SELECT g.* FROM gallery g JOIN gallery_fts f ON g.rowid = f.rowid WHERE gallery_fts MATCH ? AND g.domain = ? LIMIT ?";
            params = [query, domain4, effectiveLimit];
          }
          return tryD1(
            () => db.prepare(sql2).bind(...params).all()
          ).pipe(
            Effect_exports.map((result) => mapRows(result.results)),
            Effect_exports.tap((results) => cachePut(cacheKey, JSON.stringify(results)))
          );
        })
      );
    }, "search"),
    publish: /* @__PURE__ */ __name((siteId, contributor = "anonymous") => Effect_exports.gen(function* () {
      const site = yield* store.getSite(siteId);
      const endpoints2 = yield* store.getEndpoints(siteId);
      const endpointsSummary = endpoints2.map((ep) => `${ep.method} ${ep.pathPattern}`).join(", ");
      const specKey = `specs/${siteId}/openapi.json`;
      const now2 = nowISO2();
      const existing = yield* tryD1(
        () => db.prepare("SELECT * FROM gallery WHERE domain = ? LIMIT 1").bind(site.domain).first()
      );
      if (existing) {
        const row = existing;
        const newVersion = (row.version ?? 1) + 1;
        yield* tryD1(
          () => db.prepare(
            "UPDATE gallery SET url = ?, task = ?, endpoint_count = ?, endpoints_summary = ?, spec_key = ?, contributor = ?, updated_at = ?, version = ? WHERE id = ?"
          ).bind(
            site.url,
            endpoints2.length > 0 ? endpointsSummary : row.task,
            endpoints2.length,
            endpointsSummary,
            specKey,
            contributor,
            now2,
            newVersion,
            row.id
          ).run()
        );
        return mapRow({
          ...row,
          url: site.url,
          task: endpoints2.length > 0 ? endpointsSummary : row.task,
          endpoint_count: endpoints2.length,
          endpoints_summary: endpointsSummary,
          spec_key: specKey,
          contributor,
          updated_at: now2,
          version: newVersion
        });
      }
      const id2 = generateId2("gal");
      const task = endpoints2.length > 0 ? endpointsSummary : "no endpoints captured";
      yield* tryD1(
        () => db.prepare(
          "INSERT INTO gallery (id, domain, url, task, endpoint_count, endpoints_summary, spec_key, contributor, created_at, updated_at, version) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 1)"
        ).bind(
          id2,
          site.domain,
          site.url,
          task,
          endpoints2.length,
          endpointsSummary,
          specKey,
          contributor,
          now2,
          now2
        ).run()
      );
      return mapRow({
        id: id2,
        domain: site.domain,
        url: site.url,
        task,
        endpoint_count: endpoints2.length,
        endpoints_summary: endpointsSummary,
        spec_key: specKey,
        contributor,
        created_at: now2,
        updated_at: now2,
        version: 1
      });
    }), "publish"),
    getSpec: /* @__PURE__ */ __name((galleryId) => Effect_exports.gen(function* () {
      const row = yield* tryD1(
        () => db.prepare("SELECT spec_key FROM gallery WHERE id = ?").bind(galleryId).first()
      );
      if (!row) {
        return yield* Effect_exports.fail(new NotFoundError({ id: galleryId, resource: "gallery" }));
      }
      const specKey = row.spec_key;
      const blob2 = yield* store.getBlob(specKey);
      if (!blob2) {
        return yield* Effect_exports.fail(new NotFoundError({ id: specKey, resource: "spec" }));
      }
      const text2 = new TextDecoder().decode(blob2);
      return JSON.parse(text2);
    }), "getSpec"),
    getByDomain: /* @__PURE__ */ __name((domain4) => {
      const cacheKey = `domain:${domain4}`;
      return cacheGet(cacheKey).pipe(
        Effect_exports.flatMap((cached5) => {
          if (cached5) {
            return Effect_exports.succeed(JSON.parse(cached5));
          }
          return tryD1(
            () => db.prepare("SELECT * FROM gallery WHERE domain = ? LIMIT 1").bind(domain4).first()
          ).pipe(
            Effect_exports.map((row) => row ? mapRow(row) : null),
            Effect_exports.tap(
              (result) => result ? cachePut(cacheKey, JSON.stringify(result)) : Effect_exports.void
            )
          );
        })
      );
    }, "getByDomain")
  };
}
__name(makeD1Gallery, "makeD1Gallery");
function mapRow(row) {
  return {
    id: row.id,
    domain: row.domain,
    url: row.url,
    task: row.task,
    endpointCount: row.endpoint_count,
    endpointsSummary: row.endpoints_summary,
    specKey: row.spec_key,
    contributor: row.contributor ?? "anonymous",
    createdAt: row.created_at,
    updatedAt: row.updated_at,
    version: row.version
  };
}
__name(mapRow, "mapRow");
function mapRows(rows) {
  return rows.map(mapRow);
}
__name(mapRows, "mapRows");
function makeKvCache(kv) {
  const tryKv = /* @__PURE__ */ __name((fn2) => Effect_exports.tryPromise({
    try: fn2,
    catch: /* @__PURE__ */ __name((e) => new StoreError({ message: String(e) }), "catch")
  }), "tryKv");
  return {
    get: /* @__PURE__ */ __name((key) => tryKv(() => kv.get(key)), "get"),
    put: /* @__PURE__ */ __name((key, value3, ttlSeconds) => tryKv(() => kv.put(key, value3, { expirationTtl: ttlSeconds })), "put")
  };
}
__name(makeKvCache, "makeKvCache");

// src/services/OpenApiGenerator.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();
var OpenApiGenerator = class extends Context_exports.Tag("OpenApiGenerator")() {
  static {
    __name(this, "OpenApiGenerator");
  }
};
var METHODS_WITH_BODY = /* @__PURE__ */ new Set(["POST", "PUT", "PATCH"]);
function endpointToOperation(ep) {
  const op = {
    operationId: `${ep.method.toLowerCase()}_${ep.pathPattern.replace(/[/:{}]/g, "_").replace(/_+/g, "_").replace(/^_|_$/g, "")}`,
    responses: {}
  };
  if (METHODS_WITH_BODY.has(ep.method)) {
    const reqSchema = Option_exports.isSome(ep.requestSchema) ? ep.requestSchema.value : void 0;
    if (reqSchema) {
      op.requestBody = {
        required: true,
        content: { "application/json": { schema: reqSchema } }
      };
    }
  }
  const resSchema = Option_exports.isSome(ep.responseSchema) ? ep.responseSchema.value : void 0;
  op.responses = {
    "200": resSchema ? {
      description: "Successful response",
      content: { "application/json": { schema: resSchema } }
    } : { description: "Successful response" }
  };
  const pathParams = extractPathParams(ep.pathPattern);
  if (pathParams.length > 0) {
    op.parameters = pathParams;
  }
  return op;
}
__name(endpointToOperation, "endpointToOperation");
function extractPathParams(pattern2) {
  const params = [];
  const segments = pattern2.split("/");
  for (const seg of segments) {
    if (seg.startsWith(":")) {
      const name = seg.slice(1);
      params.push({
        name,
        in: "path",
        required: true,
        schema: { type: "string" }
      });
    }
  }
  return params;
}
__name(extractPathParams, "extractPathParams");
function toOpenApiPath(pattern2) {
  let path = pattern2;
  try {
    const url3 = new URL(pattern2);
    path = url3.pathname + url3.search;
  } catch {
  }
  return path.replace(/:([a-zA-Z_][a-zA-Z0-9_]*)/g, "{$1}");
}
__name(toOpenApiPath, "toOpenApiPath");
function groupByPath(endpoints2) {
  const groups = /* @__PURE__ */ new Map();
  for (const ep of endpoints2) {
    const path = ep.pathPattern;
    const existing = groups.get(path) ?? [];
    existing.push(ep);
    groups.set(path, existing);
  }
  return groups;
}
__name(groupByPath, "groupByPath");
function buildSpec(siteUrl, endpoints2) {
  const paths2 = {};
  const grouped3 = groupByPath(endpoints2);
  for (const [pattern2, eps] of grouped3) {
    const openApiPath = toOpenApiPath(pattern2);
    const pathItem = {};
    for (const ep of eps) {
      const method = ep.method.toLowerCase();
      pathItem[method] = endpointToOperation(ep);
    }
    paths2[openApiPath] = pathItem;
  }
  let domain4;
  try {
    domain4 = new URL(siteUrl).hostname;
  } catch {
    domain4 = siteUrl;
  }
  return {
    openapi: "3.1.0",
    info: {
      title: `API for ${domain4}`,
      version: "1.0.0",
      description: `Auto-generated by unsurf from ${siteUrl}`
    },
    servers: [{ url: siteUrl }],
    paths: paths2
  };
}
__name(buildSpec, "buildSpec");
function makeOpenApiGenerator() {
  return {
    generate: /* @__PURE__ */ __name((siteUrl, endpoints2) => Effect_exports.succeed(buildSpec(siteUrl, endpoints2)), "generate")
  };
}
__name(makeOpenApiGenerator, "makeOpenApiGenerator");
var OpenApiGeneratorLive = Layer_exports.succeed(OpenApiGenerator, makeOpenApiGenerator());

// src/services/SchemaInferrer.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();
var SchemaInferrer = class extends Context_exports.Tag("SchemaInferrer")() {
  static {
    __name(this, "SchemaInferrer");
  }
};
function inferType(value3) {
  if (value3 === null) return { type: "null" };
  if (value3 === void 0) return {};
  switch (typeof value3) {
    case "string":
      return inferStringSchema(value3);
    case "number":
      return Number.isInteger(value3) ? { type: "integer" } : { type: "number" };
    case "boolean":
      return { type: "boolean" };
    case "object":
      return Array.isArray(value3) ? inferArraySchema(value3) : inferObjectSchema(value3);
    default:
      return {};
  }
}
__name(inferType, "inferType");
function inferStringSchema(value3) {
  const schema = { type: "string" };
  if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/.test(value3)) {
    schema.format = "date-time";
  } else if (/^\d{4}-\d{2}-\d{2}$/.test(value3)) {
    schema.format = "date";
  } else if (/^[^@]+@[^@]+\.[^@]+$/.test(value3)) {
    schema.format = "email";
  } else if (/^https?:\/\//.test(value3)) {
    schema.format = "uri";
  } else if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value3)) {
    schema.format = "uuid";
  }
  return schema;
}
__name(inferStringSchema, "inferStringSchema");
function inferArraySchema(arr) {
  if (arr.length === 0) return { type: "array", items: {} };
  let itemSchema = inferType(arr[0]);
  for (let i = 1; i < arr.length; i++) {
    itemSchema = mergeSchemas(itemSchema, inferType(arr[i]));
  }
  return { type: "array", items: itemSchema };
}
__name(inferArraySchema, "inferArraySchema");
function inferObjectSchema(obj) {
  const record4 = obj;
  const properties = {};
  const required4 = [];
  for (const [key, val] of Object.entries(record4)) {
    properties[key] = inferType(val);
    if (val !== null && val !== void 0) {
      required4.push(key);
    }
  }
  const schema = { type: "object", properties };
  if (required4.length > 0) {
    schema.required = required4;
  }
  return schema;
}
__name(inferObjectSchema, "inferObjectSchema");
function inferFromSamples(samples) {
  if (samples.length === 0) return {};
  let schema = inferType(samples[0]);
  for (let i = 1; i < samples.length; i++) {
    schema = mergeSchemas(schema, inferType(samples[i]));
  }
  return schema;
}
__name(inferFromSamples, "inferFromSamples");
function mergeSchemas(a, b) {
  const typeA = a.type;
  const typeB = b.type;
  if (!typeA) return b;
  if (!typeB) return a;
  if (typeA === typeB) return mergeSameType(a, b, typeA);
  if (typeA === "integer" && typeB === "number" || typeA === "number" && typeB === "integer") {
    return { type: "number" };
  }
  return mergeIntoAnyOf(a, b);
}
__name(mergeSchemas, "mergeSchemas");
function mergeSameType(a, b, type) {
  switch (type) {
    case "object":
      return mergeObjectSchemas(a, b);
    case "array":
      return mergeArraySchemas(a, b);
    case "string":
      return mergeStringSchemas(a, b);
    case "integer":
      return { type: "integer" };
    case "number":
      return { type: "number" };
    default:
      return a;
  }
}
__name(mergeSameType, "mergeSameType");
function mergeObjectSchemas(a, b) {
  const propsA = a.properties ?? {};
  const propsB = b.properties ?? {};
  const reqA = new Set(a.required ?? []);
  const reqB = new Set(b.required ?? []);
  const allKeys = /* @__PURE__ */ new Set([...Object.keys(propsA), ...Object.keys(propsB)]);
  const properties = {};
  const required4 = [];
  for (const key of allKeys) {
    const schemaA = propsA[key];
    const schemaB = propsB[key];
    if (schemaA && schemaB) {
      properties[key] = mergeSchemas(schemaA, schemaB);
      if (reqA.has(key) && reqB.has(key)) required4.push(key);
    } else {
      properties[key] = schemaA ?? schemaB ?? {};
    }
  }
  const schema = { type: "object", properties };
  if (required4.length > 0) schema.required = required4;
  return schema;
}
__name(mergeObjectSchemas, "mergeObjectSchemas");
function mergeArraySchemas(a, b) {
  const itemsA = a.items ?? {};
  const itemsB = b.items ?? {};
  return { type: "array", items: mergeSchemas(itemsA, itemsB) };
}
__name(mergeArraySchemas, "mergeArraySchemas");
function mergeStringSchemas(a, b) {
  if (a.format && a.format === b.format) return { type: "string", format: a.format };
  return { type: "string" };
}
__name(mergeStringSchemas, "mergeStringSchemas");
function mergeIntoAnyOf(a, b) {
  const schemasA = a.anyOf ?? [a];
  const schemasB = b.anyOf ?? [b];
  const seen = /* @__PURE__ */ new Set();
  const merged = [];
  for (const s of [...schemasA, ...schemasB]) {
    const key = JSON.stringify(s);
    if (!seen.has(key)) {
      seen.add(key);
      merged.push(s);
    }
  }
  return merged.length === 1 ? merged[0] ?? {} : { anyOf: merged };
}
__name(mergeIntoAnyOf, "mergeIntoAnyOf");
function makeSchemaInferrer() {
  return {
    infer: /* @__PURE__ */ __name((samples) => Effect_exports.succeed(inferFromSamples(samples)), "infer"),
    merge: /* @__PURE__ */ __name((a, b) => Effect_exports.succeed(mergeSchemas(a, b)), "merge")
  };
}
__name(makeSchemaInferrer, "makeSchemaInferrer");
var SchemaInferrerLive = Layer_exports.succeed(SchemaInferrer, makeSchemaInferrer());

// src/services/Store.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();
init_Errors();
var Store = class extends Context_exports.Tag("Store")() {
  static {
    __name(this, "Store");
  }
};
function makeD1Store(db, r2) {
  const tryDb = /* @__PURE__ */ __name((fn2) => Effect_exports.tryPromise({
    try: /* @__PURE__ */ __name(() => Promise.resolve(fn2()), "try"),
    catch: /* @__PURE__ */ __name((e) => new StoreError({ message: String(e) }), "catch")
  }), "tryDb");
  return {
    saveSite: /* @__PURE__ */ __name((site) => tryDb(
      () => upsertSite(db, {
        id: site.id,
        url: site.url,
        domain: site.domain,
        firstScoutedAt: site.firstScoutedAt,
        lastScoutedAt: site.lastScoutedAt
      })
    ).pipe(Effect_exports.asVoid), "saveSite"),
    getSite: /* @__PURE__ */ __name((id2) => tryDb(() => getSite(db, id2)).pipe(
      Effect_exports.flatMap(
        (row) => row ? Effect_exports.succeed(row) : Effect_exports.fail(new NotFoundError({ id: id2, resource: "site" }))
      )
    ), "getSite"),
    saveEndpoints: /* @__PURE__ */ __name((endpoints2) => Effect_exports.forEach(
      endpoints2,
      (ep) => tryDb(
        () => upsertEndpoint(db, {
          id: ep.id,
          siteId: ep.siteId,
          method: ep.method,
          pathPattern: ep.pathPattern,
          requestSchema: JSON.stringify(ep.requestSchema),
          responseSchema: JSON.stringify(ep.responseSchema),
          sampleCount: ep.sampleCount,
          firstSeenAt: ep.firstSeenAt,
          lastSeenAt: ep.lastSeenAt
        })
      )
    ).pipe(Effect_exports.asVoid), "saveEndpoints"),
    getEndpoints: /* @__PURE__ */ __name((siteId) => tryDb(() => getEndpointsBySite(db, siteId)).pipe(
      Effect_exports.map(
        (rows) => rows.map(
          (r) => ({
            id: r.id,
            siteId: r.siteId,
            method: r.method,
            pathPattern: r.pathPattern,
            requestSchema: r.requestSchema ? JSON.parse(r.requestSchema) : void 0,
            responseSchema: r.responseSchema ? JSON.parse(r.responseSchema) : void 0,
            sampleCount: r.sampleCount,
            firstSeenAt: r.firstSeenAt,
            lastSeenAt: r.lastSeenAt
          })
        )
      )
    ), "getEndpoints"),
    savePath: /* @__PURE__ */ __name((path) => tryDb(
      () => upsertPath(db, {
        id: path.id,
        siteId: path.siteId,
        task: path.task,
        steps: JSON.stringify(path.steps),
        endpointIds: JSON.stringify(path.endpointIds),
        status: path.status,
        createdAt: path.createdAt,
        lastUsedAt: Option_exports.getOrUndefined(path.lastUsedAt),
        failCount: path.failCount,
        healCount: path.healCount
      })
    ).pipe(Effect_exports.asVoid), "savePath"),
    getPath: /* @__PURE__ */ __name((id2) => tryDb(() => getPath(db, id2)).pipe(
      Effect_exports.flatMap(
        (row) => row ? Effect_exports.succeed({
          ...row,
          steps: JSON.parse(row.steps),
          endpointIds: JSON.parse(row.endpointIds)
        }) : Effect_exports.fail(new NotFoundError({ id: id2, resource: "path" }))
      )
    ), "getPath"),
    listPaths: /* @__PURE__ */ __name((siteId) => tryDb(() => getPathsBySite(db, siteId)).pipe(
      Effect_exports.map(
        (rows) => rows.map(
          (r) => ({
            ...r,
            steps: JSON.parse(r.steps),
            endpointIds: JSON.parse(r.endpointIds),
            lastUsedAt: r.lastUsedAt ? Option_exports.some(r.lastUsedAt) : Option_exports.none()
          })
        )
      )
    ), "listPaths"),
    saveRun: /* @__PURE__ */ __name((run6) => tryDb(() => insertRun(db, run6)).pipe(Effect_exports.asVoid), "saveRun"),
    saveBlob: /* @__PURE__ */ __name((key, data) => Effect_exports.tryPromise({
      try: /* @__PURE__ */ __name(() => r2.put(key, data), "try"),
      catch: /* @__PURE__ */ __name((e) => new StoreError({ message: `R2 put failed: ${e}` }), "catch")
    }).pipe(Effect_exports.asVoid), "saveBlob"),
    getBlob: /* @__PURE__ */ __name((key) => Effect_exports.tryPromise({
      try: /* @__PURE__ */ __name(async () => {
        const obj = await r2.get(key);
        if (!obj) return null;
        const buf = await obj.arrayBuffer();
        return new Uint8Array(buf);
      }, "try"),
      catch: /* @__PURE__ */ __name((e) => new StoreError({ message: `R2 get failed: ${e}` }), "catch")
    }), "getBlob")
  };
}
__name(makeD1Store, "makeD1Store");
var StoreD1Live = /* @__PURE__ */ __name((d1, r2) => Layer_exports.succeed(Store, makeD1Store(createDb(d1), r2)), "StoreD1Live");
function makeTestStore() {
  const sites2 = /* @__PURE__ */ new Map();
  const endpoints2 = /* @__PURE__ */ new Map();
  const pathsMap = /* @__PURE__ */ new Map();
  const runs2 = [];
  const blobs = /* @__PURE__ */ new Map();
  return {
    saveSite: /* @__PURE__ */ __name((site) => Effect_exports.sync(() => {
      sites2.set(site.id, site);
    }), "saveSite"),
    getSite: /* @__PURE__ */ __name((id2) => Effect_exports.sync(() => sites2.get(id2)).pipe(
      Effect_exports.flatMap(
        (s) => s ? Effect_exports.succeed(s) : Effect_exports.fail(new NotFoundError({ id: id2, resource: "site" }))
      )
    ), "getSite"),
    saveEndpoints: /* @__PURE__ */ __name((eps) => Effect_exports.sync(() => {
      for (const ep of eps) {
        const existing = endpoints2.get(ep.siteId) ?? [];
        const idx = existing.findIndex((e) => e.id === ep.id);
        if (idx >= 0) {
          existing[idx] = ep;
        } else {
          existing.push(ep);
        }
        endpoints2.set(ep.siteId, existing);
      }
    }), "saveEndpoints"),
    getEndpoints: /* @__PURE__ */ __name((siteId) => Effect_exports.succeed(endpoints2.get(siteId) ?? []), "getEndpoints"),
    savePath: /* @__PURE__ */ __name((path) => Effect_exports.sync(() => {
      pathsMap.set(path.id, path);
    }), "savePath"),
    getPath: /* @__PURE__ */ __name((id2) => Effect_exports.sync(() => pathsMap.get(id2)).pipe(
      Effect_exports.flatMap(
        (p) => p ? Effect_exports.succeed(p) : Effect_exports.fail(new NotFoundError({ id: id2, resource: "path" }))
      )
    ), "getPath"),
    listPaths: /* @__PURE__ */ __name((siteId) => Effect_exports.succeed([...pathsMap.values()].filter((p) => p.siteId === siteId)), "listPaths"),
    saveRun: /* @__PURE__ */ __name((run6) => Effect_exports.sync(() => {
      runs2.push(run6);
    }), "saveRun"),
    saveBlob: /* @__PURE__ */ __name((key, data) => Effect_exports.sync(() => {
      blobs.set(key, data);
    }), "saveBlob"),
    getBlob: /* @__PURE__ */ __name((key) => Effect_exports.succeed(blobs.get(key) ?? null), "getBlob")
  };
}
__name(makeTestStore, "makeTestStore");
var StoreTestLive = Layer_exports.succeed(Store, makeTestStore());

// src/tools/Heal.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();

// src/tools/Scout.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();

// src/domain/Endpoint.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();
var HttpMethod = Schema_exports.Literal("GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS");
var CapturedEndpoint = class extends Schema_exports.Class("CapturedEndpoint")({
  id: Schema_exports.String,
  siteId: Schema_exports.String,
  method: HttpMethod,
  pathPattern: Schema_exports.String,
  requestSchema: Schema_exports.optionalWith(Schema_exports.Unknown, { as: "Option" }),
  responseSchema: Schema_exports.optionalWith(Schema_exports.Unknown, { as: "Option" }),
  sampleCount: Schema_exports.Number,
  firstSeenAt: Schema_exports.String,
  lastSeenAt: Schema_exports.String
}) {
  static {
    __name(this, "CapturedEndpoint");
  }
};

// src/domain/Path.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();
var PathStep = class extends Schema_exports.Class("PathStep")({
  action: Schema_exports.Literal("navigate", "click", "fill", "submit", "wait"),
  selector: Schema_exports.optional(Schema_exports.String),
  value: Schema_exports.optional(Schema_exports.String),
  url: Schema_exports.optional(Schema_exports.String)
}) {
  static {
    __name(this, "PathStep");
  }
};
var PathStatus = Schema_exports.Literal("active", "broken", "healing");
var ScoutedPath = class extends Schema_exports.Class("ScoutedPath")({
  id: Schema_exports.String,
  siteId: Schema_exports.String,
  task: Schema_exports.String,
  steps: Schema_exports.Array(PathStep),
  endpointIds: Schema_exports.Array(Schema_exports.String),
  status: PathStatus,
  createdAt: Schema_exports.String,
  lastUsedAt: Schema_exports.optionalWith(Schema_exports.String, { as: "Option" }),
  failCount: Schema_exports.Number,
  healCount: Schema_exports.Number
}) {
  static {
    __name(this, "ScoutedPath");
  }
};

// src/domain/Site.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();
var Site = class extends Schema_exports.Class("Site")({
  id: Schema_exports.String,
  url: Schema_exports.String,
  domain: Schema_exports.String,
  firstScoutedAt: Schema_exports.String,
  lastScoutedAt: Schema_exports.String
}) {
  static {
    __name(this, "Site");
  }
};

// src/lib/url.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var UUID_RE = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
var NUMERIC_RE = /^\d+$/;
var BASE64_RE = /^[A-Za-z0-9+/=]{16,}$/;
var HEX_RE = /^[0-9a-f]{8,}$/i;
function normalizeUrlPattern(url3) {
  const parsed = new URL(url3);
  const segments = parsed.pathname.split("/").map((segment) => {
    if (!segment) return segment;
    if (UUID_RE.test(segment)) return ":id";
    if (NUMERIC_RE.test(segment)) return ":id";
    if (BASE64_RE.test(segment)) return ":id";
    if (HEX_RE.test(segment)) return ":id";
    return segment;
  });
  return `${parsed.origin}${segments.join("/")}`;
}
__name(normalizeUrlPattern, "normalizeUrlPattern");
function extractDomain(url3) {
  return new URL(url3).hostname;
}
__name(extractDomain, "extractDomain");

// src/tools/Scout.ts
function generateId3(prefix) {
  const rand = Math.random().toString(36).slice(2, 10);
  const ts = Date.now().toString(36);
  return `${prefix}_${ts}_${rand}`;
}
__name(generateId3, "generateId");
function nowISO3() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
__name(nowISO3, "nowISO");
var VALID_METHODS = /* @__PURE__ */ new Set(["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"]);
var BLOCKED_DOMAINS = [
  "wikipedia.org",
  "wikimedia.org",
  "wiktionary.org",
  "wikiquote.org",
  "wikibooks.org",
  "wikisource.org",
  "wikinews.org",
  "wikiversity.org",
  "wikivoyage.org",
  "mediawiki.org"
];
function isBlockedDomain(url3) {
  try {
    const hostname3 = new URL(url3).hostname.toLowerCase();
    return BLOCKED_DOMAINS.some((domain4) => hostname3.includes(domain4));
  } catch {
    return false;
  }
}
__name(isBlockedDomain, "isBlockedDomain");
function isValidMethod(m) {
  return VALID_METHODS.has(m.toUpperCase());
}
__name(isValidMethod, "isValidMethod");
function groupByEndpoint(events) {
  const groups = /* @__PURE__ */ new Map();
  for (const ev of events) {
    if (!isApiRequest(ev.resourceType, ev.url)) continue;
    const method = ev.method.toUpperCase();
    if (!isValidMethod(method)) continue;
    let pattern2;
    try {
      pattern2 = normalizeUrlPattern(ev.url);
    } catch {
      continue;
    }
    const key = `${method} ${pattern2}`;
    const existing = groups.get(key);
    if (existing) {
      existing.events.push(ev);
    } else {
      groups.set(key, { method, pattern: pattern2, events: [ev] });
    }
  }
  return groups;
}
__name(groupByEndpoint, "groupByEndpoint");
function tryParseJson(body) {
  if (!body) return void 0;
  try {
    return JSON.parse(body);
  } catch {
    return void 0;
  }
}
__name(tryParseJson, "tryParseJson");
function collectSamples(events) {
  const responseSamples = [];
  const requestSamples = [];
  for (const ev of events) {
    const resBody = tryParseJson(ev.responseBody);
    if (resBody !== void 0) responseSamples.push(resBody);
    const reqBody = tryParseJson(ev.requestBody);
    if (reqBody !== void 0) requestSamples.push(reqBody);
  }
  return { responseSamples, requestSamples };
}
__name(collectSamples, "collectSamples");
var buildEndpoint = /* @__PURE__ */ __name((group3, siteId, now2) => Effect_exports.gen(function* () {
  const inferrer = yield* SchemaInferrer;
  const epId = generateId3("ep");
  const { responseSamples, requestSamples } = collectSamples(group3.events);
  const responseSchema = responseSamples.length > 0 ? yield* inferrer.infer(responseSamples) : void 0;
  const requestSchema = requestSamples.length > 0 ? yield* inferrer.infer(requestSamples) : void 0;
  return new CapturedEndpoint({
    id: epId,
    siteId,
    method: group3.method,
    pathPattern: group3.pattern,
    requestSchema: requestSchema ? Option_exports.some(requestSchema) : Option_exports.none(),
    responseSchema: responseSchema ? Option_exports.some(responseSchema) : Option_exports.none(),
    sampleCount: group3.events.length,
    firstSeenAt: now2,
    lastSeenAt: now2
  });
}), "buildEndpoint");
var persistResults = /* @__PURE__ */ __name((site, endpoints2, path, openApiSpec, screenshot, input) => Effect_exports.gen(function* () {
  const store = yield* Store;
  yield* store.saveSite(site);
  if (endpoints2.length > 0) {
    yield* store.saveEndpoints(endpoints2);
  }
  yield* store.savePath(path);
  yield* store.saveBlob(`screenshots/${site.id}/scout.png`, screenshot);
  const specBytes = new TextEncoder().encode(JSON.stringify(openApiSpec, null, 2));
  yield* store.saveBlob(`specs/${site.id}/openapi.json`, specBytes);
  yield* store.saveRun({
    id: generateId3("run"),
    pathId: path.id,
    tool: "scout",
    status: "success",
    input: JSON.stringify({ url: input.url, task: input.task }),
    output: JSON.stringify({
      siteId: site.id,
      endpointCount: endpoints2.length,
      pathId: path.id
    }),
    createdAt: site.lastScoutedAt
  });
}), "persistResults");
var scout = /* @__PURE__ */ __name((input) => Effect_exports.gen(function* () {
  const openapi = yield* OpenApiGenerator;
  const store = yield* Store;
  const now2 = nowISO3();
  const domain4 = extractDomain(input.url);
  if (isBlockedDomain(input.url)) {
    const { BlockedDomainError: BlockedErr } = yield* Effect_exports.promise(
      () => Promise.resolve().then(() => (init_Errors(), Errors_exports))
    );
    return yield* Effect_exports.fail(
      new BlockedErr({
        domain: domain4,
        message: "This site does not permit automated access. Please respect their robots.txt and terms of service."
      })
    );
  }
  const galleryResult = input.force ? null : yield* Effect_exports.serviceOption(Gallery).pipe(
    Effect_exports.flatMap((galleryOpt) => {
      if (Option_exports.isNone(galleryOpt)) return Effect_exports.succeed(null);
      const gallery2 = galleryOpt.value;
      return gallery2.getByDomain(domain4).pipe(
        Effect_exports.flatMap((entry) => {
          if (!entry) return Effect_exports.succeed(null);
          return gallery2.getSpec(entry.id).pipe(
            Effect_exports.map((spec) => ({ entry, spec })),
            Effect_exports.catchAll(() => Effect_exports.succeed(null))
          );
        }),
        Effect_exports.catchAll(() => Effect_exports.succeed(null))
      );
    })
  );
  if (galleryResult) {
    const siteId2 = generateId3("site");
    const site2 = new Site({
      id: siteId2,
      url: input.url,
      domain: domain4,
      firstScoutedAt: now2,
      lastScoutedAt: now2
    });
    const specPaths = galleryResult.spec.paths ?? {};
    const galleryEndpoints = [];
    for (const [pathPattern, methods] of Object.entries(specPaths)) {
      for (const [method, _detail] of Object.entries(methods)) {
        const upperMethod = method.toUpperCase();
        if (!isValidMethod(upperMethod)) continue;
        const epId = generateId3("ep");
        galleryEndpoints.push(
          new CapturedEndpoint({
            id: epId,
            siteId: siteId2,
            method: upperMethod,
            pathPattern,
            requestSchema: Option_exports.none(),
            responseSchema: Option_exports.none(),
            sampleCount: 0,
            firstSeenAt: now2,
            lastSeenAt: now2
          })
        );
      }
    }
    const pathId2 = generateId3("path");
    const path2 = new ScoutedPath({
      id: pathId2,
      siteId: siteId2,
      task: input.task,
      steps: [new PathStep({ action: "navigate", url: input.url })],
      endpointIds: galleryEndpoints.map((ep) => ep.id),
      status: "active",
      createdAt: now2,
      lastUsedAt: Option_exports.some(now2),
      failCount: 0,
      healCount: 0
    });
    yield* store.saveSite(site2);
    if (galleryEndpoints.length > 0) {
      yield* store.saveEndpoints(galleryEndpoints);
    }
    yield* store.savePath(path2);
    const specBytes = new TextEncoder().encode(JSON.stringify(galleryResult.spec, null, 2));
    yield* store.saveBlob(`specs/${siteId2}/openapi.json`, specBytes);
    yield* store.saveRun({
      id: generateId3("run"),
      pathId: path2.id,
      tool: "scout",
      status: "success",
      input: JSON.stringify({ url: input.url, task: input.task }),
      output: JSON.stringify({
        siteId: site2.id,
        endpointCount: galleryEndpoints.length,
        pathId: path2.id,
        fromGallery: true
      }),
      createdAt: now2
    });
    yield* Effect_exports.serviceOption(Gallery).pipe(
      Effect_exports.flatMap((galleryOpt) => {
        if (Option_exports.isNone(galleryOpt)) return Effect_exports.void;
        return galleryOpt.value.publish(siteId2).pipe(Effect_exports.catchAll(() => Effect_exports.void));
      })
    );
    if (input.publish === true) {
      yield* Effect_exports.serviceOption(Directory).pipe(
        Effect_exports.flatMap((dirOpt) => {
          if (Option_exports.isNone(dirOpt)) return Effect_exports.void;
          return dirOpt.value.publish(siteId2).pipe(
            Effect_exports.catchTag("ValidationError", (e) => {
              console.error(
                `[Scout] Directory publish validation failed: ${e.field} - ${e.message}`
              );
              return Effect_exports.fail(e);
            }),
            Effect_exports.catchAll((e) => {
              console.error(`[Scout] Directory publish failed: ${e}`);
              return Effect_exports.void;
            })
          );
        })
      );
    }
    return {
      siteId: siteId2,
      endpointCount: galleryEndpoints.length,
      pathId: pathId2,
      openApiSpec: galleryResult.spec,
      fromGallery: true
    };
  }
  const browser = yield* Browser2;
  const siteId = generateId3("site");
  yield* browser.navigate(input.url);
  const events = yield* browser.getNetworkEvents();
  const screenshot = yield* browser.screenshot();
  const grouped3 = groupByEndpoint(events);
  const endpoints2 = yield* Effect_exports.forEach(
    [...grouped3.values()],
    (group3) => buildEndpoint(group3, siteId, now2)
  );
  const site = new Site({
    id: siteId,
    url: input.url,
    domain: domain4,
    firstScoutedAt: now2,
    lastScoutedAt: now2
  });
  const pathId = generateId3("path");
  const path = new ScoutedPath({
    id: pathId,
    siteId,
    task: input.task,
    steps: [new PathStep({ action: "navigate", url: input.url })],
    endpointIds: endpoints2.map((ep) => ep.id),
    status: "active",
    createdAt: now2,
    lastUsedAt: Option_exports.some(now2),
    failCount: 0,
    healCount: 0
  });
  const openApiSpec = yield* openapi.generate(input.url, endpoints2);
  yield* persistResults(site, [...endpoints2], path, openApiSpec, screenshot, input);
  if (input.publish !== false) {
    yield* Effect_exports.serviceOption(Gallery).pipe(
      Effect_exports.flatMap((galleryOpt) => {
        if (Option_exports.isNone(galleryOpt)) return Effect_exports.void;
        return galleryOpt.value.publish(siteId).pipe(Effect_exports.catchAll(() => Effect_exports.void));
      })
    );
  }
  if (input.publish === true) {
    yield* Effect_exports.serviceOption(Directory).pipe(
      Effect_exports.flatMap((dirOpt) => {
        if (Option_exports.isNone(dirOpt)) return Effect_exports.void;
        return dirOpt.value.publish(siteId).pipe(
          Effect_exports.catchTag("ValidationError", (e) => {
            console.error(
              `[Scout] Directory publish validation failed: ${e.field} - ${e.message}`
            );
            return Effect_exports.fail(e);
          }),
          Effect_exports.catchAll((e) => {
            console.error(`[Scout] Directory publish failed: ${e}`);
            return Effect_exports.void;
          })
        );
      })
    );
  }
  return { siteId, endpointCount: endpoints2.length, pathId, openApiSpec };
}), "scout");

// src/tools/Worker.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_esm();
init_Errors();
function generateId4(prefix) {
  const rand = Math.random().toString(36).slice(2, 10);
  const ts = Date.now().toString(36);
  return `${prefix}_${ts}_${rand}`;
}
__name(generateId4, "generateId");
function nowISO4() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
__name(nowISO4, "nowISO");
function resolveUrl(pattern2, data) {
  if (!data) return pattern2;
  return pattern2.replace(/:([a-zA-Z_][a-zA-Z0-9_]*)/g, (_, name) => {
    const val = data[name];
    return val !== void 0 ? String(val) : `:${name}`;
  });
}
__name(resolveUrl, "resolveUrl");
var replayEndpoint = /* @__PURE__ */ __name((endpoint, baseUrl, data, customHeaders) => Effect_exports.gen(function* () {
  const resolvedPath = resolveUrl(endpoint.pathPattern, data);
  const url3 = resolvedPath.startsWith("http") ? resolvedPath : `${baseUrl.replace(/\/$/, "")}${resolvedPath}`;
  const method = endpoint.method;
  const hasBody = ["POST", "PUT", "PATCH"].includes(method);
  const headers = {
    Accept: "application/json",
    ...customHeaders
    // Merge custom headers (auth, cookies, etc.)
  };
  const init = { method, headers };
  if (hasBody && data) {
    headers["Content-Type"] = "application/json";
    init.body = JSON.stringify(data);
  }
  const response = yield* Effect_exports.tryPromise({
    try: /* @__PURE__ */ __name(() => fetch(url3, init), "try"),
    catch: /* @__PURE__ */ __name((e) => new NetworkError({ url: url3, message: `Fetch failed: ${e}` }), "catch")
  });
  if (!response.ok) {
    yield* Effect_exports.fail(
      new NetworkError({
        url: url3,
        status: response.status,
        message: `HTTP ${response.status} ${response.statusText}`
      })
    );
  }
  const contentType = response.headers.get("content-type") ?? "";
  if (contentType.includes("json")) {
    return yield* Effect_exports.tryPromise({
      try: /* @__PURE__ */ __name(() => response.json(), "try"),
      catch: /* @__PURE__ */ __name((e) => new NetworkError({ url: url3, message: `JSON parse failed: ${e}` }), "catch")
    });
  }
  return yield* Effect_exports.tryPromise({
    try: /* @__PURE__ */ __name(() => response.text(), "try"),
    catch: /* @__PURE__ */ __name((e) => new NetworkError({ url: url3, message: `Body read failed: ${e}` }), "catch")
  });
}), "replayEndpoint");
var saveWorkerRun = /* @__PURE__ */ __name((pathId, success2, data, response, error50) => Effect_exports.gen(function* () {
  const store = yield* Store;
  yield* store.saveRun({
    id: generateId4("run"),
    pathId,
    tool: "worker",
    status: success2 ? "success" : "failure",
    input: JSON.stringify({ pathId, data }),
    output: success2 ? JSON.stringify(response) : void 0,
    error: error50,
    createdAt: nowISO4()
  });
}), "saveWorkerRun");
var worker = /* @__PURE__ */ __name((input) => Effect_exports.gen(function* () {
  const store = yield* Store;
  const path = yield* store.getPath(input.pathId);
  const allEndpoints = yield* store.getEndpoints(path.siteId);
  const pathEndpoints = allEndpoints.filter((ep) => path.endpointIds.includes(ep.id));
  if (pathEndpoints.length === 0) {
    yield* saveWorkerRun(input.pathId, false, input.data, null, "No endpoints found for path");
    return { success: false, response: "No endpoints found for path" };
  }
  const endpoint = input.data ? pathEndpoints.find((ep) => ["POST", "PUT", "PATCH"].includes(ep.method)) ?? pathEndpoints[0] : pathEndpoints.find((ep) => ep.method === "GET") ?? pathEndpoints[0];
  if (!endpoint) {
    yield* saveWorkerRun(input.pathId, false, input.data, null, "No matching endpoint");
    return { success: false, response: "No matching endpoint" };
  }
  const site = yield* store.getSite(path.siteId);
  const response = yield* replayEndpoint(endpoint, site.url, input.data, input.headers);
  yield* saveWorkerRun(input.pathId, true, input.data, response);
  return { success: true, response };
}), "worker");

// src/tools/Heal.ts
function generateId5(prefix) {
  const rand = Math.random().toString(36).slice(2, 10);
  const ts = Date.now().toString(36);
  return `${prefix}_${ts}_${rand}`;
}
__name(generateId5, "generateId");
function nowISO5() {
  return (/* @__PURE__ */ new Date()).toISOString();
}
__name(nowISO5, "nowISO");
var retryPolicy = Schedule_exports.intersect(Schedule_exports.recurs(2), Schedule_exports.exponential("500 millis"));
var markBroken = /* @__PURE__ */ __name((pathId, error50) => Effect_exports.gen(function* () {
  const store = yield* Store;
  const path = yield* store.getPath(pathId);
  const updated = {
    ...path,
    status: "broken",
    failCount: path.failCount + 1
  };
  yield* store.savePath(updated);
  yield* store.saveRun({
    id: generateId5("run"),
    pathId,
    tool: "heal",
    status: "failure",
    input: JSON.stringify({ pathId, error: error50 }),
    error: error50 ?? "Unknown error",
    createdAt: nowISO5()
  });
}), "markBroken");
var rescoutAndRetry = /* @__PURE__ */ __name((pathId) => Effect_exports.gen(function* () {
  const store = yield* Store;
  const oldPath = yield* store.getPath(pathId);
  yield* store.savePath({ ...oldPath, status: "healing" });
  const site = yield* store.getSite(oldPath.siteId);
  const scoutResult = yield* scout({ url: site.url, task: oldPath.task, force: true });
  const workerResult = yield* Effect_exports.either(worker({ pathId: scoutResult.pathId }));
  if (workerResult._tag === "Right" && workerResult.right.success) {
    yield* store.savePath({
      ...oldPath,
      status: "active",
      healCount: oldPath.healCount + 1
    });
    yield* store.saveRun({
      id: generateId5("run"),
      pathId,
      tool: "heal",
      status: "success",
      input: JSON.stringify({ pathId }),
      output: JSON.stringify({ newPathId: scoutResult.pathId }),
      createdAt: nowISO5()
    });
    return { healed: true, newPathId: scoutResult.pathId };
  }
  yield* store.savePath({
    ...oldPath,
    status: "broken",
    failCount: oldPath.failCount + 1,
    healCount: oldPath.healCount + 1
  });
  return { healed: false };
}), "rescoutAndRetry");
var heal = /* @__PURE__ */ __name((input) => Effect_exports.gen(function* () {
  const retryResult = yield* Effect_exports.either(
    worker({ pathId: input.pathId }).pipe(Effect_exports.retry(retryPolicy))
  );
  if (retryResult._tag === "Right" && retryResult.right.success) {
    return { healed: true };
  }
  yield* markBroken(input.pathId, input.error);
  return yield* rescoutAndRetry(input.pathId);
}), "heal");

// src/mcp.ts
function buildGalleryService(env2) {
  const storeService = makeD1Store(createDb(env2.DB), env2.STORAGE);
  const kvCache = env2.CACHE ? makeKvCache(env2.CACHE) : void 0;
  return makeD1Gallery(env2.DB, storeService, kvCache);
}
__name(buildGalleryService, "buildGalleryService");
function buildLayer(env2) {
  const storeService = makeD1Store(createDb(env2.DB), env2.STORAGE);
  const kvCache = env2.CACHE ? makeKvCache(env2.CACHE) : void 0;
  return Layer_exports.mergeAll(
    StoreD1Live(env2.DB, env2.STORAGE),
    BrowserCfLive(env2.BROWSER),
    Layer_exports.succeed(SchemaInferrer, makeSchemaInferrer()),
    Layer_exports.succeed(OpenApiGenerator, makeOpenApiGenerator()),
    Layer_exports.succeed(Gallery, makeD1Gallery(env2.DB, storeService, kvCache))
  );
}
__name(buildLayer, "buildLayer");
function buildWorkerLayer(env2) {
  return Layer_exports.mergeAll(
    StoreD1Live(env2.DB, env2.STORAGE),
    Layer_exports.succeed(SchemaInferrer, makeSchemaInferrer()),
    Layer_exports.succeed(OpenApiGenerator, makeOpenApiGenerator())
  );
}
__name(buildWorkerLayer, "buildWorkerLayer");
function okText(data) {
  return {
    content: [{ type: "text", text: JSON.stringify(data, null, 2) }]
  };
}
__name(okText, "okText");
function errText(message) {
  return {
    content: [{ type: "text", text: JSON.stringify({ error: message }) }],
    isError: true
  };
}
__name(errText, "errText");
function createMcpServer(env2) {
  const server = new McpServer(
    { name: "unsurf", version: "0.2.0" },
    { capabilities: { tools: {} } }
  );
  server.registerTool(
    "scout",
    {
      title: "Scout",
      description: "Use when you need to discover what API endpoints a website uses internally. Opens the URL in a headless browser, captures all network traffic (XHR/fetch), groups requests by endpoint pattern, infers request/response schemas, and generates an OpenAPI spec. Returns a siteId (for publishing), pathId (for replaying via worker), endpoint count, and the full OpenAPI spec. Check gallery/directory first \u2014 the site may already be captured.",
      inputSchema: {
        url: external_exports3.string().url().describe(
          "Full URL to scout, e.g. 'https://api.example.com' or 'https://app.example.com/dashboard'"
        ),
        task: external_exports3.string().describe(
          "What to look for \u2014 guides which page to visit. E.g. 'find all API endpoints', 'discover the search API', 'map the user authentication flow'"
        ),
        publish: external_exports3.boolean().optional().describe(
          "Set true to auto-publish results to the public API directory after scouting. Default: false (private)."
        )
      }
    },
    async ({ url: url3, task, publish: publish3 }) => {
      const result = await Effect_exports.runPromise(
        scout({ url: url3, task, publish: publish3 }).pipe(Effect_exports.provide(buildLayer(env2)))
      );
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2)
          }
        ]
      };
    }
  );
  server.registerTool(
    "worker",
    {
      title: "Worker",
      description: "Use to execute a previously scouted API endpoint directly \u2014 no browser needed. Looks up the pathId from a scout result, finds the matching endpoint, and replays the HTTP request. Returns the API response. Requires a pathId from a previous scout result. If it fails, use 'heal' to fix the broken path.",
      inputSchema: {
        pathId: external_exports3.string().describe(
          "Path ID from a scout result (format: path_<timestamp>_<random>). Get this from the scout tool's output."
        ),
        data: external_exports3.record(external_exports3.string(), external_exports3.unknown()).optional().describe(
          "Data for the request. Used as JSON body for POST/PUT/PATCH, or substituted into URL params for GET (e.g. {id: '123'} fills :id)."
        ),
        headers: external_exports3.record(external_exports3.string(), external_exports3.string()).optional().describe(
          "Custom HTTP headers. Use for authenticated endpoints: {'Authorization': 'Bearer <token>'} or {'Cookie': 'session=abc'}."
        )
      }
    },
    async ({ pathId, data, headers }) => {
      const result = await Effect_exports.runPromise(
        worker({ pathId, data, headers }).pipe(Effect_exports.provide(buildWorkerLayer(env2)))
      );
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2)
          }
        ]
      };
    }
  );
  server.registerTool(
    "heal",
    {
      title: "Heal",
      description: "Use when a worker call fails \u2014 fixes broken API paths automatically. First retries the endpoint with exponential backoff (handles transient errors). If retries fail, re-scouts the original URL to discover updated endpoints, then verifies the new path works. Returns whether healing succeeded and optionally a new pathId to use going forward.",
      inputSchema: {
        pathId: external_exports3.string().describe("The broken path ID from a failed worker call"),
        error: external_exports3.string().optional().describe(
          "The error message from the failed worker call \u2014 helps diagnose the issue (e.g. 'HTTP 404', 'endpoint returned HTML instead of JSON')"
        )
      }
    },
    async ({ pathId, error: error50 }) => {
      const result = await Effect_exports.runPromise(
        heal({ pathId, error: error50 }).pipe(Effect_exports.provide(buildLayer(env2)))
      );
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2)
          }
        ]
      };
    }
  );
  server.registerTool(
    "gallery",
    {
      title: "Gallery",
      description: "Search the cache of previously scouted APIs before using scout. Returns matching sites with their domains, endpoint counts, and OpenAPI spec availability. Much faster than scouting \u2014 no browser needed. Use this first to avoid redundant scouting.",
      inputSchema: {
        query: external_exports3.string().optional().describe(
          "Free-text search \u2014 matches domain names, endpoint paths, and descriptions. E.g. 'weather', 'pokemon', 'user authentication'"
        ),
        domain: external_exports3.string().optional().describe("Exact domain lookup, e.g. 'api.github.com'. More precise than query search.")
      }
    },
    async ({ query, domain: domain4 }) => {
      const galleryService = buildGalleryService(env2);
      const results = await Effect_exports.runPromise(galleryService.search(query ?? "", domain4));
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({ results, total: results.length }, null, 2)
          }
        ]
      };
    }
  );
  if (env2.VECTORS && env2.AI) {
    const directoryService = makeD1Directory(env2.DB, env2.STORAGE, env2.VECTORS, env2.AI);
    server.registerTool(
      "directory",
      {
        title: "Directory",
        description: "The public API directory \u2014 look up domains, browse by capability, inspect endpoints, or search across all known APIs. Start with 'fingerprint' for a lightweight overview (~50 tokens), drill into 'capability' for endpoint lists, or use 'search' for semantic matching. Use 'publish' to add a scouted site. Token-efficient: returns compact fingerprints, not full specs.",
        inputSchema: {
          action: external_exports3.enum(["fingerprint", "capability", "endpoint", "search", "publish"]).describe(
            "fingerprint: get domain overview (~50 tokens). capability: list endpoints by capability (~200 tokens). endpoint: single endpoint detail (~80 tokens). search: semantic search across all APIs. publish: add a scouted site to the directory."
          ),
          domain: external_exports3.string().optional().describe("Domain to look up (required for fingerprint, capability, endpoint)"),
          capability: external_exports3.enum([
            "auth",
            "payments",
            "content",
            "crud",
            "search",
            "messaging",
            "files",
            "analytics",
            "social",
            "ecommerce",
            "forms",
            "other"
          ]).optional().describe("Capability category (required for capability action)"),
          method: external_exports3.string().optional().describe("HTTP method (required for endpoint action)"),
          path: external_exports3.string().optional().describe("Endpoint path (required for endpoint action)"),
          query: external_exports3.string().optional().describe("Search query (required for search action)"),
          siteId: external_exports3.string().optional().describe("Site ID from a scout result (required for publish action)")
        }
      },
      // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: routing dispatch
      async ({ action, domain: domain4, capability, method, path, query, siteId }) => {
        const run6 = /* @__PURE__ */ __name((effect4) => Effect_exports.runPromise(effect4), "run");
        switch (action) {
          case "fingerprint": {
            if (!domain4) return errText("domain is required for fingerprint action");
            const fp = await run6(directoryService.getFingerprint(domain4));
            return okText(fp);
          }
          case "capability": {
            if (!domain4) return errText("domain is required for capability action");
            if (!capability) return errText("capability is required for capability action");
            const slice = await run6(directoryService.getCapabilitySlice(domain4, capability));
            return okText(slice);
          }
          case "endpoint": {
            if (!domain4) return errText("domain is required for endpoint action");
            if (!method) return errText("method is required for endpoint action");
            if (!path) return errText("path is required for endpoint action");
            const ep = await run6(directoryService.getEndpoint(domain4, method, path));
            return okText(ep);
          }
          case "search": {
            if (!query) return errText("query is required for search action");
            const results = await run6(directoryService.search(query));
            return okText({ results, total: results.length });
          }
          case "publish": {
            if (!siteId) return errText("siteId is required for publish action");
            const fp = await run6(directoryService.publish(siteId));
            return okText(fp);
          }
        }
      }
    );
  }
  if (env2.ANTHROPIC_API_KEY) {
    server.registerTool(
      "agent-scout",
      {
        title: "Agent Scout",
        description: "Use instead of regular scout when the site requires interaction \u2014 clicking buttons, filling forms, navigating menus \u2014 to trigger API calls that wouldn't appear from a simple page load. An AI agent controls the browser, performing actions you describe, while capturing all network traffic. More thorough but slower and more expensive than regular scout. Use regular scout first; escalate to agent-scout if it finds too few endpoints.",
        inputSchema: {
          url: external_exports3.string().url().describe("The URL to explore"),
          task: external_exports3.string().describe(
            "Instructions for the AI browser agent. Be specific: 'click the search button, type a query, submit the form' rather than just 'find search API'"
          )
        }
      },
      async ({ url: url3, task }) => {
        const llm = makeAnthropicProvider({
          apiKey: env2.ANTHROPIC_API_KEY
        });
        const browserEffect = Effect_exports.scoped(
          Effect_exports.gen(function* () {
            const browser = yield* makeCfBrowser(env2.BROWSER);
            return yield* runScoutAgent({ browser, llm, url: url3, task });
          })
        );
        const result = await Effect_exports.runPromise(browserEffect);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(
                {
                  steps: result.steps,
                  networkEventsCount: result.events.length,
                  events: result.events.map((e) => ({
                    method: e.method,
                    url: e.url,
                    status: e.responseStatus
                  }))
                },
                null,
                2
              )
            }
          ]
        };
      }
    );
  }
  return server;
}
__name(createMcpServer, "createMcpServer");
async function handleMcpRequest(req, env2) {
  const transport = new WebStandardStreamableHTTPServerTransport({
    enableJsonResponse: true
  });
  const server = createMcpServer(env2);
  await server.connect(transport);
  try {
    return await transport.handleRequest(req);
  } finally {
    await server.close();
  }
}
__name(handleMcpRequest, "handleMcpRequest");

// src/cf-worker.ts
function corsHeaders() {
  return {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type"
  };
}
__name(corsHeaders, "corsHeaders");
function jsonResponse(data, status2 = 200) {
  return new Response(JSON.stringify(data), {
    status: status2,
    headers: {
      "Content-Type": "application/json",
      ...corsHeaders()
    }
  });
}
__name(jsonResponse, "jsonResponse");
function errorResponse(message, status2 = 500) {
  return jsonResponse({ error: message }, status2);
}
__name(errorResponse, "errorResponse");
function buildLayer2(env2) {
  const storeService = makeD1Store(createDb(env2.DB), env2.STORAGE);
  const kvCache = env2.CACHE ? makeKvCache(env2.CACHE) : void 0;
  const baseLayers = [
    StoreD1Live(env2.DB, env2.STORAGE),
    BrowserCfLive(env2.BROWSER),
    Layer_exports.succeed(SchemaInferrer, makeSchemaInferrer()),
    Layer_exports.succeed(OpenApiGenerator, makeOpenApiGenerator()),
    Layer_exports.succeed(Gallery, makeD1Gallery(env2.DB, storeService, kvCache))
  ];
  if (env2.VECTORS && env2.AI) {
    return Layer_exports.mergeAll(
      ...baseLayers,
      Layer_exports.succeed(Directory, makeD1Directory(env2.DB, env2.STORAGE, env2.VECTORS, env2.AI))
    );
  }
  return Layer_exports.mergeAll(...baseLayers);
}
__name(buildLayer2, "buildLayer");
function buildGalleryService2(env2) {
  const storeService = makeD1Store(createDb(env2.DB), env2.STORAGE);
  const kvCache = env2.CACHE ? makeKvCache(env2.CACHE) : void 0;
  return makeD1Gallery(env2.DB, storeService, kvCache);
}
__name(buildGalleryService2, "buildGalleryService");
function buildDirectoryService(env2) {
  if (!env2.VECTORS || !env2.AI) {
    throw new Error("Directory requires VECTORS and AI bindings");
  }
  return makeD1Directory(env2.DB, env2.STORAGE, env2.VECTORS, env2.AI);
}
__name(buildDirectoryService, "buildDirectoryService");
async function handleGallerySearch(url3, env2) {
  const q = url3.searchParams.get("q") ?? void 0;
  const domain4 = url3.searchParams.get("domain") ?? void 0;
  const limitParam = url3.searchParams.get("limit");
  const limit = limitParam ? Number.parseInt(limitParam, 10) : void 0;
  if (!q && !domain4) {
    return errorResponse("At least one of 'q' or 'domain' must be provided", 400);
  }
  const gallery2 = buildGalleryService2(env2);
  const results = await Effect_exports.runPromise(gallery2.search(q ?? "", domain4, limit));
  return jsonResponse({ results, total: results.length });
}
__name(handleGallerySearch, "handleGallerySearch");
async function handleGallerySpec(id2, env2) {
  const gallery2 = buildGalleryService2(env2);
  const spec = await Effect_exports.runPromise(gallery2.getSpec(id2));
  return jsonResponse(spec);
}
__name(handleGallerySpec, "handleGallerySpec");
async function handleGalleryPublish(body, env2) {
  const { siteId, contributor } = body;
  if (!siteId) {
    return errorResponse("Missing 'siteId' in request body", 400);
  }
  const gallery2 = buildGalleryService2(env2);
  const entry = await Effect_exports.runPromise(gallery2.publish(siteId, contributor));
  return jsonResponse(entry);
}
__name(handleGalleryPublish, "handleGalleryPublish");
async function handleScout(body, env2) {
  const { url: url3, task, publish: publish3, force } = body;
  if (!url3 || !task) {
    return errorResponse("Missing 'url' and 'task' in request body", 400);
  }
  const result = await Effect_exports.runPromise(
    scout({ url: url3, task, publish: publish3, force }).pipe(Effect_exports.provide(buildLayer2(env2)))
  );
  return jsonResponse(result);
}
__name(handleScout, "handleScout");
async function handleWorker(body, env2) {
  const { pathId, data, headers } = body;
  if (!pathId) {
    return errorResponse("Missing 'pathId' in request body", 400);
  }
  const layer = Layer_exports.mergeAll(
    StoreD1Live(env2.DB, env2.STORAGE),
    Layer_exports.succeed(SchemaInferrer, makeSchemaInferrer()),
    Layer_exports.succeed(OpenApiGenerator, makeOpenApiGenerator())
  );
  try {
    const result = await Effect_exports.runPromise(
      worker({ pathId, data, headers }).pipe(Effect_exports.provide(layer))
    );
    return jsonResponse(result);
  } catch (e) {
    const message = e instanceof Error ? e.message : String(e);
    if (message.includes('"resource"')) return errorResponse(message, 404);
    if (message.includes("BlockedDomainError")) return errorResponse(message, 403);
    return errorResponse(message);
  }
}
__name(handleWorker, "handleWorker");
async function handleHeal(body, env2) {
  const { pathId, error: error50 } = body;
  if (!pathId) {
    return errorResponse("Missing 'pathId' in request body", 400);
  }
  try {
    const result = await Effect_exports.runPromise(
      heal({ pathId, error: error50 }).pipe(Effect_exports.provide(buildLayer2(env2)))
    );
    return jsonResponse(result);
  } catch (e) {
    const message = e instanceof Error ? e.message : String(e);
    if (message.includes('"resource"')) return errorResponse(message, 404);
    if (message.includes("BlockedDomainError")) return errorResponse(message, 403);
    return errorResponse(message);
  }
}
__name(handleHeal, "handleHeal");
var cf_worker_default = {
  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: routing dispatch, each branch is simple
  async fetch(request2, env2) {
    const url3 = new URL(request2.url);
    if (request2.method === "OPTIONS") {
      return new Response(null, { headers: corsHeaders() });
    }
    if (url3.pathname === "/" || url3.pathname === "/api") {
      return jsonResponse({
        name: "unsurf",
        version: "0.3.0",
        description: "The typed internet \u2014 a machine-readable directory of every API",
        directory: {
          fingerprint: "/d/:domain",
          capability: "/d/:domain/:capability",
          endpoint: "/d/:domain/:method/:path",
          spec: "/d/:domain/spec",
          search: "/search?q=:query",
          publish: "POST /d/publish"
        },
        tools: ["scout", "worker", "heal"],
        mcp: "/mcp",
        docs: "https://unsurf.coey.dev"
      });
    }
    if (url3.pathname === "/mcp") {
      return handleMcpRequest(request2, env2);
    }
    if (url3.pathname === "/d/validate" && request2.method === "POST") {
      try {
        const { validateSite: validateSite2 } = await Promise.resolve().then(() => (init_validate(), validate_exports));
        const body = await request2.json();
        if (!body.domain || !body.endpoints) {
          return errorResponse("Missing 'domain' or 'endpoints' in body", 400);
        }
        const result = await validateSite2(body.domain, body.endpoints);
        return jsonResponse(result);
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        return errorResponse(message);
      }
    }
    if (url3.pathname === "/d/invoke" && request2.method === "POST") {
      try {
        const body = await request2.json();
        if (!body.domain || !body.method || !body.path) {
          return errorResponse("Missing domain, method, or path", 400);
        }
        const resolvedPath = body.path.replace(/\/:[\w-]+/g, "/1").replace(/\/\{[\w-]+\}/g, "/1");
        const targetUrl = `https://${body.domain}${resolvedPath}`;
        const init = {
          method: body.method,
          headers: { Accept: "application/json" }
        };
        if (body.body && ["POST", "PUT", "PATCH"].includes(body.method.toUpperCase())) {
          init.headers = {
            ...init.headers,
            "Content-Type": "application/json"
          };
          init.body = JSON.stringify(body.body);
        }
        const res = await fetch(targetUrl, init);
        const text2 = await res.text();
        let json3;
        try {
          json3 = JSON.parse(text2);
        } catch {
          json3 = text2;
        }
        return jsonResponse({
          status: res.status,
          ok: res.ok,
          body: json3
        });
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        return errorResponse(message);
      }
    }
    if (url3.pathname === "/d/publish" && request2.method === "POST") {
      try {
        if (!env2.VECTORS || !env2.AI) {
          return errorResponse("Directory not configured (requires VECTORS + AI bindings)", 503);
        }
        const body = await request2.json();
        if (!body.siteId) return errorResponse("Missing 'siteId' in body", 400);
        const directory = buildDirectoryService(env2);
        const fp = await Effect_exports.runPromise(directory.publish(body.siteId, body.contributor));
        return jsonResponse(fp);
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        return errorResponse(message);
      }
    }
    if (url3.pathname.startsWith("/d/")) {
      if (request2.method !== "GET" && request2.method !== "DELETE") {
        return errorResponse("Not found", 404);
      }
      try {
        if (!env2.VECTORS || !env2.AI) {
          return errorResponse("Directory not configured (requires VECTORS + AI bindings)", 503);
        }
        const directory = buildDirectoryService(env2);
        const parts2 = url3.pathname.slice(3).split("/").filter(Boolean);
        if (request2.method === "DELETE" && parts2.length === 1) {
          const domain5 = parts2[0] ?? "";
          await Effect_exports.runPromise(directory.delete(domain5));
          return jsonResponse({ deleted: domain5 });
        }
        if (parts2.length === 0) {
          const offset = Number(url3.searchParams.get("offset") || 0);
          const limit = Number(url3.searchParams.get("limit") || 20);
          const results = await Effect_exports.runPromise(directory.list(offset, limit));
          return jsonResponse({ fingerprints: results, count: results.length });
        }
        const domain4 = parts2[0] ?? "";
        if (parts2.length === 1) {
          const fp = await Effect_exports.runPromise(directory.getFingerprint(domain4));
          return jsonResponse(fp);
        }
        if (parts2[1] === "spec") {
          const spec = await Effect_exports.runPromise(directory.getSpec(domain4));
          return jsonResponse(spec);
        }
        if (parts2.length === 2) {
          const cap = parts2[1] ?? "";
          const slice = await Effect_exports.runPromise(directory.getCapabilitySlice(domain4, cap));
          return jsonResponse(slice);
        }
        if (parts2.length >= 3) {
          const method = parts2[1] ?? "";
          const path = `/${parts2.slice(2).join("/")}`;
          const endpoint = await Effect_exports.runPromise(directory.getEndpoint(domain4, method, path));
          return jsonResponse(endpoint);
        }
        return errorResponse("Invalid directory path", 400);
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        if (message.includes('"resource"')) return errorResponse(message, 404);
        return errorResponse(message);
      }
    }
    if (url3.pathname === "/search" && request2.method === "GET") {
      try {
        if (!env2.VECTORS || !env2.AI) {
          return errorResponse("Search not configured (requires VECTORS + AI bindings)", 503);
        }
        const q = url3.searchParams.get("q");
        if (!q) return errorResponse("Missing 'q' query parameter", 400);
        const limit = Number(url3.searchParams.get("limit") || 10);
        const directory = buildDirectoryService(env2);
        const results = await Effect_exports.runPromise(directory.search(q, limit));
        return jsonResponse({ results, total: results.length });
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        return errorResponse(message);
      }
    }
    if (url3.pathname.startsWith("/gallery")) {
      try {
        if (request2.method === "GET" && url3.pathname === "/gallery") {
          return await handleGallerySearch(url3, env2);
        }
        const specMatch = url3.pathname.match(/^\/gallery\/([^/]+)\/spec$/);
        const specId = specMatch?.[1];
        if (request2.method === "GET" && specId) {
          return await handleGallerySpec(specId, env2);
        }
        if (request2.method === "POST" && url3.pathname === "/gallery/publish") {
          const body = await request2.json();
          return await handleGalleryPublish(body, env2);
        }
        return errorResponse("Not found", 404);
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        return errorResponse(message);
      }
    }
    if (request2.method === "POST" && url3.pathname.startsWith("/tools/")) {
      try {
        const body = await request2.json();
        switch (url3.pathname) {
          case "/tools/scout":
            return await handleScout(body, env2);
          case "/tools/worker":
            return await handleWorker(body, env2);
          case "/tools/heal":
            return await handleHeal(body, env2);
          default:
            return errorResponse(`Unknown tool: ${url3.pathname}`, 404);
        }
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        return errorResponse(message);
      }
    }
    return errorResponse("Not found", 404);
  }
};
export {
  cf_worker_default as default
};
/*! Bundled license information:

@cloudflare/puppeteer/lib/esm/puppeteer/node/NodeWebSocketTransport.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/Errors.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Accessibility.js:
@cloudflare/puppeteer/lib/esm/puppeteer/api/WebWorker.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

@cloudflare/puppeteer/lib/esm/puppeteer/cloudflare/globalPatcher.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cloudflare/utils.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cloudflare/chunking.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cloudflare/PuppeteerWorkers.js:
@cloudflare/puppeteer/lib/esm/puppeteer/puppeteer-cloudflare.js:
  (**
   * @license
   * Copyright 2025 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

@cloudflare/puppeteer/lib/esm/puppeteer/util/assert.js:
@cloudflare/puppeteer/lib/esm/puppeteer/environment.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/Debug.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/PDFOptions.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/ConsoleMessage.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/FileChooser.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/AriaQueryHandler.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/SecurityDetails.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/HTTPResponse.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/BrowserConnector.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/ConnectionTransport.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/ConnectOptions.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/Product.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/TaskQueue.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/types.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/Viewport.js:
@cloudflare/puppeteer/lib/esm/puppeteer/revisions.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

@cloudflare/puppeteer/lib/esm/puppeteer/common/util.js:
@cloudflare/puppeteer/lib/esm/puppeteer/api/Browser.js:
@cloudflare/puppeteer/lib/esm/puppeteer/api/BrowserContext.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/CDPSession.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Connection.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Coverage.js:
@cloudflare/puppeteer/lib/esm/puppeteer/api/Dialog.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Dialog.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/utils.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/ExecutionContext.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Frame.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/NetworkManager.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/FrameManager.js:
@cloudflare/puppeteer/lib/esm/puppeteer/api/Input.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/USKeyboardLayout.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Input.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Page.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Browser.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/Puppeteer.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/Device.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

@cloudflare/puppeteer/lib/esm/puppeteer/util/disposable.js:
@cloudflare/puppeteer/lib/esm/puppeteer/api/Target.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/CallbackRegistry.js:
@cloudflare/puppeteer/lib/esm/puppeteer/util/decorators.js:
@cloudflare/puppeteer/lib/esm/puppeteer/api/JSHandle.js:
@cloudflare/puppeteer/lib/esm/puppeteer/api/ElementHandleSymbol.js:
@cloudflare/puppeteer/lib/esm/puppeteer/util/Function.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/HandleIterator.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/QueryHandler.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/CSSQueryHandler.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/CustomQueryHandler.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/PierceQueryHandler.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/PQueryHandler.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/PSelectorParser.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/TextQueryHandler.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/XPathQueryHandler.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/GetQueryHandler.js:
@cloudflare/puppeteer/lib/esm/puppeteer/api/Frame.js:
@cloudflare/puppeteer/lib/esm/puppeteer/api/ElementHandle.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/FrameManagerEvents.js:
@cloudflare/puppeteer/lib/esm/puppeteer/api/Realm.js:
@cloudflare/puppeteer/lib/esm/puppeteer/api/HTTPResponse.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/BrowserConnector.js:
@cloudflare/puppeteer/lib/esm/puppeteer/api/Environment.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

@cloudflare/puppeteer/lib/esm/puppeteer/common/EventEmitter.js:
@cloudflare/puppeteer/lib/esm/puppeteer/util/ErrorLike.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/NetworkManagerEvents.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/FirefoxTargetManager.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/LazyArg.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/DeviceRequestPrompt.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/WaitTask.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/IsolatedWorlds.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/FrameTree.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/NetworkEventManager.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/ChromeTargetManager.js:
@cloudflare/puppeteer/lib/esm/puppeteer/api/api.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/Configuration.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/common.js:
@cloudflare/puppeteer/lib/esm/puppeteer/util/util.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

@cloudflare/puppeteer/lib/esm/puppeteer/util/Deferred.js:
@cloudflare/puppeteer/lib/esm/puppeteer/util/Mutex.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/BrowserContext.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Binding.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/ScriptInjector.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/CdpPreloadScript.js:
@cloudflare/puppeteer/lib/esm/puppeteer/common/Cookie.js:
  (**
   * @license
   * Copyright 2024 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

@cloudflare/puppeteer/lib/esm/puppeteer/common/TimeoutSettings.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/JSHandle.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/ElementHandle.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/IsolatedWorld.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/LifecycleWatcher.js:
@cloudflare/puppeteer/lib/esm/puppeteer/cdp/Target.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=cf-worker.js.map
